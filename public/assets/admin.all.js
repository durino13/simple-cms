/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/assets/";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function($) {// Author:      Juraj Marusiak
	// Created:     01.06.2016
	// Description: This is the entrance file for all JS on the page ...
	
	// -------------------------------------------------
	// Datatables
	// -------------------------------------------------
	
	// Weird way to load a datatable JS .. the define=>disable part disables AMD, so datatables will use CommonJS
	__webpack_require__(2)(window, $);
	__webpack_require__(3 )( window, $ );
	__webpack_require__(5 )( window, $ );
	__webpack_require__(6);
	__webpack_require__(13);
	__webpack_require__(15);
	__webpack_require__(16);
	__webpack_require__(18);
	__webpack_require__(19);
	__webpack_require__(20);
	__webpack_require__(17);
	__webpack_require__(21);
	
	// -------------------------------------------------
	// TinyMCE
	// -------------------------------------------------
	
	// TODO Load minified stuff in production ..
	
	__webpack_require__(23);
	__webpack_require__(26);
	__webpack_require__(27);
	__webpack_require__(37);
	__webpack_require__(38);
	__webpack_require__(39);
	__webpack_require__(40);
	__webpack_require__(41);
	__webpack_require__(42);
	__webpack_require__(43);
	__webpack_require__(31);
	__webpack_require__(30);
	__webpack_require__(29);
	__webpack_require__(32);
	
	// -------------------------------------------------                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <
	// Others
	// -------------------------------------------------
	
	// import js & css
	__webpack_require__(44);
	__webpack_require__(50);
	__webpack_require__(51);
	__webpack_require__(58);
	__webpack_require__(59);
	__webpack_require__(63);
	__webpack_require__(64);
	
	// -------------------------------------------------
	// Admin LTE
	// -------------------------------------------------
	
	// AdminLTE is loaded here .. The $=jquery notation will make jQuery available for AdminLTE, otherwise you will see
	// following message: AdminLTE requires jQuery ..
	__webpack_require__(65);
	__webpack_require__(66);
	__webpack_require__(67);
	__webpack_require__(69);
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 1 */
/***/ function(module, exports) {

	module.exports = jQuery;

/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	/*** IMPORTS FROM imports-loader ***/
	var define = false;
	
	/*! DataTables 1.10.12
	 * Â©2008-2015 SpryMedia Ltd - datatables.net/license
	 */
	
	/**
	 * @summary     DataTables
	 * @description Paginate, search and order HTML tables
	 * @version     1.10.12
	 * @file        jquery.dataTables.js
	 * @author      SpryMedia Ltd (www.sprymedia.co.uk)
	 * @contact     www.sprymedia.co.uk/contact
	 * @copyright   Copyright 2008-2015 SpryMedia Ltd.
	 *
	 * This source file is free software, available under the following license:
	 *   MIT license - http://datatables.net/license
	 *
	 * This source file is distributed in the hope that it will be useful, but
	 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
	 * or FITNESS FOR A PARTICULAR PURPOSE. See the license files for details.
	 *
	 * For details please refer to: http://www.datatables.net
	 */
	
	/*jslint evil: true, undef: true, browser: true */
	/*globals $,require,jQuery,define,_selector_run,_selector_opts,_selector_first,_selector_row_indexes,_ext,_Api,_api_register,_api_registerPlural,_re_new_lines,_re_html,_re_formatted_numeric,_re_escape_regex,_empty,_intVal,_numToDecimal,_isNumber,_isHtml,_htmlNumeric,_pluck,_pluck_order,_range,_stripHtml,_unique,_fnBuildAjax,_fnAjaxUpdate,_fnAjaxParameters,_fnAjaxUpdateDraw,_fnAjaxDataSrc,_fnAddColumn,_fnColumnOptions,_fnAdjustColumnSizing,_fnVisibleToColumnIndex,_fnColumnIndexToVisible,_fnVisbleColumns,_fnGetColumns,_fnColumnTypes,_fnApplyColumnDefs,_fnHungarianMap,_fnCamelToHungarian,_fnLanguageCompat,_fnBrowserDetect,_fnAddData,_fnAddTr,_fnNodeToDataIndex,_fnNodeToColumnIndex,_fnGetCellData,_fnSetCellData,_fnSplitObjNotation,_fnGetObjectDataFn,_fnSetObjectDataFn,_fnGetDataMaster,_fnClearTable,_fnDeleteIndex,_fnInvalidate,_fnGetRowElements,_fnCreateTr,_fnBuildHead,_fnDrawHead,_fnDraw,_fnReDraw,_fnAddOptionsHtml,_fnDetectHeader,_fnGetUniqueThs,_fnFeatureHtmlFilter,_fnFilterComplete,_fnFilterCustom,_fnFilterColumn,_fnFilter,_fnFilterCreateSearch,_fnEscapeRegex,_fnFilterData,_fnFeatureHtmlInfo,_fnUpdateInfo,_fnInfoMacros,_fnInitialise,_fnInitComplete,_fnLengthChange,_fnFeatureHtmlLength,_fnFeatureHtmlPaginate,_fnPageChange,_fnFeatureHtmlProcessing,_fnProcessingDisplay,_fnFeatureHtmlTable,_fnScrollDraw,_fnApplyToChildren,_fnCalculateColumnWidths,_fnThrottle,_fnConvertToWidth,_fnGetWidestNode,_fnGetMaxLenString,_fnStringToCss,_fnSortFlatten,_fnSort,_fnSortAria,_fnSortListener,_fnSortAttachListener,_fnSortingClasses,_fnSortData,_fnSaveState,_fnLoadState,_fnSettingsFromNode,_fnLog,_fnMap,_fnBindAction,_fnCallbackReg,_fnCallbackFire,_fnLengthOverflow,_fnRenderer,_fnDataSource,_fnRowAttributes*/
	
	(function( factory ) {
		"use strict";
	
		if ( typeof define === 'function' && define.amd ) {
			// AMD
			define( ['jquery'], function ( $ ) {
				return factory( $, window, document );
			} );
		}
		else if ( true ) {
			// CommonJS
			module.exports = function (root, $) {
				if ( ! root ) {
					// CommonJS environments without a window global must pass a
					// root. This will give an error otherwise
					root = window;
				}
	
				if ( ! $ ) {
					$ = typeof window !== 'undefined' ? // jQuery's factory checks for a global window
						__webpack_require__(1) :
						__webpack_require__(1)( root );
				}
	
				return factory( $, root, root.document );
			};
		}
		else {
			// Browser
			factory( jQuery, window, document );
		}
	}
	(function( $, window, document, undefined ) {
		"use strict";
	
		/**
		 * DataTables is a plug-in for the jQuery Javascript library. It is a highly
		 * flexible tool, based upon the foundations of progressive enhancement,
		 * which will add advanced interaction controls to any HTML table. For a
		 * full list of features please refer to
		 * [DataTables.net](href="http://datatables.net).
		 *
		 * Note that the `DataTable` object is not a global variable but is aliased
		 * to `jQuery.fn.DataTable` and `jQuery.fn.dataTable` through which it may
		 * be  accessed.
		 *
		 *  @class
		 *  @param {object} [init={}] Configuration object for DataTables. Options
		 *    are defined by {@link DataTable.defaults}
		 *  @requires jQuery 1.7+
		 *
		 *  @example
		 *    // Basic initialisation
		 *    $(document).ready( function {
		 *      $('#example').dataTable();
		 *    } );
		 *
		 *  @example
		 *    // Initialisation with configuration options - in this case, disable
		 *    // pagination and sorting.
		 *    $(document).ready( function {
		 *      $('#example').dataTable( {
		 *        "paginate": false,
		 *        "sort": false
		 *      } );
		 *    } );
		 */
		var DataTable = function ( options )
		{
			/**
			 * Perform a jQuery selector action on the table's TR elements (from the tbody) and
			 * return the resulting jQuery object.
			 *  @param {string|node|jQuery} sSelector jQuery selector or node collection to act on
			 *  @param {object} [oOpts] Optional parameters for modifying the rows to be included
			 *  @param {string} [oOpts.filter=none] Select TR elements that meet the current filter
			 *    criterion ("applied") or all TR elements (i.e. no filter).
			 *  @param {string} [oOpts.order=current] Order of the TR elements in the processed array.
			 *    Can be either 'current', whereby the current sorting of the table is used, or
			 *    'original' whereby the original order the data was read into the table is used.
			 *  @param {string} [oOpts.page=all] Limit the selection to the currently displayed page
			 *    ("current") or not ("all"). If 'current' is given, then order is assumed to be
			 *    'current' and filter is 'applied', regardless of what they might be given as.
			 *  @returns {object} jQuery object, filtered by the given selector.
			 *  @dtopt API
			 *  @deprecated Since v1.10
			 *
			 *  @example
			 *    $(document).ready(function() {
			 *      var oTable = $('#example').dataTable();
			 *
			 *      // Highlight every second row
			 *      oTable.$('tr:odd').css('backgroundColor', 'blue');
			 *    } );
			 *
			 *  @example
			 *    $(document).ready(function() {
			 *      var oTable = $('#example').dataTable();
			 *
			 *      // Filter to rows with 'Webkit' in them, add a background colour and then
			 *      // remove the filter, thus highlighting the 'Webkit' rows only.
			 *      oTable.fnFilter('Webkit');
			 *      oTable.$('tr', {"search": "applied"}).css('backgroundColor', 'blue');
			 *      oTable.fnFilter('');
			 *    } );
			 */
			this.$ = function ( sSelector, oOpts )
			{
				return this.api(true).$( sSelector, oOpts );
			};
			
			
			/**
			 * Almost identical to $ in operation, but in this case returns the data for the matched
			 * rows - as such, the jQuery selector used should match TR row nodes or TD/TH cell nodes
			 * rather than any descendants, so the data can be obtained for the row/cell. If matching
			 * rows are found, the data returned is the original data array/object that was used to
			 * create the row (or a generated array if from a DOM source).
			 *
			 * This method is often useful in-combination with $ where both functions are given the
			 * same parameters and the array indexes will match identically.
			 *  @param {string|node|jQuery} sSelector jQuery selector or node collection to act on
			 *  @param {object} [oOpts] Optional parameters for modifying the rows to be included
			 *  @param {string} [oOpts.filter=none] Select elements that meet the current filter
			 *    criterion ("applied") or all elements (i.e. no filter).
			 *  @param {string} [oOpts.order=current] Order of the data in the processed array.
			 *    Can be either 'current', whereby the current sorting of the table is used, or
			 *    'original' whereby the original order the data was read into the table is used.
			 *  @param {string} [oOpts.page=all] Limit the selection to the currently displayed page
			 *    ("current") or not ("all"). If 'current' is given, then order is assumed to be
			 *    'current' and filter is 'applied', regardless of what they might be given as.
			 *  @returns {array} Data for the matched elements. If any elements, as a result of the
			 *    selector, were not TR, TD or TH elements in the DataTable, they will have a null
			 *    entry in the array.
			 *  @dtopt API
			 *  @deprecated Since v1.10
			 *
			 *  @example
			 *    $(document).ready(function() {
			 *      var oTable = $('#example').dataTable();
			 *
			 *      // Get the data from the first row in the table
			 *      var data = oTable._('tr:first');
			 *
			 *      // Do something useful with the data
			 *      alert( "First cell is: "+data[0] );
			 *    } );
			 *
			 *  @example
			 *    $(document).ready(function() {
			 *      var oTable = $('#example').dataTable();
			 *
			 *      // Filter to 'Webkit' and get all data for
			 *      oTable.fnFilter('Webkit');
			 *      var data = oTable._('tr', {"search": "applied"});
			 *
			 *      // Do something with the data
			 *      alert( data.length+" rows matched the search" );
			 *    } );
			 */
			this._ = function ( sSelector, oOpts )
			{
				return this.api(true).rows( sSelector, oOpts ).data();
			};
			
			
			/**
			 * Create a DataTables Api instance, with the currently selected tables for
			 * the Api's context.
			 * @param {boolean} [traditional=false] Set the API instance's context to be
			 *   only the table referred to by the `DataTable.ext.iApiIndex` option, as was
			 *   used in the API presented by DataTables 1.9- (i.e. the traditional mode),
			 *   or if all tables captured in the jQuery object should be used.
			 * @return {DataTables.Api}
			 */
			this.api = function ( traditional )
			{
				return traditional ?
					new _Api(
						_fnSettingsFromNode( this[ _ext.iApiIndex ] )
					) :
					new _Api( this );
			};
			
			
			/**
			 * Add a single new row or multiple rows of data to the table. Please note
			 * that this is suitable for client-side processing only - if you are using
			 * server-side processing (i.e. "bServerSide": true), then to add data, you
			 * must add it to the data source, i.e. the server-side, through an Ajax call.
			 *  @param {array|object} data The data to be added to the table. This can be:
			 *    <ul>
			 *      <li>1D array of data - add a single row with the data provided</li>
			 *      <li>2D array of arrays - add multiple rows in a single call</li>
			 *      <li>object - data object when using <i>mData</i></li>
			 *      <li>array of objects - multiple data objects when using <i>mData</i></li>
			 *    </ul>
			 *  @param {bool} [redraw=true] redraw the table or not
			 *  @returns {array} An array of integers, representing the list of indexes in
			 *    <i>aoData</i> ({@link DataTable.models.oSettings}) that have been added to
			 *    the table.
			 *  @dtopt API
			 *  @deprecated Since v1.10
			 *
			 *  @example
			 *    // Global var for counter
			 *    var giCount = 2;
			 *
			 *    $(document).ready(function() {
			 *      $('#example').dataTable();
			 *    } );
			 *
			 *    function fnClickAddRow() {
			 *      $('#example').dataTable().fnAddData( [
			 *        giCount+".1",
			 *        giCount+".2",
			 *        giCount+".3",
			 *        giCount+".4" ]
			 *      );
			 *
			 *      giCount++;
			 *    }
			 */
			this.fnAddData = function( data, redraw )
			{
				var api = this.api( true );
			
				/* Check if we want to add multiple rows or not */
				var rows = $.isArray(data) && ( $.isArray(data[0]) || $.isPlainObject(data[0]) ) ?
					api.rows.add( data ) :
					api.row.add( data );
			
				if ( redraw === undefined || redraw ) {
					api.draw();
				}
			
				return rows.flatten().toArray();
			};
			
			
			/**
			 * This function will make DataTables recalculate the column sizes, based on the data
			 * contained in the table and the sizes applied to the columns (in the DOM, CSS or
			 * through the sWidth parameter). This can be useful when the width of the table's
			 * parent element changes (for example a window resize).
			 *  @param {boolean} [bRedraw=true] Redraw the table or not, you will typically want to
			 *  @dtopt API
			 *  @deprecated Since v1.10
			 *
			 *  @example
			 *    $(document).ready(function() {
			 *      var oTable = $('#example').dataTable( {
			 *        "sScrollY": "200px",
			 *        "bPaginate": false
			 *      } );
			 *
			 *      $(window).bind('resize', function () {
			 *        oTable.fnAdjustColumnSizing();
			 *      } );
			 *    } );
			 */
			this.fnAdjustColumnSizing = function ( bRedraw )
			{
				var api = this.api( true ).columns.adjust();
				var settings = api.settings()[0];
				var scroll = settings.oScroll;
			
				if ( bRedraw === undefined || bRedraw ) {
					api.draw( false );
				}
				else if ( scroll.sX !== "" || scroll.sY !== "" ) {
					/* If not redrawing, but scrolling, we want to apply the new column sizes anyway */
					_fnScrollDraw( settings );
				}
			};
			
			
			/**
			 * Quickly and simply clear a table
			 *  @param {bool} [bRedraw=true] redraw the table or not
			 *  @dtopt API
			 *  @deprecated Since v1.10
			 *
			 *  @example
			 *    $(document).ready(function() {
			 *      var oTable = $('#example').dataTable();
			 *
			 *      // Immediately 'nuke' the current rows (perhaps waiting for an Ajax callback...)
			 *      oTable.fnClearTable();
			 *    } );
			 */
			this.fnClearTable = function( bRedraw )
			{
				var api = this.api( true ).clear();
			
				if ( bRedraw === undefined || bRedraw ) {
					api.draw();
				}
			};
			
			
			/**
			 * The exact opposite of 'opening' a row, this function will close any rows which
			 * are currently 'open'.
			 *  @param {node} nTr the table row to 'close'
			 *  @returns {int} 0 on success, or 1 if failed (can't find the row)
			 *  @dtopt API
			 *  @deprecated Since v1.10
			 *
			 *  @example
			 *    $(document).ready(function() {
			 *      var oTable;
			 *
			 *      // 'open' an information row when a row is clicked on
			 *      $('#example tbody tr').click( function () {
			 *        if ( oTable.fnIsOpen(this) ) {
			 *          oTable.fnClose( this );
			 *        } else {
			 *          oTable.fnOpen( this, "Temporary row opened", "info_row" );
			 *        }
			 *      } );
			 *
			 *      oTable = $('#example').dataTable();
			 *    } );
			 */
			this.fnClose = function( nTr )
			{
				this.api( true ).row( nTr ).child.hide();
			};
			
			
			/**
			 * Remove a row for the table
			 *  @param {mixed} target The index of the row from aoData to be deleted, or
			 *    the TR element you want to delete
			 *  @param {function|null} [callBack] Callback function
			 *  @param {bool} [redraw=true] Redraw the table or not
			 *  @returns {array} The row that was deleted
			 *  @dtopt API
			 *  @deprecated Since v1.10
			 *
			 *  @example
			 *    $(document).ready(function() {
			 *      var oTable = $('#example').dataTable();
			 *
			 *      // Immediately remove the first row
			 *      oTable.fnDeleteRow( 0 );
			 *    } );
			 */
			this.fnDeleteRow = function( target, callback, redraw )
			{
				var api = this.api( true );
				var rows = api.rows( target );
				var settings = rows.settings()[0];
				var data = settings.aoData[ rows[0][0] ];
			
				rows.remove();
			
				if ( callback ) {
					callback.call( this, settings, data );
				}
			
				if ( redraw === undefined || redraw ) {
					api.draw();
				}
			
				return data;
			};
			
			
			/**
			 * Restore the table to it's original state in the DOM by removing all of DataTables
			 * enhancements, alterations to the DOM structure of the table and event listeners.
			 *  @param {boolean} [remove=false] Completely remove the table from the DOM
			 *  @dtopt API
			 *  @deprecated Since v1.10
			 *
			 *  @example
			 *    $(document).ready(function() {
			 *      // This example is fairly pointless in reality, but shows how fnDestroy can be used
			 *      var oTable = $('#example').dataTable();
			 *      oTable.fnDestroy();
			 *    } );
			 */
			this.fnDestroy = function ( remove )
			{
				this.api( true ).destroy( remove );
			};
			
			
			/**
			 * Redraw the table
			 *  @param {bool} [complete=true] Re-filter and resort (if enabled) the table before the draw.
			 *  @dtopt API
			 *  @deprecated Since v1.10
			 *
			 *  @example
			 *    $(document).ready(function() {
			 *      var oTable = $('#example').dataTable();
			 *
			 *      // Re-draw the table - you wouldn't want to do it here, but it's an example :-)
			 *      oTable.fnDraw();
			 *    } );
			 */
			this.fnDraw = function( complete )
			{
				// Note that this isn't an exact match to the old call to _fnDraw - it takes
				// into account the new data, but can hold position.
				this.api( true ).draw( complete );
			};
			
			
			/**
			 * Filter the input based on data
			 *  @param {string} sInput String to filter the table on
			 *  @param {int|null} [iColumn] Column to limit filtering to
			 *  @param {bool} [bRegex=false] Treat as regular expression or not
			 *  @param {bool} [bSmart=true] Perform smart filtering or not
			 *  @param {bool} [bShowGlobal=true] Show the input global filter in it's input box(es)
			 *  @param {bool} [bCaseInsensitive=true] Do case-insensitive matching (true) or not (false)
			 *  @dtopt API
			 *  @deprecated Since v1.10
			 *
			 *  @example
			 *    $(document).ready(function() {
			 *      var oTable = $('#example').dataTable();
			 *
			 *      // Sometime later - filter...
			 *      oTable.fnFilter( 'test string' );
			 *    } );
			 */
			this.fnFilter = function( sInput, iColumn, bRegex, bSmart, bShowGlobal, bCaseInsensitive )
			{
				var api = this.api( true );
			
				if ( iColumn === null || iColumn === undefined ) {
					api.search( sInput, bRegex, bSmart, bCaseInsensitive );
				}
				else {
					api.column( iColumn ).search( sInput, bRegex, bSmart, bCaseInsensitive );
				}
			
				api.draw();
			};
			
			
			/**
			 * Get the data for the whole table, an individual row or an individual cell based on the
			 * provided parameters.
			 *  @param {int|node} [src] A TR row node, TD/TH cell node or an integer. If given as
			 *    a TR node then the data source for the whole row will be returned. If given as a
			 *    TD/TH cell node then iCol will be automatically calculated and the data for the
			 *    cell returned. If given as an integer, then this is treated as the aoData internal
			 *    data index for the row (see fnGetPosition) and the data for that row used.
			 *  @param {int} [col] Optional column index that you want the data of.
			 *  @returns {array|object|string} If mRow is undefined, then the data for all rows is
			 *    returned. If mRow is defined, just data for that row, and is iCol is
			 *    defined, only data for the designated cell is returned.
			 *  @dtopt API
			 *  @deprecated Since v1.10
			 *
			 *  @example
			 *    // Row data
			 *    $(document).ready(function() {
			 *      oTable = $('#example').dataTable();
			 *
			 *      oTable.$('tr').click( function () {
			 *        var data = oTable.fnGetData( this );
			 *        // ... do something with the array / object of data for the row
			 *      } );
			 *    } );
			 *
			 *  @example
			 *    // Individual cell data
			 *    $(document).ready(function() {
			 *      oTable = $('#example').dataTable();
			 *
			 *      oTable.$('td').click( function () {
			 *        var sData = oTable.fnGetData( this );
			 *        alert( 'The cell clicked on had the value of '+sData );
			 *      } );
			 *    } );
			 */
			this.fnGetData = function( src, col )
			{
				var api = this.api( true );
			
				if ( src !== undefined ) {
					var type = src.nodeName ? src.nodeName.toLowerCase() : '';
			
					return col !== undefined || type == 'td' || type == 'th' ?
						api.cell( src, col ).data() :
						api.row( src ).data() || null;
				}
			
				return api.data().toArray();
			};
			
			
			/**
			 * Get an array of the TR nodes that are used in the table's body. Note that you will
			 * typically want to use the '$' API method in preference to this as it is more
			 * flexible.
			 *  @param {int} [iRow] Optional row index for the TR element you want
			 *  @returns {array|node} If iRow is undefined, returns an array of all TR elements
			 *    in the table's body, or iRow is defined, just the TR element requested.
			 *  @dtopt API
			 *  @deprecated Since v1.10
			 *
			 *  @example
			 *    $(document).ready(function() {
			 *      var oTable = $('#example').dataTable();
			 *
			 *      // Get the nodes from the table
			 *      var nNodes = oTable.fnGetNodes( );
			 *    } );
			 */
			this.fnGetNodes = function( iRow )
			{
				var api = this.api( true );
			
				return iRow !== undefined ?
					api.row( iRow ).node() :
					api.rows().nodes().flatten().toArray();
			};
			
			
			/**
			 * Get the array indexes of a particular cell from it's DOM element
			 * and column index including hidden columns
			 *  @param {node} node this can either be a TR, TD or TH in the table's body
			 *  @returns {int} If nNode is given as a TR, then a single index is returned, or
			 *    if given as a cell, an array of [row index, column index (visible),
			 *    column index (all)] is given.
			 *  @dtopt API
			 *  @deprecated Since v1.10
			 *
			 *  @example
			 *    $(document).ready(function() {
			 *      $('#example tbody td').click( function () {
			 *        // Get the position of the current data from the node
			 *        var aPos = oTable.fnGetPosition( this );
			 *
			 *        // Get the data array for this row
			 *        var aData = oTable.fnGetData( aPos[0] );
			 *
			 *        // Update the data array and return the value
			 *        aData[ aPos[1] ] = 'clicked';
			 *        this.innerHTML = 'clicked';
			 *      } );
			 *
			 *      // Init DataTables
			 *      oTable = $('#example').dataTable();
			 *    } );
			 */
			this.fnGetPosition = function( node )
			{
				var api = this.api( true );
				var nodeName = node.nodeName.toUpperCase();
			
				if ( nodeName == 'TR' ) {
					return api.row( node ).index();
				}
				else if ( nodeName == 'TD' || nodeName == 'TH' ) {
					var cell = api.cell( node ).index();
			
					return [
						cell.row,
						cell.columnVisible,
						cell.column
					];
				}
				return null;
			};
			
			
			/**
			 * Check to see if a row is 'open' or not.
			 *  @param {node} nTr the table row to check
			 *  @returns {boolean} true if the row is currently open, false otherwise
			 *  @dtopt API
			 *  @deprecated Since v1.10
			 *
			 *  @example
			 *    $(document).ready(function() {
			 *      var oTable;
			 *
			 *      // 'open' an information row when a row is clicked on
			 *      $('#example tbody tr').click( function () {
			 *        if ( oTable.fnIsOpen(this) ) {
			 *          oTable.fnClose( this );
			 *        } else {
			 *          oTable.fnOpen( this, "Temporary row opened", "info_row" );
			 *        }
			 *      } );
			 *
			 *      oTable = $('#example').dataTable();
			 *    } );
			 */
			this.fnIsOpen = function( nTr )
			{
				return this.api( true ).row( nTr ).child.isShown();
			};
			
			
			/**
			 * This function will place a new row directly after a row which is currently
			 * on display on the page, with the HTML contents that is passed into the
			 * function. This can be used, for example, to ask for confirmation that a
			 * particular record should be deleted.
			 *  @param {node} nTr The table row to 'open'
			 *  @param {string|node|jQuery} mHtml The HTML to put into the row
			 *  @param {string} sClass Class to give the new TD cell
			 *  @returns {node} The row opened. Note that if the table row passed in as the
			 *    first parameter, is not found in the table, this method will silently
			 *    return.
			 *  @dtopt API
			 *  @deprecated Since v1.10
			 *
			 *  @example
			 *    $(document).ready(function() {
			 *      var oTable;
			 *
			 *      // 'open' an information row when a row is clicked on
			 *      $('#example tbody tr').click( function () {
			 *        if ( oTable.fnIsOpen(this) ) {
			 *          oTable.fnClose( this );
			 *        } else {
			 *          oTable.fnOpen( this, "Temporary row opened", "info_row" );
			 *        }
			 *      } );
			 *
			 *      oTable = $('#example').dataTable();
			 *    } );
			 */
			this.fnOpen = function( nTr, mHtml, sClass )
			{
				return this.api( true )
					.row( nTr )
					.child( mHtml, sClass )
					.show()
					.child()[0];
			};
			
			
			/**
			 * Change the pagination - provides the internal logic for pagination in a simple API
			 * function. With this function you can have a DataTables table go to the next,
			 * previous, first or last pages.
			 *  @param {string|int} mAction Paging action to take: "first", "previous", "next" or "last"
			 *    or page number to jump to (integer), note that page 0 is the first page.
			 *  @param {bool} [bRedraw=true] Redraw the table or not
			 *  @dtopt API
			 *  @deprecated Since v1.10
			 *
			 *  @example
			 *    $(document).ready(function() {
			 *      var oTable = $('#example').dataTable();
			 *      oTable.fnPageChange( 'next' );
			 *    } );
			 */
			this.fnPageChange = function ( mAction, bRedraw )
			{
				var api = this.api( true ).page( mAction );
			
				if ( bRedraw === undefined || bRedraw ) {
					api.draw(false);
				}
			};
			
			
			/**
			 * Show a particular column
			 *  @param {int} iCol The column whose display should be changed
			 *  @param {bool} bShow Show (true) or hide (false) the column
			 *  @param {bool} [bRedraw=true] Redraw the table or not
			 *  @dtopt API
			 *  @deprecated Since v1.10
			 *
			 *  @example
			 *    $(document).ready(function() {
			 *      var oTable = $('#example').dataTable();
			 *
			 *      // Hide the second column after initialisation
			 *      oTable.fnSetColumnVis( 1, false );
			 *    } );
			 */
			this.fnSetColumnVis = function ( iCol, bShow, bRedraw )
			{
				var api = this.api( true ).column( iCol ).visible( bShow );
			
				if ( bRedraw === undefined || bRedraw ) {
					api.columns.adjust().draw();
				}
			};
			
			
			/**
			 * Get the settings for a particular table for external manipulation
			 *  @returns {object} DataTables settings object. See
			 *    {@link DataTable.models.oSettings}
			 *  @dtopt API
			 *  @deprecated Since v1.10
			 *
			 *  @example
			 *    $(document).ready(function() {
			 *      var oTable = $('#example').dataTable();
			 *      var oSettings = oTable.fnSettings();
			 *
			 *      // Show an example parameter from the settings
			 *      alert( oSettings._iDisplayStart );
			 *    } );
			 */
			this.fnSettings = function()
			{
				return _fnSettingsFromNode( this[_ext.iApiIndex] );
			};
			
			
			/**
			 * Sort the table by a particular column
			 *  @param {int} iCol the data index to sort on. Note that this will not match the
			 *    'display index' if you have hidden data entries
			 *  @dtopt API
			 *  @deprecated Since v1.10
			 *
			 *  @example
			 *    $(document).ready(function() {
			 *      var oTable = $('#example').dataTable();
			 *
			 *      // Sort immediately with columns 0 and 1
			 *      oTable.fnSort( [ [0,'asc'], [1,'asc'] ] );
			 *    } );
			 */
			this.fnSort = function( aaSort )
			{
				this.api( true ).order( aaSort ).draw();
			};
			
			
			/**
			 * Attach a sort listener to an element for a given column
			 *  @param {node} nNode the element to attach the sort listener to
			 *  @param {int} iColumn the column that a click on this node will sort on
			 *  @param {function} [fnCallback] callback function when sort is run
			 *  @dtopt API
			 *  @deprecated Since v1.10
			 *
			 *  @example
			 *    $(document).ready(function() {
			 *      var oTable = $('#example').dataTable();
			 *
			 *      // Sort on column 1, when 'sorter' is clicked on
			 *      oTable.fnSortListener( document.getElementById('sorter'), 1 );
			 *    } );
			 */
			this.fnSortListener = function( nNode, iColumn, fnCallback )
			{
				this.api( true ).order.listener( nNode, iColumn, fnCallback );
			};
			
			
			/**
			 * Update a table cell or row - this method will accept either a single value to
			 * update the cell with, an array of values with one element for each column or
			 * an object in the same format as the original data source. The function is
			 * self-referencing in order to make the multi column updates easier.
			 *  @param {object|array|string} mData Data to update the cell/row with
			 *  @param {node|int} mRow TR element you want to update or the aoData index
			 *  @param {int} [iColumn] The column to update, give as null or undefined to
			 *    update a whole row.
			 *  @param {bool} [bRedraw=true] Redraw the table or not
			 *  @param {bool} [bAction=true] Perform pre-draw actions or not
			 *  @returns {int} 0 on success, 1 on error
			 *  @dtopt API
			 *  @deprecated Since v1.10
			 *
			 *  @example
			 *    $(document).ready(function() {
			 *      var oTable = $('#example').dataTable();
			 *      oTable.fnUpdate( 'Example update', 0, 0 ); // Single cell
			 *      oTable.fnUpdate( ['a', 'b', 'c', 'd', 'e'], $('tbody tr')[0] ); // Row
			 *    } );
			 */
			this.fnUpdate = function( mData, mRow, iColumn, bRedraw, bAction )
			{
				var api = this.api( true );
			
				if ( iColumn === undefined || iColumn === null ) {
					api.row( mRow ).data( mData );
				}
				else {
					api.cell( mRow, iColumn ).data( mData );
				}
			
				if ( bAction === undefined || bAction ) {
					api.columns.adjust();
				}
			
				if ( bRedraw === undefined || bRedraw ) {
					api.draw();
				}
				return 0;
			};
			
			
			/**
			 * Provide a common method for plug-ins to check the version of DataTables being used, in order
			 * to ensure compatibility.
			 *  @param {string} sVersion Version string to check for, in the format "X.Y.Z". Note that the
			 *    formats "X" and "X.Y" are also acceptable.
			 *  @returns {boolean} true if this version of DataTables is greater or equal to the required
			 *    version, or false if this version of DataTales is not suitable
			 *  @method
			 *  @dtopt API
			 *  @deprecated Since v1.10
			 *
			 *  @example
			 *    $(document).ready(function() {
			 *      var oTable = $('#example').dataTable();
			 *      alert( oTable.fnVersionCheck( '1.9.0' ) );
			 *    } );
			 */
			this.fnVersionCheck = _ext.fnVersionCheck;
			
	
			var _that = this;
			var emptyInit = options === undefined;
			var len = this.length;
	
			if ( emptyInit ) {
				options = {};
			}
	
			this.oApi = this.internal = _ext.internal;
	
			// Extend with old style plug-in API methods
			for ( var fn in DataTable.ext.internal ) {
				if ( fn ) {
					this[fn] = _fnExternApiFunc(fn);
				}
			}
	
			this.each(function() {
				// For each initialisation we want to give it a clean initialisation
				// object that can be bashed around
				var o = {};
				var oInit = len > 1 ? // optimisation for single table case
					_fnExtend( o, options, true ) :
					options;
	
				/*global oInit,_that,emptyInit*/
				var i=0, iLen, j, jLen, k, kLen;
				var sId = this.getAttribute( 'id' );
				var bInitHandedOff = false;
				var defaults = DataTable.defaults;
				var $this = $(this);
				
				
				/* Sanity check */
				if ( this.nodeName.toLowerCase() != 'table' )
				{
					_fnLog( null, 0, 'Non-table node initialisation ('+this.nodeName+')', 2 );
					return;
				}
				
				/* Backwards compatibility for the defaults */
				_fnCompatOpts( defaults );
				_fnCompatCols( defaults.column );
				
				/* Convert the camel-case defaults to Hungarian */
				_fnCamelToHungarian( defaults, defaults, true );
				_fnCamelToHungarian( defaults.column, defaults.column, true );
				
				/* Setting up the initialisation object */
				_fnCamelToHungarian( defaults, $.extend( oInit, $this.data() ) );
				
				
				
				/* Check to see if we are re-initialising a table */
				var allSettings = DataTable.settings;
				for ( i=0, iLen=allSettings.length ; i<iLen ; i++ )
				{
					var s = allSettings[i];
				
					/* Base check on table node */
					if ( s.nTable == this || s.nTHead.parentNode == this || (s.nTFoot && s.nTFoot.parentNode == this) )
					{
						var bRetrieve = oInit.bRetrieve !== undefined ? oInit.bRetrieve : defaults.bRetrieve;
						var bDestroy = oInit.bDestroy !== undefined ? oInit.bDestroy : defaults.bDestroy;
				
						if ( emptyInit || bRetrieve )
						{
							return s.oInstance;
						}
						else if ( bDestroy )
						{
							s.oInstance.fnDestroy();
							break;
						}
						else
						{
							_fnLog( s, 0, 'Cannot reinitialise DataTable', 3 );
							return;
						}
					}
				
					/* If the element we are initialising has the same ID as a table which was previously
					 * initialised, but the table nodes don't match (from before) then we destroy the old
					 * instance by simply deleting it. This is under the assumption that the table has been
					 * destroyed by other methods. Anyone using non-id selectors will need to do this manually
					 */
					if ( s.sTableId == this.id )
					{
						allSettings.splice( i, 1 );
						break;
					}
				}
				
				/* Ensure the table has an ID - required for accessibility */
				if ( sId === null || sId === "" )
				{
					sId = "DataTables_Table_"+(DataTable.ext._unique++);
					this.id = sId;
				}
				
				/* Create the settings object for this table and set some of the default parameters */
				var oSettings = $.extend( true, {}, DataTable.models.oSettings, {
					"sDestroyWidth": $this[0].style.width,
					"sInstance":     sId,
					"sTableId":      sId
				} );
				oSettings.nTable = this;
				oSettings.oApi   = _that.internal;
				oSettings.oInit  = oInit;
				
				allSettings.push( oSettings );
				
				// Need to add the instance after the instance after the settings object has been added
				// to the settings array, so we can self reference the table instance if more than one
				oSettings.oInstance = (_that.length===1) ? _that : $this.dataTable();
				
				// Backwards compatibility, before we apply all the defaults
				_fnCompatOpts( oInit );
				
				if ( oInit.oLanguage )
				{
					_fnLanguageCompat( oInit.oLanguage );
				}
				
				// If the length menu is given, but the init display length is not, use the length menu
				if ( oInit.aLengthMenu && ! oInit.iDisplayLength )
				{
					oInit.iDisplayLength = $.isArray( oInit.aLengthMenu[0] ) ?
						oInit.aLengthMenu[0][0] : oInit.aLengthMenu[0];
				}
				
				// Apply the defaults and init options to make a single init object will all
				// options defined from defaults and instance options.
				oInit = _fnExtend( $.extend( true, {}, defaults ), oInit );
				
				
				// Map the initialisation options onto the settings object
				_fnMap( oSettings.oFeatures, oInit, [
					"bPaginate",
					"bLengthChange",
					"bFilter",
					"bSort",
					"bSortMulti",
					"bInfo",
					"bProcessing",
					"bAutoWidth",
					"bSortClasses",
					"bServerSide",
					"bDeferRender"
				] );
				_fnMap( oSettings, oInit, [
					"asStripeClasses",
					"ajax",
					"fnServerData",
					"fnFormatNumber",
					"sServerMethod",
					"aaSorting",
					"aaSortingFixed",
					"aLengthMenu",
					"sPaginationType",
					"sAjaxSource",
					"sAjaxDataProp",
					"iStateDuration",
					"sDom",
					"bSortCellsTop",
					"iTabIndex",
					"fnStateLoadCallback",
					"fnStateSaveCallback",
					"renderer",
					"searchDelay",
					"rowId",
					[ "iCookieDuration", "iStateDuration" ], // backwards compat
					[ "oSearch", "oPreviousSearch" ],
					[ "aoSearchCols", "aoPreSearchCols" ],
					[ "iDisplayLength", "_iDisplayLength" ],
					[ "bJQueryUI", "bJUI" ]
				] );
				_fnMap( oSettings.oScroll, oInit, [
					[ "sScrollX", "sX" ],
					[ "sScrollXInner", "sXInner" ],
					[ "sScrollY", "sY" ],
					[ "bScrollCollapse", "bCollapse" ]
				] );
				_fnMap( oSettings.oLanguage, oInit, "fnInfoCallback" );
				
				/* Callback functions which are array driven */
				_fnCallbackReg( oSettings, 'aoDrawCallback',       oInit.fnDrawCallback,      'user' );
				_fnCallbackReg( oSettings, 'aoServerParams',       oInit.fnServerParams,      'user' );
				_fnCallbackReg( oSettings, 'aoStateSaveParams',    oInit.fnStateSaveParams,   'user' );
				_fnCallbackReg( oSettings, 'aoStateLoadParams',    oInit.fnStateLoadParams,   'user' );
				_fnCallbackReg( oSettings, 'aoStateLoaded',        oInit.fnStateLoaded,       'user' );
				_fnCallbackReg( oSettings, 'aoRowCallback',        oInit.fnRowCallback,       'user' );
				_fnCallbackReg( oSettings, 'aoRowCreatedCallback', oInit.fnCreatedRow,        'user' );
				_fnCallbackReg( oSettings, 'aoHeaderCallback',     oInit.fnHeaderCallback,    'user' );
				_fnCallbackReg( oSettings, 'aoFooterCallback',     oInit.fnFooterCallback,    'user' );
				_fnCallbackReg( oSettings, 'aoInitComplete',       oInit.fnInitComplete,      'user' );
				_fnCallbackReg( oSettings, 'aoPreDrawCallback',    oInit.fnPreDrawCallback,   'user' );
				
				oSettings.rowIdFn = _fnGetObjectDataFn( oInit.rowId );
				
				/* Browser support detection */
				_fnBrowserDetect( oSettings );
				
				var oClasses = oSettings.oClasses;
				
				// @todo Remove in 1.11
				if ( oInit.bJQueryUI )
				{
					/* Use the JUI classes object for display. You could clone the oStdClasses object if
					 * you want to have multiple tables with multiple independent classes
					 */
					$.extend( oClasses, DataTable.ext.oJUIClasses, oInit.oClasses );
				
					if ( oInit.sDom === defaults.sDom && defaults.sDom === "lfrtip" )
					{
						/* Set the DOM to use a layout suitable for jQuery UI's theming */
						oSettings.sDom = '<"H"lfr>t<"F"ip>';
					}
				
					if ( ! oSettings.renderer ) {
						oSettings.renderer = 'jqueryui';
					}
					else if ( $.isPlainObject( oSettings.renderer ) && ! oSettings.renderer.header ) {
						oSettings.renderer.header = 'jqueryui';
					}
				}
				else
				{
					$.extend( oClasses, DataTable.ext.classes, oInit.oClasses );
				}
				$this.addClass( oClasses.sTable );
				
				
				if ( oSettings.iInitDisplayStart === undefined )
				{
					/* Display start point, taking into account the save saving */
					oSettings.iInitDisplayStart = oInit.iDisplayStart;
					oSettings._iDisplayStart = oInit.iDisplayStart;
				}
				
				if ( oInit.iDeferLoading !== null )
				{
					oSettings.bDeferLoading = true;
					var tmp = $.isArray( oInit.iDeferLoading );
					oSettings._iRecordsDisplay = tmp ? oInit.iDeferLoading[0] : oInit.iDeferLoading;
					oSettings._iRecordsTotal = tmp ? oInit.iDeferLoading[1] : oInit.iDeferLoading;
				}
				
				/* Language definitions */
				var oLanguage = oSettings.oLanguage;
				$.extend( true, oLanguage, oInit.oLanguage );
				
				if ( oLanguage.sUrl !== "" )
				{
					/* Get the language definitions from a file - because this Ajax call makes the language
					 * get async to the remainder of this function we use bInitHandedOff to indicate that
					 * _fnInitialise will be fired by the returned Ajax handler, rather than the constructor
					 */
					$.ajax( {
						dataType: 'json',
						url: oLanguage.sUrl,
						success: function ( json ) {
							_fnLanguageCompat( json );
							_fnCamelToHungarian( defaults.oLanguage, json );
							$.extend( true, oLanguage, json );
							_fnInitialise( oSettings );
						},
						error: function () {
							// Error occurred loading language file, continue on as best we can
							_fnInitialise( oSettings );
						}
					} );
					bInitHandedOff = true;
				}
				
				/*
				 * Stripes
				 */
				if ( oInit.asStripeClasses === null )
				{
					oSettings.asStripeClasses =[
						oClasses.sStripeOdd,
						oClasses.sStripeEven
					];
				}
				
				/* Remove row stripe classes if they are already on the table row */
				var stripeClasses = oSettings.asStripeClasses;
				var rowOne = $this.children('tbody').find('tr').eq(0);
				if ( $.inArray( true, $.map( stripeClasses, function(el, i) {
					return rowOne.hasClass(el);
				} ) ) !== -1 ) {
					$('tbody tr', this).removeClass( stripeClasses.join(' ') );
					oSettings.asDestroyStripes = stripeClasses.slice();
				}
				
				/*
				 * Columns
				 * See if we should load columns automatically or use defined ones
				 */
				var anThs = [];
				var aoColumnsInit;
				var nThead = this.getElementsByTagName('thead');
				if ( nThead.length !== 0 )
				{
					_fnDetectHeader( oSettings.aoHeader, nThead[0] );
					anThs = _fnGetUniqueThs( oSettings );
				}
				
				/* If not given a column array, generate one with nulls */
				if ( oInit.aoColumns === null )
				{
					aoColumnsInit = [];
					for ( i=0, iLen=anThs.length ; i<iLen ; i++ )
					{
						aoColumnsInit.push( null );
					}
				}
				else
				{
					aoColumnsInit = oInit.aoColumns;
				}
				
				/* Add the columns */
				for ( i=0, iLen=aoColumnsInit.length ; i<iLen ; i++ )
				{
					_fnAddColumn( oSettings, anThs ? anThs[i] : null );
				}
				
				/* Apply the column definitions */
				_fnApplyColumnDefs( oSettings, oInit.aoColumnDefs, aoColumnsInit, function (iCol, oDef) {
					_fnColumnOptions( oSettings, iCol, oDef );
				} );
				
				/* HTML5 attribute detection - build an mData object automatically if the
				 * attributes are found
				 */
				if ( rowOne.length ) {
					var a = function ( cell, name ) {
						return cell.getAttribute( 'data-'+name ) !== null ? name : null;
					};
				
					$( rowOne[0] ).children('th, td').each( function (i, cell) {
						var col = oSettings.aoColumns[i];
				
						if ( col.mData === i ) {
							var sort = a( cell, 'sort' ) || a( cell, 'order' );
							var filter = a( cell, 'filter' ) || a( cell, 'search' );
				
							if ( sort !== null || filter !== null ) {
								col.mData = {
									_:      i+'.display',
									sort:   sort !== null   ? i+'.@data-'+sort   : undefined,
									type:   sort !== null   ? i+'.@data-'+sort   : undefined,
									filter: filter !== null ? i+'.@data-'+filter : undefined
								};
				
								_fnColumnOptions( oSettings, i );
							}
						}
					} );
				}
				
				var features = oSettings.oFeatures;
				
				/* Must be done after everything which can be overridden by the state saving! */
				if ( oInit.bStateSave )
				{
					features.bStateSave = true;
					_fnLoadState( oSettings, oInit );
					_fnCallbackReg( oSettings, 'aoDrawCallback', _fnSaveState, 'state_save' );
				}
				
				
				/*
				 * Sorting
				 * @todo For modularisation (1.11) this needs to do into a sort start up handler
				 */
				
				// If aaSorting is not defined, then we use the first indicator in asSorting
				// in case that has been altered, so the default sort reflects that option
				if ( oInit.aaSorting === undefined )
				{
					var sorting = oSettings.aaSorting;
					for ( i=0, iLen=sorting.length ; i<iLen ; i++ )
					{
						sorting[i][1] = oSettings.aoColumns[ i ].asSorting[0];
					}
				}
				
				/* Do a first pass on the sorting classes (allows any size changes to be taken into
				 * account, and also will apply sorting disabled classes if disabled
				 */
				_fnSortingClasses( oSettings );
				
				if ( features.bSort )
				{
					_fnCallbackReg( oSettings, 'aoDrawCallback', function () {
						if ( oSettings.bSorted ) {
							var aSort = _fnSortFlatten( oSettings );
							var sortedColumns = {};
				
							$.each( aSort, function (i, val) {
								sortedColumns[ val.src ] = val.dir;
							} );
				
							_fnCallbackFire( oSettings, null, 'order', [oSettings, aSort, sortedColumns] );
							_fnSortAria( oSettings );
						}
					} );
				}
				
				_fnCallbackReg( oSettings, 'aoDrawCallback', function () {
					if ( oSettings.bSorted || _fnDataSource( oSettings ) === 'ssp' || features.bDeferRender ) {
						_fnSortingClasses( oSettings );
					}
				}, 'sc' );
				
				
				/*
				 * Final init
				 * Cache the header, body and footer as required, creating them if needed
				 */
				
				// Work around for Webkit bug 83867 - store the caption-side before removing from doc
				var captions = $this.children('caption').each( function () {
					this._captionSide = $this.css('caption-side');
				} );
				
				var thead = $this.children('thead');
				if ( thead.length === 0 )
				{
					thead = $('<thead/>').appendTo(this);
				}
				oSettings.nTHead = thead[0];
				
				var tbody = $this.children('tbody');
				if ( tbody.length === 0 )
				{
					tbody = $('<tbody/>').appendTo(this);
				}
				oSettings.nTBody = tbody[0];
				
				var tfoot = $this.children('tfoot');
				if ( tfoot.length === 0 && captions.length > 0 && (oSettings.oScroll.sX !== "" || oSettings.oScroll.sY !== "") )
				{
					// If we are a scrolling table, and no footer has been given, then we need to create
					// a tfoot element for the caption element to be appended to
					tfoot = $('<tfoot/>').appendTo(this);
				}
				
				if ( tfoot.length === 0 || tfoot.children().length === 0 ) {
					$this.addClass( oClasses.sNoFooter );
				}
				else if ( tfoot.length > 0 ) {
					oSettings.nTFoot = tfoot[0];
					_fnDetectHeader( oSettings.aoFooter, oSettings.nTFoot );
				}
				
				/* Check if there is data passing into the constructor */
				if ( oInit.aaData )
				{
					for ( i=0 ; i<oInit.aaData.length ; i++ )
					{
						_fnAddData( oSettings, oInit.aaData[ i ] );
					}
				}
				else if ( oSettings.bDeferLoading || _fnDataSource( oSettings ) == 'dom' )
				{
					/* Grab the data from the page - only do this when deferred loading or no Ajax
					 * source since there is no point in reading the DOM data if we are then going
					 * to replace it with Ajax data
					 */
					_fnAddTr( oSettings, $(oSettings.nTBody).children('tr') );
				}
				
				/* Copy the data index array */
				oSettings.aiDisplay = oSettings.aiDisplayMaster.slice();
				
				/* Initialisation complete - table can be drawn */
				oSettings.bInitialised = true;
				
				/* Check if we need to initialise the table (it might not have been handed off to the
				 * language processor)
				 */
				if ( bInitHandedOff === false )
				{
					_fnInitialise( oSettings );
				}
			} );
			_that = null;
			return this;
		};
	
		
		/*
		 * It is useful to have variables which are scoped locally so only the
		 * DataTables functions can access them and they don't leak into global space.
		 * At the same time these functions are often useful over multiple files in the
		 * core and API, so we list, or at least document, all variables which are used
		 * by DataTables as private variables here. This also ensures that there is no
		 * clashing of variable names and that they can easily referenced for reuse.
		 */
		
		
		// Defined else where
		//  _selector_run
		//  _selector_opts
		//  _selector_first
		//  _selector_row_indexes
		
		var _ext; // DataTable.ext
		var _Api; // DataTable.Api
		var _api_register; // DataTable.Api.register
		var _api_registerPlural; // DataTable.Api.registerPlural
		
		var _re_dic = {};
		var _re_new_lines = /[\r\n]/g;
		var _re_html = /<.*?>/g;
		var _re_date_start = /^[\w\+\-]/;
		var _re_date_end = /[\w\+\-]$/;
		
		// Escape regular expression special characters
		var _re_escape_regex = new RegExp( '(\\' + [ '/', '.', '*', '+', '?', '|', '(', ')', '[', ']', '{', '}', '\\', '$', '^', '-' ].join('|\\') + ')', 'g' );
		
		// http://en.wikipedia.org/wiki/Foreign_exchange_market
		// - \u20BD - Russian ruble.
		// - \u20a9 - South Korean Won
		// - \u20BA - Turkish Lira
		// - \u20B9 - Indian Rupee
		// - R - Brazil (R$) and South Africa
		// - fr - Swiss Franc
		// - kr - Swedish krona, Norwegian krone and Danish krone
		// - \u2009 is thin space and \u202F is narrow no-break space, both used in many
		//   standards as thousands separators.
		var _re_formatted_numeric = /[',$Â£â¬Â¥%\u2009\u202F\u20BD\u20a9\u20BArfk]/gi;
		
		
		var _empty = function ( d ) {
			return !d || d === true || d === '-' ? true : false;
		};
		
		
		var _intVal = function ( s ) {
			var integer = parseInt( s, 10 );
			return !isNaN(integer) && isFinite(s) ? integer : null;
		};
		
		// Convert from a formatted number with characters other than `.` as the
		// decimal place, to a Javascript number
		var _numToDecimal = function ( num, decimalPoint ) {
			// Cache created regular expressions for speed as this function is called often
			if ( ! _re_dic[ decimalPoint ] ) {
				_re_dic[ decimalPoint ] = new RegExp( _fnEscapeRegex( decimalPoint ), 'g' );
			}
			return typeof num === 'string' && decimalPoint !== '.' ?
				num.replace( /\./g, '' ).replace( _re_dic[ decimalPoint ], '.' ) :
				num;
		};
		
		
		var _isNumber = function ( d, decimalPoint, formatted ) {
			var strType = typeof d === 'string';
		
			// If empty return immediately so there must be a number if it is a
			// formatted string (this stops the string "k", or "kr", etc being detected
			// as a formatted number for currency
			if ( _empty( d ) ) {
				return true;
			}
		
			if ( decimalPoint && strType ) {
				d = _numToDecimal( d, decimalPoint );
			}
		
			if ( formatted && strType ) {
				d = d.replace( _re_formatted_numeric, '' );
			}
		
			return !isNaN( parseFloat(d) ) && isFinite( d );
		};
		
		
		// A string without HTML in it can be considered to be HTML still
		var _isHtml = function ( d ) {
			return _empty( d ) || typeof d === 'string';
		};
		
		
		var _htmlNumeric = function ( d, decimalPoint, formatted ) {
			if ( _empty( d ) ) {
				return true;
			}
		
			var html = _isHtml( d );
			return ! html ?
				null :
				_isNumber( _stripHtml( d ), decimalPoint, formatted ) ?
					true :
					null;
		};
		
		
		var _pluck = function ( a, prop, prop2 ) {
			var out = [];
			var i=0, ien=a.length;
		
			// Could have the test in the loop for slightly smaller code, but speed
			// is essential here
			if ( prop2 !== undefined ) {
				for ( ; i<ien ; i++ ) {
					if ( a[i] && a[i][ prop ] ) {
						out.push( a[i][ prop ][ prop2 ] );
					}
				}
			}
			else {
				for ( ; i<ien ; i++ ) {
					if ( a[i] ) {
						out.push( a[i][ prop ] );
					}
				}
			}
		
			return out;
		};
		
		
		// Basically the same as _pluck, but rather than looping over `a` we use `order`
		// as the indexes to pick from `a`
		var _pluck_order = function ( a, order, prop, prop2 )
		{
			var out = [];
			var i=0, ien=order.length;
		
			// Could have the test in the loop for slightly smaller code, but speed
			// is essential here
			if ( prop2 !== undefined ) {
				for ( ; i<ien ; i++ ) {
					if ( a[ order[i] ][ prop ] ) {
						out.push( a[ order[i] ][ prop ][ prop2 ] );
					}
				}
			}
			else {
				for ( ; i<ien ; i++ ) {
					out.push( a[ order[i] ][ prop ] );
				}
			}
		
			return out;
		};
		
		
		var _range = function ( len, start )
		{
			var out = [];
			var end;
		
			if ( start === undefined ) {
				start = 0;
				end = len;
			}
			else {
				end = start;
				start = len;
			}
		
			for ( var i=start ; i<end ; i++ ) {
				out.push( i );
			}
		
			return out;
		};
		
		
		var _removeEmpty = function ( a )
		{
			var out = [];
		
			for ( var i=0, ien=a.length ; i<ien ; i++ ) {
				if ( a[i] ) { // careful - will remove all falsy values!
					out.push( a[i] );
				}
			}
		
			return out;
		};
		
		
		var _stripHtml = function ( d ) {
			return d.replace( _re_html, '' );
		};
		
		
		/**
		 * Find the unique elements in a source array.
		 *
		 * @param  {array} src Source array
		 * @return {array} Array of unique items
		 * @ignore
		 */
		var _unique = function ( src )
		{
			// A faster unique method is to use object keys to identify used values,
			// but this doesn't work with arrays or objects, which we must also
			// consider. See jsperf.com/compare-array-unique-versions/4 for more
			// information.
			var
				out = [],
				val,
				i, ien=src.length,
				j, k=0;
		
			again: for ( i=0 ; i<ien ; i++ ) {
				val = src[i];
		
				for ( j=0 ; j<k ; j++ ) {
					if ( out[j] === val ) {
						continue again;
					}
				}
		
				out.push( val );
				k++;
			}
		
			return out;
		};
		
		
		/**
		 * DataTables utility methods
		 * 
		 * This namespace provides helper methods that DataTables uses internally to
		 * create a DataTable, but which are not exclusively used only for DataTables.
		 * These methods can be used by extension authors to save the duplication of
		 * code.
		 *
		 *  @namespace
		 */
		DataTable.util = {
			/**
			 * Throttle the calls to a function. Arguments and context are maintained
			 * for the throttled function.
			 *
			 * @param {function} fn Function to be called
			 * @param {integer} freq Call frequency in mS
			 * @return {function} Wrapped function
			 */
			throttle: function ( fn, freq ) {
				var
					frequency = freq !== undefined ? freq : 200,
					last,
					timer;
		
				return function () {
					var
						that = this,
						now  = +new Date(),
						args = arguments;
		
					if ( last && now < last + frequency ) {
						clearTimeout( timer );
		
						timer = setTimeout( function () {
							last = undefined;
							fn.apply( that, args );
						}, frequency );
					}
					else {
						last = now;
						fn.apply( that, args );
					}
				};
			},
		
		
			/**
			 * Escape a string such that it can be used in a regular expression
			 *
			 *  @param {string} val string to escape
			 *  @returns {string} escaped string
			 */
			escapeRegex: function ( val ) {
				return val.replace( _re_escape_regex, '\\$1' );
			}
		};
		
		
		
		/**
		 * Create a mapping object that allows camel case parameters to be looked up
		 * for their Hungarian counterparts. The mapping is stored in a private
		 * parameter called `_hungarianMap` which can be accessed on the source object.
		 *  @param {object} o
		 *  @memberof DataTable#oApi
		 */
		function _fnHungarianMap ( o )
		{
			var
				hungarian = 'a aa ai ao as b fn i m o s ',
				match,
				newKey,
				map = {};
		
			$.each( o, function (key, val) {
				match = key.match(/^([^A-Z]+?)([A-Z])/);
		
				if ( match && hungarian.indexOf(match[1]+' ') !== -1 )
				{
					newKey = key.replace( match[0], match[2].toLowerCase() );
					map[ newKey ] = key;
		
					if ( match[1] === 'o' )
					{
						_fnHungarianMap( o[key] );
					}
				}
			} );
		
			o._hungarianMap = map;
		}
		
		
		/**
		 * Convert from camel case parameters to Hungarian, based on a Hungarian map
		 * created by _fnHungarianMap.
		 *  @param {object} src The model object which holds all parameters that can be
		 *    mapped.
		 *  @param {object} user The object to convert from camel case to Hungarian.
		 *  @param {boolean} force When set to `true`, properties which already have a
		 *    Hungarian value in the `user` object will be overwritten. Otherwise they
		 *    won't be.
		 *  @memberof DataTable#oApi
		 */
		function _fnCamelToHungarian ( src, user, force )
		{
			if ( ! src._hungarianMap ) {
				_fnHungarianMap( src );
			}
		
			var hungarianKey;
		
			$.each( user, function (key, val) {
				hungarianKey = src._hungarianMap[ key ];
		
				if ( hungarianKey !== undefined && (force || user[hungarianKey] === undefined) )
				{
					// For objects, we need to buzz down into the object to copy parameters
					if ( hungarianKey.charAt(0) === 'o' )
					{
						// Copy the camelCase options over to the hungarian
						if ( ! user[ hungarianKey ] ) {
							user[ hungarianKey ] = {};
						}
						$.extend( true, user[hungarianKey], user[key] );
		
						_fnCamelToHungarian( src[hungarianKey], user[hungarianKey], force );
					}
					else {
						user[hungarianKey] = user[ key ];
					}
				}
			} );
		}
		
		
		/**
		 * Language compatibility - when certain options are given, and others aren't, we
		 * need to duplicate the values over, in order to provide backwards compatibility
		 * with older language files.
		 *  @param {object} oSettings dataTables settings object
		 *  @memberof DataTable#oApi
		 */
		function _fnLanguageCompat( lang )
		{
			var defaults = DataTable.defaults.oLanguage;
			var zeroRecords = lang.sZeroRecords;
		
			/* Backwards compatibility - if there is no sEmptyTable given, then use the same as
			 * sZeroRecords - assuming that is given.
			 */
			if ( ! lang.sEmptyTable && zeroRecords &&
				defaults.sEmptyTable === "No data available in table" )
			{
				_fnMap( lang, lang, 'sZeroRecords', 'sEmptyTable' );
			}
		
			/* Likewise with loading records */
			if ( ! lang.sLoadingRecords && zeroRecords &&
				defaults.sLoadingRecords === "Loading..." )
			{
				_fnMap( lang, lang, 'sZeroRecords', 'sLoadingRecords' );
			}
		
			// Old parameter name of the thousands separator mapped onto the new
			if ( lang.sInfoThousands ) {
				lang.sThousands = lang.sInfoThousands;
			}
		
			var decimal = lang.sDecimal;
			if ( decimal ) {
				_addNumericSort( decimal );
			}
		}
		
		
		/**
		 * Map one parameter onto another
		 *  @param {object} o Object to map
		 *  @param {*} knew The new parameter name
		 *  @param {*} old The old parameter name
		 */
		var _fnCompatMap = function ( o, knew, old ) {
			if ( o[ knew ] !== undefined ) {
				o[ old ] = o[ knew ];
			}
		};
		
		
		/**
		 * Provide backwards compatibility for the main DT options. Note that the new
		 * options are mapped onto the old parameters, so this is an external interface
		 * change only.
		 *  @param {object} init Object to map
		 */
		function _fnCompatOpts ( init )
		{
			_fnCompatMap( init, 'ordering',      'bSort' );
			_fnCompatMap( init, 'orderMulti',    'bSortMulti' );
			_fnCompatMap( init, 'orderClasses',  'bSortClasses' );
			_fnCompatMap( init, 'orderCellsTop', 'bSortCellsTop' );
			_fnCompatMap( init, 'order',         'aaSorting' );
			_fnCompatMap( init, 'orderFixed',    'aaSortingFixed' );
			_fnCompatMap( init, 'paging',        'bPaginate' );
			_fnCompatMap( init, 'pagingType',    'sPaginationType' );
			_fnCompatMap( init, 'pageLength',    'iDisplayLength' );
			_fnCompatMap( init, 'searching',     'bFilter' );
		
			// Boolean initialisation of x-scrolling
			if ( typeof init.sScrollX === 'boolean' ) {
				init.sScrollX = init.sScrollX ? '100%' : '';
			}
			if ( typeof init.scrollX === 'boolean' ) {
				init.scrollX = init.scrollX ? '100%' : '';
			}
		
			// Column search objects are in an array, so it needs to be converted
			// element by element
			var searchCols = init.aoSearchCols;
		
			if ( searchCols ) {
				for ( var i=0, ien=searchCols.length ; i<ien ; i++ ) {
					if ( searchCols[i] ) {
						_fnCamelToHungarian( DataTable.models.oSearch, searchCols[i] );
					}
				}
			}
		}
		
		
		/**
		 * Provide backwards compatibility for column options. Note that the new options
		 * are mapped onto the old parameters, so this is an external interface change
		 * only.
		 *  @param {object} init Object to map
		 */
		function _fnCompatCols ( init )
		{
			_fnCompatMap( init, 'orderable',     'bSortable' );
			_fnCompatMap( init, 'orderData',     'aDataSort' );
			_fnCompatMap( init, 'orderSequence', 'asSorting' );
			_fnCompatMap( init, 'orderDataType', 'sortDataType' );
		
			// orderData can be given as an integer
			var dataSort = init.aDataSort;
			if ( dataSort && ! $.isArray( dataSort ) ) {
				init.aDataSort = [ dataSort ];
			}
		}
		
		
		/**
		 * Browser feature detection for capabilities, quirks
		 *  @param {object} settings dataTables settings object
		 *  @memberof DataTable#oApi
		 */
		function _fnBrowserDetect( settings )
		{
			// We don't need to do this every time DataTables is constructed, the values
			// calculated are specific to the browser and OS configuration which we
			// don't expect to change between initialisations
			if ( ! DataTable.__browser ) {
				var browser = {};
				DataTable.__browser = browser;
		
				// Scrolling feature / quirks detection
				var n = $('<div/>')
					.css( {
						position: 'fixed',
						top: 0,
						left: 0,
						height: 1,
						width: 1,
						overflow: 'hidden'
					} )
					.append(
						$('<div/>')
							.css( {
								position: 'absolute',
								top: 1,
								left: 1,
								width: 100,
								overflow: 'scroll'
							} )
							.append(
								$('<div/>')
									.css( {
										width: '100%',
										height: 10
									} )
							)
					)
					.appendTo( 'body' );
		
				var outer = n.children();
				var inner = outer.children();
		
				// Numbers below, in order, are:
				// inner.offsetWidth, inner.clientWidth, outer.offsetWidth, outer.clientWidth
				//
				// IE6 XP:                           100 100 100  83
				// IE7 Vista:                        100 100 100  83
				// IE 8+ Windows:                     83  83 100  83
				// Evergreen Windows:                 83  83 100  83
				// Evergreen Mac with scrollbars:     85  85 100  85
				// Evergreen Mac without scrollbars: 100 100 100 100
		
				// Get scrollbar width
				browser.barWidth = outer[0].offsetWidth - outer[0].clientWidth;
		
				// IE6/7 will oversize a width 100% element inside a scrolling element, to
				// include the width of the scrollbar, while other browsers ensure the inner
				// element is contained without forcing scrolling
				browser.bScrollOversize = inner[0].offsetWidth === 100 && outer[0].clientWidth !== 100;
		
				// In rtl text layout, some browsers (most, but not all) will place the
				// scrollbar on the left, rather than the right.
				browser.bScrollbarLeft = Math.round( inner.offset().left ) !== 1;
		
				// IE8- don't provide height and width for getBoundingClientRect
				browser.bBounding = n[0].getBoundingClientRect().width ? true : false;
		
				n.remove();
			}
		
			$.extend( settings.oBrowser, DataTable.__browser );
			settings.oScroll.iBarWidth = DataTable.__browser.barWidth;
		}
		
		
		/**
		 * Array.prototype reduce[Right] method, used for browsers which don't support
		 * JS 1.6. Done this way to reduce code size, since we iterate either way
		 *  @param {object} settings dataTables settings object
		 *  @memberof DataTable#oApi
		 */
		function _fnReduce ( that, fn, init, start, end, inc )
		{
			var
				i = start,
				value,
				isSet = false;
		
			if ( init !== undefined ) {
				value = init;
				isSet = true;
			}
		
			while ( i !== end ) {
				if ( ! that.hasOwnProperty(i) ) {
					continue;
				}
		
				value = isSet ?
					fn( value, that[i], i, that ) :
					that[i];
		
				isSet = true;
				i += inc;
			}
		
			return value;
		}
		
		/**
		 * Add a column to the list used for the table with default values
		 *  @param {object} oSettings dataTables settings object
		 *  @param {node} nTh The th element for this column
		 *  @memberof DataTable#oApi
		 */
		function _fnAddColumn( oSettings, nTh )
		{
			// Add column to aoColumns array
			var oDefaults = DataTable.defaults.column;
			var iCol = oSettings.aoColumns.length;
			var oCol = $.extend( {}, DataTable.models.oColumn, oDefaults, {
				"nTh": nTh ? nTh : document.createElement('th'),
				"sTitle":    oDefaults.sTitle    ? oDefaults.sTitle    : nTh ? nTh.innerHTML : '',
				"aDataSort": oDefaults.aDataSort ? oDefaults.aDataSort : [iCol],
				"mData": oDefaults.mData ? oDefaults.mData : iCol,
				idx: iCol
			} );
			oSettings.aoColumns.push( oCol );
		
			// Add search object for column specific search. Note that the `searchCols[ iCol ]`
			// passed into extend can be undefined. This allows the user to give a default
			// with only some of the parameters defined, and also not give a default
			var searchCols = oSettings.aoPreSearchCols;
			searchCols[ iCol ] = $.extend( {}, DataTable.models.oSearch, searchCols[ iCol ] );
		
			// Use the default column options function to initialise classes etc
			_fnColumnOptions( oSettings, iCol, $(nTh).data() );
		}
		
		
		/**
		 * Apply options for a column
		 *  @param {object} oSettings dataTables settings object
		 *  @param {int} iCol column index to consider
		 *  @param {object} oOptions object with sType, bVisible and bSearchable etc
		 *  @memberof DataTable#oApi
		 */
		function _fnColumnOptions( oSettings, iCol, oOptions )
		{
			var oCol = oSettings.aoColumns[ iCol ];
			var oClasses = oSettings.oClasses;
			var th = $(oCol.nTh);
		
			// Try to get width information from the DOM. We can't get it from CSS
			// as we'd need to parse the CSS stylesheet. `width` option can override
			if ( ! oCol.sWidthOrig ) {
				// Width attribute
				oCol.sWidthOrig = th.attr('width') || null;
		
				// Style attribute
				var t = (th.attr('style') || '').match(/width:\s*(\d+[pxem%]+)/);
				if ( t ) {
					oCol.sWidthOrig = t[1];
				}
			}
		
			/* User specified column options */
			if ( oOptions !== undefined && oOptions !== null )
			{
				// Backwards compatibility
				_fnCompatCols( oOptions );
		
				// Map camel case parameters to their Hungarian counterparts
				_fnCamelToHungarian( DataTable.defaults.column, oOptions );
		
				/* Backwards compatibility for mDataProp */
				if ( oOptions.mDataProp !== undefined && !oOptions.mData )
				{
					oOptions.mData = oOptions.mDataProp;
				}
		
				if ( oOptions.sType )
				{
					oCol._sManualType = oOptions.sType;
				}
		
				// `class` is a reserved word in Javascript, so we need to provide
				// the ability to use a valid name for the camel case input
				if ( oOptions.className && ! oOptions.sClass )
				{
					oOptions.sClass = oOptions.className;
				}
		
				$.extend( oCol, oOptions );
				_fnMap( oCol, oOptions, "sWidth", "sWidthOrig" );
		
				/* iDataSort to be applied (backwards compatibility), but aDataSort will take
				 * priority if defined
				 */
				if ( oOptions.iDataSort !== undefined )
				{
					oCol.aDataSort = [ oOptions.iDataSort ];
				}
				_fnMap( oCol, oOptions, "aDataSort" );
			}
		
			/* Cache the data get and set functions for speed */
			var mDataSrc = oCol.mData;
			var mData = _fnGetObjectDataFn( mDataSrc );
			var mRender = oCol.mRender ? _fnGetObjectDataFn( oCol.mRender ) : null;
		
			var attrTest = function( src ) {
				return typeof src === 'string' && src.indexOf('@') !== -1;
			};
			oCol._bAttrSrc = $.isPlainObject( mDataSrc ) && (
				attrTest(mDataSrc.sort) || attrTest(mDataSrc.type) || attrTest(mDataSrc.filter)
			);
			oCol._setter = null;
		
			oCol.fnGetData = function (rowData, type, meta) {
				var innerData = mData( rowData, type, undefined, meta );
		
				return mRender && type ?
					mRender( innerData, type, rowData, meta ) :
					innerData;
			};
			oCol.fnSetData = function ( rowData, val, meta ) {
				return _fnSetObjectDataFn( mDataSrc )( rowData, val, meta );
			};
		
			// Indicate if DataTables should read DOM data as an object or array
			// Used in _fnGetRowElements
			if ( typeof mDataSrc !== 'number' ) {
				oSettings._rowReadObject = true;
			}
		
			/* Feature sorting overrides column specific when off */
			if ( !oSettings.oFeatures.bSort )
			{
				oCol.bSortable = false;
				th.addClass( oClasses.sSortableNone ); // Have to add class here as order event isn't called
			}
		
			/* Check that the class assignment is correct for sorting */
			var bAsc = $.inArray('asc', oCol.asSorting) !== -1;
			var bDesc = $.inArray('desc', oCol.asSorting) !== -1;
			if ( !oCol.bSortable || (!bAsc && !bDesc) )
			{
				oCol.sSortingClass = oClasses.sSortableNone;
				oCol.sSortingClassJUI = "";
			}
			else if ( bAsc && !bDesc )
			{
				oCol.sSortingClass = oClasses.sSortableAsc;
				oCol.sSortingClassJUI = oClasses.sSortJUIAscAllowed;
			}
			else if ( !bAsc && bDesc )
			{
				oCol.sSortingClass = oClasses.sSortableDesc;
				oCol.sSortingClassJUI = oClasses.sSortJUIDescAllowed;
			}
			else
			{
				oCol.sSortingClass = oClasses.sSortable;
				oCol.sSortingClassJUI = oClasses.sSortJUI;
			}
		}
		
		
		/**
		 * Adjust the table column widths for new data. Note: you would probably want to
		 * do a redraw after calling this function!
		 *  @param {object} settings dataTables settings object
		 *  @memberof DataTable#oApi
		 */
		function _fnAdjustColumnSizing ( settings )
		{
			/* Not interested in doing column width calculation if auto-width is disabled */
			if ( settings.oFeatures.bAutoWidth !== false )
			{
				var columns = settings.aoColumns;
		
				_fnCalculateColumnWidths( settings );
				for ( var i=0 , iLen=columns.length ; i<iLen ; i++ )
				{
					columns[i].nTh.style.width = columns[i].sWidth;
				}
			}
		
			var scroll = settings.oScroll;
			if ( scroll.sY !== '' || scroll.sX !== '')
			{
				_fnScrollDraw( settings );
			}
		
			_fnCallbackFire( settings, null, 'column-sizing', [settings] );
		}
		
		
		/**
		 * Covert the index of a visible column to the index in the data array (take account
		 * of hidden columns)
		 *  @param {object} oSettings dataTables settings object
		 *  @param {int} iMatch Visible column index to lookup
		 *  @returns {int} i the data index
		 *  @memberof DataTable#oApi
		 */
		function _fnVisibleToColumnIndex( oSettings, iMatch )
		{
			var aiVis = _fnGetColumns( oSettings, 'bVisible' );
		
			return typeof aiVis[iMatch] === 'number' ?
				aiVis[iMatch] :
				null;
		}
		
		
		/**
		 * Covert the index of an index in the data array and convert it to the visible
		 *   column index (take account of hidden columns)
		 *  @param {int} iMatch Column index to lookup
		 *  @param {object} oSettings dataTables settings object
		 *  @returns {int} i the data index
		 *  @memberof DataTable#oApi
		 */
		function _fnColumnIndexToVisible( oSettings, iMatch )
		{
			var aiVis = _fnGetColumns( oSettings, 'bVisible' );
			var iPos = $.inArray( iMatch, aiVis );
		
			return iPos !== -1 ? iPos : null;
		}
		
		
		/**
		 * Get the number of visible columns
		 *  @param {object} oSettings dataTables settings object
		 *  @returns {int} i the number of visible columns
		 *  @memberof DataTable#oApi
		 */
		function _fnVisbleColumns( oSettings )
		{
			var vis = 0;
		
			// No reduce in IE8, use a loop for now
			$.each( oSettings.aoColumns, function ( i, col ) {
				if ( col.bVisible && $(col.nTh).css('display') !== 'none' ) {
					vis++;
				}
			} );
		
			return vis;
		}
		
		
		/**
		 * Get an array of column indexes that match a given property
		 *  @param {object} oSettings dataTables settings object
		 *  @param {string} sParam Parameter in aoColumns to look for - typically
		 *    bVisible or bSearchable
		 *  @returns {array} Array of indexes with matched properties
		 *  @memberof DataTable#oApi
		 */
		function _fnGetColumns( oSettings, sParam )
		{
			var a = [];
		
			$.map( oSettings.aoColumns, function(val, i) {
				if ( val[sParam] ) {
					a.push( i );
				}
			} );
		
			return a;
		}
		
		
		/**
		 * Calculate the 'type' of a column
		 *  @param {object} settings dataTables settings object
		 *  @memberof DataTable#oApi
		 */
		function _fnColumnTypes ( settings )
		{
			var columns = settings.aoColumns;
			var data = settings.aoData;
			var types = DataTable.ext.type.detect;
			var i, ien, j, jen, k, ken;
			var col, cell, detectedType, cache;
		
			// For each column, spin over the 
			for ( i=0, ien=columns.length ; i<ien ; i++ ) {
				col = columns[i];
				cache = [];
		
				if ( ! col.sType && col._sManualType ) {
					col.sType = col._sManualType;
				}
				else if ( ! col.sType ) {
					for ( j=0, jen=types.length ; j<jen ; j++ ) {
						for ( k=0, ken=data.length ; k<ken ; k++ ) {
							// Use a cache array so we only need to get the type data
							// from the formatter once (when using multiple detectors)
							if ( cache[k] === undefined ) {
								cache[k] = _fnGetCellData( settings, k, i, 'type' );
							}
		
							detectedType = types[j]( cache[k], settings );
		
							// If null, then this type can't apply to this column, so
							// rather than testing all cells, break out. There is an
							// exception for the last type which is `html`. We need to
							// scan all rows since it is possible to mix string and HTML
							// types
							if ( ! detectedType && j !== types.length-1 ) {
								break;
							}
		
							// Only a single match is needed for html type since it is
							// bottom of the pile and very similar to string
							if ( detectedType === 'html' ) {
								break;
							}
						}
		
						// Type is valid for all data points in the column - use this
						// type
						if ( detectedType ) {
							col.sType = detectedType;
							break;
						}
					}
		
					// Fall back - if no type was detected, always use string
					if ( ! col.sType ) {
						col.sType = 'string';
					}
				}
			}
		}
		
		
		/**
		 * Take the column definitions and static columns arrays and calculate how
		 * they relate to column indexes. The callback function will then apply the
		 * definition found for a column to a suitable configuration object.
		 *  @param {object} oSettings dataTables settings object
		 *  @param {array} aoColDefs The aoColumnDefs array that is to be applied
		 *  @param {array} aoCols The aoColumns array that defines columns individually
		 *  @param {function} fn Callback function - takes two parameters, the calculated
		 *    column index and the definition for that column.
		 *  @memberof DataTable#oApi
		 */
		function _fnApplyColumnDefs( oSettings, aoColDefs, aoCols, fn )
		{
			var i, iLen, j, jLen, k, kLen, def;
			var columns = oSettings.aoColumns;
		
			// Column definitions with aTargets
			if ( aoColDefs )
			{
				/* Loop over the definitions array - loop in reverse so first instance has priority */
				for ( i=aoColDefs.length-1 ; i>=0 ; i-- )
				{
					def = aoColDefs[i];
		
					/* Each definition can target multiple columns, as it is an array */
					var aTargets = def.targets !== undefined ?
						def.targets :
						def.aTargets;
		
					if ( ! $.isArray( aTargets ) )
					{
						aTargets = [ aTargets ];
					}
		
					for ( j=0, jLen=aTargets.length ; j<jLen ; j++ )
					{
						if ( typeof aTargets[j] === 'number' && aTargets[j] >= 0 )
						{
							/* Add columns that we don't yet know about */
							while( columns.length <= aTargets[j] )
							{
								_fnAddColumn( oSettings );
							}
		
							/* Integer, basic index */
							fn( aTargets[j], def );
						}
						else if ( typeof aTargets[j] === 'number' && aTargets[j] < 0 )
						{
							/* Negative integer, right to left column counting */
							fn( columns.length+aTargets[j], def );
						}
						else if ( typeof aTargets[j] === 'string' )
						{
							/* Class name matching on TH element */
							for ( k=0, kLen=columns.length ; k<kLen ; k++ )
							{
								if ( aTargets[j] == "_all" ||
								     $(columns[k].nTh).hasClass( aTargets[j] ) )
								{
									fn( k, def );
								}
							}
						}
					}
				}
			}
		
			// Statically defined columns array
			if ( aoCols )
			{
				for ( i=0, iLen=aoCols.length ; i<iLen ; i++ )
				{
					fn( i, aoCols[i] );
				}
			}
		}
		
		/**
		 * Add a data array to the table, creating DOM node etc. This is the parallel to
		 * _fnGatherData, but for adding rows from a Javascript source, rather than a
		 * DOM source.
		 *  @param {object} oSettings dataTables settings object
		 *  @param {array} aData data array to be added
		 *  @param {node} [nTr] TR element to add to the table - optional. If not given,
		 *    DataTables will create a row automatically
		 *  @param {array} [anTds] Array of TD|TH elements for the row - must be given
		 *    if nTr is.
		 *  @returns {int} >=0 if successful (index of new aoData entry), -1 if failed
		 *  @memberof DataTable#oApi
		 */
		function _fnAddData ( oSettings, aDataIn, nTr, anTds )
		{
			/* Create the object for storing information about this new row */
			var iRow = oSettings.aoData.length;
			var oData = $.extend( true, {}, DataTable.models.oRow, {
				src: nTr ? 'dom' : 'data',
				idx: iRow
			} );
		
			oData._aData = aDataIn;
			oSettings.aoData.push( oData );
		
			/* Create the cells */
			var nTd, sThisType;
			var columns = oSettings.aoColumns;
		
			// Invalidate the column types as the new data needs to be revalidated
			for ( var i=0, iLen=columns.length ; i<iLen ; i++ )
			{
				columns[i].sType = null;
			}
		
			/* Add to the display array */
			oSettings.aiDisplayMaster.push( iRow );
		
			var id = oSettings.rowIdFn( aDataIn );
			if ( id !== undefined ) {
				oSettings.aIds[ id ] = oData;
			}
		
			/* Create the DOM information, or register it if already present */
			if ( nTr || ! oSettings.oFeatures.bDeferRender )
			{
				_fnCreateTr( oSettings, iRow, nTr, anTds );
			}
		
			return iRow;
		}
		
		
		/**
		 * Add one or more TR elements to the table. Generally we'd expect to
		 * use this for reading data from a DOM sourced table, but it could be
		 * used for an TR element. Note that if a TR is given, it is used (i.e.
		 * it is not cloned).
		 *  @param {object} settings dataTables settings object
		 *  @param {array|node|jQuery} trs The TR element(s) to add to the table
		 *  @returns {array} Array of indexes for the added rows
		 *  @memberof DataTable#oApi
		 */
		function _fnAddTr( settings, trs )
		{
			var row;
		
			// Allow an individual node to be passed in
			if ( ! (trs instanceof $) ) {
				trs = $(trs);
			}
		
			return trs.map( function (i, el) {
				row = _fnGetRowElements( settings, el );
				return _fnAddData( settings, row.data, el, row.cells );
			} );
		}
		
		
		/**
		 * Take a TR element and convert it to an index in aoData
		 *  @param {object} oSettings dataTables settings object
		 *  @param {node} n the TR element to find
		 *  @returns {int} index if the node is found, null if not
		 *  @memberof DataTable#oApi
		 */
		function _fnNodeToDataIndex( oSettings, n )
		{
			return (n._DT_RowIndex!==undefined) ? n._DT_RowIndex : null;
		}
		
		
		/**
		 * Take a TD element and convert it into a column data index (not the visible index)
		 *  @param {object} oSettings dataTables settings object
		 *  @param {int} iRow The row number the TD/TH can be found in
		 *  @param {node} n The TD/TH element to find
		 *  @returns {int} index if the node is found, -1 if not
		 *  @memberof DataTable#oApi
		 */
		function _fnNodeToColumnIndex( oSettings, iRow, n )
		{
			return $.inArray( n, oSettings.aoData[ iRow ].anCells );
		}
		
		
		/**
		 * Get the data for a given cell from the internal cache, taking into account data mapping
		 *  @param {object} settings dataTables settings object
		 *  @param {int} rowIdx aoData row id
		 *  @param {int} colIdx Column index
		 *  @param {string} type data get type ('display', 'type' 'filter' 'sort')
		 *  @returns {*} Cell data
		 *  @memberof DataTable#oApi
		 */
		function _fnGetCellData( settings, rowIdx, colIdx, type )
		{
			var draw           = settings.iDraw;
			var col            = settings.aoColumns[colIdx];
			var rowData        = settings.aoData[rowIdx]._aData;
			var defaultContent = col.sDefaultContent;
			var cellData       = col.fnGetData( rowData, type, {
				settings: settings,
				row:      rowIdx,
				col:      colIdx
			} );
		
			if ( cellData === undefined ) {
				if ( settings.iDrawError != draw && defaultContent === null ) {
					_fnLog( settings, 0, "Requested unknown parameter "+
						(typeof col.mData=='function' ? '{function}' : "'"+col.mData+"'")+
						" for row "+rowIdx+", column "+colIdx, 4 );
					settings.iDrawError = draw;
				}
				return defaultContent;
			}
		
			// When the data source is null and a specific data type is requested (i.e.
			// not the original data), we can use default column data
			if ( (cellData === rowData || cellData === null) && defaultContent !== null && type !== undefined ) {
				cellData = defaultContent;
			}
			else if ( typeof cellData === 'function' ) {
				// If the data source is a function, then we run it and use the return,
				// executing in the scope of the data object (for instances)
				return cellData.call( rowData );
			}
		
			if ( cellData === null && type == 'display' ) {
				return '';
			}
			return cellData;
		}
		
		
		/**
		 * Set the value for a specific cell, into the internal data cache
		 *  @param {object} settings dataTables settings object
		 *  @param {int} rowIdx aoData row id
		 *  @param {int} colIdx Column index
		 *  @param {*} val Value to set
		 *  @memberof DataTable#oApi
		 */
		function _fnSetCellData( settings, rowIdx, colIdx, val )
		{
			var col     = settings.aoColumns[colIdx];
			var rowData = settings.aoData[rowIdx]._aData;
		
			col.fnSetData( rowData, val, {
				settings: settings,
				row:      rowIdx,
				col:      colIdx
			}  );
		}
		
		
		// Private variable that is used to match action syntax in the data property object
		var __reArray = /\[.*?\]$/;
		var __reFn = /\(\)$/;
		
		/**
		 * Split string on periods, taking into account escaped periods
		 * @param  {string} str String to split
		 * @return {array} Split string
		 */
		function _fnSplitObjNotation( str )
		{
			return $.map( str.match(/(\\.|[^\.])+/g) || [''], function ( s ) {
				return s.replace(/\\./g, '.');
			} );
		}
		
		
		/**
		 * Return a function that can be used to get data from a source object, taking
		 * into account the ability to use nested objects as a source
		 *  @param {string|int|function} mSource The data source for the object
		 *  @returns {function} Data get function
		 *  @memberof DataTable#oApi
		 */
		function _fnGetObjectDataFn( mSource )
		{
			if ( $.isPlainObject( mSource ) )
			{
				/* Build an object of get functions, and wrap them in a single call */
				var o = {};
				$.each( mSource, function (key, val) {
					if ( val ) {
						o[key] = _fnGetObjectDataFn( val );
					}
				} );
		
				return function (data, type, row, meta) {
					var t = o[type] || o._;
					return t !== undefined ?
						t(data, type, row, meta) :
						data;
				};
			}
			else if ( mSource === null )
			{
				/* Give an empty string for rendering / sorting etc */
				return function (data) { // type, row and meta also passed, but not used
					return data;
				};
			}
			else if ( typeof mSource === 'function' )
			{
				return function (data, type, row, meta) {
					return mSource( data, type, row, meta );
				};
			}
			else if ( typeof mSource === 'string' && (mSource.indexOf('.') !== -1 ||
				      mSource.indexOf('[') !== -1 || mSource.indexOf('(') !== -1) )
			{
				/* If there is a . in the source string then the data source is in a
				 * nested object so we loop over the data for each level to get the next
				 * level down. On each loop we test for undefined, and if found immediately
				 * return. This allows entire objects to be missing and sDefaultContent to
				 * be used if defined, rather than throwing an error
				 */
				var fetchData = function (data, type, src) {
					var arrayNotation, funcNotation, out, innerSrc;
		
					if ( src !== "" )
					{
						var a = _fnSplitObjNotation( src );
		
						for ( var i=0, iLen=a.length ; i<iLen ; i++ )
						{
							// Check if we are dealing with special notation
							arrayNotation = a[i].match(__reArray);
							funcNotation = a[i].match(__reFn);
		
							if ( arrayNotation )
							{
								// Array notation
								a[i] = a[i].replace(__reArray, '');
		
								// Condition allows simply [] to be passed in
								if ( a[i] !== "" ) {
									data = data[ a[i] ];
								}
								out = [];
		
								// Get the remainder of the nested object to get
								a.splice( 0, i+1 );
								innerSrc = a.join('.');
		
								// Traverse each entry in the array getting the properties requested
								if ( $.isArray( data ) ) {
									for ( var j=0, jLen=data.length ; j<jLen ; j++ ) {
										out.push( fetchData( data[j], type, innerSrc ) );
									}
								}
		
								// If a string is given in between the array notation indicators, that
								// is used to join the strings together, otherwise an array is returned
								var join = arrayNotation[0].substring(1, arrayNotation[0].length-1);
								data = (join==="") ? out : out.join(join);
		
								// The inner call to fetchData has already traversed through the remainder
								// of the source requested, so we exit from the loop
								break;
							}
							else if ( funcNotation )
							{
								// Function call
								a[i] = a[i].replace(__reFn, '');
								data = data[ a[i] ]();
								continue;
							}
		
							if ( data === null || data[ a[i] ] === undefined )
							{
								return undefined;
							}
							data = data[ a[i] ];
						}
					}
		
					return data;
				};
		
				return function (data, type) { // row and meta also passed, but not used
					return fetchData( data, type, mSource );
				};
			}
			else
			{
				/* Array or flat object mapping */
				return function (data, type) { // row and meta also passed, but not used
					return data[mSource];
				};
			}
		}
		
		
		/**
		 * Return a function that can be used to set data from a source object, taking
		 * into account the ability to use nested objects as a source
		 *  @param {string|int|function} mSource The data source for the object
		 *  @returns {function} Data set function
		 *  @memberof DataTable#oApi
		 */
		function _fnSetObjectDataFn( mSource )
		{
			if ( $.isPlainObject( mSource ) )
			{
				/* Unlike get, only the underscore (global) option is used for for
				 * setting data since we don't know the type here. This is why an object
				 * option is not documented for `mData` (which is read/write), but it is
				 * for `mRender` which is read only.
				 */
				return _fnSetObjectDataFn( mSource._ );
			}
			else if ( mSource === null )
			{
				/* Nothing to do when the data source is null */
				return function () {};
			}
			else if ( typeof mSource === 'function' )
			{
				return function (data, val, meta) {
					mSource( data, 'set', val, meta );
				};
			}
			else if ( typeof mSource === 'string' && (mSource.indexOf('.') !== -1 ||
				      mSource.indexOf('[') !== -1 || mSource.indexOf('(') !== -1) )
			{
				/* Like the get, we need to get data from a nested object */
				var setData = function (data, val, src) {
					var a = _fnSplitObjNotation( src ), b;
					var aLast = a[a.length-1];
					var arrayNotation, funcNotation, o, innerSrc;
		
					for ( var i=0, iLen=a.length-1 ; i<iLen ; i++ )
					{
						// Check if we are dealing with an array notation request
						arrayNotation = a[i].match(__reArray);
						funcNotation = a[i].match(__reFn);
		
						if ( arrayNotation )
						{
							a[i] = a[i].replace(__reArray, '');
							data[ a[i] ] = [];
		
							// Get the remainder of the nested object to set so we can recurse
							b = a.slice();
							b.splice( 0, i+1 );
							innerSrc = b.join('.');
		
							// Traverse each entry in the array setting the properties requested
							if ( $.isArray( val ) )
							{
								for ( var j=0, jLen=val.length ; j<jLen ; j++ )
								{
									o = {};
									setData( o, val[j], innerSrc );
									data[ a[i] ].push( o );
								}
							}
							else
							{
								// We've been asked to save data to an array, but it
								// isn't array data to be saved. Best that can be done
								// is to just save the value.
								data[ a[i] ] = val;
							}
		
							// The inner call to setData has already traversed through the remainder
							// of the source and has set the data, thus we can exit here
							return;
						}
						else if ( funcNotation )
						{
							// Function call
							a[i] = a[i].replace(__reFn, '');
							data = data[ a[i] ]( val );
						}
		
						// If the nested object doesn't currently exist - since we are
						// trying to set the value - create it
						if ( data[ a[i] ] === null || data[ a[i] ] === undefined )
						{
							data[ a[i] ] = {};
						}
						data = data[ a[i] ];
					}
		
					// Last item in the input - i.e, the actual set
					if ( aLast.match(__reFn ) )
					{
						// Function call
						data = data[ aLast.replace(__reFn, '') ]( val );
					}
					else
					{
						// If array notation is used, we just want to strip it and use the property name
						// and assign the value. If it isn't used, then we get the result we want anyway
						data[ aLast.replace(__reArray, '') ] = val;
					}
				};
		
				return function (data, val) { // meta is also passed in, but not used
					return setData( data, val, mSource );
				};
			}
			else
			{
				/* Array or flat object mapping */
				return function (data, val) { // meta is also passed in, but not used
					data[mSource] = val;
				};
			}
		}
		
		
		/**
		 * Return an array with the full table data
		 *  @param {object} oSettings dataTables settings object
		 *  @returns array {array} aData Master data array
		 *  @memberof DataTable#oApi
		 */
		function _fnGetDataMaster ( settings )
		{
			return _pluck( settings.aoData, '_aData' );
		}
		
		
		/**
		 * Nuke the table
		 *  @param {object} oSettings dataTables settings object
		 *  @memberof DataTable#oApi
		 */
		function _fnClearTable( settings )
		{
			settings.aoData.length = 0;
			settings.aiDisplayMaster.length = 0;
			settings.aiDisplay.length = 0;
			settings.aIds = {};
		}
		
		
		 /**
		 * Take an array of integers (index array) and remove a target integer (value - not
		 * the key!)
		 *  @param {array} a Index array to target
		 *  @param {int} iTarget value to find
		 *  @memberof DataTable#oApi
		 */
		function _fnDeleteIndex( a, iTarget, splice )
		{
			var iTargetIndex = -1;
		
			for ( var i=0, iLen=a.length ; i<iLen ; i++ )
			{
				if ( a[i] == iTarget )
				{
					iTargetIndex = i;
				}
				else if ( a[i] > iTarget )
				{
					a[i]--;
				}
			}
		
			if ( iTargetIndex != -1 && splice === undefined )
			{
				a.splice( iTargetIndex, 1 );
			}
		}
		
		
		/**
		 * Mark cached data as invalid such that a re-read of the data will occur when
		 * the cached data is next requested. Also update from the data source object.
		 *
		 * @param {object} settings DataTables settings object
		 * @param {int}    rowIdx   Row index to invalidate
		 * @param {string} [src]    Source to invalidate from: undefined, 'auto', 'dom'
		 *     or 'data'
		 * @param {int}    [colIdx] Column index to invalidate. If undefined the whole
		 *     row will be invalidated
		 * @memberof DataTable#oApi
		 *
		 * @todo For the modularisation of v1.11 this will need to become a callback, so
		 *   the sort and filter methods can subscribe to it. That will required
		 *   initialisation options for sorting, which is why it is not already baked in
		 */
		function _fnInvalidate( settings, rowIdx, src, colIdx )
		{
			var row = settings.aoData[ rowIdx ];
			var i, ien;
			var cellWrite = function ( cell, col ) {
				// This is very frustrating, but in IE if you just write directly
				// to innerHTML, and elements that are overwritten are GC'ed,
				// even if there is a reference to them elsewhere
				while ( cell.childNodes.length ) {
					cell.removeChild( cell.firstChild );
				}
		
				cell.innerHTML = _fnGetCellData( settings, rowIdx, col, 'display' );
			};
		
			// Are we reading last data from DOM or the data object?
			if ( src === 'dom' || ((! src || src === 'auto') && row.src === 'dom') ) {
				// Read the data from the DOM
				row._aData = _fnGetRowElements(
						settings, row, colIdx, colIdx === undefined ? undefined : row._aData
					)
					.data;
			}
			else {
				// Reading from data object, update the DOM
				var cells = row.anCells;
		
				if ( cells ) {
					if ( colIdx !== undefined ) {
						cellWrite( cells[colIdx], colIdx );
					}
					else {
						for ( i=0, ien=cells.length ; i<ien ; i++ ) {
							cellWrite( cells[i], i );
						}
					}
				}
			}
		
			// For both row and cell invalidation, the cached data for sorting and
			// filtering is nulled out
			row._aSortData = null;
			row._aFilterData = null;
		
			// Invalidate the type for a specific column (if given) or all columns since
			// the data might have changed
			var cols = settings.aoColumns;
			if ( colIdx !== undefined ) {
				cols[ colIdx ].sType = null;
			}
			else {
				for ( i=0, ien=cols.length ; i<ien ; i++ ) {
					cols[i].sType = null;
				}
		
				// Update DataTables special `DT_*` attributes for the row
				_fnRowAttributes( settings, row );
			}
		}
		
		
		/**
		 * Build a data source object from an HTML row, reading the contents of the
		 * cells that are in the row.
		 *
		 * @param {object} settings DataTables settings object
		 * @param {node|object} TR element from which to read data or existing row
		 *   object from which to re-read the data from the cells
		 * @param {int} [colIdx] Optional column index
		 * @param {array|object} [d] Data source object. If `colIdx` is given then this
		 *   parameter should also be given and will be used to write the data into.
		 *   Only the column in question will be written
		 * @returns {object} Object with two parameters: `data` the data read, in
		 *   document order, and `cells` and array of nodes (they can be useful to the
		 *   caller, so rather than needing a second traversal to get them, just return
		 *   them from here).
		 * @memberof DataTable#oApi
		 */
		function _fnGetRowElements( settings, row, colIdx, d )
		{
			var
				tds = [],
				td = row.firstChild,
				name, col, o, i=0, contents,
				columns = settings.aoColumns,
				objectRead = settings._rowReadObject;
		
			// Allow the data object to be passed in, or construct
			d = d !== undefined ?
				d :
				objectRead ?
					{} :
					[];
		
			var attr = function ( str, td  ) {
				if ( typeof str === 'string' ) {
					var idx = str.indexOf('@');
		
					if ( idx !== -1 ) {
						var attr = str.substring( idx+1 );
						var setter = _fnSetObjectDataFn( str );
						setter( d, td.getAttribute( attr ) );
					}
				}
			};
		
			// Read data from a cell and store into the data object
			var cellProcess = function ( cell ) {
				if ( colIdx === undefined || colIdx === i ) {
					col = columns[i];
					contents = $.trim(cell.innerHTML);
		
					if ( col && col._bAttrSrc ) {
						var setter = _fnSetObjectDataFn( col.mData._ );
						setter( d, contents );
		
						attr( col.mData.sort, cell );
						attr( col.mData.type, cell );
						attr( col.mData.filter, cell );
					}
					else {
						// Depending on the `data` option for the columns the data can
						// be read to either an object or an array.
						if ( objectRead ) {
							if ( ! col._setter ) {
								// Cache the setter function
								col._setter = _fnSetObjectDataFn( col.mData );
							}
							col._setter( d, contents );
						}
						else {
							d[i] = contents;
						}
					}
				}
		
				i++;
			};
		
			if ( td ) {
				// `tr` element was passed in
				while ( td ) {
					name = td.nodeName.toUpperCase();
		
					if ( name == "TD" || name == "TH" ) {
						cellProcess( td );
						tds.push( td );
					}
		
					td = td.nextSibling;
				}
			}
			else {
				// Existing row object passed in
				tds = row.anCells;
		
				for ( var j=0, jen=tds.length ; j<jen ; j++ ) {
					cellProcess( tds[j] );
				}
			}
		
			// Read the ID from the DOM if present
			var rowNode = row.firstChild ? row : row.nTr;
		
			if ( rowNode ) {
				var id = rowNode.getAttribute( 'id' );
		
				if ( id ) {
					_fnSetObjectDataFn( settings.rowId )( d, id );
				}
			}
		
			return {
				data: d,
				cells: tds
			};
		}
		/**
		 * Create a new TR element (and it's TD children) for a row
		 *  @param {object} oSettings dataTables settings object
		 *  @param {int} iRow Row to consider
		 *  @param {node} [nTrIn] TR element to add to the table - optional. If not given,
		 *    DataTables will create a row automatically
		 *  @param {array} [anTds] Array of TD|TH elements for the row - must be given
		 *    if nTr is.
		 *  @memberof DataTable#oApi
		 */
		function _fnCreateTr ( oSettings, iRow, nTrIn, anTds )
		{
			var
				row = oSettings.aoData[iRow],
				rowData = row._aData,
				cells = [],
				nTr, nTd, oCol,
				i, iLen;
		
			if ( row.nTr === null )
			{
				nTr = nTrIn || document.createElement('tr');
		
				row.nTr = nTr;
				row.anCells = cells;
		
				/* Use a private property on the node to allow reserve mapping from the node
				 * to the aoData array for fast look up
				 */
				nTr._DT_RowIndex = iRow;
		
				/* Special parameters can be given by the data source to be used on the row */
				_fnRowAttributes( oSettings, row );
		
				/* Process each column */
				for ( i=0, iLen=oSettings.aoColumns.length ; i<iLen ; i++ )
				{
					oCol = oSettings.aoColumns[i];
		
					nTd = nTrIn ? anTds[i] : document.createElement( oCol.sCellType );
					nTd._DT_CellIndex = {
						row: iRow,
						column: i
					};
					
					cells.push( nTd );
		
					// Need to create the HTML if new, or if a rendering function is defined
					if ( (!nTrIn || oCol.mRender || oCol.mData !== i) &&
						 (!$.isPlainObject(oCol.mData) || oCol.mData._ !== i+'.display')
					) {
						nTd.innerHTML = _fnGetCellData( oSettings, iRow, i, 'display' );
					}
		
					/* Add user defined class */
					if ( oCol.sClass )
					{
						nTd.className += ' '+oCol.sClass;
					}
		
					// Visibility - add or remove as required
					if ( oCol.bVisible && ! nTrIn )
					{
						nTr.appendChild( nTd );
					}
					else if ( ! oCol.bVisible && nTrIn )
					{
						nTd.parentNode.removeChild( nTd );
					}
		
					if ( oCol.fnCreatedCell )
					{
						oCol.fnCreatedCell.call( oSettings.oInstance,
							nTd, _fnGetCellData( oSettings, iRow, i ), rowData, iRow, i
						);
					}
				}
		
				_fnCallbackFire( oSettings, 'aoRowCreatedCallback', null, [nTr, rowData, iRow] );
			}
		
			// Remove once webkit bug 131819 and Chromium bug 365619 have been resolved
			// and deployed
			row.nTr.setAttribute( 'role', 'row' );
		}
		
		
		/**
		 * Add attributes to a row based on the special `DT_*` parameters in a data
		 * source object.
		 *  @param {object} settings DataTables settings object
		 *  @param {object} DataTables row object for the row to be modified
		 *  @memberof DataTable#oApi
		 */
		function _fnRowAttributes( settings, row )
		{
			var tr = row.nTr;
			var data = row._aData;
		
			if ( tr ) {
				var id = settings.rowIdFn( data );
		
				if ( id ) {
					tr.id = id;
				}
		
				if ( data.DT_RowClass ) {
					// Remove any classes added by DT_RowClass before
					var a = data.DT_RowClass.split(' ');
					row.__rowc = row.__rowc ?
						_unique( row.__rowc.concat( a ) ) :
						a;
		
					$(tr)
						.removeClass( row.__rowc.join(' ') )
						.addClass( data.DT_RowClass );
				}
		
				if ( data.DT_RowAttr ) {
					$(tr).attr( data.DT_RowAttr );
				}
		
				if ( data.DT_RowData ) {
					$(tr).data( data.DT_RowData );
				}
			}
		}
		
		
		/**
		 * Create the HTML header for the table
		 *  @param {object} oSettings dataTables settings object
		 *  @memberof DataTable#oApi
		 */
		function _fnBuildHead( oSettings )
		{
			var i, ien, cell, row, column;
			var thead = oSettings.nTHead;
			var tfoot = oSettings.nTFoot;
			var createHeader = $('th, td', thead).length === 0;
			var classes = oSettings.oClasses;
			var columns = oSettings.aoColumns;
		
			if ( createHeader ) {
				row = $('<tr/>').appendTo( thead );
			}
		
			for ( i=0, ien=columns.length ; i<ien ; i++ ) {
				column = columns[i];
				cell = $( column.nTh ).addClass( column.sClass );
		
				if ( createHeader ) {
					cell.appendTo( row );
				}
		
				// 1.11 move into sorting
				if ( oSettings.oFeatures.bSort ) {
					cell.addClass( column.sSortingClass );
		
					if ( column.bSortable !== false ) {
						cell
							.attr( 'tabindex', oSettings.iTabIndex )
							.attr( 'aria-controls', oSettings.sTableId );
		
						_fnSortAttachListener( oSettings, column.nTh, i );
					}
				}
		
				if ( column.sTitle != cell[0].innerHTML ) {
					cell.html( column.sTitle );
				}
		
				_fnRenderer( oSettings, 'header' )(
					oSettings, cell, column, classes
				);
			}
		
			if ( createHeader ) {
				_fnDetectHeader( oSettings.aoHeader, thead );
			}
			
			/* ARIA role for the rows */
		 	$(thead).find('>tr').attr('role', 'row');
		
			/* Deal with the footer - add classes if required */
			$(thead).find('>tr>th, >tr>td').addClass( classes.sHeaderTH );
			$(tfoot).find('>tr>th, >tr>td').addClass( classes.sFooterTH );
		
			// Cache the footer cells. Note that we only take the cells from the first
			// row in the footer. If there is more than one row the user wants to
			// interact with, they need to use the table().foot() method. Note also this
			// allows cells to be used for multiple columns using colspan
			if ( tfoot !== null ) {
				var cells = oSettings.aoFooter[0];
		
				for ( i=0, ien=cells.length ; i<ien ; i++ ) {
					column = columns[i];
					column.nTf = cells[i].cell;
		
					if ( column.sClass ) {
						$(column.nTf).addClass( column.sClass );
					}
				}
			}
		}
		
		
		/**
		 * Draw the header (or footer) element based on the column visibility states. The
		 * methodology here is to use the layout array from _fnDetectHeader, modified for
		 * the instantaneous column visibility, to construct the new layout. The grid is
		 * traversed over cell at a time in a rows x columns grid fashion, although each
		 * cell insert can cover multiple elements in the grid - which is tracks using the
		 * aApplied array. Cell inserts in the grid will only occur where there isn't
		 * already a cell in that position.
		 *  @param {object} oSettings dataTables settings object
		 *  @param array {objects} aoSource Layout array from _fnDetectHeader
		 *  @param {boolean} [bIncludeHidden=false] If true then include the hidden columns in the calc,
		 *  @memberof DataTable#oApi
		 */
		function _fnDrawHead( oSettings, aoSource, bIncludeHidden )
		{
			var i, iLen, j, jLen, k, kLen, n, nLocalTr;
			var aoLocal = [];
			var aApplied = [];
			var iColumns = oSettings.aoColumns.length;
			var iRowspan, iColspan;
		
			if ( ! aoSource )
			{
				return;
			}
		
			if (  bIncludeHidden === undefined )
			{
				bIncludeHidden = false;
			}
		
			/* Make a copy of the master layout array, but without the visible columns in it */
			for ( i=0, iLen=aoSource.length ; i<iLen ; i++ )
			{
				aoLocal[i] = aoSource[i].slice();
				aoLocal[i].nTr = aoSource[i].nTr;
		
				/* Remove any columns which are currently hidden */
				for ( j=iColumns-1 ; j>=0 ; j-- )
				{
					if ( !oSettings.aoColumns[j].bVisible && !bIncludeHidden )
					{
						aoLocal[i].splice( j, 1 );
					}
				}
		
				/* Prep the applied array - it needs an element for each row */
				aApplied.push( [] );
			}
		
			for ( i=0, iLen=aoLocal.length ; i<iLen ; i++ )
			{
				nLocalTr = aoLocal[i].nTr;
		
				/* All cells are going to be replaced, so empty out the row */
				if ( nLocalTr )
				{
					while( (n = nLocalTr.firstChild) )
					{
						nLocalTr.removeChild( n );
					}
				}
		
				for ( j=0, jLen=aoLocal[i].length ; j<jLen ; j++ )
				{
					iRowspan = 1;
					iColspan = 1;
		
					/* Check to see if there is already a cell (row/colspan) covering our target
					 * insert point. If there is, then there is nothing to do.
					 */
					if ( aApplied[i][j] === undefined )
					{
						nLocalTr.appendChild( aoLocal[i][j].cell );
						aApplied[i][j] = 1;
		
						/* Expand the cell to cover as many rows as needed */
						while ( aoLocal[i+iRowspan] !== undefined &&
						        aoLocal[i][j].cell == aoLocal[i+iRowspan][j].cell )
						{
							aApplied[i+iRowspan][j] = 1;
							iRowspan++;
						}
		
						/* Expand the cell to cover as many columns as needed */
						while ( aoLocal[i][j+iColspan] !== undefined &&
						        aoLocal[i][j].cell == aoLocal[i][j+iColspan].cell )
						{
							/* Must update the applied array over the rows for the columns */
							for ( k=0 ; k<iRowspan ; k++ )
							{
								aApplied[i+k][j+iColspan] = 1;
							}
							iColspan++;
						}
		
						/* Do the actual expansion in the DOM */
						$(aoLocal[i][j].cell)
							.attr('rowspan', iRowspan)
							.attr('colspan', iColspan);
					}
				}
			}
		}
		
		
		/**
		 * Insert the required TR nodes into the table for display
		 *  @param {object} oSettings dataTables settings object
		 *  @memberof DataTable#oApi
		 */
		function _fnDraw( oSettings )
		{
			/* Provide a pre-callback function which can be used to cancel the draw is false is returned */
			var aPreDraw = _fnCallbackFire( oSettings, 'aoPreDrawCallback', 'preDraw', [oSettings] );
			if ( $.inArray( false, aPreDraw ) !== -1 )
			{
				_fnProcessingDisplay( oSettings, false );
				return;
			}
		
			var i, iLen, n;
			var anRows = [];
			var iRowCount = 0;
			var asStripeClasses = oSettings.asStripeClasses;
			var iStripes = asStripeClasses.length;
			var iOpenRows = oSettings.aoOpenRows.length;
			var oLang = oSettings.oLanguage;
			var iInitDisplayStart = oSettings.iInitDisplayStart;
			var bServerSide = _fnDataSource( oSettings ) == 'ssp';
			var aiDisplay = oSettings.aiDisplay;
		
			oSettings.bDrawing = true;
		
			/* Check and see if we have an initial draw position from state saving */
			if ( iInitDisplayStart !== undefined && iInitDisplayStart !== -1 )
			{
				oSettings._iDisplayStart = bServerSide ?
					iInitDisplayStart :
					iInitDisplayStart >= oSettings.fnRecordsDisplay() ?
						0 :
						iInitDisplayStart;
		
				oSettings.iInitDisplayStart = -1;
			}
		
			var iDisplayStart = oSettings._iDisplayStart;
			var iDisplayEnd = oSettings.fnDisplayEnd();
		
			/* Server-side processing draw intercept */
			if ( oSettings.bDeferLoading )
			{
				oSettings.bDeferLoading = false;
				oSettings.iDraw++;
				_fnProcessingDisplay( oSettings, false );
			}
			else if ( !bServerSide )
			{
				oSettings.iDraw++;
			}
			else if ( !oSettings.bDestroying && !_fnAjaxUpdate( oSettings ) )
			{
				return;
			}
		
			if ( aiDisplay.length !== 0 )
			{
				var iStart = bServerSide ? 0 : iDisplayStart;
				var iEnd = bServerSide ? oSettings.aoData.length : iDisplayEnd;
		
				for ( var j=iStart ; j<iEnd ; j++ )
				{
					var iDataIndex = aiDisplay[j];
					var aoData = oSettings.aoData[ iDataIndex ];
					if ( aoData.nTr === null )
					{
						_fnCreateTr( oSettings, iDataIndex );
					}
		
					var nRow = aoData.nTr;
		
					/* Remove the old striping classes and then add the new one */
					if ( iStripes !== 0 )
					{
						var sStripe = asStripeClasses[ iRowCount % iStripes ];
						if ( aoData._sRowStripe != sStripe )
						{
							$(nRow).removeClass( aoData._sRowStripe ).addClass( sStripe );
							aoData._sRowStripe = sStripe;
						}
					}
		
					// Row callback functions - might want to manipulate the row
					// iRowCount and j are not currently documented. Are they at all
					// useful?
					_fnCallbackFire( oSettings, 'aoRowCallback', null,
						[nRow, aoData._aData, iRowCount, j] );
		
					anRows.push( nRow );
					iRowCount++;
				}
			}
			else
			{
				/* Table is empty - create a row with an empty message in it */
				var sZero = oLang.sZeroRecords;
				if ( oSettings.iDraw == 1 &&  _fnDataSource( oSettings ) == 'ajax' )
				{
					sZero = oLang.sLoadingRecords;
				}
				else if ( oLang.sEmptyTable && oSettings.fnRecordsTotal() === 0 )
				{
					sZero = oLang.sEmptyTable;
				}
		
				anRows[ 0 ] = $( '<tr/>', { 'class': iStripes ? asStripeClasses[0] : '' } )
					.append( $('<td />', {
						'valign':  'top',
						'colSpan': _fnVisbleColumns( oSettings ),
						'class':   oSettings.oClasses.sRowEmpty
					} ).html( sZero ) )[0];
			}
		
			/* Header and footer callbacks */
			_fnCallbackFire( oSettings, 'aoHeaderCallback', 'header', [ $(oSettings.nTHead).children('tr')[0],
				_fnGetDataMaster( oSettings ), iDisplayStart, iDisplayEnd, aiDisplay ] );
		
			_fnCallbackFire( oSettings, 'aoFooterCallback', 'footer', [ $(oSettings.nTFoot).children('tr')[0],
				_fnGetDataMaster( oSettings ), iDisplayStart, iDisplayEnd, aiDisplay ] );
		
			var body = $(oSettings.nTBody);
		
			body.children().detach();
			body.append( $(anRows) );
		
			/* Call all required callback functions for the end of a draw */
			_fnCallbackFire( oSettings, 'aoDrawCallback', 'draw', [oSettings] );
		
			/* Draw is complete, sorting and filtering must be as well */
			oSettings.bSorted = false;
			oSettings.bFiltered = false;
			oSettings.bDrawing = false;
		}
		
		
		/**
		 * Redraw the table - taking account of the various features which are enabled
		 *  @param {object} oSettings dataTables settings object
		 *  @param {boolean} [holdPosition] Keep the current paging position. By default
		 *    the paging is reset to the first page
		 *  @memberof DataTable#oApi
		 */
		function _fnReDraw( settings, holdPosition )
		{
			var
				features = settings.oFeatures,
				sort     = features.bSort,
				filter   = features.bFilter;
		
			if ( sort ) {
				_fnSort( settings );
			}
		
			if ( filter ) {
				_fnFilterComplete( settings, settings.oPreviousSearch );
			}
			else {
				// No filtering, so we want to just use the display master
				settings.aiDisplay = settings.aiDisplayMaster.slice();
			}
		
			if ( holdPosition !== true ) {
				settings._iDisplayStart = 0;
			}
		
			// Let any modules know about the draw hold position state (used by
			// scrolling internally)
			settings._drawHold = holdPosition;
		
			_fnDraw( settings );
		
			settings._drawHold = false;
		}
		
		
		/**
		 * Add the options to the page HTML for the table
		 *  @param {object} oSettings dataTables settings object
		 *  @memberof DataTable#oApi
		 */
		function _fnAddOptionsHtml ( oSettings )
		{
			var classes = oSettings.oClasses;
			var table = $(oSettings.nTable);
			var holding = $('<div/>').insertBefore( table ); // Holding element for speed
			var features = oSettings.oFeatures;
		
			// All DataTables are wrapped in a div
			var insert = $('<div/>', {
				id:      oSettings.sTableId+'_wrapper',
				'class': classes.sWrapper + (oSettings.nTFoot ? '' : ' '+classes.sNoFooter)
			} );
		
			oSettings.nHolding = holding[0];
			oSettings.nTableWrapper = insert[0];
			oSettings.nTableReinsertBefore = oSettings.nTable.nextSibling;
		
			/* Loop over the user set positioning and place the elements as needed */
			var aDom = oSettings.sDom.split('');
			var featureNode, cOption, nNewNode, cNext, sAttr, j;
			for ( var i=0 ; i<aDom.length ; i++ )
			{
				featureNode = null;
				cOption = aDom[i];
		
				if ( cOption == '<' )
				{
					/* New container div */
					nNewNode = $('<div/>')[0];
		
					/* Check to see if we should append an id and/or a class name to the container */
					cNext = aDom[i+1];
					if ( cNext == "'" || cNext == '"' )
					{
						sAttr = "";
						j = 2;
						while ( aDom[i+j] != cNext )
						{
							sAttr += aDom[i+j];
							j++;
						}
		
						/* Replace jQuery UI constants @todo depreciated */
						if ( sAttr == "H" )
						{
							sAttr = classes.sJUIHeader;
						}
						else if ( sAttr == "F" )
						{
							sAttr = classes.sJUIFooter;
						}
		
						/* The attribute can be in the format of "#id.class", "#id" or "class" This logic
						 * breaks the string into parts and applies them as needed
						 */
						if ( sAttr.indexOf('.') != -1 )
						{
							var aSplit = sAttr.split('.');
							nNewNode.id = aSplit[0].substr(1, aSplit[0].length-1);
							nNewNode.className = aSplit[1];
						}
						else if ( sAttr.charAt(0) == "#" )
						{
							nNewNode.id = sAttr.substr(1, sAttr.length-1);
						}
						else
						{
							nNewNode.className = sAttr;
						}
		
						i += j; /* Move along the position array */
					}
		
					insert.append( nNewNode );
					insert = $(nNewNode);
				}
				else if ( cOption == '>' )
				{
					/* End container div */
					insert = insert.parent();
				}
				// @todo Move options into their own plugins?
				else if ( cOption == 'l' && features.bPaginate && features.bLengthChange )
				{
					/* Length */
					featureNode = _fnFeatureHtmlLength( oSettings );
				}
				else if ( cOption == 'f' && features.bFilter )
				{
					/* Filter */
					featureNode = _fnFeatureHtmlFilter( oSettings );
				}
				else if ( cOption == 'r' && features.bProcessing )
				{
					/* pRocessing */
					featureNode = _fnFeatureHtmlProcessing( oSettings );
				}
				else if ( cOption == 't' )
				{
					/* Table */
					featureNode = _fnFeatureHtmlTable( oSettings );
				}
				else if ( cOption ==  'i' && features.bInfo )
				{
					/* Info */
					featureNode = _fnFeatureHtmlInfo( oSettings );
				}
				else if ( cOption == 'p' && features.bPaginate )
				{
					/* Pagination */
					featureNode = _fnFeatureHtmlPaginate( oSettings );
				}
				else if ( DataTable.ext.feature.length !== 0 )
				{
					/* Plug-in features */
					var aoFeatures = DataTable.ext.feature;
					for ( var k=0, kLen=aoFeatures.length ; k<kLen ; k++ )
					{
						if ( cOption == aoFeatures[k].cFeature )
						{
							featureNode = aoFeatures[k].fnInit( oSettings );
							break;
						}
					}
				}
		
				/* Add to the 2D features array */
				if ( featureNode )
				{
					var aanFeatures = oSettings.aanFeatures;
		
					if ( ! aanFeatures[cOption] )
					{
						aanFeatures[cOption] = [];
					}
		
					aanFeatures[cOption].push( featureNode );
					insert.append( featureNode );
				}
			}
		
			/* Built our DOM structure - replace the holding div with what we want */
			holding.replaceWith( insert );
			oSettings.nHolding = null;
		}
		
		
		/**
		 * Use the DOM source to create up an array of header cells. The idea here is to
		 * create a layout grid (array) of rows x columns, which contains a reference
		 * to the cell that that point in the grid (regardless of col/rowspan), such that
		 * any column / row could be removed and the new grid constructed
		 *  @param array {object} aLayout Array to store the calculated layout in
		 *  @param {node} nThead The header/footer element for the table
		 *  @memberof DataTable#oApi
		 */
		function _fnDetectHeader ( aLayout, nThead )
		{
			var nTrs = $(nThead).children('tr');
			var nTr, nCell;
			var i, k, l, iLen, jLen, iColShifted, iColumn, iColspan, iRowspan;
			var bUnique;
			var fnShiftCol = function ( a, i, j ) {
				var k = a[i];
		                while ( k[j] ) {
					j++;
				}
				return j;
			};
		
			aLayout.splice( 0, aLayout.length );
		
			/* We know how many rows there are in the layout - so prep it */
			for ( i=0, iLen=nTrs.length ; i<iLen ; i++ )
			{
				aLayout.push( [] );
			}
		
			/* Calculate a layout array */
			for ( i=0, iLen=nTrs.length ; i<iLen ; i++ )
			{
				nTr = nTrs[i];
				iColumn = 0;
		
				/* For every cell in the row... */
				nCell = nTr.firstChild;
				while ( nCell ) {
					if ( nCell.nodeName.toUpperCase() == "TD" ||
					     nCell.nodeName.toUpperCase() == "TH" )
					{
						/* Get the col and rowspan attributes from the DOM and sanitise them */
						iColspan = nCell.getAttribute('colspan') * 1;
						iRowspan = nCell.getAttribute('rowspan') * 1;
						iColspan = (!iColspan || iColspan===0 || iColspan===1) ? 1 : iColspan;
						iRowspan = (!iRowspan || iRowspan===0 || iRowspan===1) ? 1 : iRowspan;
		
						/* There might be colspan cells already in this row, so shift our target
						 * accordingly
						 */
						iColShifted = fnShiftCol( aLayout, i, iColumn );
		
						/* Cache calculation for unique columns */
						bUnique = iColspan === 1 ? true : false;
		
						/* If there is col / rowspan, copy the information into the layout grid */
						for ( l=0 ; l<iColspan ; l++ )
						{
							for ( k=0 ; k<iRowspan ; k++ )
							{
								aLayout[i+k][iColShifted+l] = {
									"cell": nCell,
									"unique": bUnique
								};
								aLayout[i+k].nTr = nTr;
							}
						}
					}
					nCell = nCell.nextSibling;
				}
			}
		}
		
		
		/**
		 * Get an array of unique th elements, one for each column
		 *  @param {object} oSettings dataTables settings object
		 *  @param {node} nHeader automatically detect the layout from this node - optional
		 *  @param {array} aLayout thead/tfoot layout from _fnDetectHeader - optional
		 *  @returns array {node} aReturn list of unique th's
		 *  @memberof DataTable#oApi
		 */
		function _fnGetUniqueThs ( oSettings, nHeader, aLayout )
		{
			var aReturn = [];
			if ( !aLayout )
			{
				aLayout = oSettings.aoHeader;
				if ( nHeader )
				{
					aLayout = [];
					_fnDetectHeader( aLayout, nHeader );
				}
			}
		
			for ( var i=0, iLen=aLayout.length ; i<iLen ; i++ )
			{
				for ( var j=0, jLen=aLayout[i].length ; j<jLen ; j++ )
				{
					if ( aLayout[i][j].unique &&
						 (!aReturn[j] || !oSettings.bSortCellsTop) )
					{
						aReturn[j] = aLayout[i][j].cell;
					}
				}
			}
		
			return aReturn;
		}
		
		/**
		 * Create an Ajax call based on the table's settings, taking into account that
		 * parameters can have multiple forms, and backwards compatibility.
		 *
		 * @param {object} oSettings dataTables settings object
		 * @param {array} data Data to send to the server, required by
		 *     DataTables - may be augmented by developer callbacks
		 * @param {function} fn Callback function to run when data is obtained
		 */
		function _fnBuildAjax( oSettings, data, fn )
		{
			// Compatibility with 1.9-, allow fnServerData and event to manipulate
			_fnCallbackFire( oSettings, 'aoServerParams', 'serverParams', [data] );
		
			// Convert to object based for 1.10+ if using the old array scheme which can
			// come from server-side processing or serverParams
			if ( data && $.isArray(data) ) {
				var tmp = {};
				var rbracket = /(.*?)\[\]$/;
		
				$.each( data, function (key, val) {
					var match = val.name.match(rbracket);
		
					if ( match ) {
						// Support for arrays
						var name = match[0];
		
						if ( ! tmp[ name ] ) {
							tmp[ name ] = [];
						}
						tmp[ name ].push( val.value );
					}
					else {
						tmp[val.name] = val.value;
					}
				} );
				data = tmp;
			}
		
			var ajaxData;
			var ajax = oSettings.ajax;
			var instance = oSettings.oInstance;
			var callback = function ( json ) {
				_fnCallbackFire( oSettings, null, 'xhr', [oSettings, json, oSettings.jqXHR] );
				fn( json );
			};
		
			if ( $.isPlainObject( ajax ) && ajax.data )
			{
				ajaxData = ajax.data;
		
				var newData = $.isFunction( ajaxData ) ?
					ajaxData( data, oSettings ) :  // fn can manipulate data or return
					ajaxData;                      // an object object or array to merge
		
				// If the function returned something, use that alone
				data = $.isFunction( ajaxData ) && newData ?
					newData :
					$.extend( true, data, newData );
		
				// Remove the data property as we've resolved it already and don't want
				// jQuery to do it again (it is restored at the end of the function)
				delete ajax.data;
			}
		
			var baseAjax = {
				"data": data,
				"success": function (json) {
					var error = json.error || json.sError;
					if ( error ) {
						_fnLog( oSettings, 0, error );
					}
		
					oSettings.json = json;
					callback( json );
				},
				"dataType": "json",
				"cache": false,
				"type": oSettings.sServerMethod,
				"error": function (xhr, error, thrown) {
					var ret = _fnCallbackFire( oSettings, null, 'xhr', [oSettings, null, oSettings.jqXHR] );
		
					if ( $.inArray( true, ret ) === -1 ) {
						if ( error == "parsererror" ) {
							_fnLog( oSettings, 0, 'Invalid JSON response', 1 );
						}
						else if ( xhr.readyState === 4 ) {
							_fnLog( oSettings, 0, 'Ajax error', 7 );
						}
					}
		
					_fnProcessingDisplay( oSettings, false );
				}
			};
		
			// Store the data submitted for the API
			oSettings.oAjaxData = data;
		
			// Allow plug-ins and external processes to modify the data
			_fnCallbackFire( oSettings, null, 'preXhr', [oSettings, data] );
		
			if ( oSettings.fnServerData )
			{
				// DataTables 1.9- compatibility
				oSettings.fnServerData.call( instance,
					oSettings.sAjaxSource,
					$.map( data, function (val, key) { // Need to convert back to 1.9 trad format
						return { name: key, value: val };
					} ),
					callback,
					oSettings
				);
			}
			else if ( oSettings.sAjaxSource || typeof ajax === 'string' )
			{
				// DataTables 1.9- compatibility
				oSettings.jqXHR = $.ajax( $.extend( baseAjax, {
					url: ajax || oSettings.sAjaxSource
				} ) );
			}
			else if ( $.isFunction( ajax ) )
			{
				// Is a function - let the caller define what needs to be done
				oSettings.jqXHR = ajax.call( instance, data, callback, oSettings );
			}
			else
			{
				// Object to extend the base settings
				oSettings.jqXHR = $.ajax( $.extend( baseAjax, ajax ) );
		
				// Restore for next time around
				ajax.data = ajaxData;
			}
		}
		
		
		/**
		 * Update the table using an Ajax call
		 *  @param {object} settings dataTables settings object
		 *  @returns {boolean} Block the table drawing or not
		 *  @memberof DataTable#oApi
		 */
		function _fnAjaxUpdate( settings )
		{
			if ( settings.bAjaxDataGet ) {
				settings.iDraw++;
				_fnProcessingDisplay( settings, true );
		
				_fnBuildAjax(
					settings,
					_fnAjaxParameters( settings ),
					function(json) {
						_fnAjaxUpdateDraw( settings, json );
					}
				);
		
				return false;
			}
			return true;
		}
		
		
		/**
		 * Build up the parameters in an object needed for a server-side processing
		 * request. Note that this is basically done twice, is different ways - a modern
		 * method which is used by default in DataTables 1.10 which uses objects and
		 * arrays, or the 1.9- method with is name / value pairs. 1.9 method is used if
		 * the sAjaxSource option is used in the initialisation, or the legacyAjax
		 * option is set.
		 *  @param {object} oSettings dataTables settings object
		 *  @returns {bool} block the table drawing or not
		 *  @memberof DataTable#oApi
		 */
		function _fnAjaxParameters( settings )
		{
			var
				columns = settings.aoColumns,
				columnCount = columns.length,
				features = settings.oFeatures,
				preSearch = settings.oPreviousSearch,
				preColSearch = settings.aoPreSearchCols,
				i, data = [], dataProp, column, columnSearch,
				sort = _fnSortFlatten( settings ),
				displayStart = settings._iDisplayStart,
				displayLength = features.bPaginate !== false ?
					settings._iDisplayLength :
					-1;
		
			var param = function ( name, value ) {
				data.push( { 'name': name, 'value': value } );
			};
		
			// DataTables 1.9- compatible method
			param( 'sEcho',          settings.iDraw );
			param( 'iColumns',       columnCount );
			param( 'sColumns',       _pluck( columns, 'sName' ).join(',') );
			param( 'iDisplayStart',  displayStart );
			param( 'iDisplayLength', displayLength );
		
			// DataTables 1.10+ method
			var d = {
				draw:    settings.iDraw,
				columns: [],
				order:   [],
				start:   displayStart,
				length:  displayLength,
				search:  {
					value: preSearch.sSearch,
					regex: preSearch.bRegex
				}
			};
		
			for ( i=0 ; i<columnCount ; i++ ) {
				column = columns[i];
				columnSearch = preColSearch[i];
				dataProp = typeof column.mData=="function" ? 'function' : column.mData ;
		
				d.columns.push( {
					data:       dataProp,
					name:       column.sName,
					searchable: column.bSearchable,
					orderable:  column.bSortable,
					search:     {
						value: columnSearch.sSearch,
						regex: columnSearch.bRegex
					}
				} );
		
				param( "mDataProp_"+i, dataProp );
		
				if ( features.bFilter ) {
					param( 'sSearch_'+i,     columnSearch.sSearch );
					param( 'bRegex_'+i,      columnSearch.bRegex );
					param( 'bSearchable_'+i, column.bSearchable );
				}
		
				if ( features.bSort ) {
					param( 'bSortable_'+i, column.bSortable );
				}
			}
		
			if ( features.bFilter ) {
				param( 'sSearch', preSearch.sSearch );
				param( 'bRegex', preSearch.bRegex );
			}
		
			if ( features.bSort ) {
				$.each( sort, function ( i, val ) {
					d.order.push( { column: val.col, dir: val.dir } );
		
					param( 'iSortCol_'+i, val.col );
					param( 'sSortDir_'+i, val.dir );
				} );
		
				param( 'iSortingCols', sort.length );
			}
		
			// If the legacy.ajax parameter is null, then we automatically decide which
			// form to use, based on sAjaxSource
			var legacy = DataTable.ext.legacy.ajax;
			if ( legacy === null ) {
				return settings.sAjaxSource ? data : d;
			}
		
			// Otherwise, if legacy has been specified then we use that to decide on the
			// form
			return legacy ? data : d;
		}
		
		
		/**
		 * Data the data from the server (nuking the old) and redraw the table
		 *  @param {object} oSettings dataTables settings object
		 *  @param {object} json json data return from the server.
		 *  @param {string} json.sEcho Tracking flag for DataTables to match requests
		 *  @param {int} json.iTotalRecords Number of records in the data set, not accounting for filtering
		 *  @param {int} json.iTotalDisplayRecords Number of records in the data set, accounting for filtering
		 *  @param {array} json.aaData The data to display on this page
		 *  @param {string} [json.sColumns] Column ordering (sName, comma separated)
		 *  @memberof DataTable#oApi
		 */
		function _fnAjaxUpdateDraw ( settings, json )
		{
			// v1.10 uses camelCase variables, while 1.9 uses Hungarian notation.
			// Support both
			var compat = function ( old, modern ) {
				return json[old] !== undefined ? json[old] : json[modern];
			};
		
			var data = _fnAjaxDataSrc( settings, json );
			var draw            = compat( 'sEcho',                'draw' );
			var recordsTotal    = compat( 'iTotalRecords',        'recordsTotal' );
			var recordsFiltered = compat( 'iTotalDisplayRecords', 'recordsFiltered' );
		
			if ( draw ) {
				// Protect against out of sequence returns
				if ( draw*1 < settings.iDraw ) {
					return;
				}
				settings.iDraw = draw * 1;
			}
		
			_fnClearTable( settings );
			settings._iRecordsTotal   = parseInt(recordsTotal, 10);
			settings._iRecordsDisplay = parseInt(recordsFiltered, 10);
		
			for ( var i=0, ien=data.length ; i<ien ; i++ ) {
				_fnAddData( settings, data[i] );
			}
			settings.aiDisplay = settings.aiDisplayMaster.slice();
		
			settings.bAjaxDataGet = false;
			_fnDraw( settings );
		
			if ( ! settings._bInitComplete ) {
				_fnInitComplete( settings, json );
			}
		
			settings.bAjaxDataGet = true;
			_fnProcessingDisplay( settings, false );
		}
		
		
		/**
		 * Get the data from the JSON data source to use for drawing a table. Using
		 * `_fnGetObjectDataFn` allows the data to be sourced from a property of the
		 * source object, or from a processing function.
		 *  @param {object} oSettings dataTables settings object
		 *  @param  {object} json Data source object / array from the server
		 *  @return {array} Array of data to use
		 */
		function _fnAjaxDataSrc ( oSettings, json )
		{
			var dataSrc = $.isPlainObject( oSettings.ajax ) && oSettings.ajax.dataSrc !== undefined ?
				oSettings.ajax.dataSrc :
				oSettings.sAjaxDataProp; // Compatibility with 1.9-.
		
			// Compatibility with 1.9-. In order to read from aaData, check if the
			// default has been changed, if not, check for aaData
			if ( dataSrc === 'data' ) {
				return json.aaData || json[dataSrc];
			}
		
			return dataSrc !== "" ?
				_fnGetObjectDataFn( dataSrc )( json ) :
				json;
		}
		
		/**
		 * Generate the node required for filtering text
		 *  @returns {node} Filter control element
		 *  @param {object} oSettings dataTables settings object
		 *  @memberof DataTable#oApi
		 */
		function _fnFeatureHtmlFilter ( settings )
		{
			var classes = settings.oClasses;
			var tableId = settings.sTableId;
			var language = settings.oLanguage;
			var previousSearch = settings.oPreviousSearch;
			var features = settings.aanFeatures;
			var input = '<input type="search" class="'+classes.sFilterInput+'"/>';
		
			var str = language.sSearch;
			str = str.match(/_INPUT_/) ?
				str.replace('_INPUT_', input) :
				str+input;
		
			var filter = $('<div/>', {
					'id': ! features.f ? tableId+'_filter' : null,
					'class': classes.sFilter
				} )
				.append( $('<label/>' ).append( str ) );
		
			var searchFn = function() {
				/* Update all other filter input elements for the new display */
				var n = features.f;
				var val = !this.value ? "" : this.value; // mental IE8 fix :-(
		
				/* Now do the filter */
				if ( val != previousSearch.sSearch ) {
					_fnFilterComplete( settings, {
						"sSearch": val,
						"bRegex": previousSearch.bRegex,
						"bSmart": previousSearch.bSmart ,
						"bCaseInsensitive": previousSearch.bCaseInsensitive
					} );
		
					// Need to redraw, without resorting
					settings._iDisplayStart = 0;
					_fnDraw( settings );
				}
			};
		
			var searchDelay = settings.searchDelay !== null ?
				settings.searchDelay :
				_fnDataSource( settings ) === 'ssp' ?
					400 :
					0;
		
			var jqFilter = $('input', filter)
				.val( previousSearch.sSearch )
				.attr( 'placeholder', language.sSearchPlaceholder )
				.bind(
					'keyup.DT search.DT input.DT paste.DT cut.DT',
					searchDelay ?
						_fnThrottle( searchFn, searchDelay ) :
						searchFn
				)
				.bind( 'keypress.DT', function(e) {
					/* Prevent form submission */
					if ( e.keyCode == 13 ) {
						return false;
					}
				} )
				.attr('aria-controls', tableId);
		
			// Update the input elements whenever the table is filtered
			$(settings.nTable).on( 'search.dt.DT', function ( ev, s ) {
				if ( settings === s ) {
					// IE9 throws an 'unknown error' if document.activeElement is used
					// inside an iframe or frame...
					try {
						if ( jqFilter[0] !== document.activeElement ) {
							jqFilter.val( previousSearch.sSearch );
						}
					}
					catch ( e ) {}
				}
			} );
		
			return filter[0];
		}
		
		
		/**
		 * Filter the table using both the global filter and column based filtering
		 *  @param {object} oSettings dataTables settings object
		 *  @param {object} oSearch search information
		 *  @param {int} [iForce] force a research of the master array (1) or not (undefined or 0)
		 *  @memberof DataTable#oApi
		 */
		function _fnFilterComplete ( oSettings, oInput, iForce )
		{
			var oPrevSearch = oSettings.oPreviousSearch;
			var aoPrevSearch = oSettings.aoPreSearchCols;
			var fnSaveFilter = function ( oFilter ) {
				/* Save the filtering values */
				oPrevSearch.sSearch = oFilter.sSearch;
				oPrevSearch.bRegex = oFilter.bRegex;
				oPrevSearch.bSmart = oFilter.bSmart;
				oPrevSearch.bCaseInsensitive = oFilter.bCaseInsensitive;
			};
			var fnRegex = function ( o ) {
				// Backwards compatibility with the bEscapeRegex option
				return o.bEscapeRegex !== undefined ? !o.bEscapeRegex : o.bRegex;
			};
		
			// Resolve any column types that are unknown due to addition or invalidation
			// @todo As per sort - can this be moved into an event handler?
			_fnColumnTypes( oSettings );
		
			/* In server-side processing all filtering is done by the server, so no point hanging around here */
			if ( _fnDataSource( oSettings ) != 'ssp' )
			{
				/* Global filter */
				_fnFilter( oSettings, oInput.sSearch, iForce, fnRegex(oInput), oInput.bSmart, oInput.bCaseInsensitive );
				fnSaveFilter( oInput );
		
				/* Now do the individual column filter */
				for ( var i=0 ; i<aoPrevSearch.length ; i++ )
				{
					_fnFilterColumn( oSettings, aoPrevSearch[i].sSearch, i, fnRegex(aoPrevSearch[i]),
						aoPrevSearch[i].bSmart, aoPrevSearch[i].bCaseInsensitive );
				}
		
				/* Custom filtering */
				_fnFilterCustom( oSettings );
			}
			else
			{
				fnSaveFilter( oInput );
			}
		
			/* Tell the draw function we have been filtering */
			oSettings.bFiltered = true;
			_fnCallbackFire( oSettings, null, 'search', [oSettings] );
		}
		
		
		/**
		 * Apply custom filtering functions
		 *  @param {object} oSettings dataTables settings object
		 *  @memberof DataTable#oApi
		 */
		function _fnFilterCustom( settings )
		{
			var filters = DataTable.ext.search;
			var displayRows = settings.aiDisplay;
			var row, rowIdx;
		
			for ( var i=0, ien=filters.length ; i<ien ; i++ ) {
				var rows = [];
		
				// Loop over each row and see if it should be included
				for ( var j=0, jen=displayRows.length ; j<jen ; j++ ) {
					rowIdx = displayRows[ j ];
					row = settings.aoData[ rowIdx ];
		
					if ( filters[i]( settings, row._aFilterData, rowIdx, row._aData, j ) ) {
						rows.push( rowIdx );
					}
				}
		
				// So the array reference doesn't break set the results into the
				// existing array
				displayRows.length = 0;
				$.merge( displayRows, rows );
			}
		}
		
		
		/**
		 * Filter the table on a per-column basis
		 *  @param {object} oSettings dataTables settings object
		 *  @param {string} sInput string to filter on
		 *  @param {int} iColumn column to filter
		 *  @param {bool} bRegex treat search string as a regular expression or not
		 *  @param {bool} bSmart use smart filtering or not
		 *  @param {bool} bCaseInsensitive Do case insenstive matching or not
		 *  @memberof DataTable#oApi
		 */
		function _fnFilterColumn ( settings, searchStr, colIdx, regex, smart, caseInsensitive )
		{
			if ( searchStr === '' ) {
				return;
			}
		
			var data;
			var display = settings.aiDisplay;
			var rpSearch = _fnFilterCreateSearch( searchStr, regex, smart, caseInsensitive );
		
			for ( var i=display.length-1 ; i>=0 ; i-- ) {
				data = settings.aoData[ display[i] ]._aFilterData[ colIdx ];
		
				if ( ! rpSearch.test( data ) ) {
					display.splice( i, 1 );
				}
			}
		}
		
		
		/**
		 * Filter the data table based on user input and draw the table
		 *  @param {object} settings dataTables settings object
		 *  @param {string} input string to filter on
		 *  @param {int} force optional - force a research of the master array (1) or not (undefined or 0)
		 *  @param {bool} regex treat as a regular expression or not
		 *  @param {bool} smart perform smart filtering or not
		 *  @param {bool} caseInsensitive Do case insenstive matching or not
		 *  @memberof DataTable#oApi
		 */
		function _fnFilter( settings, input, force, regex, smart, caseInsensitive )
		{
			var rpSearch = _fnFilterCreateSearch( input, regex, smart, caseInsensitive );
			var prevSearch = settings.oPreviousSearch.sSearch;
			var displayMaster = settings.aiDisplayMaster;
			var display, invalidated, i;
		
			// Need to take account of custom filtering functions - always filter
			if ( DataTable.ext.search.length !== 0 ) {
				force = true;
			}
		
			// Check if any of the rows were invalidated
			invalidated = _fnFilterData( settings );
		
			// If the input is blank - we just want the full data set
			if ( input.length <= 0 ) {
				settings.aiDisplay = displayMaster.slice();
			}
			else {
				// New search - start from the master array
				if ( invalidated ||
					 force ||
					 prevSearch.length > input.length ||
					 input.indexOf(prevSearch) !== 0 ||
					 settings.bSorted // On resort, the display master needs to be
					                  // re-filtered since indexes will have changed
				) {
					settings.aiDisplay = displayMaster.slice();
				}
		
				// Search the display array
				display = settings.aiDisplay;
		
				for ( i=display.length-1 ; i>=0 ; i-- ) {
					if ( ! rpSearch.test( settings.aoData[ display[i] ]._sFilterRow ) ) {
						display.splice( i, 1 );
					}
				}
			}
		}
		
		
		/**
		 * Build a regular expression object suitable for searching a table
		 *  @param {string} sSearch string to search for
		 *  @param {bool} bRegex treat as a regular expression or not
		 *  @param {bool} bSmart perform smart filtering or not
		 *  @param {bool} bCaseInsensitive Do case insensitive matching or not
		 *  @returns {RegExp} constructed object
		 *  @memberof DataTable#oApi
		 */
		function _fnFilterCreateSearch( search, regex, smart, caseInsensitive )
		{
			search = regex ?
				search :
				_fnEscapeRegex( search );
			
			if ( smart ) {
				/* For smart filtering we want to allow the search to work regardless of
				 * word order. We also want double quoted text to be preserved, so word
				 * order is important - a la google. So this is what we want to
				 * generate:
				 * 
				 * ^(?=.*?\bone\b)(?=.*?\btwo three\b)(?=.*?\bfour\b).*$
				 */
				var a = $.map( search.match( /"[^"]+"|[^ ]+/g ) || [''], function ( word ) {
					if ( word.charAt(0) === '"' ) {
						var m = word.match( /^"(.*)"$/ );
						word = m ? m[1] : word;
					}
		
					return word.replace('"', '');
				} );
		
				search = '^(?=.*?'+a.join( ')(?=.*?' )+').*$';
			}
		
			return new RegExp( search, caseInsensitive ? 'i' : '' );
		}
		
		
		/**
		 * Escape a string such that it can be used in a regular expression
		 *  @param {string} sVal string to escape
		 *  @returns {string} escaped string
		 *  @memberof DataTable#oApi
		 */
		var _fnEscapeRegex = DataTable.util.escapeRegex;
		
		var __filter_div = $('<div>')[0];
		var __filter_div_textContent = __filter_div.textContent !== undefined;
		
		// Update the filtering data for each row if needed (by invalidation or first run)
		function _fnFilterData ( settings )
		{
			var columns = settings.aoColumns;
			var column;
			var i, j, ien, jen, filterData, cellData, row;
			var fomatters = DataTable.ext.type.search;
			var wasInvalidated = false;
		
			for ( i=0, ien=settings.aoData.length ; i<ien ; i++ ) {
				row = settings.aoData[i];
		
				if ( ! row._aFilterData ) {
					filterData = [];
		
					for ( j=0, jen=columns.length ; j<jen ; j++ ) {
						column = columns[j];
		
						if ( column.bSearchable ) {
							cellData = _fnGetCellData( settings, i, j, 'filter' );
		
							if ( fomatters[ column.sType ] ) {
								cellData = fomatters[ column.sType ]( cellData );
							}
		
							// Search in DataTables 1.10 is string based. In 1.11 this
							// should be altered to also allow strict type checking.
							if ( cellData === null ) {
								cellData = '';
							}
		
							if ( typeof cellData !== 'string' && cellData.toString ) {
								cellData = cellData.toString();
							}
						}
						else {
							cellData = '';
						}
		
						// If it looks like there is an HTML entity in the string,
						// attempt to decode it so sorting works as expected. Note that
						// we could use a single line of jQuery to do this, but the DOM
						// method used here is much faster http://jsperf.com/html-decode
						if ( cellData.indexOf && cellData.indexOf('&') !== -1 ) {
							__filter_div.innerHTML = cellData;
							cellData = __filter_div_textContent ?
								__filter_div.textContent :
								__filter_div.innerText;
						}
		
						if ( cellData.replace ) {
							cellData = cellData.replace(/[\r\n]/g, '');
						}
		
						filterData.push( cellData );
					}
		
					row._aFilterData = filterData;
					row._sFilterRow = filterData.join('  ');
					wasInvalidated = true;
				}
			}
		
			return wasInvalidated;
		}
		
		
		/**
		 * Convert from the internal Hungarian notation to camelCase for external
		 * interaction
		 *  @param {object} obj Object to convert
		 *  @returns {object} Inverted object
		 *  @memberof DataTable#oApi
		 */
		function _fnSearchToCamel ( obj )
		{
			return {
				search:          obj.sSearch,
				smart:           obj.bSmart,
				regex:           obj.bRegex,
				caseInsensitive: obj.bCaseInsensitive
			};
		}
		
		
		
		/**
		 * Convert from camelCase notation to the internal Hungarian. We could use the
		 * Hungarian convert function here, but this is cleaner
		 *  @param {object} obj Object to convert
		 *  @returns {object} Inverted object
		 *  @memberof DataTable#oApi
		 */
		function _fnSearchToHung ( obj )
		{
			return {
				sSearch:          obj.search,
				bSmart:           obj.smart,
				bRegex:           obj.regex,
				bCaseInsensitive: obj.caseInsensitive
			};
		}
		
		/**
		 * Generate the node required for the info display
		 *  @param {object} oSettings dataTables settings object
		 *  @returns {node} Information element
		 *  @memberof DataTable#oApi
		 */
		function _fnFeatureHtmlInfo ( settings )
		{
			var
				tid = settings.sTableId,
				nodes = settings.aanFeatures.i,
				n = $('<div/>', {
					'class': settings.oClasses.sInfo,
					'id': ! nodes ? tid+'_info' : null
				} );
		
			if ( ! nodes ) {
				// Update display on each draw
				settings.aoDrawCallback.push( {
					"fn": _fnUpdateInfo,
					"sName": "information"
				} );
		
				n
					.attr( 'role', 'status' )
					.attr( 'aria-live', 'polite' );
		
				// Table is described by our info div
				$(settings.nTable).attr( 'aria-describedby', tid+'_info' );
			}
		
			return n[0];
		}
		
		
		/**
		 * Update the information elements in the display
		 *  @param {object} settings dataTables settings object
		 *  @memberof DataTable#oApi
		 */
		function _fnUpdateInfo ( settings )
		{
			/* Show information about the table */
			var nodes = settings.aanFeatures.i;
			if ( nodes.length === 0 ) {
				return;
			}
		
			var
				lang  = settings.oLanguage,
				start = settings._iDisplayStart+1,
				end   = settings.fnDisplayEnd(),
				max   = settings.fnRecordsTotal(),
				total = settings.fnRecordsDisplay(),
				out   = total ?
					lang.sInfo :
					lang.sInfoEmpty;
		
			if ( total !== max ) {
				/* Record set after filtering */
				out += ' ' + lang.sInfoFiltered;
			}
		
			// Convert the macros
			out += lang.sInfoPostFix;
			out = _fnInfoMacros( settings, out );
		
			var callback = lang.fnInfoCallback;
			if ( callback !== null ) {
				out = callback.call( settings.oInstance,
					settings, start, end, max, total, out
				);
			}
		
			$(nodes).html( out );
		}
		
		
		function _fnInfoMacros ( settings, str )
		{
			// When infinite scrolling, we are always starting at 1. _iDisplayStart is used only
			// internally
			var
				formatter  = settings.fnFormatNumber,
				start      = settings._iDisplayStart+1,
				len        = settings._iDisplayLength,
				vis        = settings.fnRecordsDisplay(),
				all        = len === -1;
		
			return str.
				replace(/_START_/g, formatter.call( settings, start ) ).
				replace(/_END_/g,   formatter.call( settings, settings.fnDisplayEnd() ) ).
				replace(/_MAX_/g,   formatter.call( settings, settings.fnRecordsTotal() ) ).
				replace(/_TOTAL_/g, formatter.call( settings, vis ) ).
				replace(/_PAGE_/g,  formatter.call( settings, all ? 1 : Math.ceil( start / len ) ) ).
				replace(/_PAGES_/g, formatter.call( settings, all ? 1 : Math.ceil( vis / len ) ) );
		}
		
		
		
		/**
		 * Draw the table for the first time, adding all required features
		 *  @param {object} settings dataTables settings object
		 *  @memberof DataTable#oApi
		 */
		function _fnInitialise ( settings )
		{
			var i, iLen, iAjaxStart=settings.iInitDisplayStart;
			var columns = settings.aoColumns, column;
			var features = settings.oFeatures;
			var deferLoading = settings.bDeferLoading; // value modified by the draw
		
			/* Ensure that the table data is fully initialised */
			if ( ! settings.bInitialised ) {
				setTimeout( function(){ _fnInitialise( settings ); }, 200 );
				return;
			}
		
			/* Show the display HTML options */
			_fnAddOptionsHtml( settings );
		
			/* Build and draw the header / footer for the table */
			_fnBuildHead( settings );
			_fnDrawHead( settings, settings.aoHeader );
			_fnDrawHead( settings, settings.aoFooter );
		
			/* Okay to show that something is going on now */
			_fnProcessingDisplay( settings, true );
		
			/* Calculate sizes for columns */
			if ( features.bAutoWidth ) {
				_fnCalculateColumnWidths( settings );
			}
		
			for ( i=0, iLen=columns.length ; i<iLen ; i++ ) {
				column = columns[i];
		
				if ( column.sWidth ) {
					column.nTh.style.width = _fnStringToCss( column.sWidth );
				}
			}
		
			_fnCallbackFire( settings, null, 'preInit', [settings] );
		
			// If there is default sorting required - let's do it. The sort function
			// will do the drawing for us. Otherwise we draw the table regardless of the
			// Ajax source - this allows the table to look initialised for Ajax sourcing
			// data (show 'loading' message possibly)
			_fnReDraw( settings );
		
			// Server-side processing init complete is done by _fnAjaxUpdateDraw
			var dataSrc = _fnDataSource( settings );
			if ( dataSrc != 'ssp' || deferLoading ) {
				// if there is an ajax source load the data
				if ( dataSrc == 'ajax' ) {
					_fnBuildAjax( settings, [], function(json) {
						var aData = _fnAjaxDataSrc( settings, json );
		
						// Got the data - add it to the table
						for ( i=0 ; i<aData.length ; i++ ) {
							_fnAddData( settings, aData[i] );
						}
		
						// Reset the init display for cookie saving. We've already done
						// a filter, and therefore cleared it before. So we need to make
						// it appear 'fresh'
						settings.iInitDisplayStart = iAjaxStart;
		
						_fnReDraw( settings );
		
						_fnProcessingDisplay( settings, false );
						_fnInitComplete( settings, json );
					}, settings );
				}
				else {
					_fnProcessingDisplay( settings, false );
					_fnInitComplete( settings );
				}
			}
		}
		
		
		/**
		 * Draw the table for the first time, adding all required features
		 *  @param {object} oSettings dataTables settings object
		 *  @param {object} [json] JSON from the server that completed the table, if using Ajax source
		 *    with client-side processing (optional)
		 *  @memberof DataTable#oApi
		 */
		function _fnInitComplete ( settings, json )
		{
			settings._bInitComplete = true;
		
			// When data was added after the initialisation (data or Ajax) we need to
			// calculate the column sizing
			if ( json || settings.oInit.aaData ) {
				_fnAdjustColumnSizing( settings );
			}
		
			_fnCallbackFire( settings, null, 'plugin-init', [settings, json] );
			_fnCallbackFire( settings, 'aoInitComplete', 'init', [settings, json] );
		}
		
		
		function _fnLengthChange ( settings, val )
		{
			var len = parseInt( val, 10 );
			settings._iDisplayLength = len;
		
			_fnLengthOverflow( settings );
		
			// Fire length change event
			_fnCallbackFire( settings, null, 'length', [settings, len] );
		}
		
		
		/**
		 * Generate the node required for user display length changing
		 *  @param {object} settings dataTables settings object
		 *  @returns {node} Display length feature node
		 *  @memberof DataTable#oApi
		 */
		function _fnFeatureHtmlLength ( settings )
		{
			var
				classes  = settings.oClasses,
				tableId  = settings.sTableId,
				menu     = settings.aLengthMenu,
				d2       = $.isArray( menu[0] ),
				lengths  = d2 ? menu[0] : menu,
				language = d2 ? menu[1] : menu;
		
			var select = $('<select/>', {
				'name':          tableId+'_length',
				'aria-controls': tableId,
				'class':         classes.sLengthSelect
			} );
		
			for ( var i=0, ien=lengths.length ; i<ien ; i++ ) {
				select[0][ i ] = new Option( language[i], lengths[i] );
			}
		
			var div = $('<div><label/></div>').addClass( classes.sLength );
			if ( ! settings.aanFeatures.l ) {
				div[0].id = tableId+'_length';
			}
		
			div.children().append(
				settings.oLanguage.sLengthMenu.replace( '_MENU_', select[0].outerHTML )
			);
		
			// Can't use `select` variable as user might provide their own and the
			// reference is broken by the use of outerHTML
			$('select', div)
				.val( settings._iDisplayLength )
				.bind( 'change.DT', function(e) {
					_fnLengthChange( settings, $(this).val() );
					_fnDraw( settings );
				} );
		
			// Update node value whenever anything changes the table's length
			$(settings.nTable).bind( 'length.dt.DT', function (e, s, len) {
				if ( settings === s ) {
					$('select', div).val( len );
				}
			} );
		
			return div[0];
		}
		
		
		
		/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
		 * Note that most of the paging logic is done in
		 * DataTable.ext.pager
		 */
		
		/**
		 * Generate the node required for default pagination
		 *  @param {object} oSettings dataTables settings object
		 *  @returns {node} Pagination feature node
		 *  @memberof DataTable#oApi
		 */
		function _fnFeatureHtmlPaginate ( settings )
		{
			var
				type   = settings.sPaginationType,
				plugin = DataTable.ext.pager[ type ],
				modern = typeof plugin === 'function',
				redraw = function( settings ) {
					_fnDraw( settings );
				},
				node = $('<div/>').addClass( settings.oClasses.sPaging + type )[0],
				features = settings.aanFeatures;
		
			if ( ! modern ) {
				plugin.fnInit( settings, node, redraw );
			}
		
			/* Add a draw callback for the pagination on first instance, to update the paging display */
			if ( ! features.p )
			{
				node.id = settings.sTableId+'_paginate';
		
				settings.aoDrawCallback.push( {
					"fn": function( settings ) {
						if ( modern ) {
							var
								start      = settings._iDisplayStart,
								len        = settings._iDisplayLength,
								visRecords = settings.fnRecordsDisplay(),
								all        = len === -1,
								page = all ? 0 : Math.ceil( start / len ),
								pages = all ? 1 : Math.ceil( visRecords / len ),
								buttons = plugin(page, pages),
								i, ien;
		
							for ( i=0, ien=features.p.length ; i<ien ; i++ ) {
								_fnRenderer( settings, 'pageButton' )(
									settings, features.p[i], i, buttons, page, pages
								);
							}
						}
						else {
							plugin.fnUpdate( settings, redraw );
						}
					},
					"sName": "pagination"
				} );
			}
		
			return node;
		}
		
		
		/**
		 * Alter the display settings to change the page
		 *  @param {object} settings DataTables settings object
		 *  @param {string|int} action Paging action to take: "first", "previous",
		 *    "next" or "last" or page number to jump to (integer)
		 *  @param [bool] redraw Automatically draw the update or not
		 *  @returns {bool} true page has changed, false - no change
		 *  @memberof DataTable#oApi
		 */
		function _fnPageChange ( settings, action, redraw )
		{
			var
				start     = settings._iDisplayStart,
				len       = settings._iDisplayLength,
				records   = settings.fnRecordsDisplay();
		
			if ( records === 0 || len === -1 )
			{
				start = 0;
			}
			else if ( typeof action === "number" )
			{
				start = action * len;
		
				if ( start > records )
				{
					start = 0;
				}
			}
			else if ( action == "first" )
			{
				start = 0;
			}
			else if ( action == "previous" )
			{
				start = len >= 0 ?
					start - len :
					0;
		
				if ( start < 0 )
				{
				  start = 0;
				}
			}
			else if ( action == "next" )
			{
				if ( start + len < records )
				{
					start += len;
				}
			}
			else if ( action == "last" )
			{
				start = Math.floor( (records-1) / len) * len;
			}
			else
			{
				_fnLog( settings, 0, "Unknown paging action: "+action, 5 );
			}
		
			var changed = settings._iDisplayStart !== start;
			settings._iDisplayStart = start;
		
			if ( changed ) {
				_fnCallbackFire( settings, null, 'page', [settings] );
		
				if ( redraw ) {
					_fnDraw( settings );
				}
			}
		
			return changed;
		}
		
		
		
		/**
		 * Generate the node required for the processing node
		 *  @param {object} settings dataTables settings object
		 *  @returns {node} Processing element
		 *  @memberof DataTable#oApi
		 */
		function _fnFeatureHtmlProcessing ( settings )
		{
			return $('<div/>', {
					'id': ! settings.aanFeatures.r ? settings.sTableId+'_processing' : null,
					'class': settings.oClasses.sProcessing
				} )
				.html( settings.oLanguage.sProcessing )
				.insertBefore( settings.nTable )[0];
		}
		
		
		/**
		 * Display or hide the processing indicator
		 *  @param {object} settings dataTables settings object
		 *  @param {bool} show Show the processing indicator (true) or not (false)
		 *  @memberof DataTable#oApi
		 */
		function _fnProcessingDisplay ( settings, show )
		{
			if ( settings.oFeatures.bProcessing ) {
				$(settings.aanFeatures.r).css( 'display', show ? 'block' : 'none' );
			}
		
			_fnCallbackFire( settings, null, 'processing', [settings, show] );
		}
		
		/**
		 * Add any control elements for the table - specifically scrolling
		 *  @param {object} settings dataTables settings object
		 *  @returns {node} Node to add to the DOM
		 *  @memberof DataTable#oApi
		 */
		function _fnFeatureHtmlTable ( settings )
		{
			var table = $(settings.nTable);
		
			// Add the ARIA grid role to the table
			table.attr( 'role', 'grid' );
		
			// Scrolling from here on in
			var scroll = settings.oScroll;
		
			if ( scroll.sX === '' && scroll.sY === '' ) {
				return settings.nTable;
			}
		
			var scrollX = scroll.sX;
			var scrollY = scroll.sY;
			var classes = settings.oClasses;
			var caption = table.children('caption');
			var captionSide = caption.length ? caption[0]._captionSide : null;
			var headerClone = $( table[0].cloneNode(false) );
			var footerClone = $( table[0].cloneNode(false) );
			var footer = table.children('tfoot');
			var _div = '<div/>';
			var size = function ( s ) {
				return !s ? null : _fnStringToCss( s );
			};
		
			if ( ! footer.length ) {
				footer = null;
			}
		
			/*
			 * The HTML structure that we want to generate in this function is:
			 *  div - scroller
			 *    div - scroll head
			 *      div - scroll head inner
			 *        table - scroll head table
			 *          thead - thead
			 *    div - scroll body
			 *      table - table (master table)
			 *        thead - thead clone for sizing
			 *        tbody - tbody
			 *    div - scroll foot
			 *      div - scroll foot inner
			 *        table - scroll foot table
			 *          tfoot - tfoot
			 */
			var scroller = $( _div, { 'class': classes.sScrollWrapper } )
				.append(
					$(_div, { 'class': classes.sScrollHead } )
						.css( {
							overflow: 'hidden',
							position: 'relative',
							border: 0,
							width: scrollX ? size(scrollX) : '100%'
						} )
						.append(
							$(_div, { 'class': classes.sScrollHeadInner } )
								.css( {
									'box-sizing': 'content-box',
									width: scroll.sXInner || '100%'
								} )
								.append(
									headerClone
										.removeAttr('id')
										.css( 'margin-left', 0 )
										.append( captionSide === 'top' ? caption : null )
										.append(
											table.children('thead')
										)
								)
						)
				)
				.append(
					$(_div, { 'class': classes.sScrollBody } )
						.css( {
							position: 'relative',
							overflow: 'auto',
							width: size( scrollX )
						} )
						.append( table )
				);
		
			if ( footer ) {
				scroller.append(
					$(_div, { 'class': classes.sScrollFoot } )
						.css( {
							overflow: 'hidden',
							border: 0,
							width: scrollX ? size(scrollX) : '100%'
						} )
						.append(
							$(_div, { 'class': classes.sScrollFootInner } )
								.append(
									footerClone
										.removeAttr('id')
										.css( 'margin-left', 0 )
										.append( captionSide === 'bottom' ? caption : null )
										.append(
											table.children('tfoot')
										)
								)
						)
				);
			}
		
			var children = scroller.children();
			var scrollHead = children[0];
			var scrollBody = children[1];
			var scrollFoot = footer ? children[2] : null;
		
			// When the body is scrolled, then we also want to scroll the headers
			if ( scrollX ) {
				$(scrollBody).on( 'scroll.DT', function (e) {
					var scrollLeft = this.scrollLeft;
		
					scrollHead.scrollLeft = scrollLeft;
		
					if ( footer ) {
						scrollFoot.scrollLeft = scrollLeft;
					}
				} );
			}
		
			$(scrollBody).css(
				scrollY && scroll.bCollapse ? 'max-height' : 'height', 
				scrollY
			);
		
			settings.nScrollHead = scrollHead;
			settings.nScrollBody = scrollBody;
			settings.nScrollFoot = scrollFoot;
		
			// On redraw - align columns
			settings.aoDrawCallback.push( {
				"fn": _fnScrollDraw,
				"sName": "scrolling"
			} );
		
			return scroller[0];
		}
		
		
		
		/**
		 * Update the header, footer and body tables for resizing - i.e. column
		 * alignment.
		 *
		 * Welcome to the most horrible function DataTables. The process that this
		 * function follows is basically:
		 *   1. Re-create the table inside the scrolling div
		 *   2. Take live measurements from the DOM
		 *   3. Apply the measurements to align the columns
		 *   4. Clean up
		 *
		 *  @param {object} settings dataTables settings object
		 *  @memberof DataTable#oApi
		 */
		function _fnScrollDraw ( settings )
		{
			// Given that this is such a monster function, a lot of variables are use
			// to try and keep the minimised size as small as possible
			var
				scroll         = settings.oScroll,
				scrollX        = scroll.sX,
				scrollXInner   = scroll.sXInner,
				scrollY        = scroll.sY,
				barWidth       = scroll.iBarWidth,
				divHeader      = $(settings.nScrollHead),
				divHeaderStyle = divHeader[0].style,
				divHeaderInner = divHeader.children('div'),
				divHeaderInnerStyle = divHeaderInner[0].style,
				divHeaderTable = divHeaderInner.children('table'),
				divBodyEl      = settings.nScrollBody,
				divBody        = $(divBodyEl),
				divBodyStyle   = divBodyEl.style,
				divFooter      = $(settings.nScrollFoot),
				divFooterInner = divFooter.children('div'),
				divFooterTable = divFooterInner.children('table'),
				header         = $(settings.nTHead),
				table          = $(settings.nTable),
				tableEl        = table[0],
				tableStyle     = tableEl.style,
				footer         = settings.nTFoot ? $(settings.nTFoot) : null,
				browser        = settings.oBrowser,
				ie67           = browser.bScrollOversize,
				dtHeaderCells  = _pluck( settings.aoColumns, 'nTh' ),
				headerTrgEls, footerTrgEls,
				headerSrcEls, footerSrcEls,
				headerCopy, footerCopy,
				headerWidths=[], footerWidths=[],
				headerContent=[], footerContent=[],
				idx, correction, sanityWidth,
				zeroOut = function(nSizer) {
					var style = nSizer.style;
					style.paddingTop = "0";
					style.paddingBottom = "0";
					style.borderTopWidth = "0";
					style.borderBottomWidth = "0";
					style.height = 0;
				};
		
			// If the scrollbar visibility has changed from the last draw, we need to
			// adjust the column sizes as the table width will have changed to account
			// for the scrollbar
			var scrollBarVis = divBodyEl.scrollHeight > divBodyEl.clientHeight;
			
			if ( settings.scrollBarVis !== scrollBarVis && settings.scrollBarVis !== undefined ) {
				settings.scrollBarVis = scrollBarVis;
				_fnAdjustColumnSizing( settings );
				return; // adjust column sizing will call this function again
			}
			else {
				settings.scrollBarVis = scrollBarVis;
			}
		
			/*
			 * 1. Re-create the table inside the scrolling div
			 */
		
			// Remove the old minimised thead and tfoot elements in the inner table
			table.children('thead, tfoot').remove();
		
			if ( footer ) {
				footerCopy = footer.clone().prependTo( table );
				footerTrgEls = footer.find('tr'); // the original tfoot is in its own table and must be sized
				footerSrcEls = footerCopy.find('tr');
			}
		
			// Clone the current header and footer elements and then place it into the inner table
			headerCopy = header.clone().prependTo( table );
			headerTrgEls = header.find('tr'); // original header is in its own table
			headerSrcEls = headerCopy.find('tr');
			headerCopy.find('th, td').removeAttr('tabindex');
		
		
			/*
			 * 2. Take live measurements from the DOM - do not alter the DOM itself!
			 */
		
			// Remove old sizing and apply the calculated column widths
			// Get the unique column headers in the newly created (cloned) header. We want to apply the
			// calculated sizes to this header
			if ( ! scrollX )
			{
				divBodyStyle.width = '100%';
				divHeader[0].style.width = '100%';
			}
		
			$.each( _fnGetUniqueThs( settings, headerCopy ), function ( i, el ) {
				idx = _fnVisibleToColumnIndex( settings, i );
				el.style.width = settings.aoColumns[idx].sWidth;
			} );
		
			if ( footer ) {
				_fnApplyToChildren( function(n) {
					n.style.width = "";
				}, footerSrcEls );
			}
		
			// Size the table as a whole
			sanityWidth = table.outerWidth();
			if ( scrollX === "" ) {
				// No x scrolling
				tableStyle.width = "100%";
		
				// IE7 will make the width of the table when 100% include the scrollbar
				// - which is shouldn't. When there is a scrollbar we need to take this
				// into account.
				if ( ie67 && (table.find('tbody').height() > divBodyEl.offsetHeight ||
					divBody.css('overflow-y') == "scroll")
				) {
					tableStyle.width = _fnStringToCss( table.outerWidth() - barWidth);
				}
		
				// Recalculate the sanity width
				sanityWidth = table.outerWidth();
			}
			else if ( scrollXInner !== "" ) {
				// legacy x scroll inner has been given - use it
				tableStyle.width = _fnStringToCss(scrollXInner);
		
				// Recalculate the sanity width
				sanityWidth = table.outerWidth();
			}
		
			// Hidden header should have zero height, so remove padding and borders. Then
			// set the width based on the real headers
		
			// Apply all styles in one pass
			_fnApplyToChildren( zeroOut, headerSrcEls );
		
			// Read all widths in next pass
			_fnApplyToChildren( function(nSizer) {
				headerContent.push( nSizer.innerHTML );
				headerWidths.push( _fnStringToCss( $(nSizer).css('width') ) );
			}, headerSrcEls );
		
			// Apply all widths in final pass
			_fnApplyToChildren( function(nToSize, i) {
				// Only apply widths to the DataTables detected header cells - this
				// prevents complex headers from having contradictory sizes applied
				if ( $.inArray( nToSize, dtHeaderCells ) !== -1 ) {
					nToSize.style.width = headerWidths[i];
				}
			}, headerTrgEls );
		
			$(headerSrcEls).height(0);
		
			/* Same again with the footer if we have one */
			if ( footer )
			{
				_fnApplyToChildren( zeroOut, footerSrcEls );
		
				_fnApplyToChildren( function(nSizer) {
					footerContent.push( nSizer.innerHTML );
					footerWidths.push( _fnStringToCss( $(nSizer).css('width') ) );
				}, footerSrcEls );
		
				_fnApplyToChildren( function(nToSize, i) {
					nToSize.style.width = footerWidths[i];
				}, footerTrgEls );
		
				$(footerSrcEls).height(0);
			}
		
		
			/*
			 * 3. Apply the measurements
			 */
		
			// "Hide" the header and footer that we used for the sizing. We need to keep
			// the content of the cell so that the width applied to the header and body
			// both match, but we want to hide it completely. We want to also fix their
			// width to what they currently are
			_fnApplyToChildren( function(nSizer, i) {
				nSizer.innerHTML = '<div class="dataTables_sizing" style="height:0;overflow:hidden;">'+headerContent[i]+'</div>';
				nSizer.style.width = headerWidths[i];
			}, headerSrcEls );
		
			if ( footer )
			{
				_fnApplyToChildren( function(nSizer, i) {
					nSizer.innerHTML = '<div class="dataTables_sizing" style="height:0;overflow:hidden;">'+footerContent[i]+'</div>';
					nSizer.style.width = footerWidths[i];
				}, footerSrcEls );
			}
		
			// Sanity check that the table is of a sensible width. If not then we are going to get
			// misalignment - try to prevent this by not allowing the table to shrink below its min width
			if ( table.outerWidth() < sanityWidth )
			{
				// The min width depends upon if we have a vertical scrollbar visible or not */
				correction = ((divBodyEl.scrollHeight > divBodyEl.offsetHeight ||
					divBody.css('overflow-y') == "scroll")) ?
						sanityWidth+barWidth :
						sanityWidth;
		
				// IE6/7 are a law unto themselves...
				if ( ie67 && (divBodyEl.scrollHeight >
					divBodyEl.offsetHeight || divBody.css('overflow-y') == "scroll")
				) {
					tableStyle.width = _fnStringToCss( correction-barWidth );
				}
		
				// And give the user a warning that we've stopped the table getting too small
				if ( scrollX === "" || scrollXInner !== "" ) {
					_fnLog( settings, 1, 'Possible column misalignment', 6 );
				}
			}
			else
			{
				correction = '100%';
			}
		
			// Apply to the container elements
			divBodyStyle.width = _fnStringToCss( correction );
			divHeaderStyle.width = _fnStringToCss( correction );
		
			if ( footer ) {
				settings.nScrollFoot.style.width = _fnStringToCss( correction );
			}
		
		
			/*
			 * 4. Clean up
			 */
			if ( ! scrollY ) {
				/* IE7< puts a vertical scrollbar in place (when it shouldn't be) due to subtracting
				 * the scrollbar height from the visible display, rather than adding it on. We need to
				 * set the height in order to sort this. Don't want to do it in any other browsers.
				 */
				if ( ie67 ) {
					divBodyStyle.height = _fnStringToCss( tableEl.offsetHeight+barWidth );
				}
			}
		
			/* Finally set the width's of the header and footer tables */
			var iOuterWidth = table.outerWidth();
			divHeaderTable[0].style.width = _fnStringToCss( iOuterWidth );
			divHeaderInnerStyle.width = _fnStringToCss( iOuterWidth );
		
			// Figure out if there are scrollbar present - if so then we need a the header and footer to
			// provide a bit more space to allow "overflow" scrolling (i.e. past the scrollbar)
			var bScrolling = table.height() > divBodyEl.clientHeight || divBody.css('overflow-y') == "scroll";
			var padding = 'padding' + (browser.bScrollbarLeft ? 'Left' : 'Right' );
			divHeaderInnerStyle[ padding ] = bScrolling ? barWidth+"px" : "0px";
		
			if ( footer ) {
				divFooterTable[0].style.width = _fnStringToCss( iOuterWidth );
				divFooterInner[0].style.width = _fnStringToCss( iOuterWidth );
				divFooterInner[0].style[padding] = bScrolling ? barWidth+"px" : "0px";
			}
		
			// Correct DOM ordering for colgroup - comes before the thead
			table.children('colgroup').insertBefore( table.children('thead') );
		
			/* Adjust the position of the header in case we loose the y-scrollbar */
			divBody.scroll();
		
			// If sorting or filtering has occurred, jump the scrolling back to the top
			// only if we aren't holding the position
			if ( (settings.bSorted || settings.bFiltered) && ! settings._drawHold ) {
				divBodyEl.scrollTop = 0;
			}
		}
		
		
		
		/**
		 * Apply a given function to the display child nodes of an element array (typically
		 * TD children of TR rows
		 *  @param {function} fn Method to apply to the objects
		 *  @param array {nodes} an1 List of elements to look through for display children
		 *  @param array {nodes} an2 Another list (identical structure to the first) - optional
		 *  @memberof DataTable#oApi
		 */
		function _fnApplyToChildren( fn, an1, an2 )
		{
			var index=0, i=0, iLen=an1.length;
			var nNode1, nNode2;
		
			while ( i < iLen ) {
				nNode1 = an1[i].firstChild;
				nNode2 = an2 ? an2[i].firstChild : null;
		
				while ( nNode1 ) {
					if ( nNode1.nodeType === 1 ) {
						if ( an2 ) {
							fn( nNode1, nNode2, index );
						}
						else {
							fn( nNode1, index );
						}
		
						index++;
					}
		
					nNode1 = nNode1.nextSibling;
					nNode2 = an2 ? nNode2.nextSibling : null;
				}
		
				i++;
			}
		}
		
		
		
		var __re_html_remove = /<.*?>/g;
		
		
		/**
		 * Calculate the width of columns for the table
		 *  @param {object} oSettings dataTables settings object
		 *  @memberof DataTable#oApi
		 */
		function _fnCalculateColumnWidths ( oSettings )
		{
			var
				table = oSettings.nTable,
				columns = oSettings.aoColumns,
				scroll = oSettings.oScroll,
				scrollY = scroll.sY,
				scrollX = scroll.sX,
				scrollXInner = scroll.sXInner,
				columnCount = columns.length,
				visibleColumns = _fnGetColumns( oSettings, 'bVisible' ),
				headerCells = $('th', oSettings.nTHead),
				tableWidthAttr = table.getAttribute('width'), // from DOM element
				tableContainer = table.parentNode,
				userInputs = false,
				i, column, columnIdx, width, outerWidth,
				browser = oSettings.oBrowser,
				ie67 = browser.bScrollOversize;
		
			var styleWidth = table.style.width;
			if ( styleWidth && styleWidth.indexOf('%') !== -1 ) {
				tableWidthAttr = styleWidth;
			}
		
			/* Convert any user input sizes into pixel sizes */
			for ( i=0 ; i<visibleColumns.length ; i++ ) {
				column = columns[ visibleColumns[i] ];
		
				if ( column.sWidth !== null ) {
					column.sWidth = _fnConvertToWidth( column.sWidthOrig, tableContainer );
		
					userInputs = true;
				}
			}
		
			/* If the number of columns in the DOM equals the number that we have to
			 * process in DataTables, then we can use the offsets that are created by
			 * the web- browser. No custom sizes can be set in order for this to happen,
			 * nor scrolling used
			 */
			if ( ie67 || ! userInputs && ! scrollX && ! scrollY &&
			     columnCount == _fnVisbleColumns( oSettings ) &&
			     columnCount == headerCells.length
			) {
				for ( i=0 ; i<columnCount ; i++ ) {
					var colIdx = _fnVisibleToColumnIndex( oSettings, i );
		
					if ( colIdx !== null ) {
						columns[ colIdx ].sWidth = _fnStringToCss( headerCells.eq(i).width() );
					}
				}
			}
			else
			{
				// Otherwise construct a single row, worst case, table with the widest
				// node in the data, assign any user defined widths, then insert it into
				// the DOM and allow the browser to do all the hard work of calculating
				// table widths
				var tmpTable = $(table).clone() // don't use cloneNode - IE8 will remove events on the main table
					.css( 'visibility', 'hidden' )
					.removeAttr( 'id' );
		
				// Clean up the table body
				tmpTable.find('tbody tr').remove();
				var tr = $('<tr/>').appendTo( tmpTable.find('tbody') );
		
				// Clone the table header and footer - we can't use the header / footer
				// from the cloned table, since if scrolling is active, the table's
				// real header and footer are contained in different table tags
				tmpTable.find('thead, tfoot').remove();
				tmpTable
					.append( $(oSettings.nTHead).clone() )
					.append( $(oSettings.nTFoot).clone() );
		
				// Remove any assigned widths from the footer (from scrolling)
				tmpTable.find('tfoot th, tfoot td').css('width', '');
		
				// Apply custom sizing to the cloned header
				headerCells = _fnGetUniqueThs( oSettings, tmpTable.find('thead')[0] );
		
				for ( i=0 ; i<visibleColumns.length ; i++ ) {
					column = columns[ visibleColumns[i] ];
		
					headerCells[i].style.width = column.sWidthOrig !== null && column.sWidthOrig !== '' ?
						_fnStringToCss( column.sWidthOrig ) :
						'';
		
					// For scrollX we need to force the column width otherwise the
					// browser will collapse it. If this width is smaller than the
					// width the column requires, then it will have no effect
					if ( column.sWidthOrig && scrollX ) {
						$( headerCells[i] ).append( $('<div/>').css( {
							width: column.sWidthOrig,
							margin: 0,
							padding: 0,
							border: 0,
							height: 1
						} ) );
					}
				}
		
				// Find the widest cell for each column and put it into the table
				if ( oSettings.aoData.length ) {
					for ( i=0 ; i<visibleColumns.length ; i++ ) {
						columnIdx = visibleColumns[i];
						column = columns[ columnIdx ];
		
						$( _fnGetWidestNode( oSettings, columnIdx ) )
							.clone( false )
							.append( column.sContentPadding )
							.appendTo( tr );
					}
				}
		
				// Tidy the temporary table - remove name attributes so there aren't
				// duplicated in the dom (radio elements for example)
				$('[name]', tmpTable).removeAttr('name');
		
				// Table has been built, attach to the document so we can work with it.
				// A holding element is used, positioned at the top of the container
				// with minimal height, so it has no effect on if the container scrolls
				// or not. Otherwise it might trigger scrolling when it actually isn't
				// needed
				var holder = $('<div/>').css( scrollX || scrollY ?
						{
							position: 'absolute',
							top: 0,
							left: 0,
							height: 1,
							right: 0,
							overflow: 'hidden'
						} :
						{}
					)
					.append( tmpTable )
					.appendTo( tableContainer );
		
				// When scrolling (X or Y) we want to set the width of the table as 
				// appropriate. However, when not scrolling leave the table width as it
				// is. This results in slightly different, but I think correct behaviour
				if ( scrollX && scrollXInner ) {
					tmpTable.width( scrollXInner );
				}
				else if ( scrollX ) {
					tmpTable.css( 'width', 'auto' );
					tmpTable.removeAttr('width');
		
					// If there is no width attribute or style, then allow the table to
					// collapse
					if ( tmpTable.width() < tableContainer.clientWidth && tableWidthAttr ) {
						tmpTable.width( tableContainer.clientWidth );
					}
				}
				else if ( scrollY ) {
					tmpTable.width( tableContainer.clientWidth );
				}
				else if ( tableWidthAttr ) {
					tmpTable.width( tableWidthAttr );
				}
		
				// Get the width of each column in the constructed table - we need to
				// know the inner width (so it can be assigned to the other table's
				// cells) and the outer width so we can calculate the full width of the
				// table. This is safe since DataTables requires a unique cell for each
				// column, but if ever a header can span multiple columns, this will
				// need to be modified.
				var total = 0;
				for ( i=0 ; i<visibleColumns.length ; i++ ) {
					var cell = $(headerCells[i]);
					var border = cell.outerWidth() - cell.width();
		
					// Use getBounding... where possible (not IE8-) because it can give
					// sub-pixel accuracy, which we then want to round up!
					var bounding = browser.bBounding ?
						Math.ceil( headerCells[i].getBoundingClientRect().width ) :
						cell.outerWidth();
		
					// Total is tracked to remove any sub-pixel errors as the outerWidth
					// of the table might not equal the total given here (IE!).
					total += bounding;
		
					// Width for each column to use
					columns[ visibleColumns[i] ].sWidth = _fnStringToCss( bounding - border );
				}
		
				table.style.width = _fnStringToCss( total );
		
				// Finished with the table - ditch it
				holder.remove();
			}
		
			// If there is a width attr, we want to attach an event listener which
			// allows the table sizing to automatically adjust when the window is
			// resized. Use the width attr rather than CSS, since we can't know if the
			// CSS is a relative value or absolute - DOM read is always px.
			if ( tableWidthAttr ) {
				table.style.width = _fnStringToCss( tableWidthAttr );
			}
		
			if ( (tableWidthAttr || scrollX) && ! oSettings._reszEvt ) {
				var bindResize = function () {
					$(window).bind('resize.DT-'+oSettings.sInstance, _fnThrottle( function () {
						_fnAdjustColumnSizing( oSettings );
					} ) );
				};
		
				// IE6/7 will crash if we bind a resize event handler on page load.
				// To be removed in 1.11 which drops IE6/7 support
				if ( ie67 ) {
					setTimeout( bindResize, 1000 );
				}
				else {
					bindResize();
				}
		
				oSettings._reszEvt = true;
			}
		}
		
		
		/**
		 * Throttle the calls to a function. Arguments and context are maintained for
		 * the throttled function
		 *  @param {function} fn Function to be called
		 *  @param {int} [freq=200] call frequency in mS
		 *  @returns {function} wrapped function
		 *  @memberof DataTable#oApi
		 */
		var _fnThrottle = DataTable.util.throttle;
		
		
		/**
		 * Convert a CSS unit width to pixels (e.g. 2em)
		 *  @param {string} width width to be converted
		 *  @param {node} parent parent to get the with for (required for relative widths) - optional
		 *  @returns {int} width in pixels
		 *  @memberof DataTable#oApi
		 */
		function _fnConvertToWidth ( width, parent )
		{
			if ( ! width ) {
				return 0;
			}
		
			var n = $('<div/>')
				.css( 'width', _fnStringToCss( width ) )
				.appendTo( parent || document.body );
		
			var val = n[0].offsetWidth;
			n.remove();
		
			return val;
		}
		
		
		/**
		 * Get the widest node
		 *  @param {object} settings dataTables settings object
		 *  @param {int} colIdx column of interest
		 *  @returns {node} widest table node
		 *  @memberof DataTable#oApi
		 */
		function _fnGetWidestNode( settings, colIdx )
		{
			var idx = _fnGetMaxLenString( settings, colIdx );
			if ( idx < 0 ) {
				return null;
			}
		
			var data = settings.aoData[ idx ];
			return ! data.nTr ? // Might not have been created when deferred rendering
				$('<td/>').html( _fnGetCellData( settings, idx, colIdx, 'display' ) )[0] :
				data.anCells[ colIdx ];
		}
		
		
		/**
		 * Get the maximum strlen for each data column
		 *  @param {object} settings dataTables settings object
		 *  @param {int} colIdx column of interest
		 *  @returns {string} max string length for each column
		 *  @memberof DataTable#oApi
		 */
		function _fnGetMaxLenString( settings, colIdx )
		{
			var s, max=-1, maxIdx = -1;
		
			for ( var i=0, ien=settings.aoData.length ; i<ien ; i++ ) {
				s = _fnGetCellData( settings, i, colIdx, 'display' )+'';
				s = s.replace( __re_html_remove, '' );
				s = s.replace( /&nbsp;/g, ' ' );
		
				if ( s.length > max ) {
					max = s.length;
					maxIdx = i;
				}
			}
		
			return maxIdx;
		}
		
		
		/**
		 * Append a CSS unit (only if required) to a string
		 *  @param {string} value to css-ify
		 *  @returns {string} value with css unit
		 *  @memberof DataTable#oApi
		 */
		function _fnStringToCss( s )
		{
			if ( s === null ) {
				return '0px';
			}
		
			if ( typeof s == 'number' ) {
				return s < 0 ?
					'0px' :
					s+'px';
			}
		
			// Check it has a unit character already
			return s.match(/\d$/) ?
				s+'px' :
				s;
		}
		
		
		
		function _fnSortFlatten ( settings )
		{
			var
				i, iLen, k, kLen,
				aSort = [],
				aiOrig = [],
				aoColumns = settings.aoColumns,
				aDataSort, iCol, sType, srcCol,
				fixed = settings.aaSortingFixed,
				fixedObj = $.isPlainObject( fixed ),
				nestedSort = [],
				add = function ( a ) {
					if ( a.length && ! $.isArray( a[0] ) ) {
						// 1D array
						nestedSort.push( a );
					}
					else {
						// 2D array
						$.merge( nestedSort, a );
					}
				};
		
			// Build the sort array, with pre-fix and post-fix options if they have been
			// specified
			if ( $.isArray( fixed ) ) {
				add( fixed );
			}
		
			if ( fixedObj && fixed.pre ) {
				add( fixed.pre );
			}
		
			add( settings.aaSorting );
		
			if (fixedObj && fixed.post ) {
				add( fixed.post );
			}
		
			for ( i=0 ; i<nestedSort.length ; i++ )
			{
				srcCol = nestedSort[i][0];
				aDataSort = aoColumns[ srcCol ].aDataSort;
		
				for ( k=0, kLen=aDataSort.length ; k<kLen ; k++ )
				{
					iCol = aDataSort[k];
					sType = aoColumns[ iCol ].sType || 'string';
		
					if ( nestedSort[i]._idx === undefined ) {
						nestedSort[i]._idx = $.inArray( nestedSort[i][1], aoColumns[iCol].asSorting );
					}
		
					aSort.push( {
						src:       srcCol,
						col:       iCol,
						dir:       nestedSort[i][1],
						index:     nestedSort[i]._idx,
						type:      sType,
						formatter: DataTable.ext.type.order[ sType+"-pre" ]
					} );
				}
			}
		
			return aSort;
		}
		
		/**
		 * Change the order of the table
		 *  @param {object} oSettings dataTables settings object
		 *  @memberof DataTable#oApi
		 *  @todo This really needs split up!
		 */
		function _fnSort ( oSettings )
		{
			var
				i, ien, iLen, j, jLen, k, kLen,
				sDataType, nTh,
				aiOrig = [],
				oExtSort = DataTable.ext.type.order,
				aoData = oSettings.aoData,
				aoColumns = oSettings.aoColumns,
				aDataSort, data, iCol, sType, oSort,
				formatters = 0,
				sortCol,
				displayMaster = oSettings.aiDisplayMaster,
				aSort;
		
			// Resolve any column types that are unknown due to addition or invalidation
			// @todo Can this be moved into a 'data-ready' handler which is called when
			//   data is going to be used in the table?
			_fnColumnTypes( oSettings );
		
			aSort = _fnSortFlatten( oSettings );
		
			for ( i=0, ien=aSort.length ; i<ien ; i++ ) {
				sortCol = aSort[i];
		
				// Track if we can use the fast sort algorithm
				if ( sortCol.formatter ) {
					formatters++;
				}
		
				// Load the data needed for the sort, for each cell
				_fnSortData( oSettings, sortCol.col );
			}
		
			/* No sorting required if server-side or no sorting array */
			if ( _fnDataSource( oSettings ) != 'ssp' && aSort.length !== 0 )
			{
				// Create a value - key array of the current row positions such that we can use their
				// current position during the sort, if values match, in order to perform stable sorting
				for ( i=0, iLen=displayMaster.length ; i<iLen ; i++ ) {
					aiOrig[ displayMaster[i] ] = i;
				}
		
				/* Do the sort - here we want multi-column sorting based on a given data source (column)
				 * and sorting function (from oSort) in a certain direction. It's reasonably complex to
				 * follow on it's own, but this is what we want (example two column sorting):
				 *  fnLocalSorting = function(a,b){
				 *    var iTest;
				 *    iTest = oSort['string-asc']('data11', 'data12');
				 *      if (iTest !== 0)
				 *        return iTest;
				 *    iTest = oSort['numeric-desc']('data21', 'data22');
				 *    if (iTest !== 0)
				 *      return iTest;
				 *    return oSort['numeric-asc']( aiOrig[a], aiOrig[b] );
				 *  }
				 * Basically we have a test for each sorting column, if the data in that column is equal,
				 * test the next column. If all columns match, then we use a numeric sort on the row
				 * positions in the original data array to provide a stable sort.
				 *
				 * Note - I know it seems excessive to have two sorting methods, but the first is around
				 * 15% faster, so the second is only maintained for backwards compatibility with sorting
				 * methods which do not have a pre-sort formatting function.
				 */
				if ( formatters === aSort.length ) {
					// All sort types have formatting functions
					displayMaster.sort( function ( a, b ) {
						var
							x, y, k, test, sort,
							len=aSort.length,
							dataA = aoData[a]._aSortData,
							dataB = aoData[b]._aSortData;
		
						for ( k=0 ; k<len ; k++ ) {
							sort = aSort[k];
		
							x = dataA[ sort.col ];
							y = dataB[ sort.col ];
		
							test = x<y ? -1 : x>y ? 1 : 0;
							if ( test !== 0 ) {
								return sort.dir === 'asc' ? test : -test;
							}
						}
		
						x = aiOrig[a];
						y = aiOrig[b];
						return x<y ? -1 : x>y ? 1 : 0;
					} );
				}
				else {
					// Depreciated - remove in 1.11 (providing a plug-in option)
					// Not all sort types have formatting methods, so we have to call their sorting
					// methods.
					displayMaster.sort( function ( a, b ) {
						var
							x, y, k, l, test, sort, fn,
							len=aSort.length,
							dataA = aoData[a]._aSortData,
							dataB = aoData[b]._aSortData;
		
						for ( k=0 ; k<len ; k++ ) {
							sort = aSort[k];
		
							x = dataA[ sort.col ];
							y = dataB[ sort.col ];
		
							fn = oExtSort[ sort.type+"-"+sort.dir ] || oExtSort[ "string-"+sort.dir ];
							test = fn( x, y );
							if ( test !== 0 ) {
								return test;
							}
						}
		
						x = aiOrig[a];
						y = aiOrig[b];
						return x<y ? -1 : x>y ? 1 : 0;
					} );
				}
			}
		
			/* Tell the draw function that we have sorted the data */
			oSettings.bSorted = true;
		}
		
		
		function _fnSortAria ( settings )
		{
			var label;
			var nextSort;
			var columns = settings.aoColumns;
			var aSort = _fnSortFlatten( settings );
			var oAria = settings.oLanguage.oAria;
		
			// ARIA attributes - need to loop all columns, to update all (removing old
			// attributes as needed)
			for ( var i=0, iLen=columns.length ; i<iLen ; i++ )
			{
				var col = columns[i];
				var asSorting = col.asSorting;
				var sTitle = col.sTitle.replace( /<.*?>/g, "" );
				var th = col.nTh;
		
				// IE7 is throwing an error when setting these properties with jQuery's
				// attr() and removeAttr() methods...
				th.removeAttribute('aria-sort');
		
				/* In ARIA only the first sorting column can be marked as sorting - no multi-sort option */
				if ( col.bSortable ) {
					if ( aSort.length > 0 && aSort[0].col == i ) {
						th.setAttribute('aria-sort', aSort[0].dir=="asc" ? "ascending" : "descending" );
						nextSort = asSorting[ aSort[0].index+1 ] || asSorting[0];
					}
					else {
						nextSort = asSorting[0];
					}
		
					label = sTitle + ( nextSort === "asc" ?
						oAria.sSortAscending :
						oAria.sSortDescending
					);
				}
				else {
					label = sTitle;
				}
		
				th.setAttribute('aria-label', label);
			}
		}
		
		
		/**
		 * Function to run on user sort request
		 *  @param {object} settings dataTables settings object
		 *  @param {node} attachTo node to attach the handler to
		 *  @param {int} colIdx column sorting index
		 *  @param {boolean} [append=false] Append the requested sort to the existing
		 *    sort if true (i.e. multi-column sort)
		 *  @param {function} [callback] callback function
		 *  @memberof DataTable#oApi
		 */
		function _fnSortListener ( settings, colIdx, append, callback )
		{
			var col = settings.aoColumns[ colIdx ];
			var sorting = settings.aaSorting;
			var asSorting = col.asSorting;
			var nextSortIdx;
			var next = function ( a, overflow ) {
				var idx = a._idx;
				if ( idx === undefined ) {
					idx = $.inArray( a[1], asSorting );
				}
		
				return idx+1 < asSorting.length ?
					idx+1 :
					overflow ?
						null :
						0;
			};
		
			// Convert to 2D array if needed
			if ( typeof sorting[0] === 'number' ) {
				sorting = settings.aaSorting = [ sorting ];
			}
		
			// If appending the sort then we are multi-column sorting
			if ( append && settings.oFeatures.bSortMulti ) {
				// Are we already doing some kind of sort on this column?
				var sortIdx = $.inArray( colIdx, _pluck(sorting, '0') );
		
				if ( sortIdx !== -1 ) {
					// Yes, modify the sort
					nextSortIdx = next( sorting[sortIdx], true );
		
					if ( nextSortIdx === null && sorting.length === 1 ) {
						nextSortIdx = 0; // can't remove sorting completely
					}
		
					if ( nextSortIdx === null ) {
						sorting.splice( sortIdx, 1 );
					}
					else {
						sorting[sortIdx][1] = asSorting[ nextSortIdx ];
						sorting[sortIdx]._idx = nextSortIdx;
					}
				}
				else {
					// No sort on this column yet
					sorting.push( [ colIdx, asSorting[0], 0 ] );
					sorting[sorting.length-1]._idx = 0;
				}
			}
			else if ( sorting.length && sorting[0][0] == colIdx ) {
				// Single column - already sorting on this column, modify the sort
				nextSortIdx = next( sorting[0] );
		
				sorting.length = 1;
				sorting[0][1] = asSorting[ nextSortIdx ];
				sorting[0]._idx = nextSortIdx;
			}
			else {
				// Single column - sort only on this column
				sorting.length = 0;
				sorting.push( [ colIdx, asSorting[0] ] );
				sorting[0]._idx = 0;
			}
		
			// Run the sort by calling a full redraw
			_fnReDraw( settings );
		
			// callback used for async user interaction
			if ( typeof callback == 'function' ) {
				callback( settings );
			}
		}
		
		
		/**
		 * Attach a sort handler (click) to a node
		 *  @param {object} settings dataTables settings object
		 *  @param {node} attachTo node to attach the handler to
		 *  @param {int} colIdx column sorting index
		 *  @param {function} [callback] callback function
		 *  @memberof DataTable#oApi
		 */
		function _fnSortAttachListener ( settings, attachTo, colIdx, callback )
		{
			var col = settings.aoColumns[ colIdx ];
		
			_fnBindAction( attachTo, {}, function (e) {
				/* If the column is not sortable - don't to anything */
				if ( col.bSortable === false ) {
					return;
				}
		
				// If processing is enabled use a timeout to allow the processing
				// display to be shown - otherwise to it synchronously
				if ( settings.oFeatures.bProcessing ) {
					_fnProcessingDisplay( settings, true );
		
					setTimeout( function() {
						_fnSortListener( settings, colIdx, e.shiftKey, callback );
		
						// In server-side processing, the draw callback will remove the
						// processing display
						if ( _fnDataSource( settings ) !== 'ssp' ) {
							_fnProcessingDisplay( settings, false );
						}
					}, 0 );
				}
				else {
					_fnSortListener( settings, colIdx, e.shiftKey, callback );
				}
			} );
		}
		
		
		/**
		 * Set the sorting classes on table's body, Note: it is safe to call this function
		 * when bSort and bSortClasses are false
		 *  @param {object} oSettings dataTables settings object
		 *  @memberof DataTable#oApi
		 */
		function _fnSortingClasses( settings )
		{
			var oldSort = settings.aLastSort;
			var sortClass = settings.oClasses.sSortColumn;
			var sort = _fnSortFlatten( settings );
			var features = settings.oFeatures;
			var i, ien, colIdx;
		
			if ( features.bSort && features.bSortClasses ) {
				// Remove old sorting classes
				for ( i=0, ien=oldSort.length ; i<ien ; i++ ) {
					colIdx = oldSort[i].src;
		
					// Remove column sorting
					$( _pluck( settings.aoData, 'anCells', colIdx ) )
						.removeClass( sortClass + (i<2 ? i+1 : 3) );
				}
		
				// Add new column sorting
				for ( i=0, ien=sort.length ; i<ien ; i++ ) {
					colIdx = sort[i].src;
		
					$( _pluck( settings.aoData, 'anCells', colIdx ) )
						.addClass( sortClass + (i<2 ? i+1 : 3) );
				}
			}
		
			settings.aLastSort = sort;
		}
		
		
		// Get the data to sort a column, be it from cache, fresh (populating the
		// cache), or from a sort formatter
		function _fnSortData( settings, idx )
		{
			// Custom sorting function - provided by the sort data type
			var column = settings.aoColumns[ idx ];
			var customSort = DataTable.ext.order[ column.sSortDataType ];
			var customData;
		
			if ( customSort ) {
				customData = customSort.call( settings.oInstance, settings, idx,
					_fnColumnIndexToVisible( settings, idx )
				);
			}
		
			// Use / populate cache
			var row, cellData;
			var formatter = DataTable.ext.type.order[ column.sType+"-pre" ];
		
			for ( var i=0, ien=settings.aoData.length ; i<ien ; i++ ) {
				row = settings.aoData[i];
		
				if ( ! row._aSortData ) {
					row._aSortData = [];
				}
		
				if ( ! row._aSortData[idx] || customSort ) {
					cellData = customSort ?
						customData[i] : // If there was a custom sort function, use data from there
						_fnGetCellData( settings, i, idx, 'sort' );
		
					row._aSortData[ idx ] = formatter ?
						formatter( cellData ) :
						cellData;
				}
			}
		}
		
		
		
		/**
		 * Save the state of a table
		 *  @param {object} oSettings dataTables settings object
		 *  @memberof DataTable#oApi
		 */
		function _fnSaveState ( settings )
		{
			if ( !settings.oFeatures.bStateSave || settings.bDestroying )
			{
				return;
			}
		
			/* Store the interesting variables */
			var state = {
				time:    +new Date(),
				start:   settings._iDisplayStart,
				length:  settings._iDisplayLength,
				order:   $.extend( true, [], settings.aaSorting ),
				search:  _fnSearchToCamel( settings.oPreviousSearch ),
				columns: $.map( settings.aoColumns, function ( col, i ) {
					return {
						visible: col.bVisible,
						search: _fnSearchToCamel( settings.aoPreSearchCols[i] )
					};
				} )
			};
		
			_fnCallbackFire( settings, "aoStateSaveParams", 'stateSaveParams', [settings, state] );
		
			settings.oSavedState = state;
			settings.fnStateSaveCallback.call( settings.oInstance, settings, state );
		}
		
		
		/**
		 * Attempt to load a saved table state
		 *  @param {object} oSettings dataTables settings object
		 *  @param {object} oInit DataTables init object so we can override settings
		 *  @memberof DataTable#oApi
		 */
		function _fnLoadState ( settings, oInit )
		{
			var i, ien;
			var columns = settings.aoColumns;
		
			if ( ! settings.oFeatures.bStateSave ) {
				return;
			}
		
			var state = settings.fnStateLoadCallback.call( settings.oInstance, settings );
			if ( ! state || ! state.time ) {
				return;
			}
		
			/* Allow custom and plug-in manipulation functions to alter the saved data set and
			 * cancelling of loading by returning false
			 */
			var abStateLoad = _fnCallbackFire( settings, 'aoStateLoadParams', 'stateLoadParams', [settings, state] );
			if ( $.inArray( false, abStateLoad ) !== -1 ) {
				return;
			}
		
			/* Reject old data */
			var duration = settings.iStateDuration;
			if ( duration > 0 && state.time < +new Date() - (duration*1000) ) {
				return;
			}
		
			// Number of columns have changed - all bets are off, no restore of settings
			if ( columns.length !== state.columns.length ) {
				return;
			}
		
			// Store the saved state so it might be accessed at any time
			settings.oLoadedState = $.extend( true, {}, state );
		
			// Restore key features - todo - for 1.11 this needs to be done by
			// subscribed events
			if ( state.start !== undefined ) {
				settings._iDisplayStart    = state.start;
				settings.iInitDisplayStart = state.start;
			}
			if ( state.length !== undefined ) {
				settings._iDisplayLength   = state.length;
			}
		
			// Order
			if ( state.order !== undefined ) {
				settings.aaSorting = [];
				$.each( state.order, function ( i, col ) {
					settings.aaSorting.push( col[0] >= columns.length ?
						[ 0, col[1] ] :
						col
					);
				} );
			}
		
			// Search
			if ( state.search !== undefined ) {
				$.extend( settings.oPreviousSearch, _fnSearchToHung( state.search ) );
			}
		
			// Columns
			for ( i=0, ien=state.columns.length ; i<ien ; i++ ) {
				var col = state.columns[i];
		
				// Visibility
				if ( col.visible !== undefined ) {
					columns[i].bVisible = col.visible;
				}
		
				// Search
				if ( col.search !== undefined ) {
					$.extend( settings.aoPreSearchCols[i], _fnSearchToHung( col.search ) );
				}
			}
		
			_fnCallbackFire( settings, 'aoStateLoaded', 'stateLoaded', [settings, state] );
		}
		
		
		/**
		 * Return the settings object for a particular table
		 *  @param {node} table table we are using as a dataTable
		 *  @returns {object} Settings object - or null if not found
		 *  @memberof DataTable#oApi
		 */
		function _fnSettingsFromNode ( table )
		{
			var settings = DataTable.settings;
			var idx = $.inArray( table, _pluck( settings, 'nTable' ) );
		
			return idx !== -1 ?
				settings[ idx ] :
				null;
		}
		
		
		/**
		 * Log an error message
		 *  @param {object} settings dataTables settings object
		 *  @param {int} level log error messages, or display them to the user
		 *  @param {string} msg error message
		 *  @param {int} tn Technical note id to get more information about the error.
		 *  @memberof DataTable#oApi
		 */
		function _fnLog( settings, level, msg, tn )
		{
			msg = 'DataTables warning: '+
				(settings ? 'table id='+settings.sTableId+' - ' : '')+msg;
		
			if ( tn ) {
				msg += '. For more information about this error, please see '+
				'http://datatables.net/tn/'+tn;
			}
		
			if ( ! level  ) {
				// Backwards compatibility pre 1.10
				var ext = DataTable.ext;
				var type = ext.sErrMode || ext.errMode;
		
				if ( settings ) {
					_fnCallbackFire( settings, null, 'error', [ settings, tn, msg ] );
				}
		
				if ( type == 'alert' ) {
					alert( msg );
				}
				else if ( type == 'throw' ) {
					throw new Error(msg);
				}
				else if ( typeof type == 'function' ) {
					type( settings, tn, msg );
				}
			}
			else if ( window.console && console.log ) {
				console.log( msg );
			}
		}
		
		
		/**
		 * See if a property is defined on one object, if so assign it to the other object
		 *  @param {object} ret target object
		 *  @param {object} src source object
		 *  @param {string} name property
		 *  @param {string} [mappedName] name to map too - optional, name used if not given
		 *  @memberof DataTable#oApi
		 */
		function _fnMap( ret, src, name, mappedName )
		{
			if ( $.isArray( name ) ) {
				$.each( name, function (i, val) {
					if ( $.isArray( val ) ) {
						_fnMap( ret, src, val[0], val[1] );
					}
					else {
						_fnMap( ret, src, val );
					}
				} );
		
				return;
			}
		
			if ( mappedName === undefined ) {
				mappedName = name;
			}
		
			if ( src[name] !== undefined ) {
				ret[mappedName] = src[name];
			}
		}
		
		
		/**
		 * Extend objects - very similar to jQuery.extend, but deep copy objects, and
		 * shallow copy arrays. The reason we need to do this, is that we don't want to
		 * deep copy array init values (such as aaSorting) since the dev wouldn't be
		 * able to override them, but we do want to deep copy arrays.
		 *  @param {object} out Object to extend
		 *  @param {object} extender Object from which the properties will be applied to
		 *      out
		 *  @param {boolean} breakRefs If true, then arrays will be sliced to take an
		 *      independent copy with the exception of the `data` or `aaData` parameters
		 *      if they are present. This is so you can pass in a collection to
		 *      DataTables and have that used as your data source without breaking the
		 *      references
		 *  @returns {object} out Reference, just for convenience - out === the return.
		 *  @memberof DataTable#oApi
		 *  @todo This doesn't take account of arrays inside the deep copied objects.
		 */
		function _fnExtend( out, extender, breakRefs )
		{
			var val;
		
			for ( var prop in extender ) {
				if ( extender.hasOwnProperty(prop) ) {
					val = extender[prop];
		
					if ( $.isPlainObject( val ) ) {
						if ( ! $.isPlainObject( out[prop] ) ) {
							out[prop] = {};
						}
						$.extend( true, out[prop], val );
					}
					else if ( breakRefs && prop !== 'data' && prop !== 'aaData' && $.isArray(val) ) {
						out[prop] = val.slice();
					}
					else {
						out[prop] = val;
					}
				}
			}
		
			return out;
		}
		
		
		/**
		 * Bind an event handers to allow a click or return key to activate the callback.
		 * This is good for accessibility since a return on the keyboard will have the
		 * same effect as a click, if the element has focus.
		 *  @param {element} n Element to bind the action to
		 *  @param {object} oData Data object to pass to the triggered function
		 *  @param {function} fn Callback function for when the event is triggered
		 *  @memberof DataTable#oApi
		 */
		function _fnBindAction( n, oData, fn )
		{
			$(n)
				.bind( 'click.DT', oData, function (e) {
						n.blur(); // Remove focus outline for mouse users
						fn(e);
					} )
				.bind( 'keypress.DT', oData, function (e){
						if ( e.which === 13 ) {
							e.preventDefault();
							fn(e);
						}
					} )
				.bind( 'selectstart.DT', function () {
						/* Take the brutal approach to cancelling text selection */
						return false;
					} );
		}
		
		
		/**
		 * Register a callback function. Easily allows a callback function to be added to
		 * an array store of callback functions that can then all be called together.
		 *  @param {object} oSettings dataTables settings object
		 *  @param {string} sStore Name of the array storage for the callbacks in oSettings
		 *  @param {function} fn Function to be called back
		 *  @param {string} sName Identifying name for the callback (i.e. a label)
		 *  @memberof DataTable#oApi
		 */
		function _fnCallbackReg( oSettings, sStore, fn, sName )
		{
			if ( fn )
			{
				oSettings[sStore].push( {
					"fn": fn,
					"sName": sName
				} );
			}
		}
		
		
		/**
		 * Fire callback functions and trigger events. Note that the loop over the
		 * callback array store is done backwards! Further note that you do not want to
		 * fire off triggers in time sensitive applications (for example cell creation)
		 * as its slow.
		 *  @param {object} settings dataTables settings object
		 *  @param {string} callbackArr Name of the array storage for the callbacks in
		 *      oSettings
		 *  @param {string} eventName Name of the jQuery custom event to trigger. If
		 *      null no trigger is fired
		 *  @param {array} args Array of arguments to pass to the callback function /
		 *      trigger
		 *  @memberof DataTable#oApi
		 */
		function _fnCallbackFire( settings, callbackArr, eventName, args )
		{
			var ret = [];
		
			if ( callbackArr ) {
				ret = $.map( settings[callbackArr].slice().reverse(), function (val, i) {
					return val.fn.apply( settings.oInstance, args );
				} );
			}
		
			if ( eventName !== null ) {
				var e = $.Event( eventName+'.dt' );
		
				$(settings.nTable).trigger( e, args );
		
				ret.push( e.result );
			}
		
			return ret;
		}
		
		
		function _fnLengthOverflow ( settings )
		{
			var
				start = settings._iDisplayStart,
				end = settings.fnDisplayEnd(),
				len = settings._iDisplayLength;
		
			/* If we have space to show extra rows (backing up from the end point - then do so */
			if ( start >= end )
			{
				start = end - len;
			}
		
			// Keep the start record on the current page
			start -= (start % len);
		
			if ( len === -1 || start < 0 )
			{
				start = 0;
			}
		
			settings._iDisplayStart = start;
		}
		
		
		function _fnRenderer( settings, type )
		{
			var renderer = settings.renderer;
			var host = DataTable.ext.renderer[type];
		
			if ( $.isPlainObject( renderer ) && renderer[type] ) {
				// Specific renderer for this type. If available use it, otherwise use
				// the default.
				return host[renderer[type]] || host._;
			}
			else if ( typeof renderer === 'string' ) {
				// Common renderer - if there is one available for this type use it,
				// otherwise use the default
				return host[renderer] || host._;
			}
		
			// Use the default
			return host._;
		}
		
		
		/**
		 * Detect the data source being used for the table. Used to simplify the code
		 * a little (ajax) and to make it compress a little smaller.
		 *
		 *  @param {object} settings dataTables settings object
		 *  @returns {string} Data source
		 *  @memberof DataTable#oApi
		 */
		function _fnDataSource ( settings )
		{
			if ( settings.oFeatures.bServerSide ) {
				return 'ssp';
			}
			else if ( settings.ajax || settings.sAjaxSource ) {
				return 'ajax';
			}
			return 'dom';
		}
		
	
		
		
		/**
		 * Computed structure of the DataTables API, defined by the options passed to
		 * `DataTable.Api.register()` when building the API.
		 *
		 * The structure is built in order to speed creation and extension of the Api
		 * objects since the extensions are effectively pre-parsed.
		 *
		 * The array is an array of objects with the following structure, where this
		 * base array represents the Api prototype base:
		 *
		 *     [
		 *       {
		 *         name:      'data'                -- string   - Property name
		 *         val:       function () {},       -- function - Api method (or undefined if just an object
		 *         methodExt: [ ... ],              -- array    - Array of Api object definitions to extend the method result
		 *         propExt:   [ ... ]               -- array    - Array of Api object definitions to extend the property
		 *       },
		 *       {
		 *         name:     'row'
		 *         val:       {},
		 *         methodExt: [ ... ],
		 *         propExt:   [
		 *           {
		 *             name:      'data'
		 *             val:       function () {},
		 *             methodExt: [ ... ],
		 *             propExt:   [ ... ]
		 *           },
		 *           ...
		 *         ]
		 *       }
		 *     ]
		 *
		 * @type {Array}
		 * @ignore
		 */
		var __apiStruct = [];
		
		
		/**
		 * `Array.prototype` reference.
		 *
		 * @type object
		 * @ignore
		 */
		var __arrayProto = Array.prototype;
		
		
		/**
		 * Abstraction for `context` parameter of the `Api` constructor to allow it to
		 * take several different forms for ease of use.
		 *
		 * Each of the input parameter types will be converted to a DataTables settings
		 * object where possible.
		 *
		 * @param  {string|node|jQuery|object} mixed DataTable identifier. Can be one
		 *   of:
		 *
		 *   * `string` - jQuery selector. Any DataTables' matching the given selector
		 *     with be found and used.
		 *   * `node` - `TABLE` node which has already been formed into a DataTable.
		 *   * `jQuery` - A jQuery object of `TABLE` nodes.
		 *   * `object` - DataTables settings object
		 *   * `DataTables.Api` - API instance
		 * @return {array|null} Matching DataTables settings objects. `null` or
		 *   `undefined` is returned if no matching DataTable is found.
		 * @ignore
		 */
		var _toSettings = function ( mixed )
		{
			var idx, jq;
			var settings = DataTable.settings;
			var tables = $.map( settings, function (el, i) {
				return el.nTable;
			} );
		
			if ( ! mixed ) {
				return [];
			}
			else if ( mixed.nTable && mixed.oApi ) {
				// DataTables settings object
				return [ mixed ];
			}
			else if ( mixed.nodeName && mixed.nodeName.toLowerCase() === 'table' ) {
				// Table node
				idx = $.inArray( mixed, tables );
				return idx !== -1 ? [ settings[idx] ] : null;
			}
			else if ( mixed && typeof mixed.settings === 'function' ) {
				return mixed.settings().toArray();
			}
			else if ( typeof mixed === 'string' ) {
				// jQuery selector
				jq = $(mixed);
			}
			else if ( mixed instanceof $ ) {
				// jQuery object (also DataTables instance)
				jq = mixed;
			}
		
			if ( jq ) {
				return jq.map( function(i) {
					idx = $.inArray( this, tables );
					return idx !== -1 ? settings[idx] : null;
				} ).toArray();
			}
		};
		
		
		/**
		 * DataTables API class - used to control and interface with  one or more
		 * DataTables enhanced tables.
		 *
		 * The API class is heavily based on jQuery, presenting a chainable interface
		 * that you can use to interact with tables. Each instance of the API class has
		 * a "context" - i.e. the tables that it will operate on. This could be a single
		 * table, all tables on a page or a sub-set thereof.
		 *
		 * Additionally the API is designed to allow you to easily work with the data in
		 * the tables, retrieving and manipulating it as required. This is done by
		 * presenting the API class as an array like interface. The contents of the
		 * array depend upon the actions requested by each method (for example
		 * `rows().nodes()` will return an array of nodes, while `rows().data()` will
		 * return an array of objects or arrays depending upon your table's
		 * configuration). The API object has a number of array like methods (`push`,
		 * `pop`, `reverse` etc) as well as additional helper methods (`each`, `pluck`,
		 * `unique` etc) to assist your working with the data held in a table.
		 *
		 * Most methods (those which return an Api instance) are chainable, which means
		 * the return from a method call also has all of the methods available that the
		 * top level object had. For example, these two calls are equivalent:
		 *
		 *     // Not chained
		 *     api.row.add( {...} );
		 *     api.draw();
		 *
		 *     // Chained
		 *     api.row.add( {...} ).draw();
		 *
		 * @class DataTable.Api
		 * @param {array|object|string|jQuery} context DataTable identifier. This is
		 *   used to define which DataTables enhanced tables this API will operate on.
		 *   Can be one of:
		 *
		 *   * `string` - jQuery selector. Any DataTables' matching the given selector
		 *     with be found and used.
		 *   * `node` - `TABLE` node which has already been formed into a DataTable.
		 *   * `jQuery` - A jQuery object of `TABLE` nodes.
		 *   * `object` - DataTables settings object
		 * @param {array} [data] Data to initialise the Api instance with.
		 *
		 * @example
		 *   // Direct initialisation during DataTables construction
		 *   var api = $('#example').DataTable();
		 *
		 * @example
		 *   // Initialisation using a DataTables jQuery object
		 *   var api = $('#example').dataTable().api();
		 *
		 * @example
		 *   // Initialisation as a constructor
		 *   var api = new $.fn.DataTable.Api( 'table.dataTable' );
		 */
		_Api = function ( context, data )
		{
			if ( ! (this instanceof _Api) ) {
				return new _Api( context, data );
			}
		
			var settings = [];
			var ctxSettings = function ( o ) {
				var a = _toSettings( o );
				if ( a ) {
					settings = settings.concat( a );
				}
			};
		
			if ( $.isArray( context ) ) {
				for ( var i=0, ien=context.length ; i<ien ; i++ ) {
					ctxSettings( context[i] );
				}
			}
			else {
				ctxSettings( context );
			}
		
			// Remove duplicates
			this.context = _unique( settings );
		
			// Initial data
			if ( data ) {
				$.merge( this, data );
			}
		
			// selector
			this.selector = {
				rows: null,
				cols: null,
				opts: null
			};
		
			_Api.extend( this, this, __apiStruct );
		};
		
		DataTable.Api = _Api;
		
		// Don't destroy the existing prototype, just extend it. Required for jQuery 2's
		// isPlainObject.
		$.extend( _Api.prototype, {
			any: function ()
			{
				return this.count() !== 0;
			},
		
		
			concat:  __arrayProto.concat,
		
		
			context: [], // array of table settings objects
		
		
			count: function ()
			{
				return this.flatten().length;
			},
		
		
			each: function ( fn )
			{
				for ( var i=0, ien=this.length ; i<ien; i++ ) {
					fn.call( this, this[i], i, this );
				}
		
				return this;
			},
		
		
			eq: function ( idx )
			{
				var ctx = this.context;
		
				return ctx.length > idx ?
					new _Api( ctx[idx], this[idx] ) :
					null;
			},
		
		
			filter: function ( fn )
			{
				var a = [];
		
				if ( __arrayProto.filter ) {
					a = __arrayProto.filter.call( this, fn, this );
				}
				else {
					// Compatibility for browsers without EMCA-252-5 (JS 1.6)
					for ( var i=0, ien=this.length ; i<ien ; i++ ) {
						if ( fn.call( this, this[i], i, this ) ) {
							a.push( this[i] );
						}
					}
				}
		
				return new _Api( this.context, a );
			},
		
		
			flatten: function ()
			{
				var a = [];
				return new _Api( this.context, a.concat.apply( a, this.toArray() ) );
			},
		
		
			join:    __arrayProto.join,
		
		
			indexOf: __arrayProto.indexOf || function (obj, start)
			{
				for ( var i=(start || 0), ien=this.length ; i<ien ; i++ ) {
					if ( this[i] === obj ) {
						return i;
					}
				}
				return -1;
			},
		
			iterator: function ( flatten, type, fn, alwaysNew ) {
				var
					a = [], ret,
					i, ien, j, jen,
					context = this.context,
					rows, items, item,
					selector = this.selector;
		
				// Argument shifting
				if ( typeof flatten === 'string' ) {
					alwaysNew = fn;
					fn = type;
					type = flatten;
					flatten = false;
				}
		
				for ( i=0, ien=context.length ; i<ien ; i++ ) {
					var apiInst = new _Api( context[i] );
		
					if ( type === 'table' ) {
						ret = fn.call( apiInst, context[i], i );
		
						if ( ret !== undefined ) {
							a.push( ret );
						}
					}
					else if ( type === 'columns' || type === 'rows' ) {
						// this has same length as context - one entry for each table
						ret = fn.call( apiInst, context[i], this[i], i );
		
						if ( ret !== undefined ) {
							a.push( ret );
						}
					}
					else if ( type === 'column' || type === 'column-rows' || type === 'row' || type === 'cell' ) {
						// columns and rows share the same structure.
						// 'this' is an array of column indexes for each context
						items = this[i];
		
						if ( type === 'column-rows' ) {
							rows = _selector_row_indexes( context[i], selector.opts );
						}
		
						for ( j=0, jen=items.length ; j<jen ; j++ ) {
							item = items[j];
		
							if ( type === 'cell' ) {
								ret = fn.call( apiInst, context[i], item.row, item.column, i, j );
							}
							else {
								ret = fn.call( apiInst, context[i], item, i, j, rows );
							}
		
							if ( ret !== undefined ) {
								a.push( ret );
							}
						}
					}
				}
		
				if ( a.length || alwaysNew ) {
					var api = new _Api( context, flatten ? a.concat.apply( [], a ) : a );
					var apiSelector = api.selector;
					apiSelector.rows = selector.rows;
					apiSelector.cols = selector.cols;
					apiSelector.opts = selector.opts;
					return api;
				}
				return this;
			},
		
		
			lastIndexOf: __arrayProto.lastIndexOf || function (obj, start)
			{
				// Bit cheeky...
				return this.indexOf.apply( this.toArray.reverse(), arguments );
			},
		
		
			length:  0,
		
		
			map: function ( fn )
			{
				var a = [];
		
				if ( __arrayProto.map ) {
					a = __arrayProto.map.call( this, fn, this );
				}
				else {
					// Compatibility for browsers without EMCA-252-5 (JS 1.6)
					for ( var i=0, ien=this.length ; i<ien ; i++ ) {
						a.push( fn.call( this, this[i], i ) );
					}
				}
		
				return new _Api( this.context, a );
			},
		
		
			pluck: function ( prop )
			{
				return this.map( function ( el ) {
					return el[ prop ];
				} );
			},
		
			pop:     __arrayProto.pop,
		
		
			push:    __arrayProto.push,
		
		
			// Does not return an API instance
			reduce: __arrayProto.reduce || function ( fn, init )
			{
				return _fnReduce( this, fn, init, 0, this.length, 1 );
			},
		
		
			reduceRight: __arrayProto.reduceRight || function ( fn, init )
			{
				return _fnReduce( this, fn, init, this.length-1, -1, -1 );
			},
		
		
			reverse: __arrayProto.reverse,
		
		
			// Object with rows, columns and opts
			selector: null,
		
		
			shift:   __arrayProto.shift,
		
		
			sort:    __arrayProto.sort, // ? name - order?
		
		
			splice:  __arrayProto.splice,
		
		
			toArray: function ()
			{
				return __arrayProto.slice.call( this );
			},
		
		
			to$: function ()
			{
				return $( this );
			},
		
		
			toJQuery: function ()
			{
				return $( this );
			},
		
		
			unique: function ()
			{
				return new _Api( this.context, _unique(this) );
			},
		
		
			unshift: __arrayProto.unshift
		} );
		
		
		_Api.extend = function ( scope, obj, ext )
		{
			// Only extend API instances and static properties of the API
			if ( ! ext.length || ! obj || ( ! (obj instanceof _Api) && ! obj.__dt_wrapper ) ) {
				return;
			}
		
			var
				i, ien,
				j, jen,
				struct, inner,
				methodScoping = function ( scope, fn, struc ) {
					return function () {
						var ret = fn.apply( scope, arguments );
		
						// Method extension
						_Api.extend( ret, ret, struc.methodExt );
						return ret;
					};
				};
		
			for ( i=0, ien=ext.length ; i<ien ; i++ ) {
				struct = ext[i];
		
				// Value
				obj[ struct.name ] = typeof struct.val === 'function' ?
					methodScoping( scope, struct.val, struct ) :
					$.isPlainObject( struct.val ) ?
						{} :
						struct.val;
		
				obj[ struct.name ].__dt_wrapper = true;
		
				// Property extension
				_Api.extend( scope, obj[ struct.name ], struct.propExt );
			}
		};
		
		
		// @todo - Is there need for an augment function?
		// _Api.augment = function ( inst, name )
		// {
		// 	// Find src object in the structure from the name
		// 	var parts = name.split('.');
		
		// 	_Api.extend( inst, obj );
		// };
		
		
		//     [
		//       {
		//         name:      'data'                -- string   - Property name
		//         val:       function () {},       -- function - Api method (or undefined if just an object
		//         methodExt: [ ... ],              -- array    - Array of Api object definitions to extend the method result
		//         propExt:   [ ... ]               -- array    - Array of Api object definitions to extend the property
		//       },
		//       {
		//         name:     'row'
		//         val:       {},
		//         methodExt: [ ... ],
		//         propExt:   [
		//           {
		//             name:      'data'
		//             val:       function () {},
		//             methodExt: [ ... ],
		//             propExt:   [ ... ]
		//           },
		//           ...
		//         ]
		//       }
		//     ]
		
		_Api.register = _api_register = function ( name, val )
		{
			if ( $.isArray( name ) ) {
				for ( var j=0, jen=name.length ; j<jen ; j++ ) {
					_Api.register( name[j], val );
				}
				return;
			}
		
			var
				i, ien,
				heir = name.split('.'),
				struct = __apiStruct,
				key, method;
		
			var find = function ( src, name ) {
				for ( var i=0, ien=src.length ; i<ien ; i++ ) {
					if ( src[i].name === name ) {
						return src[i];
					}
				}
				return null;
			};
		
			for ( i=0, ien=heir.length ; i<ien ; i++ ) {
				method = heir[i].indexOf('()') !== -1;
				key = method ?
					heir[i].replace('()', '') :
					heir[i];
		
				var src = find( struct, key );
				if ( ! src ) {
					src = {
						name:      key,
						val:       {},
						methodExt: [],
						propExt:   []
					};
					struct.push( src );
				}
		
				if ( i === ien-1 ) {
					src.val = val;
				}
				else {
					struct = method ?
						src.methodExt :
						src.propExt;
				}
			}
		};
		
		
		_Api.registerPlural = _api_registerPlural = function ( pluralName, singularName, val ) {
			_Api.register( pluralName, val );
		
			_Api.register( singularName, function () {
				var ret = val.apply( this, arguments );
		
				if ( ret === this ) {
					// Returned item is the API instance that was passed in, return it
					return this;
				}
				else if ( ret instanceof _Api ) {
					// New API instance returned, want the value from the first item
					// in the returned array for the singular result.
					return ret.length ?
						$.isArray( ret[0] ) ?
							new _Api( ret.context, ret[0] ) : // Array results are 'enhanced'
							ret[0] :
						undefined;
				}
		
				// Non-API return - just fire it back
				return ret;
			} );
		};
		
		
		/**
		 * Selector for HTML tables. Apply the given selector to the give array of
		 * DataTables settings objects.
		 *
		 * @param {string|integer} [selector] jQuery selector string or integer
		 * @param  {array} Array of DataTables settings objects to be filtered
		 * @return {array}
		 * @ignore
		 */
		var __table_selector = function ( selector, a )
		{
			// Integer is used to pick out a table by index
			if ( typeof selector === 'number' ) {
				return [ a[ selector ] ];
			}
		
			// Perform a jQuery selector on the table nodes
			var nodes = $.map( a, function (el, i) {
				return el.nTable;
			} );
		
			return $(nodes)
				.filter( selector )
				.map( function (i) {
					// Need to translate back from the table node to the settings
					var idx = $.inArray( this, nodes );
					return a[ idx ];
				} )
				.toArray();
		};
		
		
		
		/**
		 * Context selector for the API's context (i.e. the tables the API instance
		 * refers to.
		 *
		 * @name    DataTable.Api#tables
		 * @param {string|integer} [selector] Selector to pick which tables the iterator
		 *   should operate on. If not given, all tables in the current context are
		 *   used. This can be given as a jQuery selector (for example `':gt(0)'`) to
		 *   select multiple tables or as an integer to select a single table.
		 * @returns {DataTable.Api} Returns a new API instance if a selector is given.
		 */
		_api_register( 'tables()', function ( selector ) {
			// A new instance is created if there was a selector specified
			return selector ?
				new _Api( __table_selector( selector, this.context ) ) :
				this;
		} );
		
		
		_api_register( 'table()', function ( selector ) {
			var tables = this.tables( selector );
			var ctx = tables.context;
		
			// Truncate to the first matched table
			return ctx.length ?
				new _Api( ctx[0] ) :
				tables;
		} );
		
		
		_api_registerPlural( 'tables().nodes()', 'table().node()' , function () {
			return this.iterator( 'table', function ( ctx ) {
				return ctx.nTable;
			}, 1 );
		} );
		
		
		_api_registerPlural( 'tables().body()', 'table().body()' , function () {
			return this.iterator( 'table', function ( ctx ) {
				return ctx.nTBody;
			}, 1 );
		} );
		
		
		_api_registerPlural( 'tables().header()', 'table().header()' , function () {
			return this.iterator( 'table', function ( ctx ) {
				return ctx.nTHead;
			}, 1 );
		} );
		
		
		_api_registerPlural( 'tables().footer()', 'table().footer()' , function () {
			return this.iterator( 'table', function ( ctx ) {
				return ctx.nTFoot;
			}, 1 );
		} );
		
		
		_api_registerPlural( 'tables().containers()', 'table().container()' , function () {
			return this.iterator( 'table', function ( ctx ) {
				return ctx.nTableWrapper;
			}, 1 );
		} );
		
		
		
		/**
		 * Redraw the tables in the current context.
		 */
		_api_register( 'draw()', function ( paging ) {
			return this.iterator( 'table', function ( settings ) {
				if ( paging === 'page' ) {
					_fnDraw( settings );
				}
				else {
					if ( typeof paging === 'string' ) {
						paging = paging === 'full-hold' ?
							false :
							true;
					}
		
					_fnReDraw( settings, paging===false );
				}
			} );
		} );
		
		
		
		/**
		 * Get the current page index.
		 *
		 * @return {integer} Current page index (zero based)
		 *//**
		 * Set the current page.
		 *
		 * Note that if you attempt to show a page which does not exist, DataTables will
		 * not throw an error, but rather reset the paging.
		 *
		 * @param {integer|string} action The paging action to take. This can be one of:
		 *  * `integer` - The page index to jump to
		 *  * `string` - An action to take:
		 *    * `first` - Jump to first page.
		 *    * `next` - Jump to the next page
		 *    * `previous` - Jump to previous page
		 *    * `last` - Jump to the last page.
		 * @returns {DataTables.Api} this
		 */
		_api_register( 'page()', function ( action ) {
			if ( action === undefined ) {
				return this.page.info().page; // not an expensive call
			}
		
			// else, have an action to take on all tables
			return this.iterator( 'table', function ( settings ) {
				_fnPageChange( settings, action );
			} );
		} );
		
		
		/**
		 * Paging information for the first table in the current context.
		 *
		 * If you require paging information for another table, use the `table()` method
		 * with a suitable selector.
		 *
		 * @return {object} Object with the following properties set:
		 *  * `page` - Current page index (zero based - i.e. the first page is `0`)
		 *  * `pages` - Total number of pages
		 *  * `start` - Display index for the first record shown on the current page
		 *  * `end` - Display index for the last record shown on the current page
		 *  * `length` - Display length (number of records). Note that generally `start
		 *    + length = end`, but this is not always true, for example if there are
		 *    only 2 records to show on the final page, with a length of 10.
		 *  * `recordsTotal` - Full data set length
		 *  * `recordsDisplay` - Data set length once the current filtering criterion
		 *    are applied.
		 */
		_api_register( 'page.info()', function ( action ) {
			if ( this.context.length === 0 ) {
				return undefined;
			}
		
			var
				settings   = this.context[0],
				start      = settings._iDisplayStart,
				len        = settings.oFeatures.bPaginate ? settings._iDisplayLength : -1,
				visRecords = settings.fnRecordsDisplay(),
				all        = len === -1;
		
			return {
				"page":           all ? 0 : Math.floor( start / len ),
				"pages":          all ? 1 : Math.ceil( visRecords / len ),
				"start":          start,
				"end":            settings.fnDisplayEnd(),
				"length":         len,
				"recordsTotal":   settings.fnRecordsTotal(),
				"recordsDisplay": visRecords,
				"serverSide":     _fnDataSource( settings ) === 'ssp'
			};
		} );
		
		
		/**
		 * Get the current page length.
		 *
		 * @return {integer} Current page length. Note `-1` indicates that all records
		 *   are to be shown.
		 *//**
		 * Set the current page length.
		 *
		 * @param {integer} Page length to set. Use `-1` to show all records.
		 * @returns {DataTables.Api} this
		 */
		_api_register( 'page.len()', function ( len ) {
			// Note that we can't call this function 'length()' because `length`
			// is a Javascript property of functions which defines how many arguments
			// the function expects.
			if ( len === undefined ) {
				return this.context.length !== 0 ?
					this.context[0]._iDisplayLength :
					undefined;
			}
		
			// else, set the page length
			return this.iterator( 'table', function ( settings ) {
				_fnLengthChange( settings, len );
			} );
		} );
		
		
		
		var __reload = function ( settings, holdPosition, callback ) {
			// Use the draw event to trigger a callback
			if ( callback ) {
				var api = new _Api( settings );
		
				api.one( 'draw', function () {
					callback( api.ajax.json() );
				} );
			}
		
			if ( _fnDataSource( settings ) == 'ssp' ) {
				_fnReDraw( settings, holdPosition );
			}
			else {
				_fnProcessingDisplay( settings, true );
		
				// Cancel an existing request
				var xhr = settings.jqXHR;
				if ( xhr && xhr.readyState !== 4 ) {
					xhr.abort();
				}
		
				// Trigger xhr
				_fnBuildAjax( settings, [], function( json ) {
					_fnClearTable( settings );
		
					var data = _fnAjaxDataSrc( settings, json );
					for ( var i=0, ien=data.length ; i<ien ; i++ ) {
						_fnAddData( settings, data[i] );
					}
		
					_fnReDraw( settings, holdPosition );
					_fnProcessingDisplay( settings, false );
				} );
			}
		};
		
		
		/**
		 * Get the JSON response from the last Ajax request that DataTables made to the
		 * server. Note that this returns the JSON from the first table in the current
		 * context.
		 *
		 * @return {object} JSON received from the server.
		 */
		_api_register( 'ajax.json()', function () {
			var ctx = this.context;
		
			if ( ctx.length > 0 ) {
				return ctx[0].json;
			}
		
			// else return undefined;
		} );
		
		
		/**
		 * Get the data submitted in the last Ajax request
		 */
		_api_register( 'ajax.params()', function () {
			var ctx = this.context;
		
			if ( ctx.length > 0 ) {
				return ctx[0].oAjaxData;
			}
		
			// else return undefined;
		} );
		
		
		/**
		 * Reload tables from the Ajax data source. Note that this function will
		 * automatically re-draw the table when the remote data has been loaded.
		 *
		 * @param {boolean} [reset=true] Reset (default) or hold the current paging
		 *   position. A full re-sort and re-filter is performed when this method is
		 *   called, which is why the pagination reset is the default action.
		 * @returns {DataTables.Api} this
		 */
		_api_register( 'ajax.reload()', function ( callback, resetPaging ) {
			return this.iterator( 'table', function (settings) {
				__reload( settings, resetPaging===false, callback );
			} );
		} );
		
		
		/**
		 * Get the current Ajax URL. Note that this returns the URL from the first
		 * table in the current context.
		 *
		 * @return {string} Current Ajax source URL
		 *//**
		 * Set the Ajax URL. Note that this will set the URL for all tables in the
		 * current context.
		 *
		 * @param {string} url URL to set.
		 * @returns {DataTables.Api} this
		 */
		_api_register( 'ajax.url()', function ( url ) {
			var ctx = this.context;
		
			if ( url === undefined ) {
				// get
				if ( ctx.length === 0 ) {
					return undefined;
				}
				ctx = ctx[0];
		
				return ctx.ajax ?
					$.isPlainObject( ctx.ajax ) ?
						ctx.ajax.url :
						ctx.ajax :
					ctx.sAjaxSource;
			}
		
			// set
			return this.iterator( 'table', function ( settings ) {
				if ( $.isPlainObject( settings.ajax ) ) {
					settings.ajax.url = url;
				}
				else {
					settings.ajax = url;
				}
				// No need to consider sAjaxSource here since DataTables gives priority
				// to `ajax` over `sAjaxSource`. So setting `ajax` here, renders any
				// value of `sAjaxSource` redundant.
			} );
		} );
		
		
		/**
		 * Load data from the newly set Ajax URL. Note that this method is only
		 * available when `ajax.url()` is used to set a URL. Additionally, this method
		 * has the same effect as calling `ajax.reload()` but is provided for
		 * convenience when setting a new URL. Like `ajax.reload()` it will
		 * automatically redraw the table once the remote data has been loaded.
		 *
		 * @returns {DataTables.Api} this
		 */
		_api_register( 'ajax.url().load()', function ( callback, resetPaging ) {
			// Same as a reload, but makes sense to present it for easy access after a
			// url change
			return this.iterator( 'table', function ( ctx ) {
				__reload( ctx, resetPaging===false, callback );
			} );
		} );
		
		
		
		
		var _selector_run = function ( type, selector, selectFn, settings, opts )
		{
			var
				out = [], res,
				a, i, ien, j, jen,
				selectorType = typeof selector;
		
			// Can't just check for isArray here, as an API or jQuery instance might be
			// given with their array like look
			if ( ! selector || selectorType === 'string' || selectorType === 'function' || selector.length === undefined ) {
				selector = [ selector ];
			}
		
			for ( i=0, ien=selector.length ; i<ien ; i++ ) {
				a = selector[i] && selector[i].split ?
					selector[i].split(',') :
					[ selector[i] ];
		
				for ( j=0, jen=a.length ; j<jen ; j++ ) {
					res = selectFn( typeof a[j] === 'string' ? $.trim(a[j]) : a[j] );
		
					if ( res && res.length ) {
						out = out.concat( res );
					}
				}
			}
		
			// selector extensions
			var ext = _ext.selector[ type ];
			if ( ext.length ) {
				for ( i=0, ien=ext.length ; i<ien ; i++ ) {
					out = ext[i]( settings, opts, out );
				}
			}
		
			return _unique( out );
		};
		
		
		var _selector_opts = function ( opts )
		{
			if ( ! opts ) {
				opts = {};
			}
		
			// Backwards compatibility for 1.9- which used the terminology filter rather
			// than search
			if ( opts.filter && opts.search === undefined ) {
				opts.search = opts.filter;
			}
		
			return $.extend( {
				search: 'none',
				order: 'current',
				page: 'all'
			}, opts );
		};
		
		
		var _selector_first = function ( inst )
		{
			// Reduce the API instance to the first item found
			for ( var i=0, ien=inst.length ; i<ien ; i++ ) {
				if ( inst[i].length > 0 ) {
					// Assign the first element to the first item in the instance
					// and truncate the instance and context
					inst[0] = inst[i];
					inst[0].length = 1;
					inst.length = 1;
					inst.context = [ inst.context[i] ];
		
					return inst;
				}
			}
		
			// Not found - return an empty instance
			inst.length = 0;
			return inst;
		};
		
		
		var _selector_row_indexes = function ( settings, opts )
		{
			var
				i, ien, tmp, a=[],
				displayFiltered = settings.aiDisplay,
				displayMaster = settings.aiDisplayMaster;
		
			var
				search = opts.search,  // none, applied, removed
				order  = opts.order,   // applied, current, index (original - compatibility with 1.9)
				page   = opts.page;    // all, current
		
			if ( _fnDataSource( settings ) == 'ssp' ) {
				// In server-side processing mode, most options are irrelevant since
				// rows not shown don't exist and the index order is the applied order
				// Removed is a special case - for consistency just return an empty
				// array
				return search === 'removed' ?
					[] :
					_range( 0, displayMaster.length );
			}
			else if ( page == 'current' ) {
				// Current page implies that order=current and fitler=applied, since it is
				// fairly senseless otherwise, regardless of what order and search actually
				// are
				for ( i=settings._iDisplayStart, ien=settings.fnDisplayEnd() ; i<ien ; i++ ) {
					a.push( displayFiltered[i] );
				}
			}
			else if ( order == 'current' || order == 'applied' ) {
				a = search == 'none' ?
					displayMaster.slice() :                      // no search
					search == 'applied' ?
						displayFiltered.slice() :                // applied search
						$.map( displayMaster, function (el, i) { // removed search
							return $.inArray( el, displayFiltered ) === -1 ? el : null;
						} );
			}
			else if ( order == 'index' || order == 'original' ) {
				for ( i=0, ien=settings.aoData.length ; i<ien ; i++ ) {
					if ( search == 'none' ) {
						a.push( i );
					}
					else { // applied | removed
						tmp = $.inArray( i, displayFiltered );
		
						if ((tmp === -1 && search == 'removed') ||
							(tmp >= 0   && search == 'applied') )
						{
							a.push( i );
						}
					}
				}
			}
		
			return a;
		};
		
		
		/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
		 * Rows
		 *
		 * {}          - no selector - use all available rows
		 * {integer}   - row aoData index
		 * {node}      - TR node
		 * {string}    - jQuery selector to apply to the TR elements
		 * {array}     - jQuery array of nodes, or simply an array of TR nodes
		 *
		 */
		
		
		var __row_selector = function ( settings, selector, opts )
		{
			var run = function ( sel ) {
				var selInt = _intVal( sel );
				var i, ien;
		
				// Short cut - selector is a number and no options provided (default is
				// all records, so no need to check if the index is in there, since it
				// must be - dev error if the index doesn't exist).
				if ( selInt !== null && ! opts ) {
					return [ selInt ];
				}
		
				var rows = _selector_row_indexes( settings, opts );
		
				if ( selInt !== null && $.inArray( selInt, rows ) !== -1 ) {
					// Selector - integer
					return [ selInt ];
				}
				else if ( ! sel ) {
					// Selector - none
					return rows;
				}
		
				// Selector - function
				if ( typeof sel === 'function' ) {
					return $.map( rows, function (idx) {
						var row = settings.aoData[ idx ];
						return sel( idx, row._aData, row.nTr ) ? idx : null;
					} );
				}
		
				// Get nodes in the order from the `rows` array with null values removed
				var nodes = _removeEmpty(
					_pluck_order( settings.aoData, rows, 'nTr' )
				);
		
				// Selector - node
				if ( sel.nodeName ) {
					if ( sel._DT_RowIndex !== undefined ) {
						return [ sel._DT_RowIndex ]; // Property added by DT for fast lookup
					}
					else if ( sel._DT_CellIndex ) {
						return [ sel._DT_CellIndex.row ];
					}
					else {
						var host = $(sel).closest('*[data-dt-row]');
						return host.length ?
							[ host.data('dt-row') ] :
							[];
					}
				}
		
				// ID selector. Want to always be able to select rows by id, regardless
				// of if the tr element has been created or not, so can't rely upon
				// jQuery here - hence a custom implementation. This does not match
				// Sizzle's fast selector or HTML4 - in HTML5 the ID can be anything,
				// but to select it using a CSS selector engine (like Sizzle or
				// querySelect) it would need to need to be escaped for some characters.
				// DataTables simplifies this for row selectors since you can select
				// only a row. A # indicates an id any anything that follows is the id -
				// unescaped.
				if ( typeof sel === 'string' && sel.charAt(0) === '#' ) {
					// get row index from id
					var rowObj = settings.aIds[ sel.replace( /^#/, '' ) ];
					if ( rowObj !== undefined ) {
						return [ rowObj.idx ];
					}
		
					// need to fall through to jQuery in case there is DOM id that
					// matches
				}
		
				// Selector - jQuery selector string, array of nodes or jQuery object/
				// As jQuery's .filter() allows jQuery objects to be passed in filter,
				// it also allows arrays, so this will cope with all three options
				return $(nodes)
					.filter( sel )
					.map( function () {
						return this._DT_RowIndex;
					} )
					.toArray();
			};
		
			return _selector_run( 'row', selector, run, settings, opts );
		};
		
		
		_api_register( 'rows()', function ( selector, opts ) {
			// argument shifting
			if ( selector === undefined ) {
				selector = '';
			}
			else if ( $.isPlainObject( selector ) ) {
				opts = selector;
				selector = '';
			}
		
			opts = _selector_opts( opts );
		
			var inst = this.iterator( 'table', function ( settings ) {
				return __row_selector( settings, selector, opts );
			}, 1 );
		
			// Want argument shifting here and in __row_selector?
			inst.selector.rows = selector;
			inst.selector.opts = opts;
		
			return inst;
		} );
		
		_api_register( 'rows().nodes()', function () {
			return this.iterator( 'row', function ( settings, row ) {
				return settings.aoData[ row ].nTr || undefined;
			}, 1 );
		} );
		
		_api_register( 'rows().data()', function () {
			return this.iterator( true, 'rows', function ( settings, rows ) {
				return _pluck_order( settings.aoData, rows, '_aData' );
			}, 1 );
		} );
		
		_api_registerPlural( 'rows().cache()', 'row().cache()', function ( type ) {
			return this.iterator( 'row', function ( settings, row ) {
				var r = settings.aoData[ row ];
				return type === 'search' ? r._aFilterData : r._aSortData;
			}, 1 );
		} );
		
		_api_registerPlural( 'rows().invalidate()', 'row().invalidate()', function ( src ) {
			return this.iterator( 'row', function ( settings, row ) {
				_fnInvalidate( settings, row, src );
			} );
		} );
		
		_api_registerPlural( 'rows().indexes()', 'row().index()', function () {
			return this.iterator( 'row', function ( settings, row ) {
				return row;
			}, 1 );
		} );
		
		_api_registerPlural( 'rows().ids()', 'row().id()', function ( hash ) {
			var a = [];
			var context = this.context;
		
			// `iterator` will drop undefined values, but in this case we want them
			for ( var i=0, ien=context.length ; i<ien ; i++ ) {
				for ( var j=0, jen=this[i].length ; j<jen ; j++ ) {
					var id = context[i].rowIdFn( context[i].aoData[ this[i][j] ]._aData );
					a.push( (hash === true ? '#' : '' )+ id );
				}
			}
		
			return new _Api( context, a );
		} );
		
		_api_registerPlural( 'rows().remove()', 'row().remove()', function () {
			var that = this;
		
			this.iterator( 'row', function ( settings, row, thatIdx ) {
				var data = settings.aoData;
				var rowData = data[ row ];
				var i, ien, j, jen;
				var loopRow, loopCells;
		
				data.splice( row, 1 );
		
				// Update the cached indexes
				for ( i=0, ien=data.length ; i<ien ; i++ ) {
					loopRow = data[i];
					loopCells = loopRow.anCells;
		
					// Rows
					if ( loopRow.nTr !== null ) {
						loopRow.nTr._DT_RowIndex = i;
					}
		
					// Cells
					if ( loopCells !== null ) {
						for ( j=0, jen=loopCells.length ; j<jen ; j++ ) {
							loopCells[j]._DT_CellIndex.row = i;
						}
					}
				}
		
				// Delete from the display arrays
				_fnDeleteIndex( settings.aiDisplayMaster, row );
				_fnDeleteIndex( settings.aiDisplay, row );
				_fnDeleteIndex( that[ thatIdx ], row, false ); // maintain local indexes
		
				// Check for an 'overflow' they case for displaying the table
				_fnLengthOverflow( settings );
		
				// Remove the row's ID reference if there is one
				var id = settings.rowIdFn( rowData._aData );
				if ( id !== undefined ) {
					delete settings.aIds[ id ];
				}
			} );
		
			this.iterator( 'table', function ( settings ) {
				for ( var i=0, ien=settings.aoData.length ; i<ien ; i++ ) {
					settings.aoData[i].idx = i;
				}
			} );
		
			return this;
		} );
		
		
		_api_register( 'rows.add()', function ( rows ) {
			var newRows = this.iterator( 'table', function ( settings ) {
					var row, i, ien;
					var out = [];
		
					for ( i=0, ien=rows.length ; i<ien ; i++ ) {
						row = rows[i];
		
						if ( row.nodeName && row.nodeName.toUpperCase() === 'TR' ) {
							out.push( _fnAddTr( settings, row )[0] );
						}
						else {
							out.push( _fnAddData( settings, row ) );
						}
					}
		
					return out;
				}, 1 );
		
			// Return an Api.rows() extended instance, so rows().nodes() etc can be used
			var modRows = this.rows( -1 );
			modRows.pop();
			$.merge( modRows, newRows );
		
			return modRows;
		} );
		
		
		
		
		
		/**
		 *
		 */
		_api_register( 'row()', function ( selector, opts ) {
			return _selector_first( this.rows( selector, opts ) );
		} );
		
		
		_api_register( 'row().data()', function ( data ) {
			var ctx = this.context;
		
			if ( data === undefined ) {
				// Get
				return ctx.length && this.length ?
					ctx[0].aoData[ this[0] ]._aData :
					undefined;
			}
		
			// Set
			ctx[0].aoData[ this[0] ]._aData = data;
		
			// Automatically invalidate
			_fnInvalidate( ctx[0], this[0], 'data' );
		
			return this;
		} );
		
		
		_api_register( 'row().node()', function () {
			var ctx = this.context;
		
			return ctx.length && this.length ?
				ctx[0].aoData[ this[0] ].nTr || null :
				null;
		} );
		
		
		_api_register( 'row.add()', function ( row ) {
			// Allow a jQuery object to be passed in - only a single row is added from
			// it though - the first element in the set
			if ( row instanceof $ && row.length ) {
				row = row[0];
			}
		
			var rows = this.iterator( 'table', function ( settings ) {
				if ( row.nodeName && row.nodeName.toUpperCase() === 'TR' ) {
					return _fnAddTr( settings, row )[0];
				}
				return _fnAddData( settings, row );
			} );
		
			// Return an Api.rows() extended instance, with the newly added row selected
			return this.row( rows[0] );
		} );
		
		
		
		var __details_add = function ( ctx, row, data, klass )
		{
			// Convert to array of TR elements
			var rows = [];
			var addRow = function ( r, k ) {
				// Recursion to allow for arrays of jQuery objects
				if ( $.isArray( r ) || r instanceof $ ) {
					for ( var i=0, ien=r.length ; i<ien ; i++ ) {
						addRow( r[i], k );
					}
					return;
				}
		
				// If we get a TR element, then just add it directly - up to the dev
				// to add the correct number of columns etc
				if ( r.nodeName && r.nodeName.toLowerCase() === 'tr' ) {
					rows.push( r );
				}
				else {
					// Otherwise create a row with a wrapper
					var created = $('<tr><td/></tr>').addClass( k );
					$('td', created)
						.addClass( k )
						.html( r )
						[0].colSpan = _fnVisbleColumns( ctx );
		
					rows.push( created[0] );
				}
			};
		
			addRow( data, klass );
		
			if ( row._details ) {
				row._details.remove();
			}
		
			row._details = $(rows);
		
			// If the children were already shown, that state should be retained
			if ( row._detailsShow ) {
				row._details.insertAfter( row.nTr );
			}
		};
		
		
		var __details_remove = function ( api, idx )
		{
			var ctx = api.context;
		
			if ( ctx.length ) {
				var row = ctx[0].aoData[ idx !== undefined ? idx : api[0] ];
		
				if ( row && row._details ) {
					row._details.remove();
		
					row._detailsShow = undefined;
					row._details = undefined;
				}
			}
		};
		
		
		var __details_display = function ( api, show ) {
			var ctx = api.context;
		
			if ( ctx.length && api.length ) {
				var row = ctx[0].aoData[ api[0] ];
		
				if ( row._details ) {
					row._detailsShow = show;
		
					if ( show ) {
						row._details.insertAfter( row.nTr );
					}
					else {
						row._details.detach();
					}
		
					__details_events( ctx[0] );
				}
			}
		};
		
		
		var __details_events = function ( settings )
		{
			var api = new _Api( settings );
			var namespace = '.dt.DT_details';
			var drawEvent = 'draw'+namespace;
			var colvisEvent = 'column-visibility'+namespace;
			var destroyEvent = 'destroy'+namespace;
			var data = settings.aoData;
		
			api.off( drawEvent +' '+ colvisEvent +' '+ destroyEvent );
		
			if ( _pluck( data, '_details' ).length > 0 ) {
				// On each draw, insert the required elements into the document
				api.on( drawEvent, function ( e, ctx ) {
					if ( settings !== ctx ) {
						return;
					}
		
					api.rows( {page:'current'} ).eq(0).each( function (idx) {
						// Internal data grab
						var row = data[ idx ];
		
						if ( row._detailsShow ) {
							row._details.insertAfter( row.nTr );
						}
					} );
				} );
		
				// Column visibility change - update the colspan
				api.on( colvisEvent, function ( e, ctx, idx, vis ) {
					if ( settings !== ctx ) {
						return;
					}
		
					// Update the colspan for the details rows (note, only if it already has
					// a colspan)
					var row, visible = _fnVisbleColumns( ctx );
		
					for ( var i=0, ien=data.length ; i<ien ; i++ ) {
						row = data[i];
		
						if ( row._details ) {
							row._details.children('td[colspan]').attr('colspan', visible );
						}
					}
				} );
		
				// Table destroyed - nuke any child rows
				api.on( destroyEvent, function ( e, ctx ) {
					if ( settings !== ctx ) {
						return;
					}
		
					for ( var i=0, ien=data.length ; i<ien ; i++ ) {
						if ( data[i]._details ) {
							__details_remove( api, i );
						}
					}
				} );
			}
		};
		
		// Strings for the method names to help minification
		var _emp = '';
		var _child_obj = _emp+'row().child';
		var _child_mth = _child_obj+'()';
		
		// data can be:
		//  tr
		//  string
		//  jQuery or array of any of the above
		_api_register( _child_mth, function ( data, klass ) {
			var ctx = this.context;
		
			if ( data === undefined ) {
				// get
				return ctx.length && this.length ?
					ctx[0].aoData[ this[0] ]._details :
					undefined;
			}
			else if ( data === true ) {
				// show
				this.child.show();
			}
			else if ( data === false ) {
				// remove
				__details_remove( this );
			}
			else if ( ctx.length && this.length ) {
				// set
				__details_add( ctx[0], ctx[0].aoData[ this[0] ], data, klass );
			}
		
			return this;
		} );
		
		
		_api_register( [
			_child_obj+'.show()',
			_child_mth+'.show()' // only when `child()` was called with parameters (without
		], function ( show ) {   // it returns an object and this method is not executed)
			__details_display( this, true );
			return this;
		} );
		
		
		_api_register( [
			_child_obj+'.hide()',
			_child_mth+'.hide()' // only when `child()` was called with parameters (without
		], function () {         // it returns an object and this method is not executed)
			__details_display( this, false );
			return this;
		} );
		
		
		_api_register( [
			_child_obj+'.remove()',
			_child_mth+'.remove()' // only when `child()` was called with parameters (without
		], function () {           // it returns an object and this method is not executed)
			__details_remove( this );
			return this;
		} );
		
		
		_api_register( _child_obj+'.isShown()', function () {
			var ctx = this.context;
		
			if ( ctx.length && this.length ) {
				// _detailsShown as false or undefined will fall through to return false
				return ctx[0].aoData[ this[0] ]._detailsShow || false;
			}
			return false;
		} );
		
		
		
		/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
		 * Columns
		 *
		 * {integer}           - column index (>=0 count from left, <0 count from right)
		 * "{integer}:visIdx"  - visible column index (i.e. translate to column index)  (>=0 count from left, <0 count from right)
		 * "{integer}:visible" - alias for {integer}:visIdx  (>=0 count from left, <0 count from right)
		 * "{string}:name"     - column name
		 * "{string}"          - jQuery selector on column header nodes
		 *
		 */
		
		// can be an array of these items, comma separated list, or an array of comma
		// separated lists
		
		var __re_column_selector = /^(.+):(name|visIdx|visible)$/;
		
		
		// r1 and r2 are redundant - but it means that the parameters match for the
		// iterator callback in columns().data()
		var __columnData = function ( settings, column, r1, r2, rows ) {
			var a = [];
			for ( var row=0, ien=rows.length ; row<ien ; row++ ) {
				a.push( _fnGetCellData( settings, rows[row], column ) );
			}
			return a;
		};
		
		
		var __column_selector = function ( settings, selector, opts )
		{
			var
				columns = settings.aoColumns,
				names = _pluck( columns, 'sName' ),
				nodes = _pluck( columns, 'nTh' );
		
			var run = function ( s ) {
				var selInt = _intVal( s );
		
				// Selector - all
				if ( s === '' ) {
					return _range( columns.length );
				}
		
				// Selector - index
				if ( selInt !== null ) {
					return [ selInt >= 0 ?
						selInt : // Count from left
						columns.length + selInt // Count from right (+ because its a negative value)
					];
				}
		
				// Selector = function
				if ( typeof s === 'function' ) {
					var rows = _selector_row_indexes( settings, opts );
		
					return $.map( columns, function (col, idx) {
						return s(
								idx,
								__columnData( settings, idx, 0, 0, rows ),
								nodes[ idx ]
							) ? idx : null;
					} );
				}
		
				// jQuery or string selector
				var match = typeof s === 'string' ?
					s.match( __re_column_selector ) :
					'';
		
				if ( match ) {
					switch( match[2] ) {
						case 'visIdx':
						case 'visible':
							var idx = parseInt( match[1], 10 );
							// Visible index given, convert to column index
							if ( idx < 0 ) {
								// Counting from the right
								var visColumns = $.map( columns, function (col,i) {
									return col.bVisible ? i : null;
								} );
								return [ visColumns[ visColumns.length + idx ] ];
							}
							// Counting from the left
							return [ _fnVisibleToColumnIndex( settings, idx ) ];
		
						case 'name':
							// match by name. `names` is column index complete and in order
							return $.map( names, function (name, i) {
								return name === match[1] ? i : null;
							} );
		
						default:
							return [];
					}
				}
		
				// Cell in the table body
				if ( s.nodeName && s._DT_CellIndex ) {
					return [ s._DT_CellIndex.column ];
				}
		
				// jQuery selector on the TH elements for the columns
				var jqResult = $( nodes )
					.filter( s )
					.map( function () {
						return $.inArray( this, nodes ); // `nodes` is column index complete and in order
					} )
					.toArray();
		
				if ( jqResult.length || ! s.nodeName ) {
					return jqResult;
				}
		
				// Otherwise a node which might have a `dt-column` data attribute, or be
				// a child or such an element
				var host = $(s).closest('*[data-dt-column]');
				return host.length ?
					[ host.data('dt-column') ] :
					[];
			};
		
			return _selector_run( 'column', selector, run, settings, opts );
		};
		
		
		var __setColumnVis = function ( settings, column, vis ) {
			var
				cols = settings.aoColumns,
				col  = cols[ column ],
				data = settings.aoData,
				row, cells, i, ien, tr;
		
			// Get
			if ( vis === undefined ) {
				return col.bVisible;
			}
		
			// Set
			// No change
			if ( col.bVisible === vis ) {
				return;
			}
		
			if ( vis ) {
				// Insert column
				// Need to decide if we should use appendChild or insertBefore
				var insertBefore = $.inArray( true, _pluck(cols, 'bVisible'), column+1 );
		
				for ( i=0, ien=data.length ; i<ien ; i++ ) {
					tr = data[i].nTr;
					cells = data[i].anCells;
		
					if ( tr ) {
						// insertBefore can act like appendChild if 2nd arg is null
						tr.insertBefore( cells[ column ], cells[ insertBefore ] || null );
					}
				}
			}
			else {
				// Remove column
				$( _pluck( settings.aoData, 'anCells', column ) ).detach();
			}
		
			// Common actions
			col.bVisible = vis;
			_fnDrawHead( settings, settings.aoHeader );
			_fnDrawHead( settings, settings.aoFooter );
		
			_fnSaveState( settings );
		};
		
		
		_api_register( 'columns()', function ( selector, opts ) {
			// argument shifting
			if ( selector === undefined ) {
				selector = '';
			}
			else if ( $.isPlainObject( selector ) ) {
				opts = selector;
				selector = '';
			}
		
			opts = _selector_opts( opts );
		
			var inst = this.iterator( 'table', function ( settings ) {
				return __column_selector( settings, selector, opts );
			}, 1 );
		
			// Want argument shifting here and in _row_selector?
			inst.selector.cols = selector;
			inst.selector.opts = opts;
		
			return inst;
		} );
		
		_api_registerPlural( 'columns().header()', 'column().header()', function ( selector, opts ) {
			return this.iterator( 'column', function ( settings, column ) {
				return settings.aoColumns[column].nTh;
			}, 1 );
		} );
		
		_api_registerPlural( 'columns().footer()', 'column().footer()', function ( selector, opts ) {
			return this.iterator( 'column', function ( settings, column ) {
				return settings.aoColumns[column].nTf;
			}, 1 );
		} );
		
		_api_registerPlural( 'columns().data()', 'column().data()', function () {
			return this.iterator( 'column-rows', __columnData, 1 );
		} );
		
		_api_registerPlural( 'columns().dataSrc()', 'column().dataSrc()', function () {
			return this.iterator( 'column', function ( settings, column ) {
				return settings.aoColumns[column].mData;
			}, 1 );
		} );
		
		_api_registerPlural( 'columns().cache()', 'column().cache()', function ( type ) {
			return this.iterator( 'column-rows', function ( settings, column, i, j, rows ) {
				return _pluck_order( settings.aoData, rows,
					type === 'search' ? '_aFilterData' : '_aSortData', column
				);
			}, 1 );
		} );
		
		_api_registerPlural( 'columns().nodes()', 'column().nodes()', function () {
			return this.iterator( 'column-rows', function ( settings, column, i, j, rows ) {
				return _pluck_order( settings.aoData, rows, 'anCells', column ) ;
			}, 1 );
		} );
		
		_api_registerPlural( 'columns().visible()', 'column().visible()', function ( vis, calc ) {
			var ret = this.iterator( 'column', function ( settings, column ) {
				if ( vis === undefined ) {
					return settings.aoColumns[ column ].bVisible;
				} // else
				__setColumnVis( settings, column, vis );
			} );
		
			// Group the column visibility changes
			if ( vis !== undefined ) {
				// Second loop once the first is done for events
				this.iterator( 'column', function ( settings, column ) {
					_fnCallbackFire( settings, null, 'column-visibility', [settings, column, vis, calc] );
				} );
		
				if ( calc === undefined || calc ) {
					this.columns.adjust();
				}
			}
		
			return ret;
		} );
		
		_api_registerPlural( 'columns().indexes()', 'column().index()', function ( type ) {
			return this.iterator( 'column', function ( settings, column ) {
				return type === 'visible' ?
					_fnColumnIndexToVisible( settings, column ) :
					column;
			}, 1 );
		} );
		
		_api_register( 'columns.adjust()', function () {
			return this.iterator( 'table', function ( settings ) {
				_fnAdjustColumnSizing( settings );
			}, 1 );
		} );
		
		_api_register( 'column.index()', function ( type, idx ) {
			if ( this.context.length !== 0 ) {
				var ctx = this.context[0];
		
				if ( type === 'fromVisible' || type === 'toData' ) {
					return _fnVisibleToColumnIndex( ctx, idx );
				}
				else if ( type === 'fromData' || type === 'toVisible' ) {
					return _fnColumnIndexToVisible( ctx, idx );
				}
			}
		} );
		
		_api_register( 'column()', function ( selector, opts ) {
			return _selector_first( this.columns( selector, opts ) );
		} );
		
		
		
		var __cell_selector = function ( settings, selector, opts )
		{
			var data = settings.aoData;
			var rows = _selector_row_indexes( settings, opts );
			var cells = _removeEmpty( _pluck_order( data, rows, 'anCells' ) );
			var allCells = $( [].concat.apply([], cells) );
			var row;
			var columns = settings.aoColumns.length;
			var a, i, ien, j, o, host;
		
			var run = function ( s ) {
				var fnSelector = typeof s === 'function';
		
				if ( s === null || s === undefined || fnSelector ) {
					// All cells and function selectors
					a = [];
		
					for ( i=0, ien=rows.length ; i<ien ; i++ ) {
						row = rows[i];
		
						for ( j=0 ; j<columns ; j++ ) {
							o = {
								row: row,
								column: j
							};
		
							if ( fnSelector ) {
								// Selector - function
								host = data[ row ];
		
								if ( s( o, _fnGetCellData(settings, row, j), host.anCells ? host.anCells[j] : null ) ) {
									a.push( o );
								}
							}
							else {
								// Selector - all
								a.push( o );
							}
						}
					}
		
					return a;
				}
				
				// Selector - index
				if ( $.isPlainObject( s ) ) {
					return [s];
				}
		
				// Selector - jQuery filtered cells
				var jqResult = allCells
					.filter( s )
					.map( function (i, el) {
						return { // use a new object, in case someone changes the values
							row:    el._DT_CellIndex.row,
							column: el._DT_CellIndex.column
		 				};
					} )
					.toArray();
		
				if ( jqResult.length || ! s.nodeName ) {
					return jqResult;
				}
		
				// Otherwise the selector is a node, and there is one last option - the
				// element might be a child of an element which has dt-row and dt-column
				// data attributes
				host = $(s).closest('*[data-dt-row]');
				return host.length ?
					[ {
						row: host.data('dt-row'),
						column: host.data('dt-column')
					} ] :
					[];
			};
		
			return _selector_run( 'cell', selector, run, settings, opts );
		};
		
		
		
		
		_api_register( 'cells()', function ( rowSelector, columnSelector, opts ) {
			// Argument shifting
			if ( $.isPlainObject( rowSelector ) ) {
				// Indexes
				if ( rowSelector.row === undefined ) {
					// Selector options in first parameter
					opts = rowSelector;
					rowSelector = null;
				}
				else {
					// Cell index objects in first parameter
					opts = columnSelector;
					columnSelector = null;
				}
			}
			if ( $.isPlainObject( columnSelector ) ) {
				opts = columnSelector;
				columnSelector = null;
			}
		
			// Cell selector
			if ( columnSelector === null || columnSelector === undefined ) {
				return this.iterator( 'table', function ( settings ) {
					return __cell_selector( settings, rowSelector, _selector_opts( opts ) );
				} );
			}
		
			// Row + column selector
			var columns = this.columns( columnSelector, opts );
			var rows = this.rows( rowSelector, opts );
			var a, i, ien, j, jen;
		
			var cells = this.iterator( 'table', function ( settings, idx ) {
				a = [];
		
				for ( i=0, ien=rows[idx].length ; i<ien ; i++ ) {
					for ( j=0, jen=columns[idx].length ; j<jen ; j++ ) {
						a.push( {
							row:    rows[idx][i],
							column: columns[idx][j]
						} );
					}
				}
		
				return a;
			}, 1 );
		
			$.extend( cells.selector, {
				cols: columnSelector,
				rows: rowSelector,
				opts: opts
			} );
		
			return cells;
		} );
		
		
		_api_registerPlural( 'cells().nodes()', 'cell().node()', function () {
			return this.iterator( 'cell', function ( settings, row, column ) {
				var data = settings.aoData[ row ];
		
				return data && data.anCells ?
					data.anCells[ column ] :
					undefined;
			}, 1 );
		} );
		
		
		_api_register( 'cells().data()', function () {
			return this.iterator( 'cell', function ( settings, row, column ) {
				return _fnGetCellData( settings, row, column );
			}, 1 );
		} );
		
		
		_api_registerPlural( 'cells().cache()', 'cell().cache()', function ( type ) {
			type = type === 'search' ? '_aFilterData' : '_aSortData';
		
			return this.iterator( 'cell', function ( settings, row, column ) {
				return settings.aoData[ row ][ type ][ column ];
			}, 1 );
		} );
		
		
		_api_registerPlural( 'cells().render()', 'cell().render()', function ( type ) {
			return this.iterator( 'cell', function ( settings, row, column ) {
				return _fnGetCellData( settings, row, column, type );
			}, 1 );
		} );
		
		
		_api_registerPlural( 'cells().indexes()', 'cell().index()', function () {
			return this.iterator( 'cell', function ( settings, row, column ) {
				return {
					row: row,
					column: column,
					columnVisible: _fnColumnIndexToVisible( settings, column )
				};
			}, 1 );
		} );
		
		
		_api_registerPlural( 'cells().invalidate()', 'cell().invalidate()', function ( src ) {
			return this.iterator( 'cell', function ( settings, row, column ) {
				_fnInvalidate( settings, row, src, column );
			} );
		} );
		
		
		
		_api_register( 'cell()', function ( rowSelector, columnSelector, opts ) {
			return _selector_first( this.cells( rowSelector, columnSelector, opts ) );
		} );
		
		
		_api_register( 'cell().data()', function ( data ) {
			var ctx = this.context;
			var cell = this[0];
		
			if ( data === undefined ) {
				// Get
				return ctx.length && cell.length ?
					_fnGetCellData( ctx[0], cell[0].row, cell[0].column ) :
					undefined;
			}
		
			// Set
			_fnSetCellData( ctx[0], cell[0].row, cell[0].column, data );
			_fnInvalidate( ctx[0], cell[0].row, 'data', cell[0].column );
		
			return this;
		} );
		
		
		
		/**
		 * Get current ordering (sorting) that has been applied to the table.
		 *
		 * @returns {array} 2D array containing the sorting information for the first
		 *   table in the current context. Each element in the parent array represents
		 *   a column being sorted upon (i.e. multi-sorting with two columns would have
		 *   2 inner arrays). The inner arrays may have 2 or 3 elements. The first is
		 *   the column index that the sorting condition applies to, the second is the
		 *   direction of the sort (`desc` or `asc`) and, optionally, the third is the
		 *   index of the sorting order from the `column.sorting` initialisation array.
		 *//**
		 * Set the ordering for the table.
		 *
		 * @param {integer} order Column index to sort upon.
		 * @param {string} direction Direction of the sort to be applied (`asc` or `desc`)
		 * @returns {DataTables.Api} this
		 *//**
		 * Set the ordering for the table.
		 *
		 * @param {array} order 1D array of sorting information to be applied.
		 * @param {array} [...] Optional additional sorting conditions
		 * @returns {DataTables.Api} this
		 *//**
		 * Set the ordering for the table.
		 *
		 * @param {array} order 2D array of sorting information to be applied.
		 * @returns {DataTables.Api} this
		 */
		_api_register( 'order()', function ( order, dir ) {
			var ctx = this.context;
		
			if ( order === undefined ) {
				// get
				return ctx.length !== 0 ?
					ctx[0].aaSorting :
					undefined;
			}
		
			// set
			if ( typeof order === 'number' ) {
				// Simple column / direction passed in
				order = [ [ order, dir ] ];
			}
			else if ( order.length && ! $.isArray( order[0] ) ) {
				// Arguments passed in (list of 1D arrays)
				order = Array.prototype.slice.call( arguments );
			}
			// otherwise a 2D array was passed in
		
			return this.iterator( 'table', function ( settings ) {
				settings.aaSorting = order.slice();
			} );
		} );
		
		
		/**
		 * Attach a sort listener to an element for a given column
		 *
		 * @param {node|jQuery|string} node Identifier for the element(s) to attach the
		 *   listener to. This can take the form of a single DOM node, a jQuery
		 *   collection of nodes or a jQuery selector which will identify the node(s).
		 * @param {integer} column the column that a click on this node will sort on
		 * @param {function} [callback] callback function when sort is run
		 * @returns {DataTables.Api} this
		 */
		_api_register( 'order.listener()', function ( node, column, callback ) {
			return this.iterator( 'table', function ( settings ) {
				_fnSortAttachListener( settings, node, column, callback );
			} );
		} );
		
		
		_api_register( 'order.fixed()', function ( set ) {
			if ( ! set ) {
				var ctx = this.context;
				var fixed = ctx.length ?
					ctx[0].aaSortingFixed :
					undefined;
		
				return $.isArray( fixed ) ?
					{ pre: fixed } :
					fixed;
			}
		
			return this.iterator( 'table', function ( settings ) {
				settings.aaSortingFixed = $.extend( true, {}, set );
			} );
		} );
		
		
		// Order by the selected column(s)
		_api_register( [
			'columns().order()',
			'column().order()'
		], function ( dir ) {
			var that = this;
		
			return this.iterator( 'table', function ( settings, i ) {
				var sort = [];
		
				$.each( that[i], function (j, col) {
					sort.push( [ col, dir ] );
				} );
		
				settings.aaSorting = sort;
			} );
		} );
		
		
		
		_api_register( 'search()', function ( input, regex, smart, caseInsen ) {
			var ctx = this.context;
		
			if ( input === undefined ) {
				// get
				return ctx.length !== 0 ?
					ctx[0].oPreviousSearch.sSearch :
					undefined;
			}
		
			// set
			return this.iterator( 'table', function ( settings ) {
				if ( ! settings.oFeatures.bFilter ) {
					return;
				}
		
				_fnFilterComplete( settings, $.extend( {}, settings.oPreviousSearch, {
					"sSearch": input+"",
					"bRegex":  regex === null ? false : regex,
					"bSmart":  smart === null ? true  : smart,
					"bCaseInsensitive": caseInsen === null ? true : caseInsen
				} ), 1 );
			} );
		} );
		
		
		_api_registerPlural(
			'columns().search()',
			'column().search()',
			function ( input, regex, smart, caseInsen ) {
				return this.iterator( 'column', function ( settings, column ) {
					var preSearch = settings.aoPreSearchCols;
		
					if ( input === undefined ) {
						// get
						return preSearch[ column ].sSearch;
					}
		
					// set
					if ( ! settings.oFeatures.bFilter ) {
						return;
					}
		
					$.extend( preSearch[ column ], {
						"sSearch": input+"",
						"bRegex":  regex === null ? false : regex,
						"bSmart":  smart === null ? true  : smart,
						"bCaseInsensitive": caseInsen === null ? true : caseInsen
					} );
		
					_fnFilterComplete( settings, settings.oPreviousSearch, 1 );
				} );
			}
		);
		
		/*
		 * State API methods
		 */
		
		_api_register( 'state()', function () {
			return this.context.length ?
				this.context[0].oSavedState :
				null;
		} );
		
		
		_api_register( 'state.clear()', function () {
			return this.iterator( 'table', function ( settings ) {
				// Save an empty object
				settings.fnStateSaveCallback.call( settings.oInstance, settings, {} );
			} );
		} );
		
		
		_api_register( 'state.loaded()', function () {
			return this.context.length ?
				this.context[0].oLoadedState :
				null;
		} );
		
		
		_api_register( 'state.save()', function () {
			return this.iterator( 'table', function ( settings ) {
				_fnSaveState( settings );
			} );
		} );
		
		
		
		/**
		 * Provide a common method for plug-ins to check the version of DataTables being
		 * used, in order to ensure compatibility.
		 *
		 *  @param {string} version Version string to check for, in the format "X.Y.Z".
		 *    Note that the formats "X" and "X.Y" are also acceptable.
		 *  @returns {boolean} true if this version of DataTables is greater or equal to
		 *    the required version, or false if this version of DataTales is not
		 *    suitable
		 *  @static
		 *  @dtopt API-Static
		 *
		 *  @example
		 *    alert( $.fn.dataTable.versionCheck( '1.9.0' ) );
		 */
		DataTable.versionCheck = DataTable.fnVersionCheck = function( version )
		{
			var aThis = DataTable.version.split('.');
			var aThat = version.split('.');
			var iThis, iThat;
		
			for ( var i=0, iLen=aThat.length ; i<iLen ; i++ ) {
				iThis = parseInt( aThis[i], 10 ) || 0;
				iThat = parseInt( aThat[i], 10 ) || 0;
		
				// Parts are the same, keep comparing
				if (iThis === iThat) {
					continue;
				}
		
				// Parts are different, return immediately
				return iThis > iThat;
			}
		
			return true;
		};
		
		
		/**
		 * Check if a `<table>` node is a DataTable table already or not.
		 *
		 *  @param {node|jquery|string} table Table node, jQuery object or jQuery
		 *      selector for the table to test. Note that if more than more than one
		 *      table is passed on, only the first will be checked
		 *  @returns {boolean} true the table given is a DataTable, or false otherwise
		 *  @static
		 *  @dtopt API-Static
		 *
		 *  @example
		 *    if ( ! $.fn.DataTable.isDataTable( '#example' ) ) {
		 *      $('#example').dataTable();
		 *    }
		 */
		DataTable.isDataTable = DataTable.fnIsDataTable = function ( table )
		{
			var t = $(table).get(0);
			var is = false;
		
			$.each( DataTable.settings, function (i, o) {
				var head = o.nScrollHead ? $('table', o.nScrollHead)[0] : null;
				var foot = o.nScrollFoot ? $('table', o.nScrollFoot)[0] : null;
		
				if ( o.nTable === t || head === t || foot === t ) {
					is = true;
				}
			} );
		
			return is;
		};
		
		
		/**
		 * Get all DataTable tables that have been initialised - optionally you can
		 * select to get only currently visible tables.
		 *
		 *  @param {boolean} [visible=false] Flag to indicate if you want all (default)
		 *    or visible tables only.
		 *  @returns {array} Array of `table` nodes (not DataTable instances) which are
		 *    DataTables
		 *  @static
		 *  @dtopt API-Static
		 *
		 *  @example
		 *    $.each( $.fn.dataTable.tables(true), function () {
		 *      $(table).DataTable().columns.adjust();
		 *    } );
		 */
		DataTable.tables = DataTable.fnTables = function ( visible )
		{
			var api = false;
		
			if ( $.isPlainObject( visible ) ) {
				api = visible.api;
				visible = visible.visible;
			}
		
			var a = $.map( DataTable.settings, function (o) {
				if ( !visible || (visible && $(o.nTable).is(':visible')) ) {
					return o.nTable;
				}
			} );
		
			return api ?
				new _Api( a ) :
				a;
		};
		
		
		/**
		 * Convert from camel case parameters to Hungarian notation. This is made public
		 * for the extensions to provide the same ability as DataTables core to accept
		 * either the 1.9 style Hungarian notation, or the 1.10+ style camelCase
		 * parameters.
		 *
		 *  @param {object} src The model object which holds all parameters that can be
		 *    mapped.
		 *  @param {object} user The object to convert from camel case to Hungarian.
		 *  @param {boolean} force When set to `true`, properties which already have a
		 *    Hungarian value in the `user` object will be overwritten. Otherwise they
		 *    won't be.
		 */
		DataTable.camelToHungarian = _fnCamelToHungarian;
		
		
		
		/**
		 *
		 */
		_api_register( '$()', function ( selector, opts ) {
			var
				rows   = this.rows( opts ).nodes(), // Get all rows
				jqRows = $(rows);
		
			return $( [].concat(
				jqRows.filter( selector ).toArray(),
				jqRows.find( selector ).toArray()
			) );
		} );
		
		
		// jQuery functions to operate on the tables
		$.each( [ 'on', 'one', 'off' ], function (i, key) {
			_api_register( key+'()', function ( /* event, handler */ ) {
				var args = Array.prototype.slice.call(arguments);
		
				// Add the `dt` namespace automatically if it isn't already present
				if ( ! args[0].match(/\.dt\b/) ) {
					args[0] += '.dt';
				}
		
				var inst = $( this.tables().nodes() );
				inst[key].apply( inst, args );
				return this;
			} );
		} );
		
		
		_api_register( 'clear()', function () {
			return this.iterator( 'table', function ( settings ) {
				_fnClearTable( settings );
			} );
		} );
		
		
		_api_register( 'settings()', function () {
			return new _Api( this.context, this.context );
		} );
		
		
		_api_register( 'init()', function () {
			var ctx = this.context;
			return ctx.length ? ctx[0].oInit : null;
		} );
		
		
		_api_register( 'data()', function () {
			return this.iterator( 'table', function ( settings ) {
				return _pluck( settings.aoData, '_aData' );
			} ).flatten();
		} );
		
		
		_api_register( 'destroy()', function ( remove ) {
			remove = remove || false;
		
			return this.iterator( 'table', function ( settings ) {
				var orig      = settings.nTableWrapper.parentNode;
				var classes   = settings.oClasses;
				var table     = settings.nTable;
				var tbody     = settings.nTBody;
				var thead     = settings.nTHead;
				var tfoot     = settings.nTFoot;
				var jqTable   = $(table);
				var jqTbody   = $(tbody);
				var jqWrapper = $(settings.nTableWrapper);
				var rows      = $.map( settings.aoData, function (r) { return r.nTr; } );
				var i, ien;
		
				// Flag to note that the table is currently being destroyed - no action
				// should be taken
				settings.bDestroying = true;
		
				// Fire off the destroy callbacks for plug-ins etc
				_fnCallbackFire( settings, "aoDestroyCallback", "destroy", [settings] );
		
				// If not being removed from the document, make all columns visible
				if ( ! remove ) {
					new _Api( settings ).columns().visible( true );
				}
		
				// Blitz all `DT` namespaced events (these are internal events, the
				// lowercase, `dt` events are user subscribed and they are responsible
				// for removing them
				jqWrapper.unbind('.DT').find(':not(tbody *)').unbind('.DT');
				$(window).unbind('.DT-'+settings.sInstance);
		
				// When scrolling we had to break the table up - restore it
				if ( table != thead.parentNode ) {
					jqTable.children('thead').detach();
					jqTable.append( thead );
				}
		
				if ( tfoot && table != tfoot.parentNode ) {
					jqTable.children('tfoot').detach();
					jqTable.append( tfoot );
				}
		
				settings.aaSorting = [];
				settings.aaSortingFixed = [];
				_fnSortingClasses( settings );
		
				$( rows ).removeClass( settings.asStripeClasses.join(' ') );
		
				$('th, td', thead).removeClass( classes.sSortable+' '+
					classes.sSortableAsc+' '+classes.sSortableDesc+' '+classes.sSortableNone
				);
		
				if ( settings.bJUI ) {
					$('th span.'+classes.sSortIcon+ ', td span.'+classes.sSortIcon, thead).detach();
					$('th, td', thead).each( function () {
						var wrapper = $('div.'+classes.sSortJUIWrapper, this);
						$(this).append( wrapper.contents() );
						wrapper.detach();
					} );
				}
		
				// Add the TR elements back into the table in their original order
				jqTbody.children().detach();
				jqTbody.append( rows );
		
				// Remove the DataTables generated nodes, events and classes
				var removedMethod = remove ? 'remove' : 'detach';
				jqTable[ removedMethod ]();
				jqWrapper[ removedMethod ]();
		
				// If we need to reattach the table to the document
				if ( ! remove && orig ) {
					// insertBefore acts like appendChild if !arg[1]
					orig.insertBefore( table, settings.nTableReinsertBefore );
		
					// Restore the width of the original table - was read from the style property,
					// so we can restore directly to that
					jqTable
						.css( 'width', settings.sDestroyWidth )
						.removeClass( classes.sTable );
		
					// If the were originally stripe classes - then we add them back here.
					// Note this is not fool proof (for example if not all rows had stripe
					// classes - but it's a good effort without getting carried away
					ien = settings.asDestroyStripes.length;
		
					if ( ien ) {
						jqTbody.children().each( function (i) {
							$(this).addClass( settings.asDestroyStripes[i % ien] );
						} );
					}
				}
		
				/* Remove the settings object from the settings array */
				var idx = $.inArray( settings, DataTable.settings );
				if ( idx !== -1 ) {
					DataTable.settings.splice( idx, 1 );
				}
			} );
		} );
		
		
		// Add the `every()` method for rows, columns and cells in a compact form
		$.each( [ 'column', 'row', 'cell' ], function ( i, type ) {
			_api_register( type+'s().every()', function ( fn ) {
				var opts = this.selector.opts;
				var api = this;
		
				return this.iterator( type, function ( settings, arg1, arg2, arg3, arg4 ) {
					// Rows and columns:
					//  arg1 - index
					//  arg2 - table counter
					//  arg3 - loop counter
					//  arg4 - undefined
					// Cells:
					//  arg1 - row index
					//  arg2 - column index
					//  arg3 - table counter
					//  arg4 - loop counter
					fn.call(
						api[ type ](
							arg1,
							type==='cell' ? arg2 : opts,
							type==='cell' ? opts : undefined
						),
						arg1, arg2, arg3, arg4
					);
				} );
			} );
		} );
		
		
		// i18n method for extensions to be able to use the language object from the
		// DataTable
		_api_register( 'i18n()', function ( token, def, plural ) {
			var ctx = this.context[0];
			var resolved = _fnGetObjectDataFn( token )( ctx.oLanguage );
		
			if ( resolved === undefined ) {
				resolved = def;
			}
		
			if ( plural !== undefined && $.isPlainObject( resolved ) ) {
				resolved = resolved[ plural ] !== undefined ?
					resolved[ plural ] :
					resolved._;
			}
		
			return resolved.replace( '%d', plural ); // nb: plural might be undefined,
		} );
		/**
		 * Version string for plug-ins to check compatibility. Allowed format is
		 * `a.b.c-d` where: a:int, b:int, c:int, d:string(dev|beta|alpha). `d` is used
		 * only for non-release builds. See http://semver.org/ for more information.
		 *  @member
		 *  @type string
		 *  @default Version number
		 */
		DataTable.version = "1.10.12";
	
		/**
		 * Private data store, containing all of the settings objects that are
		 * created for the tables on a given page.
		 *
		 * Note that the `DataTable.settings` object is aliased to
		 * `jQuery.fn.dataTableExt` through which it may be accessed and
		 * manipulated, or `jQuery.fn.dataTable.settings`.
		 *  @member
		 *  @type array
		 *  @default []
		 *  @private
		 */
		DataTable.settings = [];
	
		/**
		 * Object models container, for the various models that DataTables has
		 * available to it. These models define the objects that are used to hold
		 * the active state and configuration of the table.
		 *  @namespace
		 */
		DataTable.models = {};
		
		
		
		/**
		 * Template object for the way in which DataTables holds information about
		 * search information for the global filter and individual column filters.
		 *  @namespace
		 */
		DataTable.models.oSearch = {
			/**
			 * Flag to indicate if the filtering should be case insensitive or not
			 *  @type boolean
			 *  @default true
			 */
			"bCaseInsensitive": true,
		
			/**
			 * Applied search term
			 *  @type string
			 *  @default <i>Empty string</i>
			 */
			"sSearch": "",
		
			/**
			 * Flag to indicate if the search term should be interpreted as a
			 * regular expression (true) or not (false) and therefore and special
			 * regex characters escaped.
			 *  @type boolean
			 *  @default false
			 */
			"bRegex": false,
		
			/**
			 * Flag to indicate if DataTables is to use its smart filtering or not.
			 *  @type boolean
			 *  @default true
			 */
			"bSmart": true
		};
		
		
		
		
		/**
		 * Template object for the way in which DataTables holds information about
		 * each individual row. This is the object format used for the settings
		 * aoData array.
		 *  @namespace
		 */
		DataTable.models.oRow = {
			/**
			 * TR element for the row
			 *  @type node
			 *  @default null
			 */
			"nTr": null,
		
			/**
			 * Array of TD elements for each row. This is null until the row has been
			 * created.
			 *  @type array nodes
			 *  @default []
			 */
			"anCells": null,
		
			/**
			 * Data object from the original data source for the row. This is either
			 * an array if using the traditional form of DataTables, or an object if
			 * using mData options. The exact type will depend on the passed in
			 * data from the data source, or will be an array if using DOM a data
			 * source.
			 *  @type array|object
			 *  @default []
			 */
			"_aData": [],
		
			/**
			 * Sorting data cache - this array is ostensibly the same length as the
			 * number of columns (although each index is generated only as it is
			 * needed), and holds the data that is used for sorting each column in the
			 * row. We do this cache generation at the start of the sort in order that
			 * the formatting of the sort data need be done only once for each cell
			 * per sort. This array should not be read from or written to by anything
			 * other than the master sorting methods.
			 *  @type array
			 *  @default null
			 *  @private
			 */
			"_aSortData": null,
		
			/**
			 * Per cell filtering data cache. As per the sort data cache, used to
			 * increase the performance of the filtering in DataTables
			 *  @type array
			 *  @default null
			 *  @private
			 */
			"_aFilterData": null,
		
			/**
			 * Filtering data cache. This is the same as the cell filtering cache, but
			 * in this case a string rather than an array. This is easily computed with
			 * a join on `_aFilterData`, but is provided as a cache so the join isn't
			 * needed on every search (memory traded for performance)
			 *  @type array
			 *  @default null
			 *  @private
			 */
			"_sFilterRow": null,
		
			/**
			 * Cache of the class name that DataTables has applied to the row, so we
			 * can quickly look at this variable rather than needing to do a DOM check
			 * on className for the nTr property.
			 *  @type string
			 *  @default <i>Empty string</i>
			 *  @private
			 */
			"_sRowStripe": "",
		
			/**
			 * Denote if the original data source was from the DOM, or the data source
			 * object. This is used for invalidating data, so DataTables can
			 * automatically read data from the original source, unless uninstructed
			 * otherwise.
			 *  @type string
			 *  @default null
			 *  @private
			 */
			"src": null,
		
			/**
			 * Index in the aoData array. This saves an indexOf lookup when we have the
			 * object, but want to know the index
			 *  @type integer
			 *  @default -1
			 *  @private
			 */
			"idx": -1
		};
		
		
		/**
		 * Template object for the column information object in DataTables. This object
		 * is held in the settings aoColumns array and contains all the information that
		 * DataTables needs about each individual column.
		 *
		 * Note that this object is related to {@link DataTable.defaults.column}
		 * but this one is the internal data store for DataTables's cache of columns.
		 * It should NOT be manipulated outside of DataTables. Any configuration should
		 * be done through the initialisation options.
		 *  @namespace
		 */
		DataTable.models.oColumn = {
			/**
			 * Column index. This could be worked out on-the-fly with $.inArray, but it
			 * is faster to just hold it as a variable
			 *  @type integer
			 *  @default null
			 */
			"idx": null,
		
			/**
			 * A list of the columns that sorting should occur on when this column
			 * is sorted. That this property is an array allows multi-column sorting
			 * to be defined for a column (for example first name / last name columns
			 * would benefit from this). The values are integers pointing to the
			 * columns to be sorted on (typically it will be a single integer pointing
			 * at itself, but that doesn't need to be the case).
			 *  @type array
			 */
			"aDataSort": null,
		
			/**
			 * Define the sorting directions that are applied to the column, in sequence
			 * as the column is repeatedly sorted upon - i.e. the first value is used
			 * as the sorting direction when the column if first sorted (clicked on).
			 * Sort it again (click again) and it will move on to the next index.
			 * Repeat until loop.
			 *  @type array
			 */
			"asSorting": null,
		
			/**
			 * Flag to indicate if the column is searchable, and thus should be included
			 * in the filtering or not.
			 *  @type boolean
			 */
			"bSearchable": null,
		
			/**
			 * Flag to indicate if the column is sortable or not.
			 *  @type boolean
			 */
			"bSortable": null,
		
			/**
			 * Flag to indicate if the column is currently visible in the table or not
			 *  @type boolean
			 */
			"bVisible": null,
		
			/**
			 * Store for manual type assignment using the `column.type` option. This
			 * is held in store so we can manipulate the column's `sType` property.
			 *  @type string
			 *  @default null
			 *  @private
			 */
			"_sManualType": null,
		
			/**
			 * Flag to indicate if HTML5 data attributes should be used as the data
			 * source for filtering or sorting. True is either are.
			 *  @type boolean
			 *  @default false
			 *  @private
			 */
			"_bAttrSrc": false,
		
			/**
			 * Developer definable function that is called whenever a cell is created (Ajax source,
			 * etc) or processed for input (DOM source). This can be used as a compliment to mRender
			 * allowing you to modify the DOM element (add background colour for example) when the
			 * element is available.
			 *  @type function
			 *  @param {element} nTd The TD node that has been created
			 *  @param {*} sData The Data for the cell
			 *  @param {array|object} oData The data for the whole row
			 *  @param {int} iRow The row index for the aoData data store
			 *  @default null
			 */
			"fnCreatedCell": null,
		
			/**
			 * Function to get data from a cell in a column. You should <b>never</b>
			 * access data directly through _aData internally in DataTables - always use
			 * the method attached to this property. It allows mData to function as
			 * required. This function is automatically assigned by the column
			 * initialisation method
			 *  @type function
			 *  @param {array|object} oData The data array/object for the array
			 *    (i.e. aoData[]._aData)
			 *  @param {string} sSpecific The specific data type you want to get -
			 *    'display', 'type' 'filter' 'sort'
			 *  @returns {*} The data for the cell from the given row's data
			 *  @default null
			 */
			"fnGetData": null,
		
			/**
			 * Function to set data for a cell in the column. You should <b>never</b>
			 * set the data directly to _aData internally in DataTables - always use
			 * this method. It allows mData to function as required. This function
			 * is automatically assigned by the column initialisation method
			 *  @type function
			 *  @param {array|object} oData The data array/object for the array
			 *    (i.e. aoData[]._aData)
			 *  @param {*} sValue Value to set
			 *  @default null
			 */
			"fnSetData": null,
		
			/**
			 * Property to read the value for the cells in the column from the data
			 * source array / object. If null, then the default content is used, if a
			 * function is given then the return from the function is used.
			 *  @type function|int|string|null
			 *  @default null
			 */
			"mData": null,
		
			/**
			 * Partner property to mData which is used (only when defined) to get
			 * the data - i.e. it is basically the same as mData, but without the
			 * 'set' option, and also the data fed to it is the result from mData.
			 * This is the rendering method to match the data method of mData.
			 *  @type function|int|string|null
			 *  @default null
			 */
			"mRender": null,
		
			/**
			 * Unique header TH/TD element for this column - this is what the sorting
			 * listener is attached to (if sorting is enabled.)
			 *  @type node
			 *  @default null
			 */
			"nTh": null,
		
			/**
			 * Unique footer TH/TD element for this column (if there is one). Not used
			 * in DataTables as such, but can be used for plug-ins to reference the
			 * footer for each column.
			 *  @type node
			 *  @default null
			 */
			"nTf": null,
		
			/**
			 * The class to apply to all TD elements in the table's TBODY for the column
			 *  @type string
			 *  @default null
			 */
			"sClass": null,
		
			/**
			 * When DataTables calculates the column widths to assign to each column,
			 * it finds the longest string in each column and then constructs a
			 * temporary table and reads the widths from that. The problem with this
			 * is that "mmm" is much wider then "iiii", but the latter is a longer
			 * string - thus the calculation can go wrong (doing it properly and putting
			 * it into an DOM object and measuring that is horribly(!) slow). Thus as
			 * a "work around" we provide this option. It will append its value to the
			 * text that is found to be the longest string for the column - i.e. padding.
			 *  @type string
			 */
			"sContentPadding": null,
		
			/**
			 * Allows a default value to be given for a column's data, and will be used
			 * whenever a null data source is encountered (this can be because mData
			 * is set to null, or because the data source itself is null).
			 *  @type string
			 *  @default null
			 */
			"sDefaultContent": null,
		
			/**
			 * Name for the column, allowing reference to the column by name as well as
			 * by index (needs a lookup to work by name).
			 *  @type string
			 */
			"sName": null,
		
			/**
			 * Custom sorting data type - defines which of the available plug-ins in
			 * afnSortData the custom sorting will use - if any is defined.
			 *  @type string
			 *  @default std
			 */
			"sSortDataType": 'std',
		
			/**
			 * Class to be applied to the header element when sorting on this column
			 *  @type string
			 *  @default null
			 */
			"sSortingClass": null,
		
			/**
			 * Class to be applied to the header element when sorting on this column -
			 * when jQuery UI theming is used.
			 *  @type string
			 *  @default null
			 */
			"sSortingClassJUI": null,
		
			/**
			 * Title of the column - what is seen in the TH element (nTh).
			 *  @type string
			 */
			"sTitle": null,
		
			/**
			 * Column sorting and filtering type
			 *  @type string
			 *  @default null
			 */
			"sType": null,
		
			/**
			 * Width of the column
			 *  @type string
			 *  @default null
			 */
			"sWidth": null,
		
			/**
			 * Width of the column when it was first "encountered"
			 *  @type string
			 *  @default null
			 */
			"sWidthOrig": null
		};
		
		
		/*
		 * Developer note: The properties of the object below are given in Hungarian
		 * notation, that was used as the interface for DataTables prior to v1.10, however
		 * from v1.10 onwards the primary interface is camel case. In order to avoid
		 * breaking backwards compatibility utterly with this change, the Hungarian
		 * version is still, internally the primary interface, but is is not documented
		 * - hence the @name tags in each doc comment. This allows a Javascript function
		 * to create a map from Hungarian notation to camel case (going the other direction
		 * would require each property to be listed, which would at around 3K to the size
		 * of DataTables, while this method is about a 0.5K hit.
		 *
		 * Ultimately this does pave the way for Hungarian notation to be dropped
		 * completely, but that is a massive amount of work and will break current
		 * installs (therefore is on-hold until v2).
		 */
		
		/**
		 * Initialisation options that can be given to DataTables at initialisation
		 * time.
		 *  @namespace
		 */
		DataTable.defaults = {
			/**
			 * An array of data to use for the table, passed in at initialisation which
			 * will be used in preference to any data which is already in the DOM. This is
			 * particularly useful for constructing tables purely in Javascript, for
			 * example with a custom Ajax call.
			 *  @type array
			 *  @default null
			 *
			 *  @dtopt Option
			 *  @name DataTable.defaults.data
			 *
			 *  @example
			 *    // Using a 2D array data source
			 *    $(document).ready( function () {
			 *      $('#example').dataTable( {
			 *        "data": [
			 *          ['Trident', 'Internet Explorer 4.0', 'Win 95+', 4, 'X'],
			 *          ['Trident', 'Internet Explorer 5.0', 'Win 95+', 5, 'C'],
			 *        ],
			 *        "columns": [
			 *          { "title": "Engine" },
			 *          { "title": "Browser" },
			 *          { "title": "Platform" },
			 *          { "title": "Version" },
			 *          { "title": "Grade" }
			 *        ]
			 *      } );
			 *    } );
			 *
			 *  @example
			 *    // Using an array of objects as a data source (`data`)
			 *    $(document).ready( function () {
			 *      $('#example').dataTable( {
			 *        "data": [
			 *          {
			 *            "engine":   "Trident",
			 *            "browser":  "Internet Explorer 4.0",
			 *            "platform": "Win 95+",
			 *            "version":  4,
			 *            "grade":    "X"
			 *          },
			 *          {
			 *            "engine":   "Trident",
			 *            "browser":  "Internet Explorer 5.0",
			 *            "platform": "Win 95+",
			 *            "version":  5,
			 *            "grade":    "C"
			 *          }
			 *        ],
			 *        "columns": [
			 *          { "title": "Engine",   "data": "engine" },
			 *          { "title": "Browser",  "data": "browser" },
			 *          { "title": "Platform", "data": "platform" },
			 *          { "title": "Version",  "data": "version" },
			 *          { "title": "Grade",    "data": "grade" }
			 *        ]
			 *      } );
			 *    } );
			 */
			"aaData": null,
		
		
			/**
			 * If ordering is enabled, then DataTables will perform a first pass sort on
			 * initialisation. You can define which column(s) the sort is performed
			 * upon, and the sorting direction, with this variable. The `sorting` array
			 * should contain an array for each column to be sorted initially containing
			 * the column's index and a direction string ('asc' or 'desc').
			 *  @type array
			 *  @default [[0,'asc']]
			 *
			 *  @dtopt Option
			 *  @name DataTable.defaults.order
			 *
			 *  @example
			 *    // Sort by 3rd column first, and then 4th column
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "order": [[2,'asc'], [3,'desc']]
			 *      } );
			 *    } );
			 *
			 *    // No initial sorting
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "order": []
			 *      } );
			 *    } );
			 */
			"aaSorting": [[0,'asc']],
		
		
			/**
			 * This parameter is basically identical to the `sorting` parameter, but
			 * cannot be overridden by user interaction with the table. What this means
			 * is that you could have a column (visible or hidden) which the sorting
			 * will always be forced on first - any sorting after that (from the user)
			 * will then be performed as required. This can be useful for grouping rows
			 * together.
			 *  @type array
			 *  @default null
			 *
			 *  @dtopt Option
			 *  @name DataTable.defaults.orderFixed
			 *
			 *  @example
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "orderFixed": [[0,'asc']]
			 *      } );
			 *    } )
			 */
			"aaSortingFixed": [],
		
		
			/**
			 * DataTables can be instructed to load data to display in the table from a
			 * Ajax source. This option defines how that Ajax call is made and where to.
			 *
			 * The `ajax` property has three different modes of operation, depending on
			 * how it is defined. These are:
			 *
			 * * `string` - Set the URL from where the data should be loaded from.
			 * * `object` - Define properties for `jQuery.ajax`.
			 * * `function` - Custom data get function
			 *
			 * `string`
			 * --------
			 *
			 * As a string, the `ajax` property simply defines the URL from which
			 * DataTables will load data.
			 *
			 * `object`
			 * --------
			 *
			 * As an object, the parameters in the object are passed to
			 * [jQuery.ajax](http://api.jquery.com/jQuery.ajax/) allowing fine control
			 * of the Ajax request. DataTables has a number of default parameters which
			 * you can override using this option. Please refer to the jQuery
			 * documentation for a full description of the options available, although
			 * the following parameters provide additional options in DataTables or
			 * require special consideration:
			 *
			 * * `data` - As with jQuery, `data` can be provided as an object, but it
			 *   can also be used as a function to manipulate the data DataTables sends
			 *   to the server. The function takes a single parameter, an object of
			 *   parameters with the values that DataTables has readied for sending. An
			 *   object may be returned which will be merged into the DataTables
			 *   defaults, or you can add the items to the object that was passed in and
			 *   not return anything from the function. This supersedes `fnServerParams`
			 *   from DataTables 1.9-.
			 *
			 * * `dataSrc` - By default DataTables will look for the property `data` (or
			 *   `aaData` for compatibility with DataTables 1.9-) when obtaining data
			 *   from an Ajax source or for server-side processing - this parameter
			 *   allows that property to be changed. You can use Javascript dotted
			 *   object notation to get a data source for multiple levels of nesting, or
			 *   it my be used as a function. As a function it takes a single parameter,
			 *   the JSON returned from the server, which can be manipulated as
			 *   required, with the returned value being that used by DataTables as the
			 *   data source for the table. This supersedes `sAjaxDataProp` from
			 *   DataTables 1.9-.
			 *
			 * * `success` - Should not be overridden it is used internally in
			 *   DataTables. To manipulate / transform the data returned by the server
			 *   use `ajax.dataSrc`, or use `ajax` as a function (see below).
			 *
			 * `function`
			 * ----------
			 *
			 * As a function, making the Ajax call is left up to yourself allowing
			 * complete control of the Ajax request. Indeed, if desired, a method other
			 * than Ajax could be used to obtain the required data, such as Web storage
			 * or an AIR database.
			 *
			 * The function is given four parameters and no return is required. The
			 * parameters are:
			 *
			 * 1. _object_ - Data to send to the server
			 * 2. _function_ - Callback function that must be executed when the required
			 *    data has been obtained. That data should be passed into the callback
			 *    as the only parameter
			 * 3. _object_ - DataTables settings object for the table
			 *
			 * Note that this supersedes `fnServerData` from DataTables 1.9-.
			 *
			 *  @type string|object|function
			 *  @default null
			 *
			 *  @dtopt Option
			 *  @name DataTable.defaults.ajax
			 *  @since 1.10.0
			 *
			 * @example
			 *   // Get JSON data from a file via Ajax.
			 *   // Note DataTables expects data in the form `{ data: [ ...data... ] }` by default).
			 *   $('#example').dataTable( {
			 *     "ajax": "data.json"
			 *   } );
			 *
			 * @example
			 *   // Get JSON data from a file via Ajax, using `dataSrc` to change
			 *   // `data` to `tableData` (i.e. `{ tableData: [ ...data... ] }`)
			 *   $('#example').dataTable( {
			 *     "ajax": {
			 *       "url": "data.json",
			 *       "dataSrc": "tableData"
			 *     }
			 *   } );
			 *
			 * @example
			 *   // Get JSON data from a file via Ajax, using `dataSrc` to read data
			 *   // from a plain array rather than an array in an object
			 *   $('#example').dataTable( {
			 *     "ajax": {
			 *       "url": "data.json",
			 *       "dataSrc": ""
			 *     }
			 *   } );
			 *
			 * @example
			 *   // Manipulate the data returned from the server - add a link to data
			 *   // (note this can, should, be done using `render` for the column - this
			 *   // is just a simple example of how the data can be manipulated).
			 *   $('#example').dataTable( {
			 *     "ajax": {
			 *       "url": "data.json",
			 *       "dataSrc": function ( json ) {
			 *         for ( var i=0, ien=json.length ; i<ien ; i++ ) {
			 *           json[i][0] = '<a href="/message/'+json[i][0]+'>View message</a>';
			 *         }
			 *         return json;
			 *       }
			 *     }
			 *   } );
			 *
			 * @example
			 *   // Add data to the request
			 *   $('#example').dataTable( {
			 *     "ajax": {
			 *       "url": "data.json",
			 *       "data": function ( d ) {
			 *         return {
			 *           "extra_search": $('#extra').val()
			 *         };
			 *       }
			 *     }
			 *   } );
			 *
			 * @example
			 *   // Send request as POST
			 *   $('#example').dataTable( {
			 *     "ajax": {
			 *       "url": "data.json",
			 *       "type": "POST"
			 *     }
			 *   } );
			 *
			 * @example
			 *   // Get the data from localStorage (could interface with a form for
			 *   // adding, editing and removing rows).
			 *   $('#example').dataTable( {
			 *     "ajax": function (data, callback, settings) {
			 *       callback(
			 *         JSON.parse( localStorage.getItem('dataTablesData') )
			 *       );
			 *     }
			 *   } );
			 */
			"ajax": null,
		
		
			/**
			 * This parameter allows you to readily specify the entries in the length drop
			 * down menu that DataTables shows when pagination is enabled. It can be
			 * either a 1D array of options which will be used for both the displayed
			 * option and the value, or a 2D array which will use the array in the first
			 * position as the value, and the array in the second position as the
			 * displayed options (useful for language strings such as 'All').
			 *
			 * Note that the `pageLength` property will be automatically set to the
			 * first value given in this array, unless `pageLength` is also provided.
			 *  @type array
			 *  @default [ 10, 25, 50, 100 ]
			 *
			 *  @dtopt Option
			 *  @name DataTable.defaults.lengthMenu
			 *
			 *  @example
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "lengthMenu": [[10, 25, 50, -1], [10, 25, 50, "All"]]
			 *      } );
			 *    } );
			 */
			"aLengthMenu": [ 10, 25, 50, 100 ],
		
		
			/**
			 * The `columns` option in the initialisation parameter allows you to define
			 * details about the way individual columns behave. For a full list of
			 * column options that can be set, please see
			 * {@link DataTable.defaults.column}. Note that if you use `columns` to
			 * define your columns, you must have an entry in the array for every single
			 * column that you have in your table (these can be null if you don't which
			 * to specify any options).
			 *  @member
			 *
			 *  @name DataTable.defaults.column
			 */
			"aoColumns": null,
		
			/**
			 * Very similar to `columns`, `columnDefs` allows you to target a specific
			 * column, multiple columns, or all columns, using the `targets` property of
			 * each object in the array. This allows great flexibility when creating
			 * tables, as the `columnDefs` arrays can be of any length, targeting the
			 * columns you specifically want. `columnDefs` may use any of the column
			 * options available: {@link DataTable.defaults.column}, but it _must_
			 * have `targets` defined in each object in the array. Values in the `targets`
			 * array may be:
			 *   <ul>
			 *     <li>a string - class name will be matched on the TH for the column</li>
			 *     <li>0 or a positive integer - column index counting from the left</li>
			 *     <li>a negative integer - column index counting from the right</li>
			 *     <li>the string "_all" - all columns (i.e. assign a default)</li>
			 *   </ul>
			 *  @member
			 *
			 *  @name DataTable.defaults.columnDefs
			 */
			"aoColumnDefs": null,
		
		
			/**
			 * Basically the same as `search`, this parameter defines the individual column
			 * filtering state at initialisation time. The array must be of the same size
			 * as the number of columns, and each element be an object with the parameters
			 * `search` and `escapeRegex` (the latter is optional). 'null' is also
			 * accepted and the default will be used.
			 *  @type array
			 *  @default []
			 *
			 *  @dtopt Option
			 *  @name DataTable.defaults.searchCols
			 *
			 *  @example
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "searchCols": [
			 *          null,
			 *          { "search": "My filter" },
			 *          null,
			 *          { "search": "^[0-9]", "escapeRegex": false }
			 *        ]
			 *      } );
			 *    } )
			 */
			"aoSearchCols": [],
		
		
			/**
			 * An array of CSS classes that should be applied to displayed rows. This
			 * array may be of any length, and DataTables will apply each class
			 * sequentially, looping when required.
			 *  @type array
			 *  @default null <i>Will take the values determined by the `oClasses.stripe*`
			 *    options</i>
			 *
			 *  @dtopt Option
			 *  @name DataTable.defaults.stripeClasses
			 *
			 *  @example
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "stripeClasses": [ 'strip1', 'strip2', 'strip3' ]
			 *      } );
			 *    } )
			 */
			"asStripeClasses": null,
		
		
			/**
			 * Enable or disable automatic column width calculation. This can be disabled
			 * as an optimisation (it takes some time to calculate the widths) if the
			 * tables widths are passed in using `columns`.
			 *  @type boolean
			 *  @default true
			 *
			 *  @dtopt Features
			 *  @name DataTable.defaults.autoWidth
			 *
			 *  @example
			 *    $(document).ready( function () {
			 *      $('#example').dataTable( {
			 *        "autoWidth": false
			 *      } );
			 *    } );
			 */
			"bAutoWidth": true,
		
		
			/**
			 * Deferred rendering can provide DataTables with a huge speed boost when you
			 * are using an Ajax or JS data source for the table. This option, when set to
			 * true, will cause DataTables to defer the creation of the table elements for
			 * each row until they are needed for a draw - saving a significant amount of
			 * time.
			 *  @type boolean
			 *  @default false
			 *
			 *  @dtopt Features
			 *  @name DataTable.defaults.deferRender
			 *
			 *  @example
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "ajax": "sources/arrays.txt",
			 *        "deferRender": true
			 *      } );
			 *    } );
			 */
			"bDeferRender": false,
		
		
			/**
			 * Replace a DataTable which matches the given selector and replace it with
			 * one which has the properties of the new initialisation object passed. If no
			 * table matches the selector, then the new DataTable will be constructed as
			 * per normal.
			 *  @type boolean
			 *  @default false
			 *
			 *  @dtopt Options
			 *  @name DataTable.defaults.destroy
			 *
			 *  @example
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "srollY": "200px",
			 *        "paginate": false
			 *      } );
			 *
			 *      // Some time later....
			 *      $('#example').dataTable( {
			 *        "filter": false,
			 *        "destroy": true
			 *      } );
			 *    } );
			 */
			"bDestroy": false,
		
		
			/**
			 * Enable or disable filtering of data. Filtering in DataTables is "smart" in
			 * that it allows the end user to input multiple words (space separated) and
			 * will match a row containing those words, even if not in the order that was
			 * specified (this allow matching across multiple columns). Note that if you
			 * wish to use filtering in DataTables this must remain 'true' - to remove the
			 * default filtering input box and retain filtering abilities, please use
			 * {@link DataTable.defaults.dom}.
			 *  @type boolean
			 *  @default true
			 *
			 *  @dtopt Features
			 *  @name DataTable.defaults.searching
			 *
			 *  @example
			 *    $(document).ready( function () {
			 *      $('#example').dataTable( {
			 *        "searching": false
			 *      } );
			 *    } );
			 */
			"bFilter": true,
		
		
			/**
			 * Enable or disable the table information display. This shows information
			 * about the data that is currently visible on the page, including information
			 * about filtered data if that action is being performed.
			 *  @type boolean
			 *  @default true
			 *
			 *  @dtopt Features
			 *  @name DataTable.defaults.info
			 *
			 *  @example
			 *    $(document).ready( function () {
			 *      $('#example').dataTable( {
			 *        "info": false
			 *      } );
			 *    } );
			 */
			"bInfo": true,
		
		
			/**
			 * Enable jQuery UI ThemeRoller support (required as ThemeRoller requires some
			 * slightly different and additional mark-up from what DataTables has
			 * traditionally used).
			 *  @type boolean
			 *  @default false
			 *
			 *  @dtopt Features
			 *  @name DataTable.defaults.jQueryUI
			 *
			 *  @example
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "jQueryUI": true
			 *      } );
			 *    } );
			 */
			"bJQueryUI": false,
		
		
			/**
			 * Allows the end user to select the size of a formatted page from a select
			 * menu (sizes are 10, 25, 50 and 100). Requires pagination (`paginate`).
			 *  @type boolean
			 *  @default true
			 *
			 *  @dtopt Features
			 *  @name DataTable.defaults.lengthChange
			 *
			 *  @example
			 *    $(document).ready( function () {
			 *      $('#example').dataTable( {
			 *        "lengthChange": false
			 *      } );
			 *    } );
			 */
			"bLengthChange": true,
		
		
			/**
			 * Enable or disable pagination.
			 *  @type boolean
			 *  @default true
			 *
			 *  @dtopt Features
			 *  @name DataTable.defaults.paging
			 *
			 *  @example
			 *    $(document).ready( function () {
			 *      $('#example').dataTable( {
			 *        "paging": false
			 *      } );
			 *    } );
			 */
			"bPaginate": true,
		
		
			/**
			 * Enable or disable the display of a 'processing' indicator when the table is
			 * being processed (e.g. a sort). This is particularly useful for tables with
			 * large amounts of data where it can take a noticeable amount of time to sort
			 * the entries.
			 *  @type boolean
			 *  @default false
			 *
			 *  @dtopt Features
			 *  @name DataTable.defaults.processing
			 *
			 *  @example
			 *    $(document).ready( function () {
			 *      $('#example').dataTable( {
			 *        "processing": true
			 *      } );
			 *    } );
			 */
			"bProcessing": false,
		
		
			/**
			 * Retrieve the DataTables object for the given selector. Note that if the
			 * table has already been initialised, this parameter will cause DataTables
			 * to simply return the object that has already been set up - it will not take
			 * account of any changes you might have made to the initialisation object
			 * passed to DataTables (setting this parameter to true is an acknowledgement
			 * that you understand this). `destroy` can be used to reinitialise a table if
			 * you need.
			 *  @type boolean
			 *  @default false
			 *
			 *  @dtopt Options
			 *  @name DataTable.defaults.retrieve
			 *
			 *  @example
			 *    $(document).ready( function() {
			 *      initTable();
			 *      tableActions();
			 *    } );
			 *
			 *    function initTable ()
			 *    {
			 *      return $('#example').dataTable( {
			 *        "scrollY": "200px",
			 *        "paginate": false,
			 *        "retrieve": true
			 *      } );
			 *    }
			 *
			 *    function tableActions ()
			 *    {
			 *      var table = initTable();
			 *      // perform API operations with oTable
			 *    }
			 */
			"bRetrieve": false,
		
		
			/**
			 * When vertical (y) scrolling is enabled, DataTables will force the height of
			 * the table's viewport to the given height at all times (useful for layout).
			 * However, this can look odd when filtering data down to a small data set,
			 * and the footer is left "floating" further down. This parameter (when
			 * enabled) will cause DataTables to collapse the table's viewport down when
			 * the result set will fit within the given Y height.
			 *  @type boolean
			 *  @default false
			 *
			 *  @dtopt Options
			 *  @name DataTable.defaults.scrollCollapse
			 *
			 *  @example
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "scrollY": "200",
			 *        "scrollCollapse": true
			 *      } );
			 *    } );
			 */
			"bScrollCollapse": false,
		
		
			/**
			 * Configure DataTables to use server-side processing. Note that the
			 * `ajax` parameter must also be given in order to give DataTables a
			 * source to obtain the required data for each draw.
			 *  @type boolean
			 *  @default false
			 *
			 *  @dtopt Features
			 *  @dtopt Server-side
			 *  @name DataTable.defaults.serverSide
			 *
			 *  @example
			 *    $(document).ready( function () {
			 *      $('#example').dataTable( {
			 *        "serverSide": true,
			 *        "ajax": "xhr.php"
			 *      } );
			 *    } );
			 */
			"bServerSide": false,
		
		
			/**
			 * Enable or disable sorting of columns. Sorting of individual columns can be
			 * disabled by the `sortable` option for each column.
			 *  @type boolean
			 *  @default true
			 *
			 *  @dtopt Features
			 *  @name DataTable.defaults.ordering
			 *
			 *  @example
			 *    $(document).ready( function () {
			 *      $('#example').dataTable( {
			 *        "ordering": false
			 *      } );
			 *    } );
			 */
			"bSort": true,
		
		
			/**
			 * Enable or display DataTables' ability to sort multiple columns at the
			 * same time (activated by shift-click by the user).
			 *  @type boolean
			 *  @default true
			 *
			 *  @dtopt Options
			 *  @name DataTable.defaults.orderMulti
			 *
			 *  @example
			 *    // Disable multiple column sorting ability
			 *    $(document).ready( function () {
			 *      $('#example').dataTable( {
			 *        "orderMulti": false
			 *      } );
			 *    } );
			 */
			"bSortMulti": true,
		
		
			/**
			 * Allows control over whether DataTables should use the top (true) unique
			 * cell that is found for a single column, or the bottom (false - default).
			 * This is useful when using complex headers.
			 *  @type boolean
			 *  @default false
			 *
			 *  @dtopt Options
			 *  @name DataTable.defaults.orderCellsTop
			 *
			 *  @example
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "orderCellsTop": true
			 *      } );
			 *    } );
			 */
			"bSortCellsTop": false,
		
		
			/**
			 * Enable or disable the addition of the classes `sorting\_1`, `sorting\_2` and
			 * `sorting\_3` to the columns which are currently being sorted on. This is
			 * presented as a feature switch as it can increase processing time (while
			 * classes are removed and added) so for large data sets you might want to
			 * turn this off.
			 *  @type boolean
			 *  @default true
			 *
			 *  @dtopt Features
			 *  @name DataTable.defaults.orderClasses
			 *
			 *  @example
			 *    $(document).ready( function () {
			 *      $('#example').dataTable( {
			 *        "orderClasses": false
			 *      } );
			 *    } );
			 */
			"bSortClasses": true,
		
		
			/**
			 * Enable or disable state saving. When enabled HTML5 `localStorage` will be
			 * used to save table display information such as pagination information,
			 * display length, filtering and sorting. As such when the end user reloads
			 * the page the display display will match what thy had previously set up.
			 *
			 * Due to the use of `localStorage` the default state saving is not supported
			 * in IE6 or 7. If state saving is required in those browsers, use
			 * `stateSaveCallback` to provide a storage solution such as cookies.
			 *  @type boolean
			 *  @default false
			 *
			 *  @dtopt Features
			 *  @name DataTable.defaults.stateSave
			 *
			 *  @example
			 *    $(document).ready( function () {
			 *      $('#example').dataTable( {
			 *        "stateSave": true
			 *      } );
			 *    } );
			 */
			"bStateSave": false,
		
		
			/**
			 * This function is called when a TR element is created (and all TD child
			 * elements have been inserted), or registered if using a DOM source, allowing
			 * manipulation of the TR element (adding classes etc).
			 *  @type function
			 *  @param {node} row "TR" element for the current row
			 *  @param {array} data Raw data array for this row
			 *  @param {int} dataIndex The index of this row in the internal aoData array
			 *
			 *  @dtopt Callbacks
			 *  @name DataTable.defaults.createdRow
			 *
			 *  @example
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "createdRow": function( row, data, dataIndex ) {
			 *          // Bold the grade for all 'A' grade browsers
			 *          if ( data[4] == "A" )
			 *          {
			 *            $('td:eq(4)', row).html( '<b>A</b>' );
			 *          }
			 *        }
			 *      } );
			 *    } );
			 */
			"fnCreatedRow": null,
		
		
			/**
			 * This function is called on every 'draw' event, and allows you to
			 * dynamically modify any aspect you want about the created DOM.
			 *  @type function
			 *  @param {object} settings DataTables settings object
			 *
			 *  @dtopt Callbacks
			 *  @name DataTable.defaults.drawCallback
			 *
			 *  @example
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "drawCallback": function( settings ) {
			 *          alert( 'DataTables has redrawn the table' );
			 *        }
			 *      } );
			 *    } );
			 */
			"fnDrawCallback": null,
		
		
			/**
			 * Identical to fnHeaderCallback() but for the table footer this function
			 * allows you to modify the table footer on every 'draw' event.
			 *  @type function
			 *  @param {node} foot "TR" element for the footer
			 *  @param {array} data Full table data (as derived from the original HTML)
			 *  @param {int} start Index for the current display starting point in the
			 *    display array
			 *  @param {int} end Index for the current display ending point in the
			 *    display array
			 *  @param {array int} display Index array to translate the visual position
			 *    to the full data array
			 *
			 *  @dtopt Callbacks
			 *  @name DataTable.defaults.footerCallback
			 *
			 *  @example
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "footerCallback": function( tfoot, data, start, end, display ) {
			 *          tfoot.getElementsByTagName('th')[0].innerHTML = "Starting index is "+start;
			 *        }
			 *      } );
			 *    } )
			 */
			"fnFooterCallback": null,
		
		
			/**
			 * When rendering large numbers in the information element for the table
			 * (i.e. "Showing 1 to 10 of 57 entries") DataTables will render large numbers
			 * to have a comma separator for the 'thousands' units (e.g. 1 million is
			 * rendered as "1,000,000") to help readability for the end user. This
			 * function will override the default method DataTables uses.
			 *  @type function
			 *  @member
			 *  @param {int} toFormat number to be formatted
			 *  @returns {string} formatted string for DataTables to show the number
			 *
			 *  @dtopt Callbacks
			 *  @name DataTable.defaults.formatNumber
			 *
			 *  @example
			 *    // Format a number using a single quote for the separator (note that
			 *    // this can also be done with the language.thousands option)
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "formatNumber": function ( toFormat ) {
			 *          return toFormat.toString().replace(
			 *            /\B(?=(\d{3})+(?!\d))/g, "'"
			 *          );
			 *        };
			 *      } );
			 *    } );
			 */
			"fnFormatNumber": function ( toFormat ) {
				return toFormat.toString().replace(
					/\B(?=(\d{3})+(?!\d))/g,
					this.oLanguage.sThousands
				);
			},
		
		
			/**
			 * This function is called on every 'draw' event, and allows you to
			 * dynamically modify the header row. This can be used to calculate and
			 * display useful information about the table.
			 *  @type function
			 *  @param {node} head "TR" element for the header
			 *  @param {array} data Full table data (as derived from the original HTML)
			 *  @param {int} start Index for the current display starting point in the
			 *    display array
			 *  @param {int} end Index for the current display ending point in the
			 *    display array
			 *  @param {array int} display Index array to translate the visual position
			 *    to the full data array
			 *
			 *  @dtopt Callbacks
			 *  @name DataTable.defaults.headerCallback
			 *
			 *  @example
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "fheaderCallback": function( head, data, start, end, display ) {
			 *          head.getElementsByTagName('th')[0].innerHTML = "Displaying "+(end-start)+" records";
			 *        }
			 *      } );
			 *    } )
			 */
			"fnHeaderCallback": null,
		
		
			/**
			 * The information element can be used to convey information about the current
			 * state of the table. Although the internationalisation options presented by
			 * DataTables are quite capable of dealing with most customisations, there may
			 * be times where you wish to customise the string further. This callback
			 * allows you to do exactly that.
			 *  @type function
			 *  @param {object} oSettings DataTables settings object
			 *  @param {int} start Starting position in data for the draw
			 *  @param {int} end End position in data for the draw
			 *  @param {int} max Total number of rows in the table (regardless of
			 *    filtering)
			 *  @param {int} total Total number of rows in the data set, after filtering
			 *  @param {string} pre The string that DataTables has formatted using it's
			 *    own rules
			 *  @returns {string} The string to be displayed in the information element.
			 *
			 *  @dtopt Callbacks
			 *  @name DataTable.defaults.infoCallback
			 *
			 *  @example
			 *    $('#example').dataTable( {
			 *      "infoCallback": function( settings, start, end, max, total, pre ) {
			 *        return start +" to "+ end;
			 *      }
			 *    } );
			 */
			"fnInfoCallback": null,
		
		
			/**
			 * Called when the table has been initialised. Normally DataTables will
			 * initialise sequentially and there will be no need for this function,
			 * however, this does not hold true when using external language information
			 * since that is obtained using an async XHR call.
			 *  @type function
			 *  @param {object} settings DataTables settings object
			 *  @param {object} json The JSON object request from the server - only
			 *    present if client-side Ajax sourced data is used
			 *
			 *  @dtopt Callbacks
			 *  @name DataTable.defaults.initComplete
			 *
			 *  @example
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "initComplete": function(settings, json) {
			 *          alert( 'DataTables has finished its initialisation.' );
			 *        }
			 *      } );
			 *    } )
			 */
			"fnInitComplete": null,
		
		
			/**
			 * Called at the very start of each table draw and can be used to cancel the
			 * draw by returning false, any other return (including undefined) results in
			 * the full draw occurring).
			 *  @type function
			 *  @param {object} settings DataTables settings object
			 *  @returns {boolean} False will cancel the draw, anything else (including no
			 *    return) will allow it to complete.
			 *
			 *  @dtopt Callbacks
			 *  @name DataTable.defaults.preDrawCallback
			 *
			 *  @example
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "preDrawCallback": function( settings ) {
			 *          if ( $('#test').val() == 1 ) {
			 *            return false;
			 *          }
			 *        }
			 *      } );
			 *    } );
			 */
			"fnPreDrawCallback": null,
		
		
			/**
			 * This function allows you to 'post process' each row after it have been
			 * generated for each table draw, but before it is rendered on screen. This
			 * function might be used for setting the row class name etc.
			 *  @type function
			 *  @param {node} row "TR" element for the current row
			 *  @param {array} data Raw data array for this row
			 *  @param {int} displayIndex The display index for the current table draw
			 *  @param {int} displayIndexFull The index of the data in the full list of
			 *    rows (after filtering)
			 *
			 *  @dtopt Callbacks
			 *  @name DataTable.defaults.rowCallback
			 *
			 *  @example
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "rowCallback": function( row, data, displayIndex, displayIndexFull ) {
			 *          // Bold the grade for all 'A' grade browsers
			 *          if ( data[4] == "A" ) {
			 *            $('td:eq(4)', row).html( '<b>A</b>' );
			 *          }
			 *        }
			 *      } );
			 *    } );
			 */
			"fnRowCallback": null,
		
		
			/**
			 * __Deprecated__ The functionality provided by this parameter has now been
			 * superseded by that provided through `ajax`, which should be used instead.
			 *
			 * This parameter allows you to override the default function which obtains
			 * the data from the server so something more suitable for your application.
			 * For example you could use POST data, or pull information from a Gears or
			 * AIR database.
			 *  @type function
			 *  @member
			 *  @param {string} source HTTP source to obtain the data from (`ajax`)
			 *  @param {array} data A key/value pair object containing the data to send
			 *    to the server
			 *  @param {function} callback to be called on completion of the data get
			 *    process that will draw the data on the page.
			 *  @param {object} settings DataTables settings object
			 *
			 *  @dtopt Callbacks
			 *  @dtopt Server-side
			 *  @name DataTable.defaults.serverData
			 *
			 *  @deprecated 1.10. Please use `ajax` for this functionality now.
			 */
			"fnServerData": null,
		
		
			/**
			 * __Deprecated__ The functionality provided by this parameter has now been
			 * superseded by that provided through `ajax`, which should be used instead.
			 *
			 *  It is often useful to send extra data to the server when making an Ajax
			 * request - for example custom filtering information, and this callback
			 * function makes it trivial to send extra information to the server. The
			 * passed in parameter is the data set that has been constructed by
			 * DataTables, and you can add to this or modify it as you require.
			 *  @type function
			 *  @param {array} data Data array (array of objects which are name/value
			 *    pairs) that has been constructed by DataTables and will be sent to the
			 *    server. In the case of Ajax sourced data with server-side processing
			 *    this will be an empty array, for server-side processing there will be a
			 *    significant number of parameters!
			 *  @returns {undefined} Ensure that you modify the data array passed in,
			 *    as this is passed by reference.
			 *
			 *  @dtopt Callbacks
			 *  @dtopt Server-side
			 *  @name DataTable.defaults.serverParams
			 *
			 *  @deprecated 1.10. Please use `ajax` for this functionality now.
			 */
			"fnServerParams": null,
		
		
			/**
			 * Load the table state. With this function you can define from where, and how, the
			 * state of a table is loaded. By default DataTables will load from `localStorage`
			 * but you might wish to use a server-side database or cookies.
			 *  @type function
			 *  @member
			 *  @param {object} settings DataTables settings object
			 *  @return {object} The DataTables state object to be loaded
			 *
			 *  @dtopt Callbacks
			 *  @name DataTable.defaults.stateLoadCallback
			 *
			 *  @example
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "stateSave": true,
			 *        "stateLoadCallback": function (settings) {
			 *          var o;
			 *
			 *          // Send an Ajax request to the server to get the data. Note that
			 *          // this is a synchronous request.
			 *          $.ajax( {
			 *            "url": "/state_load",
			 *            "async": false,
			 *            "dataType": "json",
			 *            "success": function (json) {
			 *              o = json;
			 *            }
			 *          } );
			 *
			 *          return o;
			 *        }
			 *      } );
			 *    } );
			 */
			"fnStateLoadCallback": function ( settings ) {
				try {
					return JSON.parse(
						(settings.iStateDuration === -1 ? sessionStorage : localStorage).getItem(
							'DataTables_'+settings.sInstance+'_'+location.pathname
						)
					);
				} catch (e) {}
			},
		
		
			/**
			 * Callback which allows modification of the saved state prior to loading that state.
			 * This callback is called when the table is loading state from the stored data, but
			 * prior to the settings object being modified by the saved state. Note that for
			 * plug-in authors, you should use the `stateLoadParams` event to load parameters for
			 * a plug-in.
			 *  @type function
			 *  @param {object} settings DataTables settings object
			 *  @param {object} data The state object that is to be loaded
			 *
			 *  @dtopt Callbacks
			 *  @name DataTable.defaults.stateLoadParams
			 *
			 *  @example
			 *    // Remove a saved filter, so filtering is never loaded
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "stateSave": true,
			 *        "stateLoadParams": function (settings, data) {
			 *          data.oSearch.sSearch = "";
			 *        }
			 *      } );
			 *    } );
			 *
			 *  @example
			 *    // Disallow state loading by returning false
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "stateSave": true,
			 *        "stateLoadParams": function (settings, data) {
			 *          return false;
			 *        }
			 *      } );
			 *    } );
			 */
			"fnStateLoadParams": null,
		
		
			/**
			 * Callback that is called when the state has been loaded from the state saving method
			 * and the DataTables settings object has been modified as a result of the loaded state.
			 *  @type function
			 *  @param {object} settings DataTables settings object
			 *  @param {object} data The state object that was loaded
			 *
			 *  @dtopt Callbacks
			 *  @name DataTable.defaults.stateLoaded
			 *
			 *  @example
			 *    // Show an alert with the filtering value that was saved
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "stateSave": true,
			 *        "stateLoaded": function (settings, data) {
			 *          alert( 'Saved filter was: '+data.oSearch.sSearch );
			 *        }
			 *      } );
			 *    } );
			 */
			"fnStateLoaded": null,
		
		
			/**
			 * Save the table state. This function allows you to define where and how the state
			 * information for the table is stored By default DataTables will use `localStorage`
			 * but you might wish to use a server-side database or cookies.
			 *  @type function
			 *  @member
			 *  @param {object} settings DataTables settings object
			 *  @param {object} data The state object to be saved
			 *
			 *  @dtopt Callbacks
			 *  @name DataTable.defaults.stateSaveCallback
			 *
			 *  @example
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "stateSave": true,
			 *        "stateSaveCallback": function (settings, data) {
			 *          // Send an Ajax request to the server with the state object
			 *          $.ajax( {
			 *            "url": "/state_save",
			 *            "data": data,
			 *            "dataType": "json",
			 *            "method": "POST"
			 *            "success": function () {}
			 *          } );
			 *        }
			 *      } );
			 *    } );
			 */
			"fnStateSaveCallback": function ( settings, data ) {
				try {
					(settings.iStateDuration === -1 ? sessionStorage : localStorage).setItem(
						'DataTables_'+settings.sInstance+'_'+location.pathname,
						JSON.stringify( data )
					);
				} catch (e) {}
			},
		
		
			/**
			 * Callback which allows modification of the state to be saved. Called when the table
			 * has changed state a new state save is required. This method allows modification of
			 * the state saving object prior to actually doing the save, including addition or
			 * other state properties or modification. Note that for plug-in authors, you should
			 * use the `stateSaveParams` event to save parameters for a plug-in.
			 *  @type function
			 *  @param {object} settings DataTables settings object
			 *  @param {object} data The state object to be saved
			 *
			 *  @dtopt Callbacks
			 *  @name DataTable.defaults.stateSaveParams
			 *
			 *  @example
			 *    // Remove a saved filter, so filtering is never saved
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "stateSave": true,
			 *        "stateSaveParams": function (settings, data) {
			 *          data.oSearch.sSearch = "";
			 *        }
			 *      } );
			 *    } );
			 */
			"fnStateSaveParams": null,
		
		
			/**
			 * Duration for which the saved state information is considered valid. After this period
			 * has elapsed the state will be returned to the default.
			 * Value is given in seconds.
			 *  @type int
			 *  @default 7200 <i>(2 hours)</i>
			 *
			 *  @dtopt Options
			 *  @name DataTable.defaults.stateDuration
			 *
			 *  @example
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "stateDuration": 60*60*24; // 1 day
			 *      } );
			 *    } )
			 */
			"iStateDuration": 7200,
		
		
			/**
			 * When enabled DataTables will not make a request to the server for the first
			 * page draw - rather it will use the data already on the page (no sorting etc
			 * will be applied to it), thus saving on an XHR at load time. `deferLoading`
			 * is used to indicate that deferred loading is required, but it is also used
			 * to tell DataTables how many records there are in the full table (allowing
			 * the information element and pagination to be displayed correctly). In the case
			 * where a filtering is applied to the table on initial load, this can be
			 * indicated by giving the parameter as an array, where the first element is
			 * the number of records available after filtering and the second element is the
			 * number of records without filtering (allowing the table information element
			 * to be shown correctly).
			 *  @type int | array
			 *  @default null
			 *
			 *  @dtopt Options
			 *  @name DataTable.defaults.deferLoading
			 *
			 *  @example
			 *    // 57 records available in the table, no filtering applied
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "serverSide": true,
			 *        "ajax": "scripts/server_processing.php",
			 *        "deferLoading": 57
			 *      } );
			 *    } );
			 *
			 *  @example
			 *    // 57 records after filtering, 100 without filtering (an initial filter applied)
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "serverSide": true,
			 *        "ajax": "scripts/server_processing.php",
			 *        "deferLoading": [ 57, 100 ],
			 *        "search": {
			 *          "search": "my_filter"
			 *        }
			 *      } );
			 *    } );
			 */
			"iDeferLoading": null,
		
		
			/**
			 * Number of rows to display on a single page when using pagination. If
			 * feature enabled (`lengthChange`) then the end user will be able to override
			 * this to a custom setting using a pop-up menu.
			 *  @type int
			 *  @default 10
			 *
			 *  @dtopt Options
			 *  @name DataTable.defaults.pageLength
			 *
			 *  @example
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "pageLength": 50
			 *      } );
			 *    } )
			 */
			"iDisplayLength": 10,
		
		
			/**
			 * Define the starting point for data display when using DataTables with
			 * pagination. Note that this parameter is the number of records, rather than
			 * the page number, so if you have 10 records per page and want to start on
			 * the third page, it should be "20".
			 *  @type int
			 *  @default 0
			 *
			 *  @dtopt Options
			 *  @name DataTable.defaults.displayStart
			 *
			 *  @example
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "displayStart": 20
			 *      } );
			 *    } )
			 */
			"iDisplayStart": 0,
		
		
			/**
			 * By default DataTables allows keyboard navigation of the table (sorting, paging,
			 * and filtering) by adding a `tabindex` attribute to the required elements. This
			 * allows you to tab through the controls and press the enter key to activate them.
			 * The tabindex is default 0, meaning that the tab follows the flow of the document.
			 * You can overrule this using this parameter if you wish. Use a value of -1 to
			 * disable built-in keyboard navigation.
			 *  @type int
			 *  @default 0
			 *
			 *  @dtopt Options
			 *  @name DataTable.defaults.tabIndex
			 *
			 *  @example
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "tabIndex": 1
			 *      } );
			 *    } );
			 */
			"iTabIndex": 0,
		
		
			/**
			 * Classes that DataTables assigns to the various components and features
			 * that it adds to the HTML table. This allows classes to be configured
			 * during initialisation in addition to through the static
			 * {@link DataTable.ext.oStdClasses} object).
			 *  @namespace
			 *  @name DataTable.defaults.classes
			 */
			"oClasses": {},
		
		
			/**
			 * All strings that DataTables uses in the user interface that it creates
			 * are defined in this object, allowing you to modified them individually or
			 * completely replace them all as required.
			 *  @namespace
			 *  @name DataTable.defaults.language
			 */
			"oLanguage": {
				/**
				 * Strings that are used for WAI-ARIA labels and controls only (these are not
				 * actually visible on the page, but will be read by screenreaders, and thus
				 * must be internationalised as well).
				 *  @namespace
				 *  @name DataTable.defaults.language.aria
				 */
				"oAria": {
					/**
					 * ARIA label that is added to the table headers when the column may be
					 * sorted ascending by activing the column (click or return when focused).
					 * Note that the column header is prefixed to this string.
					 *  @type string
					 *  @default : activate to sort column ascending
					 *
					 *  @dtopt Language
					 *  @name DataTable.defaults.language.aria.sortAscending
					 *
					 *  @example
					 *    $(document).ready( function() {
					 *      $('#example').dataTable( {
					 *        "language": {
					 *          "aria": {
					 *            "sortAscending": " - click/return to sort ascending"
					 *          }
					 *        }
					 *      } );
					 *    } );
					 */
					"sSortAscending": ": activate to sort column ascending",
		
					/**
					 * ARIA label that is added to the table headers when the column may be
					 * sorted descending by activing the column (click or return when focused).
					 * Note that the column header is prefixed to this string.
					 *  @type string
					 *  @default : activate to sort column ascending
					 *
					 *  @dtopt Language
					 *  @name DataTable.defaults.language.aria.sortDescending
					 *
					 *  @example
					 *    $(document).ready( function() {
					 *      $('#example').dataTable( {
					 *        "language": {
					 *          "aria": {
					 *            "sortDescending": " - click/return to sort descending"
					 *          }
					 *        }
					 *      } );
					 *    } );
					 */
					"sSortDescending": ": activate to sort column descending"
				},
		
				/**
				 * Pagination string used by DataTables for the built-in pagination
				 * control types.
				 *  @namespace
				 *  @name DataTable.defaults.language.paginate
				 */
				"oPaginate": {
					/**
					 * Text to use when using the 'full_numbers' type of pagination for the
					 * button to take the user to the first page.
					 *  @type string
					 *  @default First
					 *
					 *  @dtopt Language
					 *  @name DataTable.defaults.language.paginate.first
					 *
					 *  @example
					 *    $(document).ready( function() {
					 *      $('#example').dataTable( {
					 *        "language": {
					 *          "paginate": {
					 *            "first": "First page"
					 *          }
					 *        }
					 *      } );
					 *    } );
					 */
					"sFirst": "First",
		
		
					/**
					 * Text to use when using the 'full_numbers' type of pagination for the
					 * button to take the user to the last page.
					 *  @type string
					 *  @default Last
					 *
					 *  @dtopt Language
					 *  @name DataTable.defaults.language.paginate.last
					 *
					 *  @example
					 *    $(document).ready( function() {
					 *      $('#example').dataTable( {
					 *        "language": {
					 *          "paginate": {
					 *            "last": "Last page"
					 *          }
					 *        }
					 *      } );
					 *    } );
					 */
					"sLast": "Last",
		
		
					/**
					 * Text to use for the 'next' pagination button (to take the user to the
					 * next page).
					 *  @type string
					 *  @default Next
					 *
					 *  @dtopt Language
					 *  @name DataTable.defaults.language.paginate.next
					 *
					 *  @example
					 *    $(document).ready( function() {
					 *      $('#example').dataTable( {
					 *        "language": {
					 *          "paginate": {
					 *            "next": "Next page"
					 *          }
					 *        }
					 *      } );
					 *    } );
					 */
					"sNext": "Next",
		
		
					/**
					 * Text to use for the 'previous' pagination button (to take the user to
					 * the previous page).
					 *  @type string
					 *  @default Previous
					 *
					 *  @dtopt Language
					 *  @name DataTable.defaults.language.paginate.previous
					 *
					 *  @example
					 *    $(document).ready( function() {
					 *      $('#example').dataTable( {
					 *        "language": {
					 *          "paginate": {
					 *            "previous": "Previous page"
					 *          }
					 *        }
					 *      } );
					 *    } );
					 */
					"sPrevious": "Previous"
				},
		
				/**
				 * This string is shown in preference to `zeroRecords` when the table is
				 * empty of data (regardless of filtering). Note that this is an optional
				 * parameter - if it is not given, the value of `zeroRecords` will be used
				 * instead (either the default or given value).
				 *  @type string
				 *  @default No data available in table
				 *
				 *  @dtopt Language
				 *  @name DataTable.defaults.language.emptyTable
				 *
				 *  @example
				 *    $(document).ready( function() {
				 *      $('#example').dataTable( {
				 *        "language": {
				 *          "emptyTable": "No data available in table"
				 *        }
				 *      } );
				 *    } );
				 */
				"sEmptyTable": "No data available in table",
		
		
				/**
				 * This string gives information to the end user about the information
				 * that is current on display on the page. The following tokens can be
				 * used in the string and will be dynamically replaced as the table
				 * display updates. This tokens can be placed anywhere in the string, or
				 * removed as needed by the language requires:
				 *
				 * * `\_START\_` - Display index of the first record on the current page
				 * * `\_END\_` - Display index of the last record on the current page
				 * * `\_TOTAL\_` - Number of records in the table after filtering
				 * * `\_MAX\_` - Number of records in the table without filtering
				 * * `\_PAGE\_` - Current page number
				 * * `\_PAGES\_` - Total number of pages of data in the table
				 *
				 *  @type string
				 *  @default Showing _START_ to _END_ of _TOTAL_ entries
				 *
				 *  @dtopt Language
				 *  @name DataTable.defaults.language.info
				 *
				 *  @example
				 *    $(document).ready( function() {
				 *      $('#example').dataTable( {
				 *        "language": {
				 *          "info": "Showing page _PAGE_ of _PAGES_"
				 *        }
				 *      } );
				 *    } );
				 */
				"sInfo": "Showing _START_ to _END_ of _TOTAL_ entries",
		
		
				/**
				 * Display information string for when the table is empty. Typically the
				 * format of this string should match `info`.
				 *  @type string
				 *  @default Showing 0 to 0 of 0 entries
				 *
				 *  @dtopt Language
				 *  @name DataTable.defaults.language.infoEmpty
				 *
				 *  @example
				 *    $(document).ready( function() {
				 *      $('#example').dataTable( {
				 *        "language": {
				 *          "infoEmpty": "No entries to show"
				 *        }
				 *      } );
				 *    } );
				 */
				"sInfoEmpty": "Showing 0 to 0 of 0 entries",
		
		
				/**
				 * When a user filters the information in a table, this string is appended
				 * to the information (`info`) to give an idea of how strong the filtering
				 * is. The variable _MAX_ is dynamically updated.
				 *  @type string
				 *  @default (filtered from _MAX_ total entries)
				 *
				 *  @dtopt Language
				 *  @name DataTable.defaults.language.infoFiltered
				 *
				 *  @example
				 *    $(document).ready( function() {
				 *      $('#example').dataTable( {
				 *        "language": {
				 *          "infoFiltered": " - filtering from _MAX_ records"
				 *        }
				 *      } );
				 *    } );
				 */
				"sInfoFiltered": "(filtered from _MAX_ total entries)",
		
		
				/**
				 * If can be useful to append extra information to the info string at times,
				 * and this variable does exactly that. This information will be appended to
				 * the `info` (`infoEmpty` and `infoFiltered` in whatever combination they are
				 * being used) at all times.
				 *  @type string
				 *  @default <i>Empty string</i>
				 *
				 *  @dtopt Language
				 *  @name DataTable.defaults.language.infoPostFix
				 *
				 *  @example
				 *    $(document).ready( function() {
				 *      $('#example').dataTable( {
				 *        "language": {
				 *          "infoPostFix": "All records shown are derived from real information."
				 *        }
				 *      } );
				 *    } );
				 */
				"sInfoPostFix": "",
		
		
				/**
				 * This decimal place operator is a little different from the other
				 * language options since DataTables doesn't output floating point
				 * numbers, so it won't ever use this for display of a number. Rather,
				 * what this parameter does is modify the sort methods of the table so
				 * that numbers which are in a format which has a character other than
				 * a period (`.`) as a decimal place will be sorted numerically.
				 *
				 * Note that numbers with different decimal places cannot be shown in
				 * the same table and still be sortable, the table must be consistent.
				 * However, multiple different tables on the page can use different
				 * decimal place characters.
				 *  @type string
				 *  @default 
				 *
				 *  @dtopt Language
				 *  @name DataTable.defaults.language.decimal
				 *
				 *  @example
				 *    $(document).ready( function() {
				 *      $('#example').dataTable( {
				 *        "language": {
				 *          "decimal": ","
				 *          "thousands": "."
				 *        }
				 *      } );
				 *    } );
				 */
				"sDecimal": "",
		
		
				/**
				 * DataTables has a build in number formatter (`formatNumber`) which is
				 * used to format large numbers that are used in the table information.
				 * By default a comma is used, but this can be trivially changed to any
				 * character you wish with this parameter.
				 *  @type string
				 *  @default ,
				 *
				 *  @dtopt Language
				 *  @name DataTable.defaults.language.thousands
				 *
				 *  @example
				 *    $(document).ready( function() {
				 *      $('#example').dataTable( {
				 *        "language": {
				 *          "thousands": "'"
				 *        }
				 *      } );
				 *    } );
				 */
				"sThousands": ",",
		
		
				/**
				 * Detail the action that will be taken when the drop down menu for the
				 * pagination length option is changed. The '_MENU_' variable is replaced
				 * with a default select list of 10, 25, 50 and 100, and can be replaced
				 * with a custom select box if required.
				 *  @type string
				 *  @default Show _MENU_ entries
				 *
				 *  @dtopt Language
				 *  @name DataTable.defaults.language.lengthMenu
				 *
				 *  @example
				 *    // Language change only
				 *    $(document).ready( function() {
				 *      $('#example').dataTable( {
				 *        "language": {
				 *          "lengthMenu": "Display _MENU_ records"
				 *        }
				 *      } );
				 *    } );
				 *
				 *  @example
				 *    // Language and options change
				 *    $(document).ready( function() {
				 *      $('#example').dataTable( {
				 *        "language": {
				 *          "lengthMenu": 'Display <select>'+
				 *            '<option value="10">10</option>'+
				 *            '<option value="20">20</option>'+
				 *            '<option value="30">30</option>'+
				 *            '<option value="40">40</option>'+
				 *            '<option value="50">50</option>'+
				 *            '<option value="-1">All</option>'+
				 *            '</select> records'
				 *        }
				 *      } );
				 *    } );
				 */
				"sLengthMenu": "Show _MENU_ entries",
		
		
				/**
				 * When using Ajax sourced data and during the first draw when DataTables is
				 * gathering the data, this message is shown in an empty row in the table to
				 * indicate to the end user the the data is being loaded. Note that this
				 * parameter is not used when loading data by server-side processing, just
				 * Ajax sourced data with client-side processing.
				 *  @type string
				 *  @default Loading...
				 *
				 *  @dtopt Language
				 *  @name DataTable.defaults.language.loadingRecords
				 *
				 *  @example
				 *    $(document).ready( function() {
				 *      $('#example').dataTable( {
				 *        "language": {
				 *          "loadingRecords": "Please wait - loading..."
				 *        }
				 *      } );
				 *    } );
				 */
				"sLoadingRecords": "Loading...",
		
		
				/**
				 * Text which is displayed when the table is processing a user action
				 * (usually a sort command or similar).
				 *  @type string
				 *  @default Processing...
				 *
				 *  @dtopt Language
				 *  @name DataTable.defaults.language.processing
				 *
				 *  @example
				 *    $(document).ready( function() {
				 *      $('#example').dataTable( {
				 *        "language": {
				 *          "processing": "DataTables is currently busy"
				 *        }
				 *      } );
				 *    } );
				 */
				"sProcessing": "Processing...",
		
		
				/**
				 * Details the actions that will be taken when the user types into the
				 * filtering input text box. The variable "_INPUT_", if used in the string,
				 * is replaced with the HTML text box for the filtering input allowing
				 * control over where it appears in the string. If "_INPUT_" is not given
				 * then the input box is appended to the string automatically.
				 *  @type string
				 *  @default Search:
				 *
				 *  @dtopt Language
				 *  @name DataTable.defaults.language.search
				 *
				 *  @example
				 *    // Input text box will be appended at the end automatically
				 *    $(document).ready( function() {
				 *      $('#example').dataTable( {
				 *        "language": {
				 *          "search": "Filter records:"
				 *        }
				 *      } );
				 *    } );
				 *
				 *  @example
				 *    // Specify where the filter should appear
				 *    $(document).ready( function() {
				 *      $('#example').dataTable( {
				 *        "language": {
				 *          "search": "Apply filter _INPUT_ to table"
				 *        }
				 *      } );
				 *    } );
				 */
				"sSearch": "Search:",
		
		
				/**
				 * Assign a `placeholder` attribute to the search `input` element
				 *  @type string
				 *  @default 
				 *
				 *  @dtopt Language
				 *  @name DataTable.defaults.language.searchPlaceholder
				 */
				"sSearchPlaceholder": "",
		
		
				/**
				 * All of the language information can be stored in a file on the
				 * server-side, which DataTables will look up if this parameter is passed.
				 * It must store the URL of the language file, which is in a JSON format,
				 * and the object has the same properties as the oLanguage object in the
				 * initialiser object (i.e. the above parameters). Please refer to one of
				 * the example language files to see how this works in action.
				 *  @type string
				 *  @default <i>Empty string - i.e. disabled</i>
				 *
				 *  @dtopt Language
				 *  @name DataTable.defaults.language.url
				 *
				 *  @example
				 *    $(document).ready( function() {
				 *      $('#example').dataTable( {
				 *        "language": {
				 *          "url": "http://www.sprymedia.co.uk/dataTables/lang.txt"
				 *        }
				 *      } );
				 *    } );
				 */
				"sUrl": "",
		
		
				/**
				 * Text shown inside the table records when the is no information to be
				 * displayed after filtering. `emptyTable` is shown when there is simply no
				 * information in the table at all (regardless of filtering).
				 *  @type string
				 *  @default No matching records found
				 *
				 *  @dtopt Language
				 *  @name DataTable.defaults.language.zeroRecords
				 *
				 *  @example
				 *    $(document).ready( function() {
				 *      $('#example').dataTable( {
				 *        "language": {
				 *          "zeroRecords": "No records to display"
				 *        }
				 *      } );
				 *    } );
				 */
				"sZeroRecords": "No matching records found"
			},
		
		
			/**
			 * This parameter allows you to have define the global filtering state at
			 * initialisation time. As an object the `search` parameter must be
			 * defined, but all other parameters are optional. When `regex` is true,
			 * the search string will be treated as a regular expression, when false
			 * (default) it will be treated as a straight string. When `smart`
			 * DataTables will use it's smart filtering methods (to word match at
			 * any point in the data), when false this will not be done.
			 *  @namespace
			 *  @extends DataTable.models.oSearch
			 *
			 *  @dtopt Options
			 *  @name DataTable.defaults.search
			 *
			 *  @example
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "search": {"search": "Initial search"}
			 *      } );
			 *    } )
			 */
			"oSearch": $.extend( {}, DataTable.models.oSearch ),
		
		
			/**
			 * __Deprecated__ The functionality provided by this parameter has now been
			 * superseded by that provided through `ajax`, which should be used instead.
			 *
			 * By default DataTables will look for the property `data` (or `aaData` for
			 * compatibility with DataTables 1.9-) when obtaining data from an Ajax
			 * source or for server-side processing - this parameter allows that
			 * property to be changed. You can use Javascript dotted object notation to
			 * get a data source for multiple levels of nesting.
			 *  @type string
			 *  @default data
			 *
			 *  @dtopt Options
			 *  @dtopt Server-side
			 *  @name DataTable.defaults.ajaxDataProp
			 *
			 *  @deprecated 1.10. Please use `ajax` for this functionality now.
			 */
			"sAjaxDataProp": "data",
		
		
			/**
			 * __Deprecated__ The functionality provided by this parameter has now been
			 * superseded by that provided through `ajax`, which should be used instead.
			 *
			 * You can instruct DataTables to load data from an external
			 * source using this parameter (use aData if you want to pass data in you
			 * already have). Simply provide a url a JSON object can be obtained from.
			 *  @type string
			 *  @default null
			 *
			 *  @dtopt Options
			 *  @dtopt Server-side
			 *  @name DataTable.defaults.ajaxSource
			 *
			 *  @deprecated 1.10. Please use `ajax` for this functionality now.
			 */
			"sAjaxSource": null,
		
		
			/**
			 * This initialisation variable allows you to specify exactly where in the
			 * DOM you want DataTables to inject the various controls it adds to the page
			 * (for example you might want the pagination controls at the top of the
			 * table). DIV elements (with or without a custom class) can also be added to
			 * aid styling. The follow syntax is used:
			 *   <ul>
			 *     <li>The following options are allowed:
			 *       <ul>
			 *         <li>'l' - Length changing</li>
			 *         <li>'f' - Filtering input</li>
			 *         <li>'t' - The table!</li>
			 *         <li>'i' - Information</li>
			 *         <li>'p' - Pagination</li>
			 *         <li>'r' - pRocessing</li>
			 *       </ul>
			 *     </li>
			 *     <li>The following constants are allowed:
			 *       <ul>
			 *         <li>'H' - jQueryUI theme "header" classes ('fg-toolbar ui-widget-header ui-corner-tl ui-corner-tr ui-helper-clearfix')</li>
			 *         <li>'F' - jQueryUI theme "footer" classes ('fg-toolbar ui-widget-header ui-corner-bl ui-corner-br ui-helper-clearfix')</li>
			 *       </ul>
			 *     </li>
			 *     <li>The following syntax is expected:
			 *       <ul>
			 *         <li>'&lt;' and '&gt;' - div elements</li>
			 *         <li>'&lt;"class" and '&gt;' - div with a class</li>
			 *         <li>'&lt;"#id" and '&gt;' - div with an ID</li>
			 *       </ul>
			 *     </li>
			 *     <li>Examples:
			 *       <ul>
			 *         <li>'&lt;"wrapper"flipt&gt;'</li>
			 *         <li>'&lt;lf&lt;t&gt;ip&gt;'</li>
			 *       </ul>
			 *     </li>
			 *   </ul>
			 *  @type string
			 *  @default lfrtip <i>(when `jQueryUI` is false)</i> <b>or</b>
			 *    <"H"lfr>t<"F"ip> <i>(when `jQueryUI` is true)</i>
			 *
			 *  @dtopt Options
			 *  @name DataTable.defaults.dom
			 *
			 *  @example
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "dom": '&lt;"top"i&gt;rt&lt;"bottom"flp&gt;&lt;"clear"&gt;'
			 *      } );
			 *    } );
			 */
			"sDom": "lfrtip",
		
		
			/**
			 * Search delay option. This will throttle full table searches that use the
			 * DataTables provided search input element (it does not effect calls to
			 * `dt-api search()`, providing a delay before the search is made.
			 *  @type integer
			 *  @default 0
			 *
			 *  @dtopt Options
			 *  @name DataTable.defaults.searchDelay
			 *
			 *  @example
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "searchDelay": 200
			 *      } );
			 *    } )
			 */
			"searchDelay": null,
		
		
			/**
			 * DataTables features four different built-in options for the buttons to
			 * display for pagination control:
			 *
			 * * `simple` - 'Previous' and 'Next' buttons only
			 * * 'simple_numbers` - 'Previous' and 'Next' buttons, plus page numbers
			 * * `full` - 'First', 'Previous', 'Next' and 'Last' buttons
			 * * `full_numbers` - 'First', 'Previous', 'Next' and 'Last' buttons, plus
			 *   page numbers
			 *  
			 * Further methods can be added using {@link DataTable.ext.oPagination}.
			 *  @type string
			 *  @default simple_numbers
			 *
			 *  @dtopt Options
			 *  @name DataTable.defaults.pagingType
			 *
			 *  @example
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "pagingType": "full_numbers"
			 *      } );
			 *    } )
			 */
			"sPaginationType": "simple_numbers",
		
		
			/**
			 * Enable horizontal scrolling. When a table is too wide to fit into a
			 * certain layout, or you have a large number of columns in the table, you
			 * can enable x-scrolling to show the table in a viewport, which can be
			 * scrolled. This property can be `true` which will allow the table to
			 * scroll horizontally when needed, or any CSS unit, or a number (in which
			 * case it will be treated as a pixel measurement). Setting as simply `true`
			 * is recommended.
			 *  @type boolean|string
			 *  @default <i>blank string - i.e. disabled</i>
			 *
			 *  @dtopt Features
			 *  @name DataTable.defaults.scrollX
			 *
			 *  @example
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "scrollX": true,
			 *        "scrollCollapse": true
			 *      } );
			 *    } );
			 */
			"sScrollX": "",
		
		
			/**
			 * This property can be used to force a DataTable to use more width than it
			 * might otherwise do when x-scrolling is enabled. For example if you have a
			 * table which requires to be well spaced, this parameter is useful for
			 * "over-sizing" the table, and thus forcing scrolling. This property can by
			 * any CSS unit, or a number (in which case it will be treated as a pixel
			 * measurement).
			 *  @type string
			 *  @default <i>blank string - i.e. disabled</i>
			 *
			 *  @dtopt Options
			 *  @name DataTable.defaults.scrollXInner
			 *
			 *  @example
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "scrollX": "100%",
			 *        "scrollXInner": "110%"
			 *      } );
			 *    } );
			 */
			"sScrollXInner": "",
		
		
			/**
			 * Enable vertical scrolling. Vertical scrolling will constrain the DataTable
			 * to the given height, and enable scrolling for any data which overflows the
			 * current viewport. This can be used as an alternative to paging to display
			 * a lot of data in a small area (although paging and scrolling can both be
			 * enabled at the same time). This property can be any CSS unit, or a number
			 * (in which case it will be treated as a pixel measurement).
			 *  @type string
			 *  @default <i>blank string - i.e. disabled</i>
			 *
			 *  @dtopt Features
			 *  @name DataTable.defaults.scrollY
			 *
			 *  @example
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "scrollY": "200px",
			 *        "paginate": false
			 *      } );
			 *    } );
			 */
			"sScrollY": "",
		
		
			/**
			 * __Deprecated__ The functionality provided by this parameter has now been
			 * superseded by that provided through `ajax`, which should be used instead.
			 *
			 * Set the HTTP method that is used to make the Ajax call for server-side
			 * processing or Ajax sourced data.
			 *  @type string
			 *  @default GET
			 *
			 *  @dtopt Options
			 *  @dtopt Server-side
			 *  @name DataTable.defaults.serverMethod
			 *
			 *  @deprecated 1.10. Please use `ajax` for this functionality now.
			 */
			"sServerMethod": "GET",
		
		
			/**
			 * DataTables makes use of renderers when displaying HTML elements for
			 * a table. These renderers can be added or modified by plug-ins to
			 * generate suitable mark-up for a site. For example the Bootstrap
			 * integration plug-in for DataTables uses a paging button renderer to
			 * display pagination buttons in the mark-up required by Bootstrap.
			 *
			 * For further information about the renderers available see
			 * DataTable.ext.renderer
			 *  @type string|object
			 *  @default null
			 *
			 *  @name DataTable.defaults.renderer
			 *
			 */
			"renderer": null,
		
		
			/**
			 * Set the data property name that DataTables should use to get a row's id
			 * to set as the `id` property in the node.
			 *  @type string
			 *  @default DT_RowId
			 *
			 *  @name DataTable.defaults.rowId
			 */
			"rowId": "DT_RowId"
		};
		
		_fnHungarianMap( DataTable.defaults );
		
		
		
		/*
		 * Developer note - See note in model.defaults.js about the use of Hungarian
		 * notation and camel case.
		 */
		
		/**
		 * Column options that can be given to DataTables at initialisation time.
		 *  @namespace
		 */
		DataTable.defaults.column = {
			/**
			 * Define which column(s) an order will occur on for this column. This
			 * allows a column's ordering to take multiple columns into account when
			 * doing a sort or use the data from a different column. For example first
			 * name / last name columns make sense to do a multi-column sort over the
			 * two columns.
			 *  @type array|int
			 *  @default null <i>Takes the value of the column index automatically</i>
			 *
			 *  @name DataTable.defaults.column.orderData
			 *  @dtopt Columns
			 *
			 *  @example
			 *    // Using `columnDefs`
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "columnDefs": [
			 *          { "orderData": [ 0, 1 ], "targets": [ 0 ] },
			 *          { "orderData": [ 1, 0 ], "targets": [ 1 ] },
			 *          { "orderData": 2, "targets": [ 2 ] }
			 *        ]
			 *      } );
			 *    } );
			 *
			 *  @example
			 *    // Using `columns`
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "columns": [
			 *          { "orderData": [ 0, 1 ] },
			 *          { "orderData": [ 1, 0 ] },
			 *          { "orderData": 2 },
			 *          null,
			 *          null
			 *        ]
			 *      } );
			 *    } );
			 */
			"aDataSort": null,
			"iDataSort": -1,
		
		
			/**
			 * You can control the default ordering direction, and even alter the
			 * behaviour of the sort handler (i.e. only allow ascending ordering etc)
			 * using this parameter.
			 *  @type array
			 *  @default [ 'asc', 'desc' ]
			 *
			 *  @name DataTable.defaults.column.orderSequence
			 *  @dtopt Columns
			 *
			 *  @example
			 *    // Using `columnDefs`
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "columnDefs": [
			 *          { "orderSequence": [ "asc" ], "targets": [ 1 ] },
			 *          { "orderSequence": [ "desc", "asc", "asc" ], "targets": [ 2 ] },
			 *          { "orderSequence": [ "desc" ], "targets": [ 3 ] }
			 *        ]
			 *      } );
			 *    } );
			 *
			 *  @example
			 *    // Using `columns`
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "columns": [
			 *          null,
			 *          { "orderSequence": [ "asc" ] },
			 *          { "orderSequence": [ "desc", "asc", "asc" ] },
			 *          { "orderSequence": [ "desc" ] },
			 *          null
			 *        ]
			 *      } );
			 *    } );
			 */
			"asSorting": [ 'asc', 'desc' ],
		
		
			/**
			 * Enable or disable filtering on the data in this column.
			 *  @type boolean
			 *  @default true
			 *
			 *  @name DataTable.defaults.column.searchable
			 *  @dtopt Columns
			 *
			 *  @example
			 *    // Using `columnDefs`
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "columnDefs": [
			 *          { "searchable": false, "targets": [ 0 ] }
			 *        ] } );
			 *    } );
			 *
			 *  @example
			 *    // Using `columns`
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "columns": [
			 *          { "searchable": false },
			 *          null,
			 *          null,
			 *          null,
			 *          null
			 *        ] } );
			 *    } );
			 */
			"bSearchable": true,
		
		
			/**
			 * Enable or disable ordering on this column.
			 *  @type boolean
			 *  @default true
			 *
			 *  @name DataTable.defaults.column.orderable
			 *  @dtopt Columns
			 *
			 *  @example
			 *    // Using `columnDefs`
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "columnDefs": [
			 *          { "orderable": false, "targets": [ 0 ] }
			 *        ] } );
			 *    } );
			 *
			 *  @example
			 *    // Using `columns`
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "columns": [
			 *          { "orderable": false },
			 *          null,
			 *          null,
			 *          null,
			 *          null
			 *        ] } );
			 *    } );
			 */
			"bSortable": true,
		
		
			/**
			 * Enable or disable the display of this column.
			 *  @type boolean
			 *  @default true
			 *
			 *  @name DataTable.defaults.column.visible
			 *  @dtopt Columns
			 *
			 *  @example
			 *    // Using `columnDefs`
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "columnDefs": [
			 *          { "visible": false, "targets": [ 0 ] }
			 *        ] } );
			 *    } );
			 *
			 *  @example
			 *    // Using `columns`
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "columns": [
			 *          { "visible": false },
			 *          null,
			 *          null,
			 *          null,
			 *          null
			 *        ] } );
			 *    } );
			 */
			"bVisible": true,
		
		
			/**
			 * Developer definable function that is called whenever a cell is created (Ajax source,
			 * etc) or processed for input (DOM source). This can be used as a compliment to mRender
			 * allowing you to modify the DOM element (add background colour for example) when the
			 * element is available.
			 *  @type function
			 *  @param {element} td The TD node that has been created
			 *  @param {*} cellData The Data for the cell
			 *  @param {array|object} rowData The data for the whole row
			 *  @param {int} row The row index for the aoData data store
			 *  @param {int} col The column index for aoColumns
			 *
			 *  @name DataTable.defaults.column.createdCell
			 *  @dtopt Columns
			 *
			 *  @example
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "columnDefs": [ {
			 *          "targets": [3],
			 *          "createdCell": function (td, cellData, rowData, row, col) {
			 *            if ( cellData == "1.7" ) {
			 *              $(td).css('color', 'blue')
			 *            }
			 *          }
			 *        } ]
			 *      });
			 *    } );
			 */
			"fnCreatedCell": null,
		
		
			/**
			 * This parameter has been replaced by `data` in DataTables to ensure naming
			 * consistency. `dataProp` can still be used, as there is backwards
			 * compatibility in DataTables for this option, but it is strongly
			 * recommended that you use `data` in preference to `dataProp`.
			 *  @name DataTable.defaults.column.dataProp
			 */
		
		
			/**
			 * This property can be used to read data from any data source property,
			 * including deeply nested objects / properties. `data` can be given in a
			 * number of different ways which effect its behaviour:
			 *
			 * * `integer` - treated as an array index for the data source. This is the
			 *   default that DataTables uses (incrementally increased for each column).
			 * * `string` - read an object property from the data source. There are
			 *   three 'special' options that can be used in the string to alter how
			 *   DataTables reads the data from the source object:
			 *    * `.` - Dotted Javascript notation. Just as you use a `.` in
			 *      Javascript to read from nested objects, so to can the options
			 *      specified in `data`. For example: `browser.version` or
			 *      `browser.name`. If your object parameter name contains a period, use
			 *      `\\` to escape it - i.e. `first\\.name`.
			 *    * `[]` - Array notation. DataTables can automatically combine data
			 *      from and array source, joining the data with the characters provided
			 *      between the two brackets. For example: `name[, ]` would provide a
			 *      comma-space separated list from the source array. If no characters
			 *      are provided between the brackets, the original array source is
			 *      returned.
			 *    * `()` - Function notation. Adding `()` to the end of a parameter will
			 *      execute a function of the name given. For example: `browser()` for a
			 *      simple function on the data source, `browser.version()` for a
			 *      function in a nested property or even `browser().version` to get an
			 *      object property if the function called returns an object. Note that
			 *      function notation is recommended for use in `render` rather than
			 *      `data` as it is much simpler to use as a renderer.
			 * * `null` - use the original data source for the row rather than plucking
			 *   data directly from it. This action has effects on two other
			 *   initialisation options:
			 *    * `defaultContent` - When null is given as the `data` option and
			 *      `defaultContent` is specified for the column, the value defined by
			 *      `defaultContent` will be used for the cell.
			 *    * `render` - When null is used for the `data` option and the `render`
			 *      option is specified for the column, the whole data source for the
			 *      row is used for the renderer.
			 * * `function` - the function given will be executed whenever DataTables
			 *   needs to set or get the data for a cell in the column. The function
			 *   takes three parameters:
			 *    * Parameters:
			 *      * `{array|object}` The data source for the row
			 *      * `{string}` The type call data requested - this will be 'set' when
			 *        setting data or 'filter', 'display', 'type', 'sort' or undefined
			 *        when gathering data. Note that when `undefined` is given for the
			 *        type DataTables expects to get the raw data for the object back<
			 *      * `{*}` Data to set when the second parameter is 'set'.
			 *    * Return:
			 *      * The return value from the function is not required when 'set' is
			 *        the type of call, but otherwise the return is what will be used
			 *        for the data requested.
			 *
			 * Note that `data` is a getter and setter option. If you just require
			 * formatting of data for output, you will likely want to use `render` which
			 * is simply a getter and thus simpler to use.
			 *
			 * Note that prior to DataTables 1.9.2 `data` was called `mDataProp`. The
			 * name change reflects the flexibility of this property and is consistent
			 * with the naming of mRender. If 'mDataProp' is given, then it will still
			 * be used by DataTables, as it automatically maps the old name to the new
			 * if required.
			 *
			 *  @type string|int|function|null
			 *  @default null <i>Use automatically calculated column index</i>
			 *
			 *  @name DataTable.defaults.column.data
			 *  @dtopt Columns
			 *
			 *  @example
			 *    // Read table data from objects
			 *    // JSON structure for each row:
			 *    //   {
			 *    //      "engine": {value},
			 *    //      "browser": {value},
			 *    //      "platform": {value},
			 *    //      "version": {value},
			 *    //      "grade": {value}
			 *    //   }
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "ajaxSource": "sources/objects.txt",
			 *        "columns": [
			 *          { "data": "engine" },
			 *          { "data": "browser" },
			 *          { "data": "platform" },
			 *          { "data": "version" },
			 *          { "data": "grade" }
			 *        ]
			 *      } );
			 *    } );
			 *
			 *  @example
			 *    // Read information from deeply nested objects
			 *    // JSON structure for each row:
			 *    //   {
			 *    //      "engine": {value},
			 *    //      "browser": {value},
			 *    //      "platform": {
			 *    //         "inner": {value}
			 *    //      },
			 *    //      "details": [
			 *    //         {value}, {value}
			 *    //      ]
			 *    //   }
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "ajaxSource": "sources/deep.txt",
			 *        "columns": [
			 *          { "data": "engine" },
			 *          { "data": "browser" },
			 *          { "data": "platform.inner" },
			 *          { "data": "platform.details.0" },
			 *          { "data": "platform.details.1" }
			 *        ]
			 *      } );
			 *    } );
			 *
			 *  @example
			 *    // Using `data` as a function to provide different information for
			 *    // sorting, filtering and display. In this case, currency (price)
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "columnDefs": [ {
			 *          "targets": [ 0 ],
			 *          "data": function ( source, type, val ) {
			 *            if (type === 'set') {
			 *              source.price = val;
			 *              // Store the computed dislay and filter values for efficiency
			 *              source.price_display = val=="" ? "" : "$"+numberFormat(val);
			 *              source.price_filter  = val=="" ? "" : "$"+numberFormat(val)+" "+val;
			 *              return;
			 *            }
			 *            else if (type === 'display') {
			 *              return source.price_display;
			 *            }
			 *            else if (type === 'filter') {
			 *              return source.price_filter;
			 *            }
			 *            // 'sort', 'type' and undefined all just use the integer
			 *            return source.price;
			 *          }
			 *        } ]
			 *      } );
			 *    } );
			 *
			 *  @example
			 *    // Using default content
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "columnDefs": [ {
			 *          "targets": [ 0 ],
			 *          "data": null,
			 *          "defaultContent": "Click to edit"
			 *        } ]
			 *      } );
			 *    } );
			 *
			 *  @example
			 *    // Using array notation - outputting a list from an array
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "columnDefs": [ {
			 *          "targets": [ 0 ],
			 *          "data": "name[, ]"
			 *        } ]
			 *      } );
			 *    } );
			 *
			 */
			"mData": null,
		
		
			/**
			 * This property is the rendering partner to `data` and it is suggested that
			 * when you want to manipulate data for display (including filtering,
			 * sorting etc) without altering the underlying data for the table, use this
			 * property. `render` can be considered to be the the read only companion to
			 * `data` which is read / write (then as such more complex). Like `data`
			 * this option can be given in a number of different ways to effect its
			 * behaviour:
			 *
			 * * `integer` - treated as an array index for the data source. This is the
			 *   default that DataTables uses (incrementally increased for each column).
			 * * `string` - read an object property from the data source. There are
			 *   three 'special' options that can be used in the string to alter how
			 *   DataTables reads the data from the source object:
			 *    * `.` - Dotted Javascript notation. Just as you use a `.` in
			 *      Javascript to read from nested objects, so to can the options
			 *      specified in `data`. For example: `browser.version` or
			 *      `browser.name`. If your object parameter name contains a period, use
			 *      `\\` to escape it - i.e. `first\\.name`.
			 *    * `[]` - Array notation. DataTables can automatically combine data
			 *      from and array source, joining the data with the characters provided
			 *      between the two brackets. For example: `name[, ]` would provide a
			 *      comma-space separated list from the source array. If no characters
			 *      are provided between the brackets, the original array source is
			 *      returned.
			 *    * `()` - Function notation. Adding `()` to the end of a parameter will
			 *      execute a function of the name given. For example: `browser()` for a
			 *      simple function on the data source, `browser.version()` for a
			 *      function in a nested property or even `browser().version` to get an
			 *      object property if the function called returns an object.
			 * * `object` - use different data for the different data types requested by
			 *   DataTables ('filter', 'display', 'type' or 'sort'). The property names
			 *   of the object is the data type the property refers to and the value can
			 *   defined using an integer, string or function using the same rules as
			 *   `render` normally does. Note that an `_` option _must_ be specified.
			 *   This is the default value to use if you haven't specified a value for
			 *   the data type requested by DataTables.
			 * * `function` - the function given will be executed whenever DataTables
			 *   needs to set or get the data for a cell in the column. The function
			 *   takes three parameters:
			 *    * Parameters:
			 *      * {array|object} The data source for the row (based on `data`)
			 *      * {string} The type call data requested - this will be 'filter',
			 *        'display', 'type' or 'sort'.
			 *      * {array|object} The full data source for the row (not based on
			 *        `data`)
			 *    * Return:
			 *      * The return value from the function is what will be used for the
			 *        data requested.
			 *
			 *  @type string|int|function|object|null
			 *  @default null Use the data source value.
			 *
			 *  @name DataTable.defaults.column.render
			 *  @dtopt Columns
			 *
			 *  @example
			 *    // Create a comma separated list from an array of objects
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "ajaxSource": "sources/deep.txt",
			 *        "columns": [
			 *          { "data": "engine" },
			 *          { "data": "browser" },
			 *          {
			 *            "data": "platform",
			 *            "render": "[, ].name"
			 *          }
			 *        ]
			 *      } );
			 *    } );
			 *
			 *  @example
			 *    // Execute a function to obtain data
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "columnDefs": [ {
			 *          "targets": [ 0 ],
			 *          "data": null, // Use the full data source object for the renderer's source
			 *          "render": "browserName()"
			 *        } ]
			 *      } );
			 *    } );
			 *
			 *  @example
			 *    // As an object, extracting different data for the different types
			 *    // This would be used with a data source such as:
			 *    //   { "phone": 5552368, "phone_filter": "5552368 555-2368", "phone_display": "555-2368" }
			 *    // Here the `phone` integer is used for sorting and type detection, while `phone_filter`
			 *    // (which has both forms) is used for filtering for if a user inputs either format, while
			 *    // the formatted phone number is the one that is shown in the table.
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "columnDefs": [ {
			 *          "targets": [ 0 ],
			 *          "data": null, // Use the full data source object for the renderer's source
			 *          "render": {
			 *            "_": "phone",
			 *            "filter": "phone_filter",
			 *            "display": "phone_display"
			 *          }
			 *        } ]
			 *      } );
			 *    } );
			 *
			 *  @example
			 *    // Use as a function to create a link from the data source
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "columnDefs": [ {
			 *          "targets": [ 0 ],
			 *          "data": "download_link",
			 *          "render": function ( data, type, full ) {
			 *            return '<a href="'+data+'">Download</a>';
			 *          }
			 *        } ]
			 *      } );
			 *    } );
			 */
			"mRender": null,
		
		
			/**
			 * Change the cell type created for the column - either TD cells or TH cells. This
			 * can be useful as TH cells have semantic meaning in the table body, allowing them
			 * to act as a header for a row (you may wish to add scope='row' to the TH elements).
			 *  @type string
			 *  @default td
			 *
			 *  @name DataTable.defaults.column.cellType
			 *  @dtopt Columns
			 *
			 *  @example
			 *    // Make the first column use TH cells
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "columnDefs": [ {
			 *          "targets": [ 0 ],
			 *          "cellType": "th"
			 *        } ]
			 *      } );
			 *    } );
			 */
			"sCellType": "td",
		
		
			/**
			 * Class to give to each cell in this column.
			 *  @type string
			 *  @default <i>Empty string</i>
			 *
			 *  @name DataTable.defaults.column.class
			 *  @dtopt Columns
			 *
			 *  @example
			 *    // Using `columnDefs`
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "columnDefs": [
			 *          { "class": "my_class", "targets": [ 0 ] }
			 *        ]
			 *      } );
			 *    } );
			 *
			 *  @example
			 *    // Using `columns`
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "columns": [
			 *          { "class": "my_class" },
			 *          null,
			 *          null,
			 *          null,
			 *          null
			 *        ]
			 *      } );
			 *    } );
			 */
			"sClass": "",
		
			/**
			 * When DataTables calculates the column widths to assign to each column,
			 * it finds the longest string in each column and then constructs a
			 * temporary table and reads the widths from that. The problem with this
			 * is that "mmm" is much wider then "iiii", but the latter is a longer
			 * string - thus the calculation can go wrong (doing it properly and putting
			 * it into an DOM object and measuring that is horribly(!) slow). Thus as
			 * a "work around" we provide this option. It will append its value to the
			 * text that is found to be the longest string for the column - i.e. padding.
			 * Generally you shouldn't need this!
			 *  @type string
			 *  @default <i>Empty string<i>
			 *
			 *  @name DataTable.defaults.column.contentPadding
			 *  @dtopt Columns
			 *
			 *  @example
			 *    // Using `columns`
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "columns": [
			 *          null,
			 *          null,
			 *          null,
			 *          {
			 *            "contentPadding": "mmm"
			 *          }
			 *        ]
			 *      } );
			 *    } );
			 */
			"sContentPadding": "",
		
		
			/**
			 * Allows a default value to be given for a column's data, and will be used
			 * whenever a null data source is encountered (this can be because `data`
			 * is set to null, or because the data source itself is null).
			 *  @type string
			 *  @default null
			 *
			 *  @name DataTable.defaults.column.defaultContent
			 *  @dtopt Columns
			 *
			 *  @example
			 *    // Using `columnDefs`
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "columnDefs": [
			 *          {
			 *            "data": null,
			 *            "defaultContent": "Edit",
			 *            "targets": [ -1 ]
			 *          }
			 *        ]
			 *      } );
			 *    } );
			 *
			 *  @example
			 *    // Using `columns`
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "columns": [
			 *          null,
			 *          null,
			 *          null,
			 *          {
			 *            "data": null,
			 *            "defaultContent": "Edit"
			 *          }
			 *        ]
			 *      } );
			 *    } );
			 */
			"sDefaultContent": null,
		
		
			/**
			 * This parameter is only used in DataTables' server-side processing. It can
			 * be exceptionally useful to know what columns are being displayed on the
			 * client side, and to map these to database fields. When defined, the names
			 * also allow DataTables to reorder information from the server if it comes
			 * back in an unexpected order (i.e. if you switch your columns around on the
			 * client-side, your server-side code does not also need updating).
			 *  @type string
			 *  @default <i>Empty string</i>
			 *
			 *  @name DataTable.defaults.column.name
			 *  @dtopt Columns
			 *
			 *  @example
			 *    // Using `columnDefs`
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "columnDefs": [
			 *          { "name": "engine", "targets": [ 0 ] },
			 *          { "name": "browser", "targets": [ 1 ] },
			 *          { "name": "platform", "targets": [ 2 ] },
			 *          { "name": "version", "targets": [ 3 ] },
			 *          { "name": "grade", "targets": [ 4 ] }
			 *        ]
			 *      } );
			 *    } );
			 *
			 *  @example
			 *    // Using `columns`
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "columns": [
			 *          { "name": "engine" },
			 *          { "name": "browser" },
			 *          { "name": "platform" },
			 *          { "name": "version" },
			 *          { "name": "grade" }
			 *        ]
			 *      } );
			 *    } );
			 */
			"sName": "",
		
		
			/**
			 * Defines a data source type for the ordering which can be used to read
			 * real-time information from the table (updating the internally cached
			 * version) prior to ordering. This allows ordering to occur on user
			 * editable elements such as form inputs.
			 *  @type string
			 *  @default std
			 *
			 *  @name DataTable.defaults.column.orderDataType
			 *  @dtopt Columns
			 *
			 *  @example
			 *    // Using `columnDefs`
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "columnDefs": [
			 *          { "orderDataType": "dom-text", "targets": [ 2, 3 ] },
			 *          { "type": "numeric", "targets": [ 3 ] },
			 *          { "orderDataType": "dom-select", "targets": [ 4 ] },
			 *          { "orderDataType": "dom-checkbox", "targets": [ 5 ] }
			 *        ]
			 *      } );
			 *    } );
			 *
			 *  @example
			 *    // Using `columns`
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "columns": [
			 *          null,
			 *          null,
			 *          { "orderDataType": "dom-text" },
			 *          { "orderDataType": "dom-text", "type": "numeric" },
			 *          { "orderDataType": "dom-select" },
			 *          { "orderDataType": "dom-checkbox" }
			 *        ]
			 *      } );
			 *    } );
			 */
			"sSortDataType": "std",
		
		
			/**
			 * The title of this column.
			 *  @type string
			 *  @default null <i>Derived from the 'TH' value for this column in the
			 *    original HTML table.</i>
			 *
			 *  @name DataTable.defaults.column.title
			 *  @dtopt Columns
			 *
			 *  @example
			 *    // Using `columnDefs`
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "columnDefs": [
			 *          { "title": "My column title", "targets": [ 0 ] }
			 *        ]
			 *      } );
			 *    } );
			 *
			 *  @example
			 *    // Using `columns`
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "columns": [
			 *          { "title": "My column title" },
			 *          null,
			 *          null,
			 *          null,
			 *          null
			 *        ]
			 *      } );
			 *    } );
			 */
			"sTitle": null,
		
		
			/**
			 * The type allows you to specify how the data for this column will be
			 * ordered. Four types (string, numeric, date and html (which will strip
			 * HTML tags before ordering)) are currently available. Note that only date
			 * formats understood by Javascript's Date() object will be accepted as type
			 * date. For example: "Mar 26, 2008 5:03 PM". May take the values: 'string',
			 * 'numeric', 'date' or 'html' (by default). Further types can be adding
			 * through plug-ins.
			 *  @type string
			 *  @default null <i>Auto-detected from raw data</i>
			 *
			 *  @name DataTable.defaults.column.type
			 *  @dtopt Columns
			 *
			 *  @example
			 *    // Using `columnDefs`
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "columnDefs": [
			 *          { "type": "html", "targets": [ 0 ] }
			 *        ]
			 *      } );
			 *    } );
			 *
			 *  @example
			 *    // Using `columns`
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "columns": [
			 *          { "type": "html" },
			 *          null,
			 *          null,
			 *          null,
			 *          null
			 *        ]
			 *      } );
			 *    } );
			 */
			"sType": null,
		
		
			/**
			 * Defining the width of the column, this parameter may take any CSS value
			 * (3em, 20px etc). DataTables applies 'smart' widths to columns which have not
			 * been given a specific width through this interface ensuring that the table
			 * remains readable.
			 *  @type string
			 *  @default null <i>Automatic</i>
			 *
			 *  @name DataTable.defaults.column.width
			 *  @dtopt Columns
			 *
			 *  @example
			 *    // Using `columnDefs`
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "columnDefs": [
			 *          { "width": "20%", "targets": [ 0 ] }
			 *        ]
			 *      } );
			 *    } );
			 *
			 *  @example
			 *    // Using `columns`
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "columns": [
			 *          { "width": "20%" },
			 *          null,
			 *          null,
			 *          null,
			 *          null
			 *        ]
			 *      } );
			 *    } );
			 */
			"sWidth": null
		};
		
		_fnHungarianMap( DataTable.defaults.column );
		
		
		
		/**
		 * DataTables settings object - this holds all the information needed for a
		 * given table, including configuration, data and current application of the
		 * table options. DataTables does not have a single instance for each DataTable
		 * with the settings attached to that instance, but rather instances of the
		 * DataTable "class" are created on-the-fly as needed (typically by a
		 * $().dataTable() call) and the settings object is then applied to that
		 * instance.
		 *
		 * Note that this object is related to {@link DataTable.defaults} but this
		 * one is the internal data store for DataTables's cache of columns. It should
		 * NOT be manipulated outside of DataTables. Any configuration should be done
		 * through the initialisation options.
		 *  @namespace
		 *  @todo Really should attach the settings object to individual instances so we
		 *    don't need to create new instances on each $().dataTable() call (if the
		 *    table already exists). It would also save passing oSettings around and
		 *    into every single function. However, this is a very significant
		 *    architecture change for DataTables and will almost certainly break
		 *    backwards compatibility with older installations. This is something that
		 *    will be done in 2.0.
		 */
		DataTable.models.oSettings = {
			/**
			 * Primary features of DataTables and their enablement state.
			 *  @namespace
			 */
			"oFeatures": {
		
				/**
				 * Flag to say if DataTables should automatically try to calculate the
				 * optimum table and columns widths (true) or not (false).
				 * Note that this parameter will be set by the initialisation routine. To
				 * set a default use {@link DataTable.defaults}.
				 *  @type boolean
				 */
				"bAutoWidth": null,
		
				/**
				 * Delay the creation of TR and TD elements until they are actually
				 * needed by a driven page draw. This can give a significant speed
				 * increase for Ajax source and Javascript source data, but makes no
				 * difference at all fro DOM and server-side processing tables.
				 * Note that this parameter will be set by the initialisation routine. To
				 * set a default use {@link DataTable.defaults}.
				 *  @type boolean
				 */
				"bDeferRender": null,
		
				/**
				 * Enable filtering on the table or not. Note that if this is disabled
				 * then there is no filtering at all on the table, including fnFilter.
				 * To just remove the filtering input use sDom and remove the 'f' option.
				 * Note that this parameter will be set by the initialisation routine. To
				 * set a default use {@link DataTable.defaults}.
				 *  @type boolean
				 */
				"bFilter": null,
		
				/**
				 * Table information element (the 'Showing x of y records' div) enable
				 * flag.
				 * Note that this parameter will be set by the initialisation routine. To
				 * set a default use {@link DataTable.defaults}.
				 *  @type boolean
				 */
				"bInfo": null,
		
				/**
				 * Present a user control allowing the end user to change the page size
				 * when pagination is enabled.
				 * Note that this parameter will be set by the initialisation routine. To
				 * set a default use {@link DataTable.defaults}.
				 *  @type boolean
				 */
				"bLengthChange": null,
		
				/**
				 * Pagination enabled or not. Note that if this is disabled then length
				 * changing must also be disabled.
				 * Note that this parameter will be set by the initialisation routine. To
				 * set a default use {@link DataTable.defaults}.
				 *  @type boolean
				 */
				"bPaginate": null,
		
				/**
				 * Processing indicator enable flag whenever DataTables is enacting a
				 * user request - typically an Ajax request for server-side processing.
				 * Note that this parameter will be set by the initialisation routine. To
				 * set a default use {@link DataTable.defaults}.
				 *  @type boolean
				 */
				"bProcessing": null,
		
				/**
				 * Server-side processing enabled flag - when enabled DataTables will
				 * get all data from the server for every draw - there is no filtering,
				 * sorting or paging done on the client-side.
				 * Note that this parameter will be set by the initialisation routine. To
				 * set a default use {@link DataTable.defaults}.
				 *  @type boolean
				 */
				"bServerSide": null,
		
				/**
				 * Sorting enablement flag.
				 * Note that this parameter will be set by the initialisation routine. To
				 * set a default use {@link DataTable.defaults}.
				 *  @type boolean
				 */
				"bSort": null,
		
				/**
				 * Multi-column sorting
				 * Note that this parameter will be set by the initialisation routine. To
				 * set a default use {@link DataTable.defaults}.
				 *  @type boolean
				 */
				"bSortMulti": null,
		
				/**
				 * Apply a class to the columns which are being sorted to provide a
				 * visual highlight or not. This can slow things down when enabled since
				 * there is a lot of DOM interaction.
				 * Note that this parameter will be set by the initialisation routine. To
				 * set a default use {@link DataTable.defaults}.
				 *  @type boolean
				 */
				"bSortClasses": null,
		
				/**
				 * State saving enablement flag.
				 * Note that this parameter will be set by the initialisation routine. To
				 * set a default use {@link DataTable.defaults}.
				 *  @type boolean
				 */
				"bStateSave": null
			},
		
		
			/**
			 * Scrolling settings for a table.
			 *  @namespace
			 */
			"oScroll": {
				/**
				 * When the table is shorter in height than sScrollY, collapse the
				 * table container down to the height of the table (when true).
				 * Note that this parameter will be set by the initialisation routine. To
				 * set a default use {@link DataTable.defaults}.
				 *  @type boolean
				 */
				"bCollapse": null,
		
				/**
				 * Width of the scrollbar for the web-browser's platform. Calculated
				 * during table initialisation.
				 *  @type int
				 *  @default 0
				 */
				"iBarWidth": 0,
		
				/**
				 * Viewport width for horizontal scrolling. Horizontal scrolling is
				 * disabled if an empty string.
				 * Note that this parameter will be set by the initialisation routine. To
				 * set a default use {@link DataTable.defaults}.
				 *  @type string
				 */
				"sX": null,
		
				/**
				 * Width to expand the table to when using x-scrolling. Typically you
				 * should not need to use this.
				 * Note that this parameter will be set by the initialisation routine. To
				 * set a default use {@link DataTable.defaults}.
				 *  @type string
				 *  @deprecated
				 */
				"sXInner": null,
		
				/**
				 * Viewport height for vertical scrolling. Vertical scrolling is disabled
				 * if an empty string.
				 * Note that this parameter will be set by the initialisation routine. To
				 * set a default use {@link DataTable.defaults}.
				 *  @type string
				 */
				"sY": null
			},
		
			/**
			 * Language information for the table.
			 *  @namespace
			 *  @extends DataTable.defaults.oLanguage
			 */
			"oLanguage": {
				/**
				 * Information callback function. See
				 * {@link DataTable.defaults.fnInfoCallback}
				 *  @type function
				 *  @default null
				 */
				"fnInfoCallback": null
			},
		
			/**
			 * Browser support parameters
			 *  @namespace
			 */
			"oBrowser": {
				/**
				 * Indicate if the browser incorrectly calculates width:100% inside a
				 * scrolling element (IE6/7)
				 *  @type boolean
				 *  @default false
				 */
				"bScrollOversize": false,
		
				/**
				 * Determine if the vertical scrollbar is on the right or left of the
				 * scrolling container - needed for rtl language layout, although not
				 * all browsers move the scrollbar (Safari).
				 *  @type boolean
				 *  @default false
				 */
				"bScrollbarLeft": false,
		
				/**
				 * Flag for if `getBoundingClientRect` is fully supported or not
				 *  @type boolean
				 *  @default false
				 */
				"bBounding": false,
		
				/**
				 * Browser scrollbar width
				 *  @type integer
				 *  @default 0
				 */
				"barWidth": 0
			},
		
		
			"ajax": null,
		
		
			/**
			 * Array referencing the nodes which are used for the features. The
			 * parameters of this object match what is allowed by sDom - i.e.
			 *   <ul>
			 *     <li>'l' - Length changing</li>
			 *     <li>'f' - Filtering input</li>
			 *     <li>'t' - The table!</li>
			 *     <li>'i' - Information</li>
			 *     <li>'p' - Pagination</li>
			 *     <li>'r' - pRocessing</li>
			 *   </ul>
			 *  @type array
			 *  @default []
			 */
			"aanFeatures": [],
		
			/**
			 * Store data information - see {@link DataTable.models.oRow} for detailed
			 * information.
			 *  @type array
			 *  @default []
			 */
			"aoData": [],
		
			/**
			 * Array of indexes which are in the current display (after filtering etc)
			 *  @type array
			 *  @default []
			 */
			"aiDisplay": [],
		
			/**
			 * Array of indexes for display - no filtering
			 *  @type array
			 *  @default []
			 */
			"aiDisplayMaster": [],
		
			/**
			 * Map of row ids to data indexes
			 *  @type object
			 *  @default {}
			 */
			"aIds": {},
		
			/**
			 * Store information about each column that is in use
			 *  @type array
			 *  @default []
			 */
			"aoColumns": [],
		
			/**
			 * Store information about the table's header
			 *  @type array
			 *  @default []
			 */
			"aoHeader": [],
		
			/**
			 * Store information about the table's footer
			 *  @type array
			 *  @default []
			 */
			"aoFooter": [],
		
			/**
			 * Store the applied global search information in case we want to force a
			 * research or compare the old search to a new one.
			 * Note that this parameter will be set by the initialisation routine. To
			 * set a default use {@link DataTable.defaults}.
			 *  @namespace
			 *  @extends DataTable.models.oSearch
			 */
			"oPreviousSearch": {},
		
			/**
			 * Store the applied search for each column - see
			 * {@link DataTable.models.oSearch} for the format that is used for the
			 * filtering information for each column.
			 *  @type array
			 *  @default []
			 */
			"aoPreSearchCols": [],
		
			/**
			 * Sorting that is applied to the table. Note that the inner arrays are
			 * used in the following manner:
			 * <ul>
			 *   <li>Index 0 - column number</li>
			 *   <li>Index 1 - current sorting direction</li>
			 * </ul>
			 * Note that this parameter will be set by the initialisation routine. To
			 * set a default use {@link DataTable.defaults}.
			 *  @type array
			 *  @todo These inner arrays should really be objects
			 */
			"aaSorting": null,
		
			/**
			 * Sorting that is always applied to the table (i.e. prefixed in front of
			 * aaSorting).
			 * Note that this parameter will be set by the initialisation routine. To
			 * set a default use {@link DataTable.defaults}.
			 *  @type array
			 *  @default []
			 */
			"aaSortingFixed": [],
		
			/**
			 * Classes to use for the striping of a table.
			 * Note that this parameter will be set by the initialisation routine. To
			 * set a default use {@link DataTable.defaults}.
			 *  @type array
			 *  @default []
			 */
			"asStripeClasses": null,
		
			/**
			 * If restoring a table - we should restore its striping classes as well
			 *  @type array
			 *  @default []
			 */
			"asDestroyStripes": [],
		
			/**
			 * If restoring a table - we should restore its width
			 *  @type int
			 *  @default 0
			 */
			"sDestroyWidth": 0,
		
			/**
			 * Callback functions array for every time a row is inserted (i.e. on a draw).
			 *  @type array
			 *  @default []
			 */
			"aoRowCallback": [],
		
			/**
			 * Callback functions for the header on each draw.
			 *  @type array
			 *  @default []
			 */
			"aoHeaderCallback": [],
		
			/**
			 * Callback function for the footer on each draw.
			 *  @type array
			 *  @default []
			 */
			"aoFooterCallback": [],
		
			/**
			 * Array of callback functions for draw callback functions
			 *  @type array
			 *  @default []
			 */
			"aoDrawCallback": [],
		
			/**
			 * Array of callback functions for row created function
			 *  @type array
			 *  @default []
			 */
			"aoRowCreatedCallback": [],
		
			/**
			 * Callback functions for just before the table is redrawn. A return of
			 * false will be used to cancel the draw.
			 *  @type array
			 *  @default []
			 */
			"aoPreDrawCallback": [],
		
			/**
			 * Callback functions for when the table has been initialised.
			 *  @type array
			 *  @default []
			 */
			"aoInitComplete": [],
		
		
			/**
			 * Callbacks for modifying the settings to be stored for state saving, prior to
			 * saving state.
			 *  @type array
			 *  @default []
			 */
			"aoStateSaveParams": [],
		
			/**
			 * Callbacks for modifying the settings that have been stored for state saving
			 * prior to using the stored values to restore the state.
			 *  @type array
			 *  @default []
			 */
			"aoStateLoadParams": [],
		
			/**
			 * Callbacks for operating on the settings object once the saved state has been
			 * loaded
			 *  @type array
			 *  @default []
			 */
			"aoStateLoaded": [],
		
			/**
			 * Cache the table ID for quick access
			 *  @type string
			 *  @default <i>Empty string</i>
			 */
			"sTableId": "",
		
			/**
			 * The TABLE node for the main table
			 *  @type node
			 *  @default null
			 */
			"nTable": null,
		
			/**
			 * Permanent ref to the thead element
			 *  @type node
			 *  @default null
			 */
			"nTHead": null,
		
			/**
			 * Permanent ref to the tfoot element - if it exists
			 *  @type node
			 *  @default null
			 */
			"nTFoot": null,
		
			/**
			 * Permanent ref to the tbody element
			 *  @type node
			 *  @default null
			 */
			"nTBody": null,
		
			/**
			 * Cache the wrapper node (contains all DataTables controlled elements)
			 *  @type node
			 *  @default null
			 */
			"nTableWrapper": null,
		
			/**
			 * Indicate if when using server-side processing the loading of data
			 * should be deferred until the second draw.
			 * Note that this parameter will be set by the initialisation routine. To
			 * set a default use {@link DataTable.defaults}.
			 *  @type boolean
			 *  @default false
			 */
			"bDeferLoading": false,
		
			/**
			 * Indicate if all required information has been read in
			 *  @type boolean
			 *  @default false
			 */
			"bInitialised": false,
		
			/**
			 * Information about open rows. Each object in the array has the parameters
			 * 'nTr' and 'nParent'
			 *  @type array
			 *  @default []
			 */
			"aoOpenRows": [],
		
			/**
			 * Dictate the positioning of DataTables' control elements - see
			 * {@link DataTable.model.oInit.sDom}.
			 * Note that this parameter will be set by the initialisation routine. To
			 * set a default use {@link DataTable.defaults}.
			 *  @type string
			 *  @default null
			 */
			"sDom": null,
		
			/**
			 * Search delay (in mS)
			 *  @type integer
			 *  @default null
			 */
			"searchDelay": null,
		
			/**
			 * Which type of pagination should be used.
			 * Note that this parameter will be set by the initialisation routine. To
			 * set a default use {@link DataTable.defaults}.
			 *  @type string
			 *  @default two_button
			 */
			"sPaginationType": "two_button",
		
			/**
			 * The state duration (for `stateSave`) in seconds.
			 * Note that this parameter will be set by the initialisation routine. To
			 * set a default use {@link DataTable.defaults}.
			 *  @type int
			 *  @default 0
			 */
			"iStateDuration": 0,
		
			/**
			 * Array of callback functions for state saving. Each array element is an
			 * object with the following parameters:
			 *   <ul>
			 *     <li>function:fn - function to call. Takes two parameters, oSettings
			 *       and the JSON string to save that has been thus far created. Returns
			 *       a JSON string to be inserted into a json object
			 *       (i.e. '"param": [ 0, 1, 2]')</li>
			 *     <li>string:sName - name of callback</li>
			 *   </ul>
			 *  @type array
			 *  @default []
			 */
			"aoStateSave": [],
		
			/**
			 * Array of callback functions for state loading. Each array element is an
			 * object with the following parameters:
			 *   <ul>
			 *     <li>function:fn - function to call. Takes two parameters, oSettings
			 *       and the object stored. May return false to cancel state loading</li>
			 *     <li>string:sName - name of callback</li>
			 *   </ul>
			 *  @type array
			 *  @default []
			 */
			"aoStateLoad": [],
		
			/**
			 * State that was saved. Useful for back reference
			 *  @type object
			 *  @default null
			 */
			"oSavedState": null,
		
			/**
			 * State that was loaded. Useful for back reference
			 *  @type object
			 *  @default null
			 */
			"oLoadedState": null,
		
			/**
			 * Source url for AJAX data for the table.
			 * Note that this parameter will be set by the initialisation routine. To
			 * set a default use {@link DataTable.defaults}.
			 *  @type string
			 *  @default null
			 */
			"sAjaxSource": null,
		
			/**
			 * Property from a given object from which to read the table data from. This
			 * can be an empty string (when not server-side processing), in which case
			 * it is  assumed an an array is given directly.
			 * Note that this parameter will be set by the initialisation routine. To
			 * set a default use {@link DataTable.defaults}.
			 *  @type string
			 */
			"sAjaxDataProp": null,
		
			/**
			 * Note if draw should be blocked while getting data
			 *  @type boolean
			 *  @default true
			 */
			"bAjaxDataGet": true,
		
			/**
			 * The last jQuery XHR object that was used for server-side data gathering.
			 * This can be used for working with the XHR information in one of the
			 * callbacks
			 *  @type object
			 *  @default null
			 */
			"jqXHR": null,
		
			/**
			 * JSON returned from the server in the last Ajax request
			 *  @type object
			 *  @default undefined
			 */
			"json": undefined,
		
			/**
			 * Data submitted as part of the last Ajax request
			 *  @type object
			 *  @default undefined
			 */
			"oAjaxData": undefined,
		
			/**
			 * Function to get the server-side data.
			 * Note that this parameter will be set by the initialisation routine. To
			 * set a default use {@link DataTable.defaults}.
			 *  @type function
			 */
			"fnServerData": null,
		
			/**
			 * Functions which are called prior to sending an Ajax request so extra
			 * parameters can easily be sent to the server
			 *  @type array
			 *  @default []
			 */
			"aoServerParams": [],
		
			/**
			 * Send the XHR HTTP method - GET or POST (could be PUT or DELETE if
			 * required).
			 * Note that this parameter will be set by the initialisation routine. To
			 * set a default use {@link DataTable.defaults}.
			 *  @type string
			 */
			"sServerMethod": null,
		
			/**
			 * Format numbers for display.
			 * Note that this parameter will be set by the initialisation routine. To
			 * set a default use {@link DataTable.defaults}.
			 *  @type function
			 */
			"fnFormatNumber": null,
		
			/**
			 * List of options that can be used for the user selectable length menu.
			 * Note that this parameter will be set by the initialisation routine. To
			 * set a default use {@link DataTable.defaults}.
			 *  @type array
			 *  @default []
			 */
			"aLengthMenu": null,
		
			/**
			 * Counter for the draws that the table does. Also used as a tracker for
			 * server-side processing
			 *  @type int
			 *  @default 0
			 */
			"iDraw": 0,
		
			/**
			 * Indicate if a redraw is being done - useful for Ajax
			 *  @type boolean
			 *  @default false
			 */
			"bDrawing": false,
		
			/**
			 * Draw index (iDraw) of the last error when parsing the returned data
			 *  @type int
			 *  @default -1
			 */
			"iDrawError": -1,
		
			/**
			 * Paging display length
			 *  @type int
			 *  @default 10
			 */
			"_iDisplayLength": 10,
		
			/**
			 * Paging start point - aiDisplay index
			 *  @type int
			 *  @default 0
			 */
			"_iDisplayStart": 0,
		
			/**
			 * Server-side processing - number of records in the result set
			 * (i.e. before filtering), Use fnRecordsTotal rather than
			 * this property to get the value of the number of records, regardless of
			 * the server-side processing setting.
			 *  @type int
			 *  @default 0
			 *  @private
			 */
			"_iRecordsTotal": 0,
		
			/**
			 * Server-side processing - number of records in the current display set
			 * (i.e. after filtering). Use fnRecordsDisplay rather than
			 * this property to get the value of the number of records, regardless of
			 * the server-side processing setting.
			 *  @type boolean
			 *  @default 0
			 *  @private
			 */
			"_iRecordsDisplay": 0,
		
			/**
			 * Flag to indicate if jQuery UI marking and classes should be used.
			 * Note that this parameter will be set by the initialisation routine. To
			 * set a default use {@link DataTable.defaults}.
			 *  @type boolean
			 */
			"bJUI": null,
		
			/**
			 * The classes to use for the table
			 *  @type object
			 *  @default {}
			 */
			"oClasses": {},
		
			/**
			 * Flag attached to the settings object so you can check in the draw
			 * callback if filtering has been done in the draw. Deprecated in favour of
			 * events.
			 *  @type boolean
			 *  @default false
			 *  @deprecated
			 */
			"bFiltered": false,
		
			/**
			 * Flag attached to the settings object so you can check in the draw
			 * callback if sorting has been done in the draw. Deprecated in favour of
			 * events.
			 *  @type boolean
			 *  @default false
			 *  @deprecated
			 */
			"bSorted": false,
		
			/**
			 * Indicate that if multiple rows are in the header and there is more than
			 * one unique cell per column, if the top one (true) or bottom one (false)
			 * should be used for sorting / title by DataTables.
			 * Note that this parameter will be set by the initialisation routine. To
			 * set a default use {@link DataTable.defaults}.
			 *  @type boolean
			 */
			"bSortCellsTop": null,
		
			/**
			 * Initialisation object that is used for the table
			 *  @type object
			 *  @default null
			 */
			"oInit": null,
		
			/**
			 * Destroy callback functions - for plug-ins to attach themselves to the
			 * destroy so they can clean up markup and events.
			 *  @type array
			 *  @default []
			 */
			"aoDestroyCallback": [],
		
		
			/**
			 * Get the number of records in the current record set, before filtering
			 *  @type function
			 */
			"fnRecordsTotal": function ()
			{
				return _fnDataSource( this ) == 'ssp' ?
					this._iRecordsTotal * 1 :
					this.aiDisplayMaster.length;
			},
		
			/**
			 * Get the number of records in the current record set, after filtering
			 *  @type function
			 */
			"fnRecordsDisplay": function ()
			{
				return _fnDataSource( this ) == 'ssp' ?
					this._iRecordsDisplay * 1 :
					this.aiDisplay.length;
			},
		
			/**
			 * Get the display end point - aiDisplay index
			 *  @type function
			 */
			"fnDisplayEnd": function ()
			{
				var
					len      = this._iDisplayLength,
					start    = this._iDisplayStart,
					calc     = start + len,
					records  = this.aiDisplay.length,
					features = this.oFeatures,
					paginate = features.bPaginate;
		
				if ( features.bServerSide ) {
					return paginate === false || len === -1 ?
						start + records :
						Math.min( start+len, this._iRecordsDisplay );
				}
				else {
					return ! paginate || calc>records || len===-1 ?
						records :
						calc;
				}
			},
		
			/**
			 * The DataTables object for this table
			 *  @type object
			 *  @default null
			 */
			"oInstance": null,
		
			/**
			 * Unique identifier for each instance of the DataTables object. If there
			 * is an ID on the table node, then it takes that value, otherwise an
			 * incrementing internal counter is used.
			 *  @type string
			 *  @default null
			 */
			"sInstance": null,
		
			/**
			 * tabindex attribute value that is added to DataTables control elements, allowing
			 * keyboard navigation of the table and its controls.
			 */
			"iTabIndex": 0,
		
			/**
			 * DIV container for the footer scrolling table if scrolling
			 */
			"nScrollHead": null,
		
			/**
			 * DIV container for the footer scrolling table if scrolling
			 */
			"nScrollFoot": null,
		
			/**
			 * Last applied sort
			 *  @type array
			 *  @default []
			 */
			"aLastSort": [],
		
			/**
			 * Stored plug-in instances
			 *  @type object
			 *  @default {}
			 */
			"oPlugins": {},
		
			/**
			 * Function used to get a row's id from the row's data
			 *  @type function
			 *  @default null
			 */
			"rowIdFn": null,
		
			/**
			 * Data location where to store a row's id
			 *  @type string
			 *  @default null
			 */
			"rowId": null
		};
	
		/**
		 * Extension object for DataTables that is used to provide all extension
		 * options.
		 *
		 * Note that the `DataTable.ext` object is available through
		 * `jQuery.fn.dataTable.ext` where it may be accessed and manipulated. It is
		 * also aliased to `jQuery.fn.dataTableExt` for historic reasons.
		 *  @namespace
		 *  @extends DataTable.models.ext
		 */
		
		
		/**
		 * DataTables extensions
		 * 
		 * This namespace acts as a collection area for plug-ins that can be used to
		 * extend DataTables capabilities. Indeed many of the build in methods
		 * use this method to provide their own capabilities (sorting methods for
		 * example).
		 *
		 * Note that this namespace is aliased to `jQuery.fn.dataTableExt` for legacy
		 * reasons
		 *
		 *  @namespace
		 */
		DataTable.ext = _ext = {
			/**
			 * Buttons. For use with the Buttons extension for DataTables. This is
			 * defined here so other extensions can define buttons regardless of load
			 * order. It is _not_ used by DataTables core.
			 *
			 *  @type object
			 *  @default {}
			 */
			buttons: {},
		
		
			/**
			 * Element class names
			 *
			 *  @type object
			 *  @default {}
			 */
			classes: {},
		
		
			/**
			 * DataTables build type (expanded by the download builder)
			 *
			 *  @type string
			 */
			builder: "-source-",
		
		
			/**
			 * Error reporting.
			 * 
			 * How should DataTables report an error. Can take the value 'alert',
			 * 'throw', 'none' or a function.
			 *
			 *  @type string|function
			 *  @default alert
			 */
			errMode: "alert",
		
		
			/**
			 * Feature plug-ins.
			 * 
			 * This is an array of objects which describe the feature plug-ins that are
			 * available to DataTables. These feature plug-ins are then available for
			 * use through the `dom` initialisation option.
			 * 
			 * Each feature plug-in is described by an object which must have the
			 * following properties:
			 * 
			 * * `fnInit` - function that is used to initialise the plug-in,
			 * * `cFeature` - a character so the feature can be enabled by the `dom`
			 *   instillation option. This is case sensitive.
			 *
			 * The `fnInit` function has the following input parameters:
			 *
			 * 1. `{object}` DataTables settings object: see
			 *    {@link DataTable.models.oSettings}
			 *
			 * And the following return is expected:
			 * 
			 * * {node|null} The element which contains your feature. Note that the
			 *   return may also be void if your plug-in does not require to inject any
			 *   DOM elements into DataTables control (`dom`) - for example this might
			 *   be useful when developing a plug-in which allows table control via
			 *   keyboard entry
			 *
			 *  @type array
			 *
			 *  @example
			 *    $.fn.dataTable.ext.features.push( {
			 *      "fnInit": function( oSettings ) {
			 *        return new TableTools( { "oDTSettings": oSettings } );
			 *      },
			 *      "cFeature": "T"
			 *    } );
			 */
			feature: [],
		
		
			/**
			 * Row searching.
			 * 
			 * This method of searching is complimentary to the default type based
			 * searching, and a lot more comprehensive as it allows you complete control
			 * over the searching logic. Each element in this array is a function
			 * (parameters described below) that is called for every row in the table,
			 * and your logic decides if it should be included in the searching data set
			 * or not.
			 *
			 * Searching functions have the following input parameters:
			 *
			 * 1. `{object}` DataTables settings object: see
			 *    {@link DataTable.models.oSettings}
			 * 2. `{array|object}` Data for the row to be processed (same as the
			 *    original format that was passed in as the data source, or an array
			 *    from a DOM data source
			 * 3. `{int}` Row index ({@link DataTable.models.oSettings.aoData}), which
			 *    can be useful to retrieve the `TR` element if you need DOM interaction.
			 *
			 * And the following return is expected:
			 *
			 * * {boolean} Include the row in the searched result set (true) or not
			 *   (false)
			 *
			 * Note that as with the main search ability in DataTables, technically this
			 * is "filtering", since it is subtractive. However, for consistency in
			 * naming we call it searching here.
			 *
			 *  @type array
			 *  @default []
			 *
			 *  @example
			 *    // The following example shows custom search being applied to the
			 *    // fourth column (i.e. the data[3] index) based on two input values
			 *    // from the end-user, matching the data in a certain range.
			 *    $.fn.dataTable.ext.search.push(
			 *      function( settings, data, dataIndex ) {
			 *        var min = document.getElementById('min').value * 1;
			 *        var max = document.getElementById('max').value * 1;
			 *        var version = data[3] == "-" ? 0 : data[3]*1;
			 *
			 *        if ( min == "" && max == "" ) {
			 *          return true;
			 *        }
			 *        else if ( min == "" && version < max ) {
			 *          return true;
			 *        }
			 *        else if ( min < version && "" == max ) {
			 *          return true;
			 *        }
			 *        else if ( min < version && version < max ) {
			 *          return true;
			 *        }
			 *        return false;
			 *      }
			 *    );
			 */
			search: [],
		
		
			/**
			 * Selector extensions
			 *
			 * The `selector` option can be used to extend the options available for the
			 * selector modifier options (`selector-modifier` object data type) that
			 * each of the three built in selector types offer (row, column and cell +
			 * their plural counterparts). For example the Select extension uses this
			 * mechanism to provide an option to select only rows, columns and cells
			 * that have been marked as selected by the end user (`{selected: true}`),
			 * which can be used in conjunction with the existing built in selector
			 * options.
			 *
			 * Each property is an array to which functions can be pushed. The functions
			 * take three attributes:
			 *
			 * * Settings object for the host table
			 * * Options object (`selector-modifier` object type)
			 * * Array of selected item indexes
			 *
			 * The return is an array of the resulting item indexes after the custom
			 * selector has been applied.
			 *
			 *  @type object
			 */
			selector: {
				cell: [],
				column: [],
				row: []
			},
		
		
			/**
			 * Internal functions, exposed for used in plug-ins.
			 * 
			 * Please note that you should not need to use the internal methods for
			 * anything other than a plug-in (and even then, try to avoid if possible).
			 * The internal function may change between releases.
			 *
			 *  @type object
			 *  @default {}
			 */
			internal: {},
		
		
			/**
			 * Legacy configuration options. Enable and disable legacy options that
			 * are available in DataTables.
			 *
			 *  @type object
			 */
			legacy: {
				/**
				 * Enable / disable DataTables 1.9 compatible server-side processing
				 * requests
				 *
				 *  @type boolean
				 *  @default null
				 */
				ajax: null
			},
		
		
			/**
			 * Pagination plug-in methods.
			 * 
			 * Each entry in this object is a function and defines which buttons should
			 * be shown by the pagination rendering method that is used for the table:
			 * {@link DataTable.ext.renderer.pageButton}. The renderer addresses how the
			 * buttons are displayed in the document, while the functions here tell it
			 * what buttons to display. This is done by returning an array of button
			 * descriptions (what each button will do).
			 *
			 * Pagination types (the four built in options and any additional plug-in
			 * options defined here) can be used through the `paginationType`
			 * initialisation parameter.
			 *
			 * The functions defined take two parameters:
			 *
			 * 1. `{int} page` The current page index
			 * 2. `{int} pages` The number of pages in the table
			 *
			 * Each function is expected to return an array where each element of the
			 * array can be one of:
			 *
			 * * `first` - Jump to first page when activated
			 * * `last` - Jump to last page when activated
			 * * `previous` - Show previous page when activated
			 * * `next` - Show next page when activated
			 * * `{int}` - Show page of the index given
			 * * `{array}` - A nested array containing the above elements to add a
			 *   containing 'DIV' element (might be useful for styling).
			 *
			 * Note that DataTables v1.9- used this object slightly differently whereby
			 * an object with two functions would be defined for each plug-in. That
			 * ability is still supported by DataTables 1.10+ to provide backwards
			 * compatibility, but this option of use is now decremented and no longer
			 * documented in DataTables 1.10+.
			 *
			 *  @type object
			 *  @default {}
			 *
			 *  @example
			 *    // Show previous, next and current page buttons only
			 *    $.fn.dataTableExt.oPagination.current = function ( page, pages ) {
			 *      return [ 'previous', page, 'next' ];
			 *    };
			 */
			pager: {},
		
		
			renderer: {
				pageButton: {},
				header: {}
			},
		
		
			/**
			 * Ordering plug-ins - custom data source
			 * 
			 * The extension options for ordering of data available here is complimentary
			 * to the default type based ordering that DataTables typically uses. It
			 * allows much greater control over the the data that is being used to
			 * order a column, but is necessarily therefore more complex.
			 * 
			 * This type of ordering is useful if you want to do ordering based on data
			 * live from the DOM (for example the contents of an 'input' element) rather
			 * than just the static string that DataTables knows of.
			 * 
			 * The way these plug-ins work is that you create an array of the values you
			 * wish to be ordering for the column in question and then return that
			 * array. The data in the array much be in the index order of the rows in
			 * the table (not the currently ordering order!). Which order data gathering
			 * function is run here depends on the `dt-init columns.orderDataType`
			 * parameter that is used for the column (if any).
			 *
			 * The functions defined take two parameters:
			 *
			 * 1. `{object}` DataTables settings object: see
			 *    {@link DataTable.models.oSettings}
			 * 2. `{int}` Target column index
			 *
			 * Each function is expected to return an array:
			 *
			 * * `{array}` Data for the column to be ordering upon
			 *
			 *  @type array
			 *
			 *  @example
			 *    // Ordering using `input` node values
			 *    $.fn.dataTable.ext.order['dom-text'] = function  ( settings, col )
			 *    {
			 *      return this.api().column( col, {order:'index'} ).nodes().map( function ( td, i ) {
			 *        return $('input', td).val();
			 *      } );
			 *    }
			 */
			order: {},
		
		
			/**
			 * Type based plug-ins.
			 *
			 * Each column in DataTables has a type assigned to it, either by automatic
			 * detection or by direct assignment using the `type` option for the column.
			 * The type of a column will effect how it is ordering and search (plug-ins
			 * can also make use of the column type if required).
			 *
			 * @namespace
			 */
			type: {
				/**
				 * Type detection functions.
				 *
				 * The functions defined in this object are used to automatically detect
				 * a column's type, making initialisation of DataTables super easy, even
				 * when complex data is in the table.
				 *
				 * The functions defined take two parameters:
				 *
			     *  1. `{*}` Data from the column cell to be analysed
			     *  2. `{settings}` DataTables settings object. This can be used to
			     *     perform context specific type detection - for example detection
			     *     based on language settings such as using a comma for a decimal
			     *     place. Generally speaking the options from the settings will not
			     *     be required
				 *
				 * Each function is expected to return:
				 *
				 * * `{string|null}` Data type detected, or null if unknown (and thus
				 *   pass it on to the other type detection functions.
				 *
				 *  @type array
				 *
				 *  @example
				 *    // Currency type detection plug-in:
				 *    $.fn.dataTable.ext.type.detect.push(
				 *      function ( data, settings ) {
				 *        // Check the numeric part
				 *        if ( ! $.isNumeric( data.substring(1) ) ) {
				 *          return null;
				 *        }
				 *
				 *        // Check prefixed by currency
				 *        if ( data.charAt(0) == '$' || data.charAt(0) == '&pound;' ) {
				 *          return 'currency';
				 *        }
				 *        return null;
				 *      }
				 *    );
				 */
				detect: [],
		
		
				/**
				 * Type based search formatting.
				 *
				 * The type based searching functions can be used to pre-format the
				 * data to be search on. For example, it can be used to strip HTML
				 * tags or to de-format telephone numbers for numeric only searching.
				 *
				 * Note that is a search is not defined for a column of a given type,
				 * no search formatting will be performed.
				 * 
				 * Pre-processing of searching data plug-ins - When you assign the sType
				 * for a column (or have it automatically detected for you by DataTables
				 * or a type detection plug-in), you will typically be using this for
				 * custom sorting, but it can also be used to provide custom searching
				 * by allowing you to pre-processing the data and returning the data in
				 * the format that should be searched upon. This is done by adding
				 * functions this object with a parameter name which matches the sType
				 * for that target column. This is the corollary of <i>afnSortData</i>
				 * for searching data.
				 *
				 * The functions defined take a single parameter:
				 *
			     *  1. `{*}` Data from the column cell to be prepared for searching
				 *
				 * Each function is expected to return:
				 *
				 * * `{string|null}` Formatted string that will be used for the searching.
				 *
				 *  @type object
				 *  @default {}
				 *
				 *  @example
				 *    $.fn.dataTable.ext.type.search['title-numeric'] = function ( d ) {
				 *      return d.replace(/\n/g," ").replace( /<.*?>/g, "" );
				 *    }
				 */
				search: {},
		
		
				/**
				 * Type based ordering.
				 *
				 * The column type tells DataTables what ordering to apply to the table
				 * when a column is sorted upon. The order for each type that is defined,
				 * is defined by the functions available in this object.
				 *
				 * Each ordering option can be described by three properties added to
				 * this object:
				 *
				 * * `{type}-pre` - Pre-formatting function
				 * * `{type}-asc` - Ascending order function
				 * * `{type}-desc` - Descending order function
				 *
				 * All three can be used together, only `{type}-pre` or only
				 * `{type}-asc` and `{type}-desc` together. It is generally recommended
				 * that only `{type}-pre` is used, as this provides the optimal
				 * implementation in terms of speed, although the others are provided
				 * for compatibility with existing Javascript sort functions.
				 *
				 * `{type}-pre`: Functions defined take a single parameter:
				 *
			     *  1. `{*}` Data from the column cell to be prepared for ordering
				 *
				 * And return:
				 *
				 * * `{*}` Data to be sorted upon
				 *
				 * `{type}-asc` and `{type}-desc`: Functions are typical Javascript sort
				 * functions, taking two parameters:
				 *
			     *  1. `{*}` Data to compare to the second parameter
			     *  2. `{*}` Data to compare to the first parameter
				 *
				 * And returning:
				 *
				 * * `{*}` Ordering match: <0 if first parameter should be sorted lower
				 *   than the second parameter, ===0 if the two parameters are equal and
				 *   >0 if the first parameter should be sorted height than the second
				 *   parameter.
				 * 
				 *  @type object
				 *  @default {}
				 *
				 *  @example
				 *    // Numeric ordering of formatted numbers with a pre-formatter
				 *    $.extend( $.fn.dataTable.ext.type.order, {
				 *      "string-pre": function(x) {
				 *        a = (a === "-" || a === "") ? 0 : a.replace( /[^\d\-\.]/g, "" );
				 *        return parseFloat( a );
				 *      }
				 *    } );
				 *
				 *  @example
				 *    // Case-sensitive string ordering, with no pre-formatting method
				 *    $.extend( $.fn.dataTable.ext.order, {
				 *      "string-case-asc": function(x,y) {
				 *        return ((x < y) ? -1 : ((x > y) ? 1 : 0));
				 *      },
				 *      "string-case-desc": function(x,y) {
				 *        return ((x < y) ? 1 : ((x > y) ? -1 : 0));
				 *      }
				 *    } );
				 */
				order: {}
			},
		
			/**
			 * Unique DataTables instance counter
			 *
			 * @type int
			 * @private
			 */
			_unique: 0,
		
		
			//
			// Depreciated
			// The following properties are retained for backwards compatiblity only.
			// The should not be used in new projects and will be removed in a future
			// version
			//
		
			/**
			 * Version check function.
			 *  @type function
			 *  @depreciated Since 1.10
			 */
			fnVersionCheck: DataTable.fnVersionCheck,
		
		
			/**
			 * Index for what 'this' index API functions should use
			 *  @type int
			 *  @deprecated Since v1.10
			 */
			iApiIndex: 0,
		
		
			/**
			 * jQuery UI class container
			 *  @type object
			 *  @deprecated Since v1.10
			 */
			oJUIClasses: {},
		
		
			/**
			 * Software version
			 *  @type string
			 *  @deprecated Since v1.10
			 */
			sVersion: DataTable.version
		};
		
		
		//
		// Backwards compatibility. Alias to pre 1.10 Hungarian notation counter parts
		//
		$.extend( _ext, {
			afnFiltering: _ext.search,
			aTypes:       _ext.type.detect,
			ofnSearch:    _ext.type.search,
			oSort:        _ext.type.order,
			afnSortData:  _ext.order,
			aoFeatures:   _ext.feature,
			oApi:         _ext.internal,
			oStdClasses:  _ext.classes,
			oPagination:  _ext.pager
		} );
		
		
		$.extend( DataTable.ext.classes, {
			"sTable": "dataTable",
			"sNoFooter": "no-footer",
		
			/* Paging buttons */
			"sPageButton": "paginate_button",
			"sPageButtonActive": "current",
			"sPageButtonDisabled": "disabled",
		
			/* Striping classes */
			"sStripeOdd": "odd",
			"sStripeEven": "even",
		
			/* Empty row */
			"sRowEmpty": "dataTables_empty",
		
			/* Features */
			"sWrapper": "dataTables_wrapper",
			"sFilter": "dataTables_filter",
			"sInfo": "dataTables_info",
			"sPaging": "dataTables_paginate paging_", /* Note that the type is postfixed */
			"sLength": "dataTables_length",
			"sProcessing": "dataTables_processing",
		
			/* Sorting */
			"sSortAsc": "sorting_asc",
			"sSortDesc": "sorting_desc",
			"sSortable": "sorting", /* Sortable in both directions */
			"sSortableAsc": "sorting_asc_disabled",
			"sSortableDesc": "sorting_desc_disabled",
			"sSortableNone": "sorting_disabled",
			"sSortColumn": "sorting_", /* Note that an int is postfixed for the sorting order */
		
			/* Filtering */
			"sFilterInput": "",
		
			/* Page length */
			"sLengthSelect": "",
		
			/* Scrolling */
			"sScrollWrapper": "dataTables_scroll",
			"sScrollHead": "dataTables_scrollHead",
			"sScrollHeadInner": "dataTables_scrollHeadInner",
			"sScrollBody": "dataTables_scrollBody",
			"sScrollFoot": "dataTables_scrollFoot",
			"sScrollFootInner": "dataTables_scrollFootInner",
		
			/* Misc */
			"sHeaderTH": "",
			"sFooterTH": "",
		
			// Deprecated
			"sSortJUIAsc": "",
			"sSortJUIDesc": "",
			"sSortJUI": "",
			"sSortJUIAscAllowed": "",
			"sSortJUIDescAllowed": "",
			"sSortJUIWrapper": "",
			"sSortIcon": "",
			"sJUIHeader": "",
			"sJUIFooter": ""
		} );
		
		
		(function() {
		
		// Reused strings for better compression. Closure compiler appears to have a
		// weird edge case where it is trying to expand strings rather than use the
		// variable version. This results in about 200 bytes being added, for very
		// little preference benefit since it this run on script load only.
		var _empty = '';
		_empty = '';
		
		var _stateDefault = _empty + 'ui-state-default';
		var _sortIcon     = _empty + 'css_right ui-icon ui-icon-';
		var _headerFooter = _empty + 'fg-toolbar ui-toolbar ui-widget-header ui-helper-clearfix';
		
		$.extend( DataTable.ext.oJUIClasses, DataTable.ext.classes, {
			/* Full numbers paging buttons */
			"sPageButton":         "fg-button ui-button "+_stateDefault,
			"sPageButtonActive":   "ui-state-disabled",
			"sPageButtonDisabled": "ui-state-disabled",
		
			/* Features */
			"sPaging": "dataTables_paginate fg-buttonset ui-buttonset fg-buttonset-multi "+
				"ui-buttonset-multi paging_", /* Note that the type is postfixed */
		
			/* Sorting */
			"sSortAsc":            _stateDefault+" sorting_asc",
			"sSortDesc":           _stateDefault+" sorting_desc",
			"sSortable":           _stateDefault+" sorting",
			"sSortableAsc":        _stateDefault+" sorting_asc_disabled",
			"sSortableDesc":       _stateDefault+" sorting_desc_disabled",
			"sSortableNone":       _stateDefault+" sorting_disabled",
			"sSortJUIAsc":         _sortIcon+"triangle-1-n",
			"sSortJUIDesc":        _sortIcon+"triangle-1-s",
			"sSortJUI":            _sortIcon+"carat-2-n-s",
			"sSortJUIAscAllowed":  _sortIcon+"carat-1-n",
			"sSortJUIDescAllowed": _sortIcon+"carat-1-s",
			"sSortJUIWrapper":     "DataTables_sort_wrapper",
			"sSortIcon":           "DataTables_sort_icon",
		
			/* Scrolling */
			"sScrollHead": "dataTables_scrollHead "+_stateDefault,
			"sScrollFoot": "dataTables_scrollFoot "+_stateDefault,
		
			/* Misc */
			"sHeaderTH":  _stateDefault,
			"sFooterTH":  _stateDefault,
			"sJUIHeader": _headerFooter+" ui-corner-tl ui-corner-tr",
			"sJUIFooter": _headerFooter+" ui-corner-bl ui-corner-br"
		} );
		
		}());
		
		
		
		var extPagination = DataTable.ext.pager;
		
		function _numbers ( page, pages ) {
			var
				numbers = [],
				buttons = extPagination.numbers_length,
				half = Math.floor( buttons / 2 ),
				i = 1;
		
			if ( pages <= buttons ) {
				numbers = _range( 0, pages );
			}
			else if ( page <= half ) {
				numbers = _range( 0, buttons-2 );
				numbers.push( 'ellipsis' );
				numbers.push( pages-1 );
			}
			else if ( page >= pages - 1 - half ) {
				numbers = _range( pages-(buttons-2), pages );
				numbers.splice( 0, 0, 'ellipsis' ); // no unshift in ie6
				numbers.splice( 0, 0, 0 );
			}
			else {
				numbers = _range( page-half+2, page+half-1 );
				numbers.push( 'ellipsis' );
				numbers.push( pages-1 );
				numbers.splice( 0, 0, 'ellipsis' );
				numbers.splice( 0, 0, 0 );
			}
		
			numbers.DT_el = 'span';
			return numbers;
		}
		
		
		$.extend( extPagination, {
			simple: function ( page, pages ) {
				return [ 'previous', 'next' ];
			},
		
			full: function ( page, pages ) {
				return [  'first', 'previous', 'next', 'last' ];
			},
		
			numbers: function ( page, pages ) {
				return [ _numbers(page, pages) ];
			},
		
			simple_numbers: function ( page, pages ) {
				return [ 'previous', _numbers(page, pages), 'next' ];
			},
		
			full_numbers: function ( page, pages ) {
				return [ 'first', 'previous', _numbers(page, pages), 'next', 'last' ];
			},
		
			// For testing and plug-ins to use
			_numbers: _numbers,
		
			// Number of number buttons (including ellipsis) to show. _Must be odd!_
			numbers_length: 7
		} );
		
		
		$.extend( true, DataTable.ext.renderer, {
			pageButton: {
				_: function ( settings, host, idx, buttons, page, pages ) {
					var classes = settings.oClasses;
					var lang = settings.oLanguage.oPaginate;
					var aria = settings.oLanguage.oAria.paginate || {};
					var btnDisplay, btnClass, counter=0;
		
					var attach = function( container, buttons ) {
						var i, ien, node, button;
						var clickHandler = function ( e ) {
							_fnPageChange( settings, e.data.action, true );
						};
		
						for ( i=0, ien=buttons.length ; i<ien ; i++ ) {
							button = buttons[i];
		
							if ( $.isArray( button ) ) {
								var inner = $( '<'+(button.DT_el || 'div')+'/>' )
									.appendTo( container );
								attach( inner, button );
							}
							else {
								btnDisplay = null;
								btnClass = '';
		
								switch ( button ) {
									case 'ellipsis':
										container.append('<span class="ellipsis">&#x2026;</span>');
										break;
		
									case 'first':
										btnDisplay = lang.sFirst;
										btnClass = button + (page > 0 ?
											'' : ' '+classes.sPageButtonDisabled);
										break;
		
									case 'previous':
										btnDisplay = lang.sPrevious;
										btnClass = button + (page > 0 ?
											'' : ' '+classes.sPageButtonDisabled);
										break;
		
									case 'next':
										btnDisplay = lang.sNext;
										btnClass = button + (page < pages-1 ?
											'' : ' '+classes.sPageButtonDisabled);
										break;
		
									case 'last':
										btnDisplay = lang.sLast;
										btnClass = button + (page < pages-1 ?
											'' : ' '+classes.sPageButtonDisabled);
										break;
		
									default:
										btnDisplay = button + 1;
										btnClass = page === button ?
											classes.sPageButtonActive : '';
										break;
								}
		
								if ( btnDisplay !== null ) {
									node = $('<a>', {
											'class': classes.sPageButton+' '+btnClass,
											'aria-controls': settings.sTableId,
											'aria-label': aria[ button ],
											'data-dt-idx': counter,
											'tabindex': settings.iTabIndex,
											'id': idx === 0 && typeof button === 'string' ?
												settings.sTableId +'_'+ button :
												null
										} )
										.html( btnDisplay )
										.appendTo( container );
		
									_fnBindAction(
										node, {action: button}, clickHandler
									);
		
									counter++;
								}
							}
						}
					};
		
					// IE9 throws an 'unknown error' if document.activeElement is used
					// inside an iframe or frame. Try / catch the error. Not good for
					// accessibility, but neither are frames.
					var activeEl;
		
					try {
						// Because this approach is destroying and recreating the paging
						// elements, focus is lost on the select button which is bad for
						// accessibility. So we want to restore focus once the draw has
						// completed
						activeEl = $(host).find(document.activeElement).data('dt-idx');
					}
					catch (e) {}
		
					attach( $(host).empty(), buttons );
		
					if ( activeEl ) {
						$(host).find( '[data-dt-idx='+activeEl+']' ).focus();
					}
				}
			}
		} );
		
		
		
		// Built in type detection. See model.ext.aTypes for information about
		// what is required from this methods.
		$.extend( DataTable.ext.type.detect, [
			// Plain numbers - first since V8 detects some plain numbers as dates
			// e.g. Date.parse('55') (but not all, e.g. Date.parse('22')...).
			function ( d, settings )
			{
				var decimal = settings.oLanguage.sDecimal;
				return _isNumber( d, decimal ) ? 'num'+decimal : null;
			},
		
			// Dates (only those recognised by the browser's Date.parse)
			function ( d, settings )
			{
				// V8 will remove any unknown characters at the start and end of the
				// expression, leading to false matches such as `$245.12` or `10%` being
				// a valid date. See forum thread 18941 for detail.
				if ( d && !(d instanceof Date) && ( ! _re_date_start.test(d) || ! _re_date_end.test(d) ) ) {
					return null;
				}
				var parsed = Date.parse(d);
				return (parsed !== null && !isNaN(parsed)) || _empty(d) ? 'date' : null;
			},
		
			// Formatted numbers
			function ( d, settings )
			{
				var decimal = settings.oLanguage.sDecimal;
				return _isNumber( d, decimal, true ) ? 'num-fmt'+decimal : null;
			},
		
			// HTML numeric
			function ( d, settings )
			{
				var decimal = settings.oLanguage.sDecimal;
				return _htmlNumeric( d, decimal ) ? 'html-num'+decimal : null;
			},
		
			// HTML numeric, formatted
			function ( d, settings )
			{
				var decimal = settings.oLanguage.sDecimal;
				return _htmlNumeric( d, decimal, true ) ? 'html-num-fmt'+decimal : null;
			},
		
			// HTML (this is strict checking - there must be html)
			function ( d, settings )
			{
				return _empty( d ) || (typeof d === 'string' && d.indexOf('<') !== -1) ?
					'html' : null;
			}
		] );
		
		
		
		// Filter formatting functions. See model.ext.ofnSearch for information about
		// what is required from these methods.
		// 
		// Note that additional search methods are added for the html numbers and
		// html formatted numbers by `_addNumericSort()` when we know what the decimal
		// place is
		
		
		$.extend( DataTable.ext.type.search, {
			html: function ( data ) {
				return _empty(data) ?
					data :
					typeof data === 'string' ?
						data
							.replace( _re_new_lines, " " )
							.replace( _re_html, "" ) :
						'';
			},
		
			string: function ( data ) {
				return _empty(data) ?
					data :
					typeof data === 'string' ?
						data.replace( _re_new_lines, " " ) :
						data;
			}
		} );
		
		
		
		var __numericReplace = function ( d, decimalPlace, re1, re2 ) {
			if ( d !== 0 && (!d || d === '-') ) {
				return -Infinity;
			}
		
			// If a decimal place other than `.` is used, it needs to be given to the
			// function so we can detect it and replace with a `.` which is the only
			// decimal place Javascript recognises - it is not locale aware.
			if ( decimalPlace ) {
				d = _numToDecimal( d, decimalPlace );
			}
		
			if ( d.replace ) {
				if ( re1 ) {
					d = d.replace( re1, '' );
				}
		
				if ( re2 ) {
					d = d.replace( re2, '' );
				}
			}
		
			return d * 1;
		};
		
		
		// Add the numeric 'deformatting' functions for sorting and search. This is done
		// in a function to provide an easy ability for the language options to add
		// additional methods if a non-period decimal place is used.
		function _addNumericSort ( decimalPlace ) {
			$.each(
				{
					// Plain numbers
					"num": function ( d ) {
						return __numericReplace( d, decimalPlace );
					},
		
					// Formatted numbers
					"num-fmt": function ( d ) {
						return __numericReplace( d, decimalPlace, _re_formatted_numeric );
					},
		
					// HTML numeric
					"html-num": function ( d ) {
						return __numericReplace( d, decimalPlace, _re_html );
					},
		
					// HTML numeric, formatted
					"html-num-fmt": function ( d ) {
						return __numericReplace( d, decimalPlace, _re_html, _re_formatted_numeric );
					}
				},
				function ( key, fn ) {
					// Add the ordering method
					_ext.type.order[ key+decimalPlace+'-pre' ] = fn;
		
					// For HTML types add a search formatter that will strip the HTML
					if ( key.match(/^html\-/) ) {
						_ext.type.search[ key+decimalPlace ] = _ext.type.search.html;
					}
				}
			);
		}
		
		
		// Default sort methods
		$.extend( _ext.type.order, {
			// Dates
			"date-pre": function ( d ) {
				return Date.parse( d ) || 0;
			},
		
			// html
			"html-pre": function ( a ) {
				return _empty(a) ?
					'' :
					a.replace ?
						a.replace( /<.*?>/g, "" ).toLowerCase() :
						a+'';
			},
		
			// string
			"string-pre": function ( a ) {
				// This is a little complex, but faster than always calling toString,
				// http://jsperf.com/tostring-v-check
				return _empty(a) ?
					'' :
					typeof a === 'string' ?
						a.toLowerCase() :
						! a.toString ?
							'' :
							a.toString();
			},
		
			// string-asc and -desc are retained only for compatibility with the old
			// sort methods
			"string-asc": function ( x, y ) {
				return ((x < y) ? -1 : ((x > y) ? 1 : 0));
			},
		
			"string-desc": function ( x, y ) {
				return ((x < y) ? 1 : ((x > y) ? -1 : 0));
			}
		} );
		
		
		// Numeric sorting types - order doesn't matter here
		_addNumericSort( '' );
		
		
		$.extend( true, DataTable.ext.renderer, {
			header: {
				_: function ( settings, cell, column, classes ) {
					// No additional mark-up required
					// Attach a sort listener to update on sort - note that using the
					// `DT` namespace will allow the event to be removed automatically
					// on destroy, while the `dt` namespaced event is the one we are
					// listening for
					$(settings.nTable).on( 'order.dt.DT', function ( e, ctx, sorting, columns ) {
						if ( settings !== ctx ) { // need to check this this is the host
							return;               // table, not a nested one
						}
		
						var colIdx = column.idx;
		
						cell
							.removeClass(
								column.sSortingClass +' '+
								classes.sSortAsc +' '+
								classes.sSortDesc
							)
							.addClass( columns[ colIdx ] == 'asc' ?
								classes.sSortAsc : columns[ colIdx ] == 'desc' ?
									classes.sSortDesc :
									column.sSortingClass
							);
					} );
				},
		
				jqueryui: function ( settings, cell, column, classes ) {
					$('<div/>')
						.addClass( classes.sSortJUIWrapper )
						.append( cell.contents() )
						.append( $('<span/>')
							.addClass( classes.sSortIcon+' '+column.sSortingClassJUI )
						)
						.appendTo( cell );
		
					// Attach a sort listener to update on sort
					$(settings.nTable).on( 'order.dt.DT', function ( e, ctx, sorting, columns ) {
						if ( settings !== ctx ) {
							return;
						}
		
						var colIdx = column.idx;
		
						cell
							.removeClass( classes.sSortAsc +" "+classes.sSortDesc )
							.addClass( columns[ colIdx ] == 'asc' ?
								classes.sSortAsc : columns[ colIdx ] == 'desc' ?
									classes.sSortDesc :
									column.sSortingClass
							);
		
						cell
							.find( 'span.'+classes.sSortIcon )
							.removeClass(
								classes.sSortJUIAsc +" "+
								classes.sSortJUIDesc +" "+
								classes.sSortJUI +" "+
								classes.sSortJUIAscAllowed +" "+
								classes.sSortJUIDescAllowed
							)
							.addClass( columns[ colIdx ] == 'asc' ?
								classes.sSortJUIAsc : columns[ colIdx ] == 'desc' ?
									classes.sSortJUIDesc :
									column.sSortingClassJUI
							);
					} );
				}
			}
		} );
		
		/*
		 * Public helper functions. These aren't used internally by DataTables, or
		 * called by any of the options passed into DataTables, but they can be used
		 * externally by developers working with DataTables. They are helper functions
		 * to make working with DataTables a little bit easier.
		 */
		
		var __htmlEscapeEntities = function ( d ) {
			return typeof d === 'string' ?
				d.replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;') :
				d;
		};
		
		/**
		 * Helpers for `columns.render`.
		 *
		 * The options defined here can be used with the `columns.render` initialisation
		 * option to provide a display renderer. The following functions are defined:
		 *
		 * * `number` - Will format numeric data (defined by `columns.data`) for
		 *   display, retaining the original unformatted data for sorting and filtering.
		 *   It takes 5 parameters:
		 *   * `string` - Thousands grouping separator
		 *   * `string` - Decimal point indicator
		 *   * `integer` - Number of decimal points to show
		 *   * `string` (optional) - Prefix.
		 *   * `string` (optional) - Postfix (/suffix).
		 * * `text` - Escape HTML to help prevent XSS attacks. It has no optional
		 *   parameters.
		 *
		 * @example
		 *   // Column definition using the number renderer
		 *   {
		 *     data: "salary",
		 *     render: $.fn.dataTable.render.number( '\'', '.', 0, '$' )
		 *   }
		 *
		 * @namespace
		 */
		DataTable.render = {
			number: function ( thousands, decimal, precision, prefix, postfix ) {
				return {
					display: function ( d ) {
						if ( typeof d !== 'number' && typeof d !== 'string' ) {
							return d;
						}
		
						var negative = d < 0 ? '-' : '';
						var flo = parseFloat( d );
		
						// If NaN then there isn't much formatting that we can do - just
						// return immediately, escaping any HTML (this was supposed to
						// be a number after all)
						if ( isNaN( flo ) ) {
							return __htmlEscapeEntities( d );
						}
		
						d = Math.abs( flo );
		
						var intPart = parseInt( d, 10 );
						var floatPart = precision ?
							decimal+(d - intPart).toFixed( precision ).substring( 2 ):
							'';
		
						return negative + (prefix||'') +
							intPart.toString().replace(
								/\B(?=(\d{3})+(?!\d))/g, thousands
							) +
							floatPart +
							(postfix||'');
					}
				};
			},
		
			text: function () {
				return {
					display: __htmlEscapeEntities
				};
			}
		};
		
		
		/*
		 * This is really a good bit rubbish this method of exposing the internal methods
		 * publicly... - To be fixed in 2.0 using methods on the prototype
		 */
		
		
		/**
		 * Create a wrapper function for exporting an internal functions to an external API.
		 *  @param {string} fn API function name
		 *  @returns {function} wrapped function
		 *  @memberof DataTable#internal
		 */
		function _fnExternApiFunc (fn)
		{
			return function() {
				var args = [_fnSettingsFromNode( this[DataTable.ext.iApiIndex] )].concat(
					Array.prototype.slice.call(arguments)
				);
				return DataTable.ext.internal[fn].apply( this, args );
			};
		}
		
		
		/**
		 * Reference to internal functions for use by plug-in developers. Note that
		 * these methods are references to internal functions and are considered to be
		 * private. If you use these methods, be aware that they are liable to change
		 * between versions.
		 *  @namespace
		 */
		$.extend( DataTable.ext.internal, {
			_fnExternApiFunc: _fnExternApiFunc,
			_fnBuildAjax: _fnBuildAjax,
			_fnAjaxUpdate: _fnAjaxUpdate,
			_fnAjaxParameters: _fnAjaxParameters,
			_fnAjaxUpdateDraw: _fnAjaxUpdateDraw,
			_fnAjaxDataSrc: _fnAjaxDataSrc,
			_fnAddColumn: _fnAddColumn,
			_fnColumnOptions: _fnColumnOptions,
			_fnAdjustColumnSizing: _fnAdjustColumnSizing,
			_fnVisibleToColumnIndex: _fnVisibleToColumnIndex,
			_fnColumnIndexToVisible: _fnColumnIndexToVisible,
			_fnVisbleColumns: _fnVisbleColumns,
			_fnGetColumns: _fnGetColumns,
			_fnColumnTypes: _fnColumnTypes,
			_fnApplyColumnDefs: _fnApplyColumnDefs,
			_fnHungarianMap: _fnHungarianMap,
			_fnCamelToHungarian: _fnCamelToHungarian,
			_fnLanguageCompat: _fnLanguageCompat,
			_fnBrowserDetect: _fnBrowserDetect,
			_fnAddData: _fnAddData,
			_fnAddTr: _fnAddTr,
			_fnNodeToDataIndex: _fnNodeToDataIndex,
			_fnNodeToColumnIndex: _fnNodeToColumnIndex,
			_fnGetCellData: _fnGetCellData,
			_fnSetCellData: _fnSetCellData,
			_fnSplitObjNotation: _fnSplitObjNotation,
			_fnGetObjectDataFn: _fnGetObjectDataFn,
			_fnSetObjectDataFn: _fnSetObjectDataFn,
			_fnGetDataMaster: _fnGetDataMaster,
			_fnClearTable: _fnClearTable,
			_fnDeleteIndex: _fnDeleteIndex,
			_fnInvalidate: _fnInvalidate,
			_fnGetRowElements: _fnGetRowElements,
			_fnCreateTr: _fnCreateTr,
			_fnBuildHead: _fnBuildHead,
			_fnDrawHead: _fnDrawHead,
			_fnDraw: _fnDraw,
			_fnReDraw: _fnReDraw,
			_fnAddOptionsHtml: _fnAddOptionsHtml,
			_fnDetectHeader: _fnDetectHeader,
			_fnGetUniqueThs: _fnGetUniqueThs,
			_fnFeatureHtmlFilter: _fnFeatureHtmlFilter,
			_fnFilterComplete: _fnFilterComplete,
			_fnFilterCustom: _fnFilterCustom,
			_fnFilterColumn: _fnFilterColumn,
			_fnFilter: _fnFilter,
			_fnFilterCreateSearch: _fnFilterCreateSearch,
			_fnEscapeRegex: _fnEscapeRegex,
			_fnFilterData: _fnFilterData,
			_fnFeatureHtmlInfo: _fnFeatureHtmlInfo,
			_fnUpdateInfo: _fnUpdateInfo,
			_fnInfoMacros: _fnInfoMacros,
			_fnInitialise: _fnInitialise,
			_fnInitComplete: _fnInitComplete,
			_fnLengthChange: _fnLengthChange,
			_fnFeatureHtmlLength: _fnFeatureHtmlLength,
			_fnFeatureHtmlPaginate: _fnFeatureHtmlPaginate,
			_fnPageChange: _fnPageChange,
			_fnFeatureHtmlProcessing: _fnFeatureHtmlProcessing,
			_fnProcessingDisplay: _fnProcessingDisplay,
			_fnFeatureHtmlTable: _fnFeatureHtmlTable,
			_fnScrollDraw: _fnScrollDraw,
			_fnApplyToChildren: _fnApplyToChildren,
			_fnCalculateColumnWidths: _fnCalculateColumnWidths,
			_fnThrottle: _fnThrottle,
			_fnConvertToWidth: _fnConvertToWidth,
			_fnGetWidestNode: _fnGetWidestNode,
			_fnGetMaxLenString: _fnGetMaxLenString,
			_fnStringToCss: _fnStringToCss,
			_fnSortFlatten: _fnSortFlatten,
			_fnSort: _fnSort,
			_fnSortAria: _fnSortAria,
			_fnSortListener: _fnSortListener,
			_fnSortAttachListener: _fnSortAttachListener,
			_fnSortingClasses: _fnSortingClasses,
			_fnSortData: _fnSortData,
			_fnSaveState: _fnSaveState,
			_fnLoadState: _fnLoadState,
			_fnSettingsFromNode: _fnSettingsFromNode,
			_fnLog: _fnLog,
			_fnMap: _fnMap,
			_fnBindAction: _fnBindAction,
			_fnCallbackReg: _fnCallbackReg,
			_fnCallbackFire: _fnCallbackFire,
			_fnLengthOverflow: _fnLengthOverflow,
			_fnRenderer: _fnRenderer,
			_fnDataSource: _fnDataSource,
			_fnRowAttributes: _fnRowAttributes,
			_fnCalculateEnd: function () {} // Used by a lot of plug-ins, but redundant
			                                // in 1.10, so this dead-end function is
			                                // added to prevent errors
		} );
		
	
		// jQuery access
		$.fn.dataTable = DataTable;
	
		// Provide access to the host jQuery object (circular reference)
		DataTable.$ = $;
	
		// Legacy aliases
		$.fn.dataTableSettings = DataTable.settings;
		$.fn.dataTableExt = DataTable.ext;
	
		// With a capital `D` we return a DataTables API instance rather than a
		// jQuery object
		$.fn.DataTable = function ( opts ) {
			return $(this).dataTable( opts ).api();
		};
	
		// All properties that are available to $.fn.dataTable should also be
		// available on $.fn.DataTable
		$.each( DataTable, function ( prop, val ) {
			$.fn.DataTable[ prop ] = val;
		} );
	
	
		// Information about events fired by DataTables - for documentation.
		/**
		 * Draw event, fired whenever the table is redrawn on the page, at the same
		 * point as fnDrawCallback. This may be useful for binding events or
		 * performing calculations when the table is altered at all.
		 *  @name DataTable#draw.dt
		 *  @event
		 *  @param {event} e jQuery event object
		 *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
		 */
	
		/**
		 * Search event, fired when the searching applied to the table (using the
		 * built-in global search, or column filters) is altered.
		 *  @name DataTable#search.dt
		 *  @event
		 *  @param {event} e jQuery event object
		 *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
		 */
	
		/**
		 * Page change event, fired when the paging of the table is altered.
		 *  @name DataTable#page.dt
		 *  @event
		 *  @param {event} e jQuery event object
		 *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
		 */
	
		/**
		 * Order event, fired when the ordering applied to the table is altered.
		 *  @name DataTable#order.dt
		 *  @event
		 *  @param {event} e jQuery event object
		 *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
		 */
	
		/**
		 * DataTables initialisation complete event, fired when the table is fully
		 * drawn, including Ajax data loaded, if Ajax data is required.
		 *  @name DataTable#init.dt
		 *  @event
		 *  @param {event} e jQuery event object
		 *  @param {object} oSettings DataTables settings object
		 *  @param {object} json The JSON object request from the server - only
		 *    present if client-side Ajax sourced data is used</li></ol>
		 */
	
		/**
		 * State save event, fired when the table has changed state a new state save
		 * is required. This event allows modification of the state saving object
		 * prior to actually doing the save, including addition or other state
		 * properties (for plug-ins) or modification of a DataTables core property.
		 *  @name DataTable#stateSaveParams.dt
		 *  @event
		 *  @param {event} e jQuery event object
		 *  @param {object} oSettings DataTables settings object
		 *  @param {object} json The state information to be saved
		 */
	
		/**
		 * State load event, fired when the table is loading state from the stored
		 * data, but prior to the settings object being modified by the saved state
		 * - allowing modification of the saved state is required or loading of
		 * state for a plug-in.
		 *  @name DataTable#stateLoadParams.dt
		 *  @event
		 *  @param {event} e jQuery event object
		 *  @param {object} oSettings DataTables settings object
		 *  @param {object} json The saved state information
		 */
	
		/**
		 * State loaded event, fired when state has been loaded from stored data and
		 * the settings object has been modified by the loaded data.
		 *  @name DataTable#stateLoaded.dt
		 *  @event
		 *  @param {event} e jQuery event object
		 *  @param {object} oSettings DataTables settings object
		 *  @param {object} json The saved state information
		 */
	
		/**
		 * Processing event, fired when DataTables is doing some kind of processing
		 * (be it, order, searcg or anything else). It can be used to indicate to
		 * the end user that there is something happening, or that something has
		 * finished.
		 *  @name DataTable#processing.dt
		 *  @event
		 *  @param {event} e jQuery event object
		 *  @param {object} oSettings DataTables settings object
		 *  @param {boolean} bShow Flag for if DataTables is doing processing or not
		 */
	
		/**
		 * Ajax (XHR) event, fired whenever an Ajax request is completed from a
		 * request to made to the server for new data. This event is called before
		 * DataTables processed the returned data, so it can also be used to pre-
		 * process the data returned from the server, if needed.
		 *
		 * Note that this trigger is called in `fnServerData`, if you override
		 * `fnServerData` and which to use this event, you need to trigger it in you
		 * success function.
		 *  @name DataTable#xhr.dt
		 *  @event
		 *  @param {event} e jQuery event object
		 *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
		 *  @param {object} json JSON returned from the server
		 *
		 *  @example
		 *     // Use a custom property returned from the server in another DOM element
		 *     $('#table').dataTable().on('xhr.dt', function (e, settings, json) {
		 *       $('#status').html( json.status );
		 *     } );
		 *
		 *  @example
		 *     // Pre-process the data returned from the server
		 *     $('#table').dataTable().on('xhr.dt', function (e, settings, json) {
		 *       for ( var i=0, ien=json.aaData.length ; i<ien ; i++ ) {
		 *         json.aaData[i].sum = json.aaData[i].one + json.aaData[i].two;
		 *       }
		 *       // Note no return - manipulate the data directly in the JSON object.
		 *     } );
		 */
	
		/**
		 * Destroy event, fired when the DataTable is destroyed by calling fnDestroy
		 * or passing the bDestroy:true parameter in the initialisation object. This
		 * can be used to remove bound events, added DOM nodes, etc.
		 *  @name DataTable#destroy.dt
		 *  @event
		 *  @param {event} e jQuery event object
		 *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
		 */
	
		/**
		 * Page length change event, fired when number of records to show on each
		 * page (the length) is changed.
		 *  @name DataTable#length.dt
		 *  @event
		 *  @param {event} e jQuery event object
		 *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
		 *  @param {integer} len New length
		 */
	
		/**
		 * Column sizing has changed.
		 *  @name DataTable#column-sizing.dt
		 *  @event
		 *  @param {event} e jQuery event object
		 *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
		 */
	
		/**
		 * Column visibility has changed.
		 *  @name DataTable#column-visibility.dt
		 *  @event
		 *  @param {event} e jQuery event object
		 *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
		 *  @param {int} column Column index
		 *  @param {bool} vis `false` if column now hidden, or `true` if visible
		 */
	
		return $.fn.dataTable;
	}));
	


/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	/*** IMPORTS FROM imports-loader ***/
	var define = false;
	
	/*! DataTables Bootstrap 3 integration
	 * Â©2011-2015 SpryMedia Ltd - datatables.net/license
	 */
	
	/**
	 * DataTables integration for Bootstrap 3. This requires Bootstrap 3 and
	 * DataTables 1.10 or newer.
	 *
	 * This file sets the defaults and adds options to DataTables to style its
	 * controls using Bootstrap. See http://datatables.net/manual/styling/bootstrap
	 * for further information.
	 */
	(function( factory ){
		if ( typeof define === 'function' && define.amd ) {
			// AMD
			define( ['jquery', 'datatables.net'], function ( $ ) {
				return factory( $, window, document );
			} );
		}
		else if ( true ) {
			// CommonJS
			module.exports = function (root, $) {
				if ( ! root ) {
					root = window;
				}
	
				if ( ! $ || ! $.fn.dataTable ) {
					// Require DataTables, which attaches to jQuery, including
					// jQuery if needed and have a $ property so we can access the
					// jQuery object that is used
					$ = __webpack_require__(4)(root, $).$;
				}
	
				return factory( $, root, root.document );
			};
		}
		else {
			// Browser
			factory( jQuery, window, document );
		}
	}(function( $, window, document, undefined ) {
	'use strict';
	var DataTable = $.fn.dataTable;
	
	
	/* Set the defaults for DataTables initialisation */
	$.extend( true, DataTable.defaults, {
		dom:
			"<'row'<'col-sm-6'l><'col-sm-6'f>>" +
			"<'row'<'col-sm-12'tr>>" +
			"<'row'<'col-sm-5'i><'col-sm-7'p>>",
		renderer: 'bootstrap'
	} );
	
	
	/* Default class modification */
	$.extend( DataTable.ext.classes, {
		sWrapper:      "dataTables_wrapper form-inline dt-bootstrap",
		sFilterInput:  "form-control input-sm",
		sLengthSelect: "form-control input-sm",
		sProcessing:   "dataTables_processing panel panel-default"
	} );
	
	
	/* Bootstrap paging button renderer */
	DataTable.ext.renderer.pageButton.bootstrap = function ( settings, host, idx, buttons, page, pages ) {
		var api     = new DataTable.Api( settings );
		var classes = settings.oClasses;
		var lang    = settings.oLanguage.oPaginate;
		var aria = settings.oLanguage.oAria.paginate || {};
		var btnDisplay, btnClass, counter=0;
	
		var attach = function( container, buttons ) {
			var i, ien, node, button;
			var clickHandler = function ( e ) {
				e.preventDefault();
				if ( !$(e.currentTarget).hasClass('disabled') && api.page() != e.data.action ) {
					api.page( e.data.action ).draw( 'page' );
				}
			};
	
			for ( i=0, ien=buttons.length ; i<ien ; i++ ) {
				button = buttons[i];
	
				if ( $.isArray( button ) ) {
					attach( container, button );
				}
				else {
					btnDisplay = '';
					btnClass = '';
	
					switch ( button ) {
						case 'ellipsis':
							btnDisplay = '&#x2026;';
							btnClass = 'disabled';
							break;
	
						case 'first':
							btnDisplay = lang.sFirst;
							btnClass = button + (page > 0 ?
								'' : ' disabled');
							break;
	
						case 'previous':
							btnDisplay = lang.sPrevious;
							btnClass = button + (page > 0 ?
								'' : ' disabled');
							break;
	
						case 'next':
							btnDisplay = lang.sNext;
							btnClass = button + (page < pages-1 ?
								'' : ' disabled');
							break;
	
						case 'last':
							btnDisplay = lang.sLast;
							btnClass = button + (page < pages-1 ?
								'' : ' disabled');
							break;
	
						default:
							btnDisplay = button + 1;
							btnClass = page === button ?
								'active' : '';
							break;
					}
	
					if ( btnDisplay ) {
						node = $('<li>', {
								'class': classes.sPageButton+' '+btnClass,
								'id': idx === 0 && typeof button === 'string' ?
									settings.sTableId +'_'+ button :
									null
							} )
							.append( $('<a>', {
									'href': '#',
									'aria-controls': settings.sTableId,
									'aria-label': aria[ button ],
									'data-dt-idx': counter,
									'tabindex': settings.iTabIndex
								} )
								.html( btnDisplay )
							)
							.appendTo( container );
	
						settings.oApi._fnBindAction(
							node, {action: button}, clickHandler
						);
	
						counter++;
					}
				}
			}
		};
	
		// IE9 throws an 'unknown error' if document.activeElement is used
		// inside an iframe or frame. 
		var activeEl;
	
		try {
			// Because this approach is destroying and recreating the paging
			// elements, focus is lost on the select button which is bad for
			// accessibility. So we want to restore focus once the draw has
			// completed
			activeEl = $(host).find(document.activeElement).data('dt-idx');
		}
		catch (e) {}
	
		attach(
			$(host).empty().html('<ul class="pagination"/>').children('ul'),
			buttons
		);
	
		if ( activeEl ) {
			$(host).find( '[data-dt-idx='+activeEl+']' ).focus();
		}
	};
	
	
	return DataTable;
	}));


/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*! DataTables 1.10.12
	 * Â©2008-2015 SpryMedia Ltd - datatables.net/license
	 */
	
	/**
	 * @summary     DataTables
	 * @description Paginate, search and order HTML tables
	 * @version     1.10.12
	 * @file        jquery.dataTables.js
	 * @author      SpryMedia Ltd (www.sprymedia.co.uk)
	 * @contact     www.sprymedia.co.uk/contact
	 * @copyright   Copyright 2008-2015 SpryMedia Ltd.
	 *
	 * This source file is free software, available under the following license:
	 *   MIT license - http://datatables.net/license
	 *
	 * This source file is distributed in the hope that it will be useful, but
	 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
	 * or FITNESS FOR A PARTICULAR PURPOSE. See the license files for details.
	 *
	 * For details please refer to: http://www.datatables.net
	 */
	
	/*jslint evil: true, undef: true, browser: true */
	/*globals $,require,jQuery,define,_selector_run,_selector_opts,_selector_first,_selector_row_indexes,_ext,_Api,_api_register,_api_registerPlural,_re_new_lines,_re_html,_re_formatted_numeric,_re_escape_regex,_empty,_intVal,_numToDecimal,_isNumber,_isHtml,_htmlNumeric,_pluck,_pluck_order,_range,_stripHtml,_unique,_fnBuildAjax,_fnAjaxUpdate,_fnAjaxParameters,_fnAjaxUpdateDraw,_fnAjaxDataSrc,_fnAddColumn,_fnColumnOptions,_fnAdjustColumnSizing,_fnVisibleToColumnIndex,_fnColumnIndexToVisible,_fnVisbleColumns,_fnGetColumns,_fnColumnTypes,_fnApplyColumnDefs,_fnHungarianMap,_fnCamelToHungarian,_fnLanguageCompat,_fnBrowserDetect,_fnAddData,_fnAddTr,_fnNodeToDataIndex,_fnNodeToColumnIndex,_fnGetCellData,_fnSetCellData,_fnSplitObjNotation,_fnGetObjectDataFn,_fnSetObjectDataFn,_fnGetDataMaster,_fnClearTable,_fnDeleteIndex,_fnInvalidate,_fnGetRowElements,_fnCreateTr,_fnBuildHead,_fnDrawHead,_fnDraw,_fnReDraw,_fnAddOptionsHtml,_fnDetectHeader,_fnGetUniqueThs,_fnFeatureHtmlFilter,_fnFilterComplete,_fnFilterCustom,_fnFilterColumn,_fnFilter,_fnFilterCreateSearch,_fnEscapeRegex,_fnFilterData,_fnFeatureHtmlInfo,_fnUpdateInfo,_fnInfoMacros,_fnInitialise,_fnInitComplete,_fnLengthChange,_fnFeatureHtmlLength,_fnFeatureHtmlPaginate,_fnPageChange,_fnFeatureHtmlProcessing,_fnProcessingDisplay,_fnFeatureHtmlTable,_fnScrollDraw,_fnApplyToChildren,_fnCalculateColumnWidths,_fnThrottle,_fnConvertToWidth,_fnGetWidestNode,_fnGetMaxLenString,_fnStringToCss,_fnSortFlatten,_fnSort,_fnSortAria,_fnSortListener,_fnSortAttachListener,_fnSortingClasses,_fnSortData,_fnSaveState,_fnLoadState,_fnSettingsFromNode,_fnLog,_fnMap,_fnBindAction,_fnCallbackReg,_fnCallbackFire,_fnLengthOverflow,_fnRenderer,_fnDataSource,_fnRowAttributes*/
	
	(function( factory ) {
		"use strict";
	
		if ( true ) {
			// AMD
			!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(1)], __WEBPACK_AMD_DEFINE_RESULT__ = function ( $ ) {
				return factory( $, window, document );
			}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
		}
		else if ( typeof exports === 'object' ) {
			// CommonJS
			module.exports = function (root, $) {
				if ( ! root ) {
					// CommonJS environments without a window global must pass a
					// root. This will give an error otherwise
					root = window;
				}
	
				if ( ! $ ) {
					$ = typeof window !== 'undefined' ? // jQuery's factory checks for a global window
						require('jquery') :
						require('jquery')( root );
				}
	
				return factory( $, root, root.document );
			};
		}
		else {
			// Browser
			factory( jQuery, window, document );
		}
	}
	(function( $, window, document, undefined ) {
		"use strict";
	
		/**
		 * DataTables is a plug-in for the jQuery Javascript library. It is a highly
		 * flexible tool, based upon the foundations of progressive enhancement,
		 * which will add advanced interaction controls to any HTML table. For a
		 * full list of features please refer to
		 * [DataTables.net](href="http://datatables.net).
		 *
		 * Note that the `DataTable` object is not a global variable but is aliased
		 * to `jQuery.fn.DataTable` and `jQuery.fn.dataTable` through which it may
		 * be  accessed.
		 *
		 *  @class
		 *  @param {object} [init={}] Configuration object for DataTables. Options
		 *    are defined by {@link DataTable.defaults}
		 *  @requires jQuery 1.7+
		 *
		 *  @example
		 *    // Basic initialisation
		 *    $(document).ready( function {
		 *      $('#example').dataTable();
		 *    } );
		 *
		 *  @example
		 *    // Initialisation with configuration options - in this case, disable
		 *    // pagination and sorting.
		 *    $(document).ready( function {
		 *      $('#example').dataTable( {
		 *        "paginate": false,
		 *        "sort": false
		 *      } );
		 *    } );
		 */
		var DataTable = function ( options )
		{
			/**
			 * Perform a jQuery selector action on the table's TR elements (from the tbody) and
			 * return the resulting jQuery object.
			 *  @param {string|node|jQuery} sSelector jQuery selector or node collection to act on
			 *  @param {object} [oOpts] Optional parameters for modifying the rows to be included
			 *  @param {string} [oOpts.filter=none] Select TR elements that meet the current filter
			 *    criterion ("applied") or all TR elements (i.e. no filter).
			 *  @param {string} [oOpts.order=current] Order of the TR elements in the processed array.
			 *    Can be either 'current', whereby the current sorting of the table is used, or
			 *    'original' whereby the original order the data was read into the table is used.
			 *  @param {string} [oOpts.page=all] Limit the selection to the currently displayed page
			 *    ("current") or not ("all"). If 'current' is given, then order is assumed to be
			 *    'current' and filter is 'applied', regardless of what they might be given as.
			 *  @returns {object} jQuery object, filtered by the given selector.
			 *  @dtopt API
			 *  @deprecated Since v1.10
			 *
			 *  @example
			 *    $(document).ready(function() {
			 *      var oTable = $('#example').dataTable();
			 *
			 *      // Highlight every second row
			 *      oTable.$('tr:odd').css('backgroundColor', 'blue');
			 *    } );
			 *
			 *  @example
			 *    $(document).ready(function() {
			 *      var oTable = $('#example').dataTable();
			 *
			 *      // Filter to rows with 'Webkit' in them, add a background colour and then
			 *      // remove the filter, thus highlighting the 'Webkit' rows only.
			 *      oTable.fnFilter('Webkit');
			 *      oTable.$('tr', {"search": "applied"}).css('backgroundColor', 'blue');
			 *      oTable.fnFilter('');
			 *    } );
			 */
			this.$ = function ( sSelector, oOpts )
			{
				return this.api(true).$( sSelector, oOpts );
			};
			
			
			/**
			 * Almost identical to $ in operation, but in this case returns the data for the matched
			 * rows - as such, the jQuery selector used should match TR row nodes or TD/TH cell nodes
			 * rather than any descendants, so the data can be obtained for the row/cell. If matching
			 * rows are found, the data returned is the original data array/object that was used to
			 * create the row (or a generated array if from a DOM source).
			 *
			 * This method is often useful in-combination with $ where both functions are given the
			 * same parameters and the array indexes will match identically.
			 *  @param {string|node|jQuery} sSelector jQuery selector or node collection to act on
			 *  @param {object} [oOpts] Optional parameters for modifying the rows to be included
			 *  @param {string} [oOpts.filter=none] Select elements that meet the current filter
			 *    criterion ("applied") or all elements (i.e. no filter).
			 *  @param {string} [oOpts.order=current] Order of the data in the processed array.
			 *    Can be either 'current', whereby the current sorting of the table is used, or
			 *    'original' whereby the original order the data was read into the table is used.
			 *  @param {string} [oOpts.page=all] Limit the selection to the currently displayed page
			 *    ("current") or not ("all"). If 'current' is given, then order is assumed to be
			 *    'current' and filter is 'applied', regardless of what they might be given as.
			 *  @returns {array} Data for the matched elements. If any elements, as a result of the
			 *    selector, were not TR, TD or TH elements in the DataTable, they will have a null
			 *    entry in the array.
			 *  @dtopt API
			 *  @deprecated Since v1.10
			 *
			 *  @example
			 *    $(document).ready(function() {
			 *      var oTable = $('#example').dataTable();
			 *
			 *      // Get the data from the first row in the table
			 *      var data = oTable._('tr:first');
			 *
			 *      // Do something useful with the data
			 *      alert( "First cell is: "+data[0] );
			 *    } );
			 *
			 *  @example
			 *    $(document).ready(function() {
			 *      var oTable = $('#example').dataTable();
			 *
			 *      // Filter to 'Webkit' and get all data for
			 *      oTable.fnFilter('Webkit');
			 *      var data = oTable._('tr', {"search": "applied"});
			 *
			 *      // Do something with the data
			 *      alert( data.length+" rows matched the search" );
			 *    } );
			 */
			this._ = function ( sSelector, oOpts )
			{
				return this.api(true).rows( sSelector, oOpts ).data();
			};
			
			
			/**
			 * Create a DataTables Api instance, with the currently selected tables for
			 * the Api's context.
			 * @param {boolean} [traditional=false] Set the API instance's context to be
			 *   only the table referred to by the `DataTable.ext.iApiIndex` option, as was
			 *   used in the API presented by DataTables 1.9- (i.e. the traditional mode),
			 *   or if all tables captured in the jQuery object should be used.
			 * @return {DataTables.Api}
			 */
			this.api = function ( traditional )
			{
				return traditional ?
					new _Api(
						_fnSettingsFromNode( this[ _ext.iApiIndex ] )
					) :
					new _Api( this );
			};
			
			
			/**
			 * Add a single new row or multiple rows of data to the table. Please note
			 * that this is suitable for client-side processing only - if you are using
			 * server-side processing (i.e. "bServerSide": true), then to add data, you
			 * must add it to the data source, i.e. the server-side, through an Ajax call.
			 *  @param {array|object} data The data to be added to the table. This can be:
			 *    <ul>
			 *      <li>1D array of data - add a single row with the data provided</li>
			 *      <li>2D array of arrays - add multiple rows in a single call</li>
			 *      <li>object - data object when using <i>mData</i></li>
			 *      <li>array of objects - multiple data objects when using <i>mData</i></li>
			 *    </ul>
			 *  @param {bool} [redraw=true] redraw the table or not
			 *  @returns {array} An array of integers, representing the list of indexes in
			 *    <i>aoData</i> ({@link DataTable.models.oSettings}) that have been added to
			 *    the table.
			 *  @dtopt API
			 *  @deprecated Since v1.10
			 *
			 *  @example
			 *    // Global var for counter
			 *    var giCount = 2;
			 *
			 *    $(document).ready(function() {
			 *      $('#example').dataTable();
			 *    } );
			 *
			 *    function fnClickAddRow() {
			 *      $('#example').dataTable().fnAddData( [
			 *        giCount+".1",
			 *        giCount+".2",
			 *        giCount+".3",
			 *        giCount+".4" ]
			 *      );
			 *
			 *      giCount++;
			 *    }
			 */
			this.fnAddData = function( data, redraw )
			{
				var api = this.api( true );
			
				/* Check if we want to add multiple rows or not */
				var rows = $.isArray(data) && ( $.isArray(data[0]) || $.isPlainObject(data[0]) ) ?
					api.rows.add( data ) :
					api.row.add( data );
			
				if ( redraw === undefined || redraw ) {
					api.draw();
				}
			
				return rows.flatten().toArray();
			};
			
			
			/**
			 * This function will make DataTables recalculate the column sizes, based on the data
			 * contained in the table and the sizes applied to the columns (in the DOM, CSS or
			 * through the sWidth parameter). This can be useful when the width of the table's
			 * parent element changes (for example a window resize).
			 *  @param {boolean} [bRedraw=true] Redraw the table or not, you will typically want to
			 *  @dtopt API
			 *  @deprecated Since v1.10
			 *
			 *  @example
			 *    $(document).ready(function() {
			 *      var oTable = $('#example').dataTable( {
			 *        "sScrollY": "200px",
			 *        "bPaginate": false
			 *      } );
			 *
			 *      $(window).bind('resize', function () {
			 *        oTable.fnAdjustColumnSizing();
			 *      } );
			 *    } );
			 */
			this.fnAdjustColumnSizing = function ( bRedraw )
			{
				var api = this.api( true ).columns.adjust();
				var settings = api.settings()[0];
				var scroll = settings.oScroll;
			
				if ( bRedraw === undefined || bRedraw ) {
					api.draw( false );
				}
				else if ( scroll.sX !== "" || scroll.sY !== "" ) {
					/* If not redrawing, but scrolling, we want to apply the new column sizes anyway */
					_fnScrollDraw( settings );
				}
			};
			
			
			/**
			 * Quickly and simply clear a table
			 *  @param {bool} [bRedraw=true] redraw the table or not
			 *  @dtopt API
			 *  @deprecated Since v1.10
			 *
			 *  @example
			 *    $(document).ready(function() {
			 *      var oTable = $('#example').dataTable();
			 *
			 *      // Immediately 'nuke' the current rows (perhaps waiting for an Ajax callback...)
			 *      oTable.fnClearTable();
			 *    } );
			 */
			this.fnClearTable = function( bRedraw )
			{
				var api = this.api( true ).clear();
			
				if ( bRedraw === undefined || bRedraw ) {
					api.draw();
				}
			};
			
			
			/**
			 * The exact opposite of 'opening' a row, this function will close any rows which
			 * are currently 'open'.
			 *  @param {node} nTr the table row to 'close'
			 *  @returns {int} 0 on success, or 1 if failed (can't find the row)
			 *  @dtopt API
			 *  @deprecated Since v1.10
			 *
			 *  @example
			 *    $(document).ready(function() {
			 *      var oTable;
			 *
			 *      // 'open' an information row when a row is clicked on
			 *      $('#example tbody tr').click( function () {
			 *        if ( oTable.fnIsOpen(this) ) {
			 *          oTable.fnClose( this );
			 *        } else {
			 *          oTable.fnOpen( this, "Temporary row opened", "info_row" );
			 *        }
			 *      } );
			 *
			 *      oTable = $('#example').dataTable();
			 *    } );
			 */
			this.fnClose = function( nTr )
			{
				this.api( true ).row( nTr ).child.hide();
			};
			
			
			/**
			 * Remove a row for the table
			 *  @param {mixed} target The index of the row from aoData to be deleted, or
			 *    the TR element you want to delete
			 *  @param {function|null} [callBack] Callback function
			 *  @param {bool} [redraw=true] Redraw the table or not
			 *  @returns {array} The row that was deleted
			 *  @dtopt API
			 *  @deprecated Since v1.10
			 *
			 *  @example
			 *    $(document).ready(function() {
			 *      var oTable = $('#example').dataTable();
			 *
			 *      // Immediately remove the first row
			 *      oTable.fnDeleteRow( 0 );
			 *    } );
			 */
			this.fnDeleteRow = function( target, callback, redraw )
			{
				var api = this.api( true );
				var rows = api.rows( target );
				var settings = rows.settings()[0];
				var data = settings.aoData[ rows[0][0] ];
			
				rows.remove();
			
				if ( callback ) {
					callback.call( this, settings, data );
				}
			
				if ( redraw === undefined || redraw ) {
					api.draw();
				}
			
				return data;
			};
			
			
			/**
			 * Restore the table to it's original state in the DOM by removing all of DataTables
			 * enhancements, alterations to the DOM structure of the table and event listeners.
			 *  @param {boolean} [remove=false] Completely remove the table from the DOM
			 *  @dtopt API
			 *  @deprecated Since v1.10
			 *
			 *  @example
			 *    $(document).ready(function() {
			 *      // This example is fairly pointless in reality, but shows how fnDestroy can be used
			 *      var oTable = $('#example').dataTable();
			 *      oTable.fnDestroy();
			 *    } );
			 */
			this.fnDestroy = function ( remove )
			{
				this.api( true ).destroy( remove );
			};
			
			
			/**
			 * Redraw the table
			 *  @param {bool} [complete=true] Re-filter and resort (if enabled) the table before the draw.
			 *  @dtopt API
			 *  @deprecated Since v1.10
			 *
			 *  @example
			 *    $(document).ready(function() {
			 *      var oTable = $('#example').dataTable();
			 *
			 *      // Re-draw the table - you wouldn't want to do it here, but it's an example :-)
			 *      oTable.fnDraw();
			 *    } );
			 */
			this.fnDraw = function( complete )
			{
				// Note that this isn't an exact match to the old call to _fnDraw - it takes
				// into account the new data, but can hold position.
				this.api( true ).draw( complete );
			};
			
			
			/**
			 * Filter the input based on data
			 *  @param {string} sInput String to filter the table on
			 *  @param {int|null} [iColumn] Column to limit filtering to
			 *  @param {bool} [bRegex=false] Treat as regular expression or not
			 *  @param {bool} [bSmart=true] Perform smart filtering or not
			 *  @param {bool} [bShowGlobal=true] Show the input global filter in it's input box(es)
			 *  @param {bool} [bCaseInsensitive=true] Do case-insensitive matching (true) or not (false)
			 *  @dtopt API
			 *  @deprecated Since v1.10
			 *
			 *  @example
			 *    $(document).ready(function() {
			 *      var oTable = $('#example').dataTable();
			 *
			 *      // Sometime later - filter...
			 *      oTable.fnFilter( 'test string' );
			 *    } );
			 */
			this.fnFilter = function( sInput, iColumn, bRegex, bSmart, bShowGlobal, bCaseInsensitive )
			{
				var api = this.api( true );
			
				if ( iColumn === null || iColumn === undefined ) {
					api.search( sInput, bRegex, bSmart, bCaseInsensitive );
				}
				else {
					api.column( iColumn ).search( sInput, bRegex, bSmart, bCaseInsensitive );
				}
			
				api.draw();
			};
			
			
			/**
			 * Get the data for the whole table, an individual row or an individual cell based on the
			 * provided parameters.
			 *  @param {int|node} [src] A TR row node, TD/TH cell node or an integer. If given as
			 *    a TR node then the data source for the whole row will be returned. If given as a
			 *    TD/TH cell node then iCol will be automatically calculated and the data for the
			 *    cell returned. If given as an integer, then this is treated as the aoData internal
			 *    data index for the row (see fnGetPosition) and the data for that row used.
			 *  @param {int} [col] Optional column index that you want the data of.
			 *  @returns {array|object|string} If mRow is undefined, then the data for all rows is
			 *    returned. If mRow is defined, just data for that row, and is iCol is
			 *    defined, only data for the designated cell is returned.
			 *  @dtopt API
			 *  @deprecated Since v1.10
			 *
			 *  @example
			 *    // Row data
			 *    $(document).ready(function() {
			 *      oTable = $('#example').dataTable();
			 *
			 *      oTable.$('tr').click( function () {
			 *        var data = oTable.fnGetData( this );
			 *        // ... do something with the array / object of data for the row
			 *      } );
			 *    } );
			 *
			 *  @example
			 *    // Individual cell data
			 *    $(document).ready(function() {
			 *      oTable = $('#example').dataTable();
			 *
			 *      oTable.$('td').click( function () {
			 *        var sData = oTable.fnGetData( this );
			 *        alert( 'The cell clicked on had the value of '+sData );
			 *      } );
			 *    } );
			 */
			this.fnGetData = function( src, col )
			{
				var api = this.api( true );
			
				if ( src !== undefined ) {
					var type = src.nodeName ? src.nodeName.toLowerCase() : '';
			
					return col !== undefined || type == 'td' || type == 'th' ?
						api.cell( src, col ).data() :
						api.row( src ).data() || null;
				}
			
				return api.data().toArray();
			};
			
			
			/**
			 * Get an array of the TR nodes that are used in the table's body. Note that you will
			 * typically want to use the '$' API method in preference to this as it is more
			 * flexible.
			 *  @param {int} [iRow] Optional row index for the TR element you want
			 *  @returns {array|node} If iRow is undefined, returns an array of all TR elements
			 *    in the table's body, or iRow is defined, just the TR element requested.
			 *  @dtopt API
			 *  @deprecated Since v1.10
			 *
			 *  @example
			 *    $(document).ready(function() {
			 *      var oTable = $('#example').dataTable();
			 *
			 *      // Get the nodes from the table
			 *      var nNodes = oTable.fnGetNodes( );
			 *    } );
			 */
			this.fnGetNodes = function( iRow )
			{
				var api = this.api( true );
			
				return iRow !== undefined ?
					api.row( iRow ).node() :
					api.rows().nodes().flatten().toArray();
			};
			
			
			/**
			 * Get the array indexes of a particular cell from it's DOM element
			 * and column index including hidden columns
			 *  @param {node} node this can either be a TR, TD or TH in the table's body
			 *  @returns {int} If nNode is given as a TR, then a single index is returned, or
			 *    if given as a cell, an array of [row index, column index (visible),
			 *    column index (all)] is given.
			 *  @dtopt API
			 *  @deprecated Since v1.10
			 *
			 *  @example
			 *    $(document).ready(function() {
			 *      $('#example tbody td').click( function () {
			 *        // Get the position of the current data from the node
			 *        var aPos = oTable.fnGetPosition( this );
			 *
			 *        // Get the data array for this row
			 *        var aData = oTable.fnGetData( aPos[0] );
			 *
			 *        // Update the data array and return the value
			 *        aData[ aPos[1] ] = 'clicked';
			 *        this.innerHTML = 'clicked';
			 *      } );
			 *
			 *      // Init DataTables
			 *      oTable = $('#example').dataTable();
			 *    } );
			 */
			this.fnGetPosition = function( node )
			{
				var api = this.api( true );
				var nodeName = node.nodeName.toUpperCase();
			
				if ( nodeName == 'TR' ) {
					return api.row( node ).index();
				}
				else if ( nodeName == 'TD' || nodeName == 'TH' ) {
					var cell = api.cell( node ).index();
			
					return [
						cell.row,
						cell.columnVisible,
						cell.column
					];
				}
				return null;
			};
			
			
			/**
			 * Check to see if a row is 'open' or not.
			 *  @param {node} nTr the table row to check
			 *  @returns {boolean} true if the row is currently open, false otherwise
			 *  @dtopt API
			 *  @deprecated Since v1.10
			 *
			 *  @example
			 *    $(document).ready(function() {
			 *      var oTable;
			 *
			 *      // 'open' an information row when a row is clicked on
			 *      $('#example tbody tr').click( function () {
			 *        if ( oTable.fnIsOpen(this) ) {
			 *          oTable.fnClose( this );
			 *        } else {
			 *          oTable.fnOpen( this, "Temporary row opened", "info_row" );
			 *        }
			 *      } );
			 *
			 *      oTable = $('#example').dataTable();
			 *    } );
			 */
			this.fnIsOpen = function( nTr )
			{
				return this.api( true ).row( nTr ).child.isShown();
			};
			
			
			/**
			 * This function will place a new row directly after a row which is currently
			 * on display on the page, with the HTML contents that is passed into the
			 * function. This can be used, for example, to ask for confirmation that a
			 * particular record should be deleted.
			 *  @param {node} nTr The table row to 'open'
			 *  @param {string|node|jQuery} mHtml The HTML to put into the row
			 *  @param {string} sClass Class to give the new TD cell
			 *  @returns {node} The row opened. Note that if the table row passed in as the
			 *    first parameter, is not found in the table, this method will silently
			 *    return.
			 *  @dtopt API
			 *  @deprecated Since v1.10
			 *
			 *  @example
			 *    $(document).ready(function() {
			 *      var oTable;
			 *
			 *      // 'open' an information row when a row is clicked on
			 *      $('#example tbody tr').click( function () {
			 *        if ( oTable.fnIsOpen(this) ) {
			 *          oTable.fnClose( this );
			 *        } else {
			 *          oTable.fnOpen( this, "Temporary row opened", "info_row" );
			 *        }
			 *      } );
			 *
			 *      oTable = $('#example').dataTable();
			 *    } );
			 */
			this.fnOpen = function( nTr, mHtml, sClass )
			{
				return this.api( true )
					.row( nTr )
					.child( mHtml, sClass )
					.show()
					.child()[0];
			};
			
			
			/**
			 * Change the pagination - provides the internal logic for pagination in a simple API
			 * function. With this function you can have a DataTables table go to the next,
			 * previous, first or last pages.
			 *  @param {string|int} mAction Paging action to take: "first", "previous", "next" or "last"
			 *    or page number to jump to (integer), note that page 0 is the first page.
			 *  @param {bool} [bRedraw=true] Redraw the table or not
			 *  @dtopt API
			 *  @deprecated Since v1.10
			 *
			 *  @example
			 *    $(document).ready(function() {
			 *      var oTable = $('#example').dataTable();
			 *      oTable.fnPageChange( 'next' );
			 *    } );
			 */
			this.fnPageChange = function ( mAction, bRedraw )
			{
				var api = this.api( true ).page( mAction );
			
				if ( bRedraw === undefined || bRedraw ) {
					api.draw(false);
				}
			};
			
			
			/**
			 * Show a particular column
			 *  @param {int} iCol The column whose display should be changed
			 *  @param {bool} bShow Show (true) or hide (false) the column
			 *  @param {bool} [bRedraw=true] Redraw the table or not
			 *  @dtopt API
			 *  @deprecated Since v1.10
			 *
			 *  @example
			 *    $(document).ready(function() {
			 *      var oTable = $('#example').dataTable();
			 *
			 *      // Hide the second column after initialisation
			 *      oTable.fnSetColumnVis( 1, false );
			 *    } );
			 */
			this.fnSetColumnVis = function ( iCol, bShow, bRedraw )
			{
				var api = this.api( true ).column( iCol ).visible( bShow );
			
				if ( bRedraw === undefined || bRedraw ) {
					api.columns.adjust().draw();
				}
			};
			
			
			/**
			 * Get the settings for a particular table for external manipulation
			 *  @returns {object} DataTables settings object. See
			 *    {@link DataTable.models.oSettings}
			 *  @dtopt API
			 *  @deprecated Since v1.10
			 *
			 *  @example
			 *    $(document).ready(function() {
			 *      var oTable = $('#example').dataTable();
			 *      var oSettings = oTable.fnSettings();
			 *
			 *      // Show an example parameter from the settings
			 *      alert( oSettings._iDisplayStart );
			 *    } );
			 */
			this.fnSettings = function()
			{
				return _fnSettingsFromNode( this[_ext.iApiIndex] );
			};
			
			
			/**
			 * Sort the table by a particular column
			 *  @param {int} iCol the data index to sort on. Note that this will not match the
			 *    'display index' if you have hidden data entries
			 *  @dtopt API
			 *  @deprecated Since v1.10
			 *
			 *  @example
			 *    $(document).ready(function() {
			 *      var oTable = $('#example').dataTable();
			 *
			 *      // Sort immediately with columns 0 and 1
			 *      oTable.fnSort( [ [0,'asc'], [1,'asc'] ] );
			 *    } );
			 */
			this.fnSort = function( aaSort )
			{
				this.api( true ).order( aaSort ).draw();
			};
			
			
			/**
			 * Attach a sort listener to an element for a given column
			 *  @param {node} nNode the element to attach the sort listener to
			 *  @param {int} iColumn the column that a click on this node will sort on
			 *  @param {function} [fnCallback] callback function when sort is run
			 *  @dtopt API
			 *  @deprecated Since v1.10
			 *
			 *  @example
			 *    $(document).ready(function() {
			 *      var oTable = $('#example').dataTable();
			 *
			 *      // Sort on column 1, when 'sorter' is clicked on
			 *      oTable.fnSortListener( document.getElementById('sorter'), 1 );
			 *    } );
			 */
			this.fnSortListener = function( nNode, iColumn, fnCallback )
			{
				this.api( true ).order.listener( nNode, iColumn, fnCallback );
			};
			
			
			/**
			 * Update a table cell or row - this method will accept either a single value to
			 * update the cell with, an array of values with one element for each column or
			 * an object in the same format as the original data source. The function is
			 * self-referencing in order to make the multi column updates easier.
			 *  @param {object|array|string} mData Data to update the cell/row with
			 *  @param {node|int} mRow TR element you want to update or the aoData index
			 *  @param {int} [iColumn] The column to update, give as null or undefined to
			 *    update a whole row.
			 *  @param {bool} [bRedraw=true] Redraw the table or not
			 *  @param {bool} [bAction=true] Perform pre-draw actions or not
			 *  @returns {int} 0 on success, 1 on error
			 *  @dtopt API
			 *  @deprecated Since v1.10
			 *
			 *  @example
			 *    $(document).ready(function() {
			 *      var oTable = $('#example').dataTable();
			 *      oTable.fnUpdate( 'Example update', 0, 0 ); // Single cell
			 *      oTable.fnUpdate( ['a', 'b', 'c', 'd', 'e'], $('tbody tr')[0] ); // Row
			 *    } );
			 */
			this.fnUpdate = function( mData, mRow, iColumn, bRedraw, bAction )
			{
				var api = this.api( true );
			
				if ( iColumn === undefined || iColumn === null ) {
					api.row( mRow ).data( mData );
				}
				else {
					api.cell( mRow, iColumn ).data( mData );
				}
			
				if ( bAction === undefined || bAction ) {
					api.columns.adjust();
				}
			
				if ( bRedraw === undefined || bRedraw ) {
					api.draw();
				}
				return 0;
			};
			
			
			/**
			 * Provide a common method for plug-ins to check the version of DataTables being used, in order
			 * to ensure compatibility.
			 *  @param {string} sVersion Version string to check for, in the format "X.Y.Z". Note that the
			 *    formats "X" and "X.Y" are also acceptable.
			 *  @returns {boolean} true if this version of DataTables is greater or equal to the required
			 *    version, or false if this version of DataTales is not suitable
			 *  @method
			 *  @dtopt API
			 *  @deprecated Since v1.10
			 *
			 *  @example
			 *    $(document).ready(function() {
			 *      var oTable = $('#example').dataTable();
			 *      alert( oTable.fnVersionCheck( '1.9.0' ) );
			 *    } );
			 */
			this.fnVersionCheck = _ext.fnVersionCheck;
			
	
			var _that = this;
			var emptyInit = options === undefined;
			var len = this.length;
	
			if ( emptyInit ) {
				options = {};
			}
	
			this.oApi = this.internal = _ext.internal;
	
			// Extend with old style plug-in API methods
			for ( var fn in DataTable.ext.internal ) {
				if ( fn ) {
					this[fn] = _fnExternApiFunc(fn);
				}
			}
	
			this.each(function() {
				// For each initialisation we want to give it a clean initialisation
				// object that can be bashed around
				var o = {};
				var oInit = len > 1 ? // optimisation for single table case
					_fnExtend( o, options, true ) :
					options;
	
				/*global oInit,_that,emptyInit*/
				var i=0, iLen, j, jLen, k, kLen;
				var sId = this.getAttribute( 'id' );
				var bInitHandedOff = false;
				var defaults = DataTable.defaults;
				var $this = $(this);
				
				
				/* Sanity check */
				if ( this.nodeName.toLowerCase() != 'table' )
				{
					_fnLog( null, 0, 'Non-table node initialisation ('+this.nodeName+')', 2 );
					return;
				}
				
				/* Backwards compatibility for the defaults */
				_fnCompatOpts( defaults );
				_fnCompatCols( defaults.column );
				
				/* Convert the camel-case defaults to Hungarian */
				_fnCamelToHungarian( defaults, defaults, true );
				_fnCamelToHungarian( defaults.column, defaults.column, true );
				
				/* Setting up the initialisation object */
				_fnCamelToHungarian( defaults, $.extend( oInit, $this.data() ) );
				
				
				
				/* Check to see if we are re-initialising a table */
				var allSettings = DataTable.settings;
				for ( i=0, iLen=allSettings.length ; i<iLen ; i++ )
				{
					var s = allSettings[i];
				
					/* Base check on table node */
					if ( s.nTable == this || s.nTHead.parentNode == this || (s.nTFoot && s.nTFoot.parentNode == this) )
					{
						var bRetrieve = oInit.bRetrieve !== undefined ? oInit.bRetrieve : defaults.bRetrieve;
						var bDestroy = oInit.bDestroy !== undefined ? oInit.bDestroy : defaults.bDestroy;
				
						if ( emptyInit || bRetrieve )
						{
							return s.oInstance;
						}
						else if ( bDestroy )
						{
							s.oInstance.fnDestroy();
							break;
						}
						else
						{
							_fnLog( s, 0, 'Cannot reinitialise DataTable', 3 );
							return;
						}
					}
				
					/* If the element we are initialising has the same ID as a table which was previously
					 * initialised, but the table nodes don't match (from before) then we destroy the old
					 * instance by simply deleting it. This is under the assumption that the table has been
					 * destroyed by other methods. Anyone using non-id selectors will need to do this manually
					 */
					if ( s.sTableId == this.id )
					{
						allSettings.splice( i, 1 );
						break;
					}
				}
				
				/* Ensure the table has an ID - required for accessibility */
				if ( sId === null || sId === "" )
				{
					sId = "DataTables_Table_"+(DataTable.ext._unique++);
					this.id = sId;
				}
				
				/* Create the settings object for this table and set some of the default parameters */
				var oSettings = $.extend( true, {}, DataTable.models.oSettings, {
					"sDestroyWidth": $this[0].style.width,
					"sInstance":     sId,
					"sTableId":      sId
				} );
				oSettings.nTable = this;
				oSettings.oApi   = _that.internal;
				oSettings.oInit  = oInit;
				
				allSettings.push( oSettings );
				
				// Need to add the instance after the instance after the settings object has been added
				// to the settings array, so we can self reference the table instance if more than one
				oSettings.oInstance = (_that.length===1) ? _that : $this.dataTable();
				
				// Backwards compatibility, before we apply all the defaults
				_fnCompatOpts( oInit );
				
				if ( oInit.oLanguage )
				{
					_fnLanguageCompat( oInit.oLanguage );
				}
				
				// If the length menu is given, but the init display length is not, use the length menu
				if ( oInit.aLengthMenu && ! oInit.iDisplayLength )
				{
					oInit.iDisplayLength = $.isArray( oInit.aLengthMenu[0] ) ?
						oInit.aLengthMenu[0][0] : oInit.aLengthMenu[0];
				}
				
				// Apply the defaults and init options to make a single init object will all
				// options defined from defaults and instance options.
				oInit = _fnExtend( $.extend( true, {}, defaults ), oInit );
				
				
				// Map the initialisation options onto the settings object
				_fnMap( oSettings.oFeatures, oInit, [
					"bPaginate",
					"bLengthChange",
					"bFilter",
					"bSort",
					"bSortMulti",
					"bInfo",
					"bProcessing",
					"bAutoWidth",
					"bSortClasses",
					"bServerSide",
					"bDeferRender"
				] );
				_fnMap( oSettings, oInit, [
					"asStripeClasses",
					"ajax",
					"fnServerData",
					"fnFormatNumber",
					"sServerMethod",
					"aaSorting",
					"aaSortingFixed",
					"aLengthMenu",
					"sPaginationType",
					"sAjaxSource",
					"sAjaxDataProp",
					"iStateDuration",
					"sDom",
					"bSortCellsTop",
					"iTabIndex",
					"fnStateLoadCallback",
					"fnStateSaveCallback",
					"renderer",
					"searchDelay",
					"rowId",
					[ "iCookieDuration", "iStateDuration" ], // backwards compat
					[ "oSearch", "oPreviousSearch" ],
					[ "aoSearchCols", "aoPreSearchCols" ],
					[ "iDisplayLength", "_iDisplayLength" ],
					[ "bJQueryUI", "bJUI" ]
				] );
				_fnMap( oSettings.oScroll, oInit, [
					[ "sScrollX", "sX" ],
					[ "sScrollXInner", "sXInner" ],
					[ "sScrollY", "sY" ],
					[ "bScrollCollapse", "bCollapse" ]
				] );
				_fnMap( oSettings.oLanguage, oInit, "fnInfoCallback" );
				
				/* Callback functions which are array driven */
				_fnCallbackReg( oSettings, 'aoDrawCallback',       oInit.fnDrawCallback,      'user' );
				_fnCallbackReg( oSettings, 'aoServerParams',       oInit.fnServerParams,      'user' );
				_fnCallbackReg( oSettings, 'aoStateSaveParams',    oInit.fnStateSaveParams,   'user' );
				_fnCallbackReg( oSettings, 'aoStateLoadParams',    oInit.fnStateLoadParams,   'user' );
				_fnCallbackReg( oSettings, 'aoStateLoaded',        oInit.fnStateLoaded,       'user' );
				_fnCallbackReg( oSettings, 'aoRowCallback',        oInit.fnRowCallback,       'user' );
				_fnCallbackReg( oSettings, 'aoRowCreatedCallback', oInit.fnCreatedRow,        'user' );
				_fnCallbackReg( oSettings, 'aoHeaderCallback',     oInit.fnHeaderCallback,    'user' );
				_fnCallbackReg( oSettings, 'aoFooterCallback',     oInit.fnFooterCallback,    'user' );
				_fnCallbackReg( oSettings, 'aoInitComplete',       oInit.fnInitComplete,      'user' );
				_fnCallbackReg( oSettings, 'aoPreDrawCallback',    oInit.fnPreDrawCallback,   'user' );
				
				oSettings.rowIdFn = _fnGetObjectDataFn( oInit.rowId );
				
				/* Browser support detection */
				_fnBrowserDetect( oSettings );
				
				var oClasses = oSettings.oClasses;
				
				// @todo Remove in 1.11
				if ( oInit.bJQueryUI )
				{
					/* Use the JUI classes object for display. You could clone the oStdClasses object if
					 * you want to have multiple tables with multiple independent classes
					 */
					$.extend( oClasses, DataTable.ext.oJUIClasses, oInit.oClasses );
				
					if ( oInit.sDom === defaults.sDom && defaults.sDom === "lfrtip" )
					{
						/* Set the DOM to use a layout suitable for jQuery UI's theming */
						oSettings.sDom = '<"H"lfr>t<"F"ip>';
					}
				
					if ( ! oSettings.renderer ) {
						oSettings.renderer = 'jqueryui';
					}
					else if ( $.isPlainObject( oSettings.renderer ) && ! oSettings.renderer.header ) {
						oSettings.renderer.header = 'jqueryui';
					}
				}
				else
				{
					$.extend( oClasses, DataTable.ext.classes, oInit.oClasses );
				}
				$this.addClass( oClasses.sTable );
				
				
				if ( oSettings.iInitDisplayStart === undefined )
				{
					/* Display start point, taking into account the save saving */
					oSettings.iInitDisplayStart = oInit.iDisplayStart;
					oSettings._iDisplayStart = oInit.iDisplayStart;
				}
				
				if ( oInit.iDeferLoading !== null )
				{
					oSettings.bDeferLoading = true;
					var tmp = $.isArray( oInit.iDeferLoading );
					oSettings._iRecordsDisplay = tmp ? oInit.iDeferLoading[0] : oInit.iDeferLoading;
					oSettings._iRecordsTotal = tmp ? oInit.iDeferLoading[1] : oInit.iDeferLoading;
				}
				
				/* Language definitions */
				var oLanguage = oSettings.oLanguage;
				$.extend( true, oLanguage, oInit.oLanguage );
				
				if ( oLanguage.sUrl !== "" )
				{
					/* Get the language definitions from a file - because this Ajax call makes the language
					 * get async to the remainder of this function we use bInitHandedOff to indicate that
					 * _fnInitialise will be fired by the returned Ajax handler, rather than the constructor
					 */
					$.ajax( {
						dataType: 'json',
						url: oLanguage.sUrl,
						success: function ( json ) {
							_fnLanguageCompat( json );
							_fnCamelToHungarian( defaults.oLanguage, json );
							$.extend( true, oLanguage, json );
							_fnInitialise( oSettings );
						},
						error: function () {
							// Error occurred loading language file, continue on as best we can
							_fnInitialise( oSettings );
						}
					} );
					bInitHandedOff = true;
				}
				
				/*
				 * Stripes
				 */
				if ( oInit.asStripeClasses === null )
				{
					oSettings.asStripeClasses =[
						oClasses.sStripeOdd,
						oClasses.sStripeEven
					];
				}
				
				/* Remove row stripe classes if they are already on the table row */
				var stripeClasses = oSettings.asStripeClasses;
				var rowOne = $this.children('tbody').find('tr').eq(0);
				if ( $.inArray( true, $.map( stripeClasses, function(el, i) {
					return rowOne.hasClass(el);
				} ) ) !== -1 ) {
					$('tbody tr', this).removeClass( stripeClasses.join(' ') );
					oSettings.asDestroyStripes = stripeClasses.slice();
				}
				
				/*
				 * Columns
				 * See if we should load columns automatically or use defined ones
				 */
				var anThs = [];
				var aoColumnsInit;
				var nThead = this.getElementsByTagName('thead');
				if ( nThead.length !== 0 )
				{
					_fnDetectHeader( oSettings.aoHeader, nThead[0] );
					anThs = _fnGetUniqueThs( oSettings );
				}
				
				/* If not given a column array, generate one with nulls */
				if ( oInit.aoColumns === null )
				{
					aoColumnsInit = [];
					for ( i=0, iLen=anThs.length ; i<iLen ; i++ )
					{
						aoColumnsInit.push( null );
					}
				}
				else
				{
					aoColumnsInit = oInit.aoColumns;
				}
				
				/* Add the columns */
				for ( i=0, iLen=aoColumnsInit.length ; i<iLen ; i++ )
				{
					_fnAddColumn( oSettings, anThs ? anThs[i] : null );
				}
				
				/* Apply the column definitions */
				_fnApplyColumnDefs( oSettings, oInit.aoColumnDefs, aoColumnsInit, function (iCol, oDef) {
					_fnColumnOptions( oSettings, iCol, oDef );
				} );
				
				/* HTML5 attribute detection - build an mData object automatically if the
				 * attributes are found
				 */
				if ( rowOne.length ) {
					var a = function ( cell, name ) {
						return cell.getAttribute( 'data-'+name ) !== null ? name : null;
					};
				
					$( rowOne[0] ).children('th, td').each( function (i, cell) {
						var col = oSettings.aoColumns[i];
				
						if ( col.mData === i ) {
							var sort = a( cell, 'sort' ) || a( cell, 'order' );
							var filter = a( cell, 'filter' ) || a( cell, 'search' );
				
							if ( sort !== null || filter !== null ) {
								col.mData = {
									_:      i+'.display',
									sort:   sort !== null   ? i+'.@data-'+sort   : undefined,
									type:   sort !== null   ? i+'.@data-'+sort   : undefined,
									filter: filter !== null ? i+'.@data-'+filter : undefined
								};
				
								_fnColumnOptions( oSettings, i );
							}
						}
					} );
				}
				
				var features = oSettings.oFeatures;
				
				/* Must be done after everything which can be overridden by the state saving! */
				if ( oInit.bStateSave )
				{
					features.bStateSave = true;
					_fnLoadState( oSettings, oInit );
					_fnCallbackReg( oSettings, 'aoDrawCallback', _fnSaveState, 'state_save' );
				}
				
				
				/*
				 * Sorting
				 * @todo For modularisation (1.11) this needs to do into a sort start up handler
				 */
				
				// If aaSorting is not defined, then we use the first indicator in asSorting
				// in case that has been altered, so the default sort reflects that option
				if ( oInit.aaSorting === undefined )
				{
					var sorting = oSettings.aaSorting;
					for ( i=0, iLen=sorting.length ; i<iLen ; i++ )
					{
						sorting[i][1] = oSettings.aoColumns[ i ].asSorting[0];
					}
				}
				
				/* Do a first pass on the sorting classes (allows any size changes to be taken into
				 * account, and also will apply sorting disabled classes if disabled
				 */
				_fnSortingClasses( oSettings );
				
				if ( features.bSort )
				{
					_fnCallbackReg( oSettings, 'aoDrawCallback', function () {
						if ( oSettings.bSorted ) {
							var aSort = _fnSortFlatten( oSettings );
							var sortedColumns = {};
				
							$.each( aSort, function (i, val) {
								sortedColumns[ val.src ] = val.dir;
							} );
				
							_fnCallbackFire( oSettings, null, 'order', [oSettings, aSort, sortedColumns] );
							_fnSortAria( oSettings );
						}
					} );
				}
				
				_fnCallbackReg( oSettings, 'aoDrawCallback', function () {
					if ( oSettings.bSorted || _fnDataSource( oSettings ) === 'ssp' || features.bDeferRender ) {
						_fnSortingClasses( oSettings );
					}
				}, 'sc' );
				
				
				/*
				 * Final init
				 * Cache the header, body and footer as required, creating them if needed
				 */
				
				// Work around for Webkit bug 83867 - store the caption-side before removing from doc
				var captions = $this.children('caption').each( function () {
					this._captionSide = $this.css('caption-side');
				} );
				
				var thead = $this.children('thead');
				if ( thead.length === 0 )
				{
					thead = $('<thead/>').appendTo(this);
				}
				oSettings.nTHead = thead[0];
				
				var tbody = $this.children('tbody');
				if ( tbody.length === 0 )
				{
					tbody = $('<tbody/>').appendTo(this);
				}
				oSettings.nTBody = tbody[0];
				
				var tfoot = $this.children('tfoot');
				if ( tfoot.length === 0 && captions.length > 0 && (oSettings.oScroll.sX !== "" || oSettings.oScroll.sY !== "") )
				{
					// If we are a scrolling table, and no footer has been given, then we need to create
					// a tfoot element for the caption element to be appended to
					tfoot = $('<tfoot/>').appendTo(this);
				}
				
				if ( tfoot.length === 0 || tfoot.children().length === 0 ) {
					$this.addClass( oClasses.sNoFooter );
				}
				else if ( tfoot.length > 0 ) {
					oSettings.nTFoot = tfoot[0];
					_fnDetectHeader( oSettings.aoFooter, oSettings.nTFoot );
				}
				
				/* Check if there is data passing into the constructor */
				if ( oInit.aaData )
				{
					for ( i=0 ; i<oInit.aaData.length ; i++ )
					{
						_fnAddData( oSettings, oInit.aaData[ i ] );
					}
				}
				else if ( oSettings.bDeferLoading || _fnDataSource( oSettings ) == 'dom' )
				{
					/* Grab the data from the page - only do this when deferred loading or no Ajax
					 * source since there is no point in reading the DOM data if we are then going
					 * to replace it with Ajax data
					 */
					_fnAddTr( oSettings, $(oSettings.nTBody).children('tr') );
				}
				
				/* Copy the data index array */
				oSettings.aiDisplay = oSettings.aiDisplayMaster.slice();
				
				/* Initialisation complete - table can be drawn */
				oSettings.bInitialised = true;
				
				/* Check if we need to initialise the table (it might not have been handed off to the
				 * language processor)
				 */
				if ( bInitHandedOff === false )
				{
					_fnInitialise( oSettings );
				}
			} );
			_that = null;
			return this;
		};
	
		
		/*
		 * It is useful to have variables which are scoped locally so only the
		 * DataTables functions can access them and they don't leak into global space.
		 * At the same time these functions are often useful over multiple files in the
		 * core and API, so we list, or at least document, all variables which are used
		 * by DataTables as private variables here. This also ensures that there is no
		 * clashing of variable names and that they can easily referenced for reuse.
		 */
		
		
		// Defined else where
		//  _selector_run
		//  _selector_opts
		//  _selector_first
		//  _selector_row_indexes
		
		var _ext; // DataTable.ext
		var _Api; // DataTable.Api
		var _api_register; // DataTable.Api.register
		var _api_registerPlural; // DataTable.Api.registerPlural
		
		var _re_dic = {};
		var _re_new_lines = /[\r\n]/g;
		var _re_html = /<.*?>/g;
		var _re_date_start = /^[\w\+\-]/;
		var _re_date_end = /[\w\+\-]$/;
		
		// Escape regular expression special characters
		var _re_escape_regex = new RegExp( '(\\' + [ '/', '.', '*', '+', '?', '|', '(', ')', '[', ']', '{', '}', '\\', '$', '^', '-' ].join('|\\') + ')', 'g' );
		
		// http://en.wikipedia.org/wiki/Foreign_exchange_market
		// - \u20BD - Russian ruble.
		// - \u20a9 - South Korean Won
		// - \u20BA - Turkish Lira
		// - \u20B9 - Indian Rupee
		// - R - Brazil (R$) and South Africa
		// - fr - Swiss Franc
		// - kr - Swedish krona, Norwegian krone and Danish krone
		// - \u2009 is thin space and \u202F is narrow no-break space, both used in many
		//   standards as thousands separators.
		var _re_formatted_numeric = /[',$Â£â¬Â¥%\u2009\u202F\u20BD\u20a9\u20BArfk]/gi;
		
		
		var _empty = function ( d ) {
			return !d || d === true || d === '-' ? true : false;
		};
		
		
		var _intVal = function ( s ) {
			var integer = parseInt( s, 10 );
			return !isNaN(integer) && isFinite(s) ? integer : null;
		};
		
		// Convert from a formatted number with characters other than `.` as the
		// decimal place, to a Javascript number
		var _numToDecimal = function ( num, decimalPoint ) {
			// Cache created regular expressions for speed as this function is called often
			if ( ! _re_dic[ decimalPoint ] ) {
				_re_dic[ decimalPoint ] = new RegExp( _fnEscapeRegex( decimalPoint ), 'g' );
			}
			return typeof num === 'string' && decimalPoint !== '.' ?
				num.replace( /\./g, '' ).replace( _re_dic[ decimalPoint ], '.' ) :
				num;
		};
		
		
		var _isNumber = function ( d, decimalPoint, formatted ) {
			var strType = typeof d === 'string';
		
			// If empty return immediately so there must be a number if it is a
			// formatted string (this stops the string "k", or "kr", etc being detected
			// as a formatted number for currency
			if ( _empty( d ) ) {
				return true;
			}
		
			if ( decimalPoint && strType ) {
				d = _numToDecimal( d, decimalPoint );
			}
		
			if ( formatted && strType ) {
				d = d.replace( _re_formatted_numeric, '' );
			}
		
			return !isNaN( parseFloat(d) ) && isFinite( d );
		};
		
		
		// A string without HTML in it can be considered to be HTML still
		var _isHtml = function ( d ) {
			return _empty( d ) || typeof d === 'string';
		};
		
		
		var _htmlNumeric = function ( d, decimalPoint, formatted ) {
			if ( _empty( d ) ) {
				return true;
			}
		
			var html = _isHtml( d );
			return ! html ?
				null :
				_isNumber( _stripHtml( d ), decimalPoint, formatted ) ?
					true :
					null;
		};
		
		
		var _pluck = function ( a, prop, prop2 ) {
			var out = [];
			var i=0, ien=a.length;
		
			// Could have the test in the loop for slightly smaller code, but speed
			// is essential here
			if ( prop2 !== undefined ) {
				for ( ; i<ien ; i++ ) {
					if ( a[i] && a[i][ prop ] ) {
						out.push( a[i][ prop ][ prop2 ] );
					}
				}
			}
			else {
				for ( ; i<ien ; i++ ) {
					if ( a[i] ) {
						out.push( a[i][ prop ] );
					}
				}
			}
		
			return out;
		};
		
		
		// Basically the same as _pluck, but rather than looping over `a` we use `order`
		// as the indexes to pick from `a`
		var _pluck_order = function ( a, order, prop, prop2 )
		{
			var out = [];
			var i=0, ien=order.length;
		
			// Could have the test in the loop for slightly smaller code, but speed
			// is essential here
			if ( prop2 !== undefined ) {
				for ( ; i<ien ; i++ ) {
					if ( a[ order[i] ][ prop ] ) {
						out.push( a[ order[i] ][ prop ][ prop2 ] );
					}
				}
			}
			else {
				for ( ; i<ien ; i++ ) {
					out.push( a[ order[i] ][ prop ] );
				}
			}
		
			return out;
		};
		
		
		var _range = function ( len, start )
		{
			var out = [];
			var end;
		
			if ( start === undefined ) {
				start = 0;
				end = len;
			}
			else {
				end = start;
				start = len;
			}
		
			for ( var i=start ; i<end ; i++ ) {
				out.push( i );
			}
		
			return out;
		};
		
		
		var _removeEmpty = function ( a )
		{
			var out = [];
		
			for ( var i=0, ien=a.length ; i<ien ; i++ ) {
				if ( a[i] ) { // careful - will remove all falsy values!
					out.push( a[i] );
				}
			}
		
			return out;
		};
		
		
		var _stripHtml = function ( d ) {
			return d.replace( _re_html, '' );
		};
		
		
		/**
		 * Find the unique elements in a source array.
		 *
		 * @param  {array} src Source array
		 * @return {array} Array of unique items
		 * @ignore
		 */
		var _unique = function ( src )
		{
			// A faster unique method is to use object keys to identify used values,
			// but this doesn't work with arrays or objects, which we must also
			// consider. See jsperf.com/compare-array-unique-versions/4 for more
			// information.
			var
				out = [],
				val,
				i, ien=src.length,
				j, k=0;
		
			again: for ( i=0 ; i<ien ; i++ ) {
				val = src[i];
		
				for ( j=0 ; j<k ; j++ ) {
					if ( out[j] === val ) {
						continue again;
					}
				}
		
				out.push( val );
				k++;
			}
		
			return out;
		};
		
		
		/**
		 * DataTables utility methods
		 * 
		 * This namespace provides helper methods that DataTables uses internally to
		 * create a DataTable, but which are not exclusively used only for DataTables.
		 * These methods can be used by extension authors to save the duplication of
		 * code.
		 *
		 *  @namespace
		 */
		DataTable.util = {
			/**
			 * Throttle the calls to a function. Arguments and context are maintained
			 * for the throttled function.
			 *
			 * @param {function} fn Function to be called
			 * @param {integer} freq Call frequency in mS
			 * @return {function} Wrapped function
			 */
			throttle: function ( fn, freq ) {
				var
					frequency = freq !== undefined ? freq : 200,
					last,
					timer;
		
				return function () {
					var
						that = this,
						now  = +new Date(),
						args = arguments;
		
					if ( last && now < last + frequency ) {
						clearTimeout( timer );
		
						timer = setTimeout( function () {
							last = undefined;
							fn.apply( that, args );
						}, frequency );
					}
					else {
						last = now;
						fn.apply( that, args );
					}
				};
			},
		
		
			/**
			 * Escape a string such that it can be used in a regular expression
			 *
			 *  @param {string} val string to escape
			 *  @returns {string} escaped string
			 */
			escapeRegex: function ( val ) {
				return val.replace( _re_escape_regex, '\\$1' );
			}
		};
		
		
		
		/**
		 * Create a mapping object that allows camel case parameters to be looked up
		 * for their Hungarian counterparts. The mapping is stored in a private
		 * parameter called `_hungarianMap` which can be accessed on the source object.
		 *  @param {object} o
		 *  @memberof DataTable#oApi
		 */
		function _fnHungarianMap ( o )
		{
			var
				hungarian = 'a aa ai ao as b fn i m o s ',
				match,
				newKey,
				map = {};
		
			$.each( o, function (key, val) {
				match = key.match(/^([^A-Z]+?)([A-Z])/);
		
				if ( match && hungarian.indexOf(match[1]+' ') !== -1 )
				{
					newKey = key.replace( match[0], match[2].toLowerCase() );
					map[ newKey ] = key;
		
					if ( match[1] === 'o' )
					{
						_fnHungarianMap( o[key] );
					}
				}
			} );
		
			o._hungarianMap = map;
		}
		
		
		/**
		 * Convert from camel case parameters to Hungarian, based on a Hungarian map
		 * created by _fnHungarianMap.
		 *  @param {object} src The model object which holds all parameters that can be
		 *    mapped.
		 *  @param {object} user The object to convert from camel case to Hungarian.
		 *  @param {boolean} force When set to `true`, properties which already have a
		 *    Hungarian value in the `user` object will be overwritten. Otherwise they
		 *    won't be.
		 *  @memberof DataTable#oApi
		 */
		function _fnCamelToHungarian ( src, user, force )
		{
			if ( ! src._hungarianMap ) {
				_fnHungarianMap( src );
			}
		
			var hungarianKey;
		
			$.each( user, function (key, val) {
				hungarianKey = src._hungarianMap[ key ];
		
				if ( hungarianKey !== undefined && (force || user[hungarianKey] === undefined) )
				{
					// For objects, we need to buzz down into the object to copy parameters
					if ( hungarianKey.charAt(0) === 'o' )
					{
						// Copy the camelCase options over to the hungarian
						if ( ! user[ hungarianKey ] ) {
							user[ hungarianKey ] = {};
						}
						$.extend( true, user[hungarianKey], user[key] );
		
						_fnCamelToHungarian( src[hungarianKey], user[hungarianKey], force );
					}
					else {
						user[hungarianKey] = user[ key ];
					}
				}
			} );
		}
		
		
		/**
		 * Language compatibility - when certain options are given, and others aren't, we
		 * need to duplicate the values over, in order to provide backwards compatibility
		 * with older language files.
		 *  @param {object} oSettings dataTables settings object
		 *  @memberof DataTable#oApi
		 */
		function _fnLanguageCompat( lang )
		{
			var defaults = DataTable.defaults.oLanguage;
			var zeroRecords = lang.sZeroRecords;
		
			/* Backwards compatibility - if there is no sEmptyTable given, then use the same as
			 * sZeroRecords - assuming that is given.
			 */
			if ( ! lang.sEmptyTable && zeroRecords &&
				defaults.sEmptyTable === "No data available in table" )
			{
				_fnMap( lang, lang, 'sZeroRecords', 'sEmptyTable' );
			}
		
			/* Likewise with loading records */
			if ( ! lang.sLoadingRecords && zeroRecords &&
				defaults.sLoadingRecords === "Loading..." )
			{
				_fnMap( lang, lang, 'sZeroRecords', 'sLoadingRecords' );
			}
		
			// Old parameter name of the thousands separator mapped onto the new
			if ( lang.sInfoThousands ) {
				lang.sThousands = lang.sInfoThousands;
			}
		
			var decimal = lang.sDecimal;
			if ( decimal ) {
				_addNumericSort( decimal );
			}
		}
		
		
		/**
		 * Map one parameter onto another
		 *  @param {object} o Object to map
		 *  @param {*} knew The new parameter name
		 *  @param {*} old The old parameter name
		 */
		var _fnCompatMap = function ( o, knew, old ) {
			if ( o[ knew ] !== undefined ) {
				o[ old ] = o[ knew ];
			}
		};
		
		
		/**
		 * Provide backwards compatibility for the main DT options. Note that the new
		 * options are mapped onto the old parameters, so this is an external interface
		 * change only.
		 *  @param {object} init Object to map
		 */
		function _fnCompatOpts ( init )
		{
			_fnCompatMap( init, 'ordering',      'bSort' );
			_fnCompatMap( init, 'orderMulti',    'bSortMulti' );
			_fnCompatMap( init, 'orderClasses',  'bSortClasses' );
			_fnCompatMap( init, 'orderCellsTop', 'bSortCellsTop' );
			_fnCompatMap( init, 'order',         'aaSorting' );
			_fnCompatMap( init, 'orderFixed',    'aaSortingFixed' );
			_fnCompatMap( init, 'paging',        'bPaginate' );
			_fnCompatMap( init, 'pagingType',    'sPaginationType' );
			_fnCompatMap( init, 'pageLength',    'iDisplayLength' );
			_fnCompatMap( init, 'searching',     'bFilter' );
		
			// Boolean initialisation of x-scrolling
			if ( typeof init.sScrollX === 'boolean' ) {
				init.sScrollX = init.sScrollX ? '100%' : '';
			}
			if ( typeof init.scrollX === 'boolean' ) {
				init.scrollX = init.scrollX ? '100%' : '';
			}
		
			// Column search objects are in an array, so it needs to be converted
			// element by element
			var searchCols = init.aoSearchCols;
		
			if ( searchCols ) {
				for ( var i=0, ien=searchCols.length ; i<ien ; i++ ) {
					if ( searchCols[i] ) {
						_fnCamelToHungarian( DataTable.models.oSearch, searchCols[i] );
					}
				}
			}
		}
		
		
		/**
		 * Provide backwards compatibility for column options. Note that the new options
		 * are mapped onto the old parameters, so this is an external interface change
		 * only.
		 *  @param {object} init Object to map
		 */
		function _fnCompatCols ( init )
		{
			_fnCompatMap( init, 'orderable',     'bSortable' );
			_fnCompatMap( init, 'orderData',     'aDataSort' );
			_fnCompatMap( init, 'orderSequence', 'asSorting' );
			_fnCompatMap( init, 'orderDataType', 'sortDataType' );
		
			// orderData can be given as an integer
			var dataSort = init.aDataSort;
			if ( dataSort && ! $.isArray( dataSort ) ) {
				init.aDataSort = [ dataSort ];
			}
		}
		
		
		/**
		 * Browser feature detection for capabilities, quirks
		 *  @param {object} settings dataTables settings object
		 *  @memberof DataTable#oApi
		 */
		function _fnBrowserDetect( settings )
		{
			// We don't need to do this every time DataTables is constructed, the values
			// calculated are specific to the browser and OS configuration which we
			// don't expect to change between initialisations
			if ( ! DataTable.__browser ) {
				var browser = {};
				DataTable.__browser = browser;
		
				// Scrolling feature / quirks detection
				var n = $('<div/>')
					.css( {
						position: 'fixed',
						top: 0,
						left: 0,
						height: 1,
						width: 1,
						overflow: 'hidden'
					} )
					.append(
						$('<div/>')
							.css( {
								position: 'absolute',
								top: 1,
								left: 1,
								width: 100,
								overflow: 'scroll'
							} )
							.append(
								$('<div/>')
									.css( {
										width: '100%',
										height: 10
									} )
							)
					)
					.appendTo( 'body' );
		
				var outer = n.children();
				var inner = outer.children();
		
				// Numbers below, in order, are:
				// inner.offsetWidth, inner.clientWidth, outer.offsetWidth, outer.clientWidth
				//
				// IE6 XP:                           100 100 100  83
				// IE7 Vista:                        100 100 100  83
				// IE 8+ Windows:                     83  83 100  83
				// Evergreen Windows:                 83  83 100  83
				// Evergreen Mac with scrollbars:     85  85 100  85
				// Evergreen Mac without scrollbars: 100 100 100 100
		
				// Get scrollbar width
				browser.barWidth = outer[0].offsetWidth - outer[0].clientWidth;
		
				// IE6/7 will oversize a width 100% element inside a scrolling element, to
				// include the width of the scrollbar, while other browsers ensure the inner
				// element is contained without forcing scrolling
				browser.bScrollOversize = inner[0].offsetWidth === 100 && outer[0].clientWidth !== 100;
		
				// In rtl text layout, some browsers (most, but not all) will place the
				// scrollbar on the left, rather than the right.
				browser.bScrollbarLeft = Math.round( inner.offset().left ) !== 1;
		
				// IE8- don't provide height and width for getBoundingClientRect
				browser.bBounding = n[0].getBoundingClientRect().width ? true : false;
		
				n.remove();
			}
		
			$.extend( settings.oBrowser, DataTable.__browser );
			settings.oScroll.iBarWidth = DataTable.__browser.barWidth;
		}
		
		
		/**
		 * Array.prototype reduce[Right] method, used for browsers which don't support
		 * JS 1.6. Done this way to reduce code size, since we iterate either way
		 *  @param {object} settings dataTables settings object
		 *  @memberof DataTable#oApi
		 */
		function _fnReduce ( that, fn, init, start, end, inc )
		{
			var
				i = start,
				value,
				isSet = false;
		
			if ( init !== undefined ) {
				value = init;
				isSet = true;
			}
		
			while ( i !== end ) {
				if ( ! that.hasOwnProperty(i) ) {
					continue;
				}
		
				value = isSet ?
					fn( value, that[i], i, that ) :
					that[i];
		
				isSet = true;
				i += inc;
			}
		
			return value;
		}
		
		/**
		 * Add a column to the list used for the table with default values
		 *  @param {object} oSettings dataTables settings object
		 *  @param {node} nTh The th element for this column
		 *  @memberof DataTable#oApi
		 */
		function _fnAddColumn( oSettings, nTh )
		{
			// Add column to aoColumns array
			var oDefaults = DataTable.defaults.column;
			var iCol = oSettings.aoColumns.length;
			var oCol = $.extend( {}, DataTable.models.oColumn, oDefaults, {
				"nTh": nTh ? nTh : document.createElement('th'),
				"sTitle":    oDefaults.sTitle    ? oDefaults.sTitle    : nTh ? nTh.innerHTML : '',
				"aDataSort": oDefaults.aDataSort ? oDefaults.aDataSort : [iCol],
				"mData": oDefaults.mData ? oDefaults.mData : iCol,
				idx: iCol
			} );
			oSettings.aoColumns.push( oCol );
		
			// Add search object for column specific search. Note that the `searchCols[ iCol ]`
			// passed into extend can be undefined. This allows the user to give a default
			// with only some of the parameters defined, and also not give a default
			var searchCols = oSettings.aoPreSearchCols;
			searchCols[ iCol ] = $.extend( {}, DataTable.models.oSearch, searchCols[ iCol ] );
		
			// Use the default column options function to initialise classes etc
			_fnColumnOptions( oSettings, iCol, $(nTh).data() );
		}
		
		
		/**
		 * Apply options for a column
		 *  @param {object} oSettings dataTables settings object
		 *  @param {int} iCol column index to consider
		 *  @param {object} oOptions object with sType, bVisible and bSearchable etc
		 *  @memberof DataTable#oApi
		 */
		function _fnColumnOptions( oSettings, iCol, oOptions )
		{
			var oCol = oSettings.aoColumns[ iCol ];
			var oClasses = oSettings.oClasses;
			var th = $(oCol.nTh);
		
			// Try to get width information from the DOM. We can't get it from CSS
			// as we'd need to parse the CSS stylesheet. `width` option can override
			if ( ! oCol.sWidthOrig ) {
				// Width attribute
				oCol.sWidthOrig = th.attr('width') || null;
		
				// Style attribute
				var t = (th.attr('style') || '').match(/width:\s*(\d+[pxem%]+)/);
				if ( t ) {
					oCol.sWidthOrig = t[1];
				}
			}
		
			/* User specified column options */
			if ( oOptions !== undefined && oOptions !== null )
			{
				// Backwards compatibility
				_fnCompatCols( oOptions );
		
				// Map camel case parameters to their Hungarian counterparts
				_fnCamelToHungarian( DataTable.defaults.column, oOptions );
		
				/* Backwards compatibility for mDataProp */
				if ( oOptions.mDataProp !== undefined && !oOptions.mData )
				{
					oOptions.mData = oOptions.mDataProp;
				}
		
				if ( oOptions.sType )
				{
					oCol._sManualType = oOptions.sType;
				}
		
				// `class` is a reserved word in Javascript, so we need to provide
				// the ability to use a valid name for the camel case input
				if ( oOptions.className && ! oOptions.sClass )
				{
					oOptions.sClass = oOptions.className;
				}
		
				$.extend( oCol, oOptions );
				_fnMap( oCol, oOptions, "sWidth", "sWidthOrig" );
		
				/* iDataSort to be applied (backwards compatibility), but aDataSort will take
				 * priority if defined
				 */
				if ( oOptions.iDataSort !== undefined )
				{
					oCol.aDataSort = [ oOptions.iDataSort ];
				}
				_fnMap( oCol, oOptions, "aDataSort" );
			}
		
			/* Cache the data get and set functions for speed */
			var mDataSrc = oCol.mData;
			var mData = _fnGetObjectDataFn( mDataSrc );
			var mRender = oCol.mRender ? _fnGetObjectDataFn( oCol.mRender ) : null;
		
			var attrTest = function( src ) {
				return typeof src === 'string' && src.indexOf('@') !== -1;
			};
			oCol._bAttrSrc = $.isPlainObject( mDataSrc ) && (
				attrTest(mDataSrc.sort) || attrTest(mDataSrc.type) || attrTest(mDataSrc.filter)
			);
			oCol._setter = null;
		
			oCol.fnGetData = function (rowData, type, meta) {
				var innerData = mData( rowData, type, undefined, meta );
		
				return mRender && type ?
					mRender( innerData, type, rowData, meta ) :
					innerData;
			};
			oCol.fnSetData = function ( rowData, val, meta ) {
				return _fnSetObjectDataFn( mDataSrc )( rowData, val, meta );
			};
		
			// Indicate if DataTables should read DOM data as an object or array
			// Used in _fnGetRowElements
			if ( typeof mDataSrc !== 'number' ) {
				oSettings._rowReadObject = true;
			}
		
			/* Feature sorting overrides column specific when off */
			if ( !oSettings.oFeatures.bSort )
			{
				oCol.bSortable = false;
				th.addClass( oClasses.sSortableNone ); // Have to add class here as order event isn't called
			}
		
			/* Check that the class assignment is correct for sorting */
			var bAsc = $.inArray('asc', oCol.asSorting) !== -1;
			var bDesc = $.inArray('desc', oCol.asSorting) !== -1;
			if ( !oCol.bSortable || (!bAsc && !bDesc) )
			{
				oCol.sSortingClass = oClasses.sSortableNone;
				oCol.sSortingClassJUI = "";
			}
			else if ( bAsc && !bDesc )
			{
				oCol.sSortingClass = oClasses.sSortableAsc;
				oCol.sSortingClassJUI = oClasses.sSortJUIAscAllowed;
			}
			else if ( !bAsc && bDesc )
			{
				oCol.sSortingClass = oClasses.sSortableDesc;
				oCol.sSortingClassJUI = oClasses.sSortJUIDescAllowed;
			}
			else
			{
				oCol.sSortingClass = oClasses.sSortable;
				oCol.sSortingClassJUI = oClasses.sSortJUI;
			}
		}
		
		
		/**
		 * Adjust the table column widths for new data. Note: you would probably want to
		 * do a redraw after calling this function!
		 *  @param {object} settings dataTables settings object
		 *  @memberof DataTable#oApi
		 */
		function _fnAdjustColumnSizing ( settings )
		{
			/* Not interested in doing column width calculation if auto-width is disabled */
			if ( settings.oFeatures.bAutoWidth !== false )
			{
				var columns = settings.aoColumns;
		
				_fnCalculateColumnWidths( settings );
				for ( var i=0 , iLen=columns.length ; i<iLen ; i++ )
				{
					columns[i].nTh.style.width = columns[i].sWidth;
				}
			}
		
			var scroll = settings.oScroll;
			if ( scroll.sY !== '' || scroll.sX !== '')
			{
				_fnScrollDraw( settings );
			}
		
			_fnCallbackFire( settings, null, 'column-sizing', [settings] );
		}
		
		
		/**
		 * Covert the index of a visible column to the index in the data array (take account
		 * of hidden columns)
		 *  @param {object} oSettings dataTables settings object
		 *  @param {int} iMatch Visible column index to lookup
		 *  @returns {int} i the data index
		 *  @memberof DataTable#oApi
		 */
		function _fnVisibleToColumnIndex( oSettings, iMatch )
		{
			var aiVis = _fnGetColumns( oSettings, 'bVisible' );
		
			return typeof aiVis[iMatch] === 'number' ?
				aiVis[iMatch] :
				null;
		}
		
		
		/**
		 * Covert the index of an index in the data array and convert it to the visible
		 *   column index (take account of hidden columns)
		 *  @param {int} iMatch Column index to lookup
		 *  @param {object} oSettings dataTables settings object
		 *  @returns {int} i the data index
		 *  @memberof DataTable#oApi
		 */
		function _fnColumnIndexToVisible( oSettings, iMatch )
		{
			var aiVis = _fnGetColumns( oSettings, 'bVisible' );
			var iPos = $.inArray( iMatch, aiVis );
		
			return iPos !== -1 ? iPos : null;
		}
		
		
		/**
		 * Get the number of visible columns
		 *  @param {object} oSettings dataTables settings object
		 *  @returns {int} i the number of visible columns
		 *  @memberof DataTable#oApi
		 */
		function _fnVisbleColumns( oSettings )
		{
			var vis = 0;
		
			// No reduce in IE8, use a loop for now
			$.each( oSettings.aoColumns, function ( i, col ) {
				if ( col.bVisible && $(col.nTh).css('display') !== 'none' ) {
					vis++;
				}
			} );
		
			return vis;
		}
		
		
		/**
		 * Get an array of column indexes that match a given property
		 *  @param {object} oSettings dataTables settings object
		 *  @param {string} sParam Parameter in aoColumns to look for - typically
		 *    bVisible or bSearchable
		 *  @returns {array} Array of indexes with matched properties
		 *  @memberof DataTable#oApi
		 */
		function _fnGetColumns( oSettings, sParam )
		{
			var a = [];
		
			$.map( oSettings.aoColumns, function(val, i) {
				if ( val[sParam] ) {
					a.push( i );
				}
			} );
		
			return a;
		}
		
		
		/**
		 * Calculate the 'type' of a column
		 *  @param {object} settings dataTables settings object
		 *  @memberof DataTable#oApi
		 */
		function _fnColumnTypes ( settings )
		{
			var columns = settings.aoColumns;
			var data = settings.aoData;
			var types = DataTable.ext.type.detect;
			var i, ien, j, jen, k, ken;
			var col, cell, detectedType, cache;
		
			// For each column, spin over the 
			for ( i=0, ien=columns.length ; i<ien ; i++ ) {
				col = columns[i];
				cache = [];
		
				if ( ! col.sType && col._sManualType ) {
					col.sType = col._sManualType;
				}
				else if ( ! col.sType ) {
					for ( j=0, jen=types.length ; j<jen ; j++ ) {
						for ( k=0, ken=data.length ; k<ken ; k++ ) {
							// Use a cache array so we only need to get the type data
							// from the formatter once (when using multiple detectors)
							if ( cache[k] === undefined ) {
								cache[k] = _fnGetCellData( settings, k, i, 'type' );
							}
		
							detectedType = types[j]( cache[k], settings );
		
							// If null, then this type can't apply to this column, so
							// rather than testing all cells, break out. There is an
							// exception for the last type which is `html`. We need to
							// scan all rows since it is possible to mix string and HTML
							// types
							if ( ! detectedType && j !== types.length-1 ) {
								break;
							}
		
							// Only a single match is needed for html type since it is
							// bottom of the pile and very similar to string
							if ( detectedType === 'html' ) {
								break;
							}
						}
		
						// Type is valid for all data points in the column - use this
						// type
						if ( detectedType ) {
							col.sType = detectedType;
							break;
						}
					}
		
					// Fall back - if no type was detected, always use string
					if ( ! col.sType ) {
						col.sType = 'string';
					}
				}
			}
		}
		
		
		/**
		 * Take the column definitions and static columns arrays and calculate how
		 * they relate to column indexes. The callback function will then apply the
		 * definition found for a column to a suitable configuration object.
		 *  @param {object} oSettings dataTables settings object
		 *  @param {array} aoColDefs The aoColumnDefs array that is to be applied
		 *  @param {array} aoCols The aoColumns array that defines columns individually
		 *  @param {function} fn Callback function - takes two parameters, the calculated
		 *    column index and the definition for that column.
		 *  @memberof DataTable#oApi
		 */
		function _fnApplyColumnDefs( oSettings, aoColDefs, aoCols, fn )
		{
			var i, iLen, j, jLen, k, kLen, def;
			var columns = oSettings.aoColumns;
		
			// Column definitions with aTargets
			if ( aoColDefs )
			{
				/* Loop over the definitions array - loop in reverse so first instance has priority */
				for ( i=aoColDefs.length-1 ; i>=0 ; i-- )
				{
					def = aoColDefs[i];
		
					/* Each definition can target multiple columns, as it is an array */
					var aTargets = def.targets !== undefined ?
						def.targets :
						def.aTargets;
		
					if ( ! $.isArray( aTargets ) )
					{
						aTargets = [ aTargets ];
					}
		
					for ( j=0, jLen=aTargets.length ; j<jLen ; j++ )
					{
						if ( typeof aTargets[j] === 'number' && aTargets[j] >= 0 )
						{
							/* Add columns that we don't yet know about */
							while( columns.length <= aTargets[j] )
							{
								_fnAddColumn( oSettings );
							}
		
							/* Integer, basic index */
							fn( aTargets[j], def );
						}
						else if ( typeof aTargets[j] === 'number' && aTargets[j] < 0 )
						{
							/* Negative integer, right to left column counting */
							fn( columns.length+aTargets[j], def );
						}
						else if ( typeof aTargets[j] === 'string' )
						{
							/* Class name matching on TH element */
							for ( k=0, kLen=columns.length ; k<kLen ; k++ )
							{
								if ( aTargets[j] == "_all" ||
								     $(columns[k].nTh).hasClass( aTargets[j] ) )
								{
									fn( k, def );
								}
							}
						}
					}
				}
			}
		
			// Statically defined columns array
			if ( aoCols )
			{
				for ( i=0, iLen=aoCols.length ; i<iLen ; i++ )
				{
					fn( i, aoCols[i] );
				}
			}
		}
		
		/**
		 * Add a data array to the table, creating DOM node etc. This is the parallel to
		 * _fnGatherData, but for adding rows from a Javascript source, rather than a
		 * DOM source.
		 *  @param {object} oSettings dataTables settings object
		 *  @param {array} aData data array to be added
		 *  @param {node} [nTr] TR element to add to the table - optional. If not given,
		 *    DataTables will create a row automatically
		 *  @param {array} [anTds] Array of TD|TH elements for the row - must be given
		 *    if nTr is.
		 *  @returns {int} >=0 if successful (index of new aoData entry), -1 if failed
		 *  @memberof DataTable#oApi
		 */
		function _fnAddData ( oSettings, aDataIn, nTr, anTds )
		{
			/* Create the object for storing information about this new row */
			var iRow = oSettings.aoData.length;
			var oData = $.extend( true, {}, DataTable.models.oRow, {
				src: nTr ? 'dom' : 'data',
				idx: iRow
			} );
		
			oData._aData = aDataIn;
			oSettings.aoData.push( oData );
		
			/* Create the cells */
			var nTd, sThisType;
			var columns = oSettings.aoColumns;
		
			// Invalidate the column types as the new data needs to be revalidated
			for ( var i=0, iLen=columns.length ; i<iLen ; i++ )
			{
				columns[i].sType = null;
			}
		
			/* Add to the display array */
			oSettings.aiDisplayMaster.push( iRow );
		
			var id = oSettings.rowIdFn( aDataIn );
			if ( id !== undefined ) {
				oSettings.aIds[ id ] = oData;
			}
		
			/* Create the DOM information, or register it if already present */
			if ( nTr || ! oSettings.oFeatures.bDeferRender )
			{
				_fnCreateTr( oSettings, iRow, nTr, anTds );
			}
		
			return iRow;
		}
		
		
		/**
		 * Add one or more TR elements to the table. Generally we'd expect to
		 * use this for reading data from a DOM sourced table, but it could be
		 * used for an TR element. Note that if a TR is given, it is used (i.e.
		 * it is not cloned).
		 *  @param {object} settings dataTables settings object
		 *  @param {array|node|jQuery} trs The TR element(s) to add to the table
		 *  @returns {array} Array of indexes for the added rows
		 *  @memberof DataTable#oApi
		 */
		function _fnAddTr( settings, trs )
		{
			var row;
		
			// Allow an individual node to be passed in
			if ( ! (trs instanceof $) ) {
				trs = $(trs);
			}
		
			return trs.map( function (i, el) {
				row = _fnGetRowElements( settings, el );
				return _fnAddData( settings, row.data, el, row.cells );
			} );
		}
		
		
		/**
		 * Take a TR element and convert it to an index in aoData
		 *  @param {object} oSettings dataTables settings object
		 *  @param {node} n the TR element to find
		 *  @returns {int} index if the node is found, null if not
		 *  @memberof DataTable#oApi
		 */
		function _fnNodeToDataIndex( oSettings, n )
		{
			return (n._DT_RowIndex!==undefined) ? n._DT_RowIndex : null;
		}
		
		
		/**
		 * Take a TD element and convert it into a column data index (not the visible index)
		 *  @param {object} oSettings dataTables settings object
		 *  @param {int} iRow The row number the TD/TH can be found in
		 *  @param {node} n The TD/TH element to find
		 *  @returns {int} index if the node is found, -1 if not
		 *  @memberof DataTable#oApi
		 */
		function _fnNodeToColumnIndex( oSettings, iRow, n )
		{
			return $.inArray( n, oSettings.aoData[ iRow ].anCells );
		}
		
		
		/**
		 * Get the data for a given cell from the internal cache, taking into account data mapping
		 *  @param {object} settings dataTables settings object
		 *  @param {int} rowIdx aoData row id
		 *  @param {int} colIdx Column index
		 *  @param {string} type data get type ('display', 'type' 'filter' 'sort')
		 *  @returns {*} Cell data
		 *  @memberof DataTable#oApi
		 */
		function _fnGetCellData( settings, rowIdx, colIdx, type )
		{
			var draw           = settings.iDraw;
			var col            = settings.aoColumns[colIdx];
			var rowData        = settings.aoData[rowIdx]._aData;
			var defaultContent = col.sDefaultContent;
			var cellData       = col.fnGetData( rowData, type, {
				settings: settings,
				row:      rowIdx,
				col:      colIdx
			} );
		
			if ( cellData === undefined ) {
				if ( settings.iDrawError != draw && defaultContent === null ) {
					_fnLog( settings, 0, "Requested unknown parameter "+
						(typeof col.mData=='function' ? '{function}' : "'"+col.mData+"'")+
						" for row "+rowIdx+", column "+colIdx, 4 );
					settings.iDrawError = draw;
				}
				return defaultContent;
			}
		
			// When the data source is null and a specific data type is requested (i.e.
			// not the original data), we can use default column data
			if ( (cellData === rowData || cellData === null) && defaultContent !== null && type !== undefined ) {
				cellData = defaultContent;
			}
			else if ( typeof cellData === 'function' ) {
				// If the data source is a function, then we run it and use the return,
				// executing in the scope of the data object (for instances)
				return cellData.call( rowData );
			}
		
			if ( cellData === null && type == 'display' ) {
				return '';
			}
			return cellData;
		}
		
		
		/**
		 * Set the value for a specific cell, into the internal data cache
		 *  @param {object} settings dataTables settings object
		 *  @param {int} rowIdx aoData row id
		 *  @param {int} colIdx Column index
		 *  @param {*} val Value to set
		 *  @memberof DataTable#oApi
		 */
		function _fnSetCellData( settings, rowIdx, colIdx, val )
		{
			var col     = settings.aoColumns[colIdx];
			var rowData = settings.aoData[rowIdx]._aData;
		
			col.fnSetData( rowData, val, {
				settings: settings,
				row:      rowIdx,
				col:      colIdx
			}  );
		}
		
		
		// Private variable that is used to match action syntax in the data property object
		var __reArray = /\[.*?\]$/;
		var __reFn = /\(\)$/;
		
		/**
		 * Split string on periods, taking into account escaped periods
		 * @param  {string} str String to split
		 * @return {array} Split string
		 */
		function _fnSplitObjNotation( str )
		{
			return $.map( str.match(/(\\.|[^\.])+/g) || [''], function ( s ) {
				return s.replace(/\\./g, '.');
			} );
		}
		
		
		/**
		 * Return a function that can be used to get data from a source object, taking
		 * into account the ability to use nested objects as a source
		 *  @param {string|int|function} mSource The data source for the object
		 *  @returns {function} Data get function
		 *  @memberof DataTable#oApi
		 */
		function _fnGetObjectDataFn( mSource )
		{
			if ( $.isPlainObject( mSource ) )
			{
				/* Build an object of get functions, and wrap them in a single call */
				var o = {};
				$.each( mSource, function (key, val) {
					if ( val ) {
						o[key] = _fnGetObjectDataFn( val );
					}
				} );
		
				return function (data, type, row, meta) {
					var t = o[type] || o._;
					return t !== undefined ?
						t(data, type, row, meta) :
						data;
				};
			}
			else if ( mSource === null )
			{
				/* Give an empty string for rendering / sorting etc */
				return function (data) { // type, row and meta also passed, but not used
					return data;
				};
			}
			else if ( typeof mSource === 'function' )
			{
				return function (data, type, row, meta) {
					return mSource( data, type, row, meta );
				};
			}
			else if ( typeof mSource === 'string' && (mSource.indexOf('.') !== -1 ||
				      mSource.indexOf('[') !== -1 || mSource.indexOf('(') !== -1) )
			{
				/* If there is a . in the source string then the data source is in a
				 * nested object so we loop over the data for each level to get the next
				 * level down. On each loop we test for undefined, and if found immediately
				 * return. This allows entire objects to be missing and sDefaultContent to
				 * be used if defined, rather than throwing an error
				 */
				var fetchData = function (data, type, src) {
					var arrayNotation, funcNotation, out, innerSrc;
		
					if ( src !== "" )
					{
						var a = _fnSplitObjNotation( src );
		
						for ( var i=0, iLen=a.length ; i<iLen ; i++ )
						{
							// Check if we are dealing with special notation
							arrayNotation = a[i].match(__reArray);
							funcNotation = a[i].match(__reFn);
		
							if ( arrayNotation )
							{
								// Array notation
								a[i] = a[i].replace(__reArray, '');
		
								// Condition allows simply [] to be passed in
								if ( a[i] !== "" ) {
									data = data[ a[i] ];
								}
								out = [];
		
								// Get the remainder of the nested object to get
								a.splice( 0, i+1 );
								innerSrc = a.join('.');
		
								// Traverse each entry in the array getting the properties requested
								if ( $.isArray( data ) ) {
									for ( var j=0, jLen=data.length ; j<jLen ; j++ ) {
										out.push( fetchData( data[j], type, innerSrc ) );
									}
								}
		
								// If a string is given in between the array notation indicators, that
								// is used to join the strings together, otherwise an array is returned
								var join = arrayNotation[0].substring(1, arrayNotation[0].length-1);
								data = (join==="") ? out : out.join(join);
		
								// The inner call to fetchData has already traversed through the remainder
								// of the source requested, so we exit from the loop
								break;
							}
							else if ( funcNotation )
							{
								// Function call
								a[i] = a[i].replace(__reFn, '');
								data = data[ a[i] ]();
								continue;
							}
		
							if ( data === null || data[ a[i] ] === undefined )
							{
								return undefined;
							}
							data = data[ a[i] ];
						}
					}
		
					return data;
				};
		
				return function (data, type) { // row and meta also passed, but not used
					return fetchData( data, type, mSource );
				};
			}
			else
			{
				/* Array or flat object mapping */
				return function (data, type) { // row and meta also passed, but not used
					return data[mSource];
				};
			}
		}
		
		
		/**
		 * Return a function that can be used to set data from a source object, taking
		 * into account the ability to use nested objects as a source
		 *  @param {string|int|function} mSource The data source for the object
		 *  @returns {function} Data set function
		 *  @memberof DataTable#oApi
		 */
		function _fnSetObjectDataFn( mSource )
		{
			if ( $.isPlainObject( mSource ) )
			{
				/* Unlike get, only the underscore (global) option is used for for
				 * setting data since we don't know the type here. This is why an object
				 * option is not documented for `mData` (which is read/write), but it is
				 * for `mRender` which is read only.
				 */
				return _fnSetObjectDataFn( mSource._ );
			}
			else if ( mSource === null )
			{
				/* Nothing to do when the data source is null */
				return function () {};
			}
			else if ( typeof mSource === 'function' )
			{
				return function (data, val, meta) {
					mSource( data, 'set', val, meta );
				};
			}
			else if ( typeof mSource === 'string' && (mSource.indexOf('.') !== -1 ||
				      mSource.indexOf('[') !== -1 || mSource.indexOf('(') !== -1) )
			{
				/* Like the get, we need to get data from a nested object */
				var setData = function (data, val, src) {
					var a = _fnSplitObjNotation( src ), b;
					var aLast = a[a.length-1];
					var arrayNotation, funcNotation, o, innerSrc;
		
					for ( var i=0, iLen=a.length-1 ; i<iLen ; i++ )
					{
						// Check if we are dealing with an array notation request
						arrayNotation = a[i].match(__reArray);
						funcNotation = a[i].match(__reFn);
		
						if ( arrayNotation )
						{
							a[i] = a[i].replace(__reArray, '');
							data[ a[i] ] = [];
		
							// Get the remainder of the nested object to set so we can recurse
							b = a.slice();
							b.splice( 0, i+1 );
							innerSrc = b.join('.');
		
							// Traverse each entry in the array setting the properties requested
							if ( $.isArray( val ) )
							{
								for ( var j=0, jLen=val.length ; j<jLen ; j++ )
								{
									o = {};
									setData( o, val[j], innerSrc );
									data[ a[i] ].push( o );
								}
							}
							else
							{
								// We've been asked to save data to an array, but it
								// isn't array data to be saved. Best that can be done
								// is to just save the value.
								data[ a[i] ] = val;
							}
		
							// The inner call to setData has already traversed through the remainder
							// of the source and has set the data, thus we can exit here
							return;
						}
						else if ( funcNotation )
						{
							// Function call
							a[i] = a[i].replace(__reFn, '');
							data = data[ a[i] ]( val );
						}
		
						// If the nested object doesn't currently exist - since we are
						// trying to set the value - create it
						if ( data[ a[i] ] === null || data[ a[i] ] === undefined )
						{
							data[ a[i] ] = {};
						}
						data = data[ a[i] ];
					}
		
					// Last item in the input - i.e, the actual set
					if ( aLast.match(__reFn ) )
					{
						// Function call
						data = data[ aLast.replace(__reFn, '') ]( val );
					}
					else
					{
						// If array notation is used, we just want to strip it and use the property name
						// and assign the value. If it isn't used, then we get the result we want anyway
						data[ aLast.replace(__reArray, '') ] = val;
					}
				};
		
				return function (data, val) { // meta is also passed in, but not used
					return setData( data, val, mSource );
				};
			}
			else
			{
				/* Array or flat object mapping */
				return function (data, val) { // meta is also passed in, but not used
					data[mSource] = val;
				};
			}
		}
		
		
		/**
		 * Return an array with the full table data
		 *  @param {object} oSettings dataTables settings object
		 *  @returns array {array} aData Master data array
		 *  @memberof DataTable#oApi
		 */
		function _fnGetDataMaster ( settings )
		{
			return _pluck( settings.aoData, '_aData' );
		}
		
		
		/**
		 * Nuke the table
		 *  @param {object} oSettings dataTables settings object
		 *  @memberof DataTable#oApi
		 */
		function _fnClearTable( settings )
		{
			settings.aoData.length = 0;
			settings.aiDisplayMaster.length = 0;
			settings.aiDisplay.length = 0;
			settings.aIds = {};
		}
		
		
		 /**
		 * Take an array of integers (index array) and remove a target integer (value - not
		 * the key!)
		 *  @param {array} a Index array to target
		 *  @param {int} iTarget value to find
		 *  @memberof DataTable#oApi
		 */
		function _fnDeleteIndex( a, iTarget, splice )
		{
			var iTargetIndex = -1;
		
			for ( var i=0, iLen=a.length ; i<iLen ; i++ )
			{
				if ( a[i] == iTarget )
				{
					iTargetIndex = i;
				}
				else if ( a[i] > iTarget )
				{
					a[i]--;
				}
			}
		
			if ( iTargetIndex != -1 && splice === undefined )
			{
				a.splice( iTargetIndex, 1 );
			}
		}
		
		
		/**
		 * Mark cached data as invalid such that a re-read of the data will occur when
		 * the cached data is next requested. Also update from the data source object.
		 *
		 * @param {object} settings DataTables settings object
		 * @param {int}    rowIdx   Row index to invalidate
		 * @param {string} [src]    Source to invalidate from: undefined, 'auto', 'dom'
		 *     or 'data'
		 * @param {int}    [colIdx] Column index to invalidate. If undefined the whole
		 *     row will be invalidated
		 * @memberof DataTable#oApi
		 *
		 * @todo For the modularisation of v1.11 this will need to become a callback, so
		 *   the sort and filter methods can subscribe to it. That will required
		 *   initialisation options for sorting, which is why it is not already baked in
		 */
		function _fnInvalidate( settings, rowIdx, src, colIdx )
		{
			var row = settings.aoData[ rowIdx ];
			var i, ien;
			var cellWrite = function ( cell, col ) {
				// This is very frustrating, but in IE if you just write directly
				// to innerHTML, and elements that are overwritten are GC'ed,
				// even if there is a reference to them elsewhere
				while ( cell.childNodes.length ) {
					cell.removeChild( cell.firstChild );
				}
		
				cell.innerHTML = _fnGetCellData( settings, rowIdx, col, 'display' );
			};
		
			// Are we reading last data from DOM or the data object?
			if ( src === 'dom' || ((! src || src === 'auto') && row.src === 'dom') ) {
				// Read the data from the DOM
				row._aData = _fnGetRowElements(
						settings, row, colIdx, colIdx === undefined ? undefined : row._aData
					)
					.data;
			}
			else {
				// Reading from data object, update the DOM
				var cells = row.anCells;
		
				if ( cells ) {
					if ( colIdx !== undefined ) {
						cellWrite( cells[colIdx], colIdx );
					}
					else {
						for ( i=0, ien=cells.length ; i<ien ; i++ ) {
							cellWrite( cells[i], i );
						}
					}
				}
			}
		
			// For both row and cell invalidation, the cached data for sorting and
			// filtering is nulled out
			row._aSortData = null;
			row._aFilterData = null;
		
			// Invalidate the type for a specific column (if given) or all columns since
			// the data might have changed
			var cols = settings.aoColumns;
			if ( colIdx !== undefined ) {
				cols[ colIdx ].sType = null;
			}
			else {
				for ( i=0, ien=cols.length ; i<ien ; i++ ) {
					cols[i].sType = null;
				}
		
				// Update DataTables special `DT_*` attributes for the row
				_fnRowAttributes( settings, row );
			}
		}
		
		
		/**
		 * Build a data source object from an HTML row, reading the contents of the
		 * cells that are in the row.
		 *
		 * @param {object} settings DataTables settings object
		 * @param {node|object} TR element from which to read data or existing row
		 *   object from which to re-read the data from the cells
		 * @param {int} [colIdx] Optional column index
		 * @param {array|object} [d] Data source object. If `colIdx` is given then this
		 *   parameter should also be given and will be used to write the data into.
		 *   Only the column in question will be written
		 * @returns {object} Object with two parameters: `data` the data read, in
		 *   document order, and `cells` and array of nodes (they can be useful to the
		 *   caller, so rather than needing a second traversal to get them, just return
		 *   them from here).
		 * @memberof DataTable#oApi
		 */
		function _fnGetRowElements( settings, row, colIdx, d )
		{
			var
				tds = [],
				td = row.firstChild,
				name, col, o, i=0, contents,
				columns = settings.aoColumns,
				objectRead = settings._rowReadObject;
		
			// Allow the data object to be passed in, or construct
			d = d !== undefined ?
				d :
				objectRead ?
					{} :
					[];
		
			var attr = function ( str, td  ) {
				if ( typeof str === 'string' ) {
					var idx = str.indexOf('@');
		
					if ( idx !== -1 ) {
						var attr = str.substring( idx+1 );
						var setter = _fnSetObjectDataFn( str );
						setter( d, td.getAttribute( attr ) );
					}
				}
			};
		
			// Read data from a cell and store into the data object
			var cellProcess = function ( cell ) {
				if ( colIdx === undefined || colIdx === i ) {
					col = columns[i];
					contents = $.trim(cell.innerHTML);
		
					if ( col && col._bAttrSrc ) {
						var setter = _fnSetObjectDataFn( col.mData._ );
						setter( d, contents );
		
						attr( col.mData.sort, cell );
						attr( col.mData.type, cell );
						attr( col.mData.filter, cell );
					}
					else {
						// Depending on the `data` option for the columns the data can
						// be read to either an object or an array.
						if ( objectRead ) {
							if ( ! col._setter ) {
								// Cache the setter function
								col._setter = _fnSetObjectDataFn( col.mData );
							}
							col._setter( d, contents );
						}
						else {
							d[i] = contents;
						}
					}
				}
		
				i++;
			};
		
			if ( td ) {
				// `tr` element was passed in
				while ( td ) {
					name = td.nodeName.toUpperCase();
		
					if ( name == "TD" || name == "TH" ) {
						cellProcess( td );
						tds.push( td );
					}
		
					td = td.nextSibling;
				}
			}
			else {
				// Existing row object passed in
				tds = row.anCells;
		
				for ( var j=0, jen=tds.length ; j<jen ; j++ ) {
					cellProcess( tds[j] );
				}
			}
		
			// Read the ID from the DOM if present
			var rowNode = row.firstChild ? row : row.nTr;
		
			if ( rowNode ) {
				var id = rowNode.getAttribute( 'id' );
		
				if ( id ) {
					_fnSetObjectDataFn( settings.rowId )( d, id );
				}
			}
		
			return {
				data: d,
				cells: tds
			};
		}
		/**
		 * Create a new TR element (and it's TD children) for a row
		 *  @param {object} oSettings dataTables settings object
		 *  @param {int} iRow Row to consider
		 *  @param {node} [nTrIn] TR element to add to the table - optional. If not given,
		 *    DataTables will create a row automatically
		 *  @param {array} [anTds] Array of TD|TH elements for the row - must be given
		 *    if nTr is.
		 *  @memberof DataTable#oApi
		 */
		function _fnCreateTr ( oSettings, iRow, nTrIn, anTds )
		{
			var
				row = oSettings.aoData[iRow],
				rowData = row._aData,
				cells = [],
				nTr, nTd, oCol,
				i, iLen;
		
			if ( row.nTr === null )
			{
				nTr = nTrIn || document.createElement('tr');
		
				row.nTr = nTr;
				row.anCells = cells;
		
				/* Use a private property on the node to allow reserve mapping from the node
				 * to the aoData array for fast look up
				 */
				nTr._DT_RowIndex = iRow;
		
				/* Special parameters can be given by the data source to be used on the row */
				_fnRowAttributes( oSettings, row );
		
				/* Process each column */
				for ( i=0, iLen=oSettings.aoColumns.length ; i<iLen ; i++ )
				{
					oCol = oSettings.aoColumns[i];
		
					nTd = nTrIn ? anTds[i] : document.createElement( oCol.sCellType );
					nTd._DT_CellIndex = {
						row: iRow,
						column: i
					};
					
					cells.push( nTd );
		
					// Need to create the HTML if new, or if a rendering function is defined
					if ( (!nTrIn || oCol.mRender || oCol.mData !== i) &&
						 (!$.isPlainObject(oCol.mData) || oCol.mData._ !== i+'.display')
					) {
						nTd.innerHTML = _fnGetCellData( oSettings, iRow, i, 'display' );
					}
		
					/* Add user defined class */
					if ( oCol.sClass )
					{
						nTd.className += ' '+oCol.sClass;
					}
		
					// Visibility - add or remove as required
					if ( oCol.bVisible && ! nTrIn )
					{
						nTr.appendChild( nTd );
					}
					else if ( ! oCol.bVisible && nTrIn )
					{
						nTd.parentNode.removeChild( nTd );
					}
		
					if ( oCol.fnCreatedCell )
					{
						oCol.fnCreatedCell.call( oSettings.oInstance,
							nTd, _fnGetCellData( oSettings, iRow, i ), rowData, iRow, i
						);
					}
				}
		
				_fnCallbackFire( oSettings, 'aoRowCreatedCallback', null, [nTr, rowData, iRow] );
			}
		
			// Remove once webkit bug 131819 and Chromium bug 365619 have been resolved
			// and deployed
			row.nTr.setAttribute( 'role', 'row' );
		}
		
		
		/**
		 * Add attributes to a row based on the special `DT_*` parameters in a data
		 * source object.
		 *  @param {object} settings DataTables settings object
		 *  @param {object} DataTables row object for the row to be modified
		 *  @memberof DataTable#oApi
		 */
		function _fnRowAttributes( settings, row )
		{
			var tr = row.nTr;
			var data = row._aData;
		
			if ( tr ) {
				var id = settings.rowIdFn( data );
		
				if ( id ) {
					tr.id = id;
				}
		
				if ( data.DT_RowClass ) {
					// Remove any classes added by DT_RowClass before
					var a = data.DT_RowClass.split(' ');
					row.__rowc = row.__rowc ?
						_unique( row.__rowc.concat( a ) ) :
						a;
		
					$(tr)
						.removeClass( row.__rowc.join(' ') )
						.addClass( data.DT_RowClass );
				}
		
				if ( data.DT_RowAttr ) {
					$(tr).attr( data.DT_RowAttr );
				}
		
				if ( data.DT_RowData ) {
					$(tr).data( data.DT_RowData );
				}
			}
		}
		
		
		/**
		 * Create the HTML header for the table
		 *  @param {object} oSettings dataTables settings object
		 *  @memberof DataTable#oApi
		 */
		function _fnBuildHead( oSettings )
		{
			var i, ien, cell, row, column;
			var thead = oSettings.nTHead;
			var tfoot = oSettings.nTFoot;
			var createHeader = $('th, td', thead).length === 0;
			var classes = oSettings.oClasses;
			var columns = oSettings.aoColumns;
		
			if ( createHeader ) {
				row = $('<tr/>').appendTo( thead );
			}
		
			for ( i=0, ien=columns.length ; i<ien ; i++ ) {
				column = columns[i];
				cell = $( column.nTh ).addClass( column.sClass );
		
				if ( createHeader ) {
					cell.appendTo( row );
				}
		
				// 1.11 move into sorting
				if ( oSettings.oFeatures.bSort ) {
					cell.addClass( column.sSortingClass );
		
					if ( column.bSortable !== false ) {
						cell
							.attr( 'tabindex', oSettings.iTabIndex )
							.attr( 'aria-controls', oSettings.sTableId );
		
						_fnSortAttachListener( oSettings, column.nTh, i );
					}
				}
		
				if ( column.sTitle != cell[0].innerHTML ) {
					cell.html( column.sTitle );
				}
		
				_fnRenderer( oSettings, 'header' )(
					oSettings, cell, column, classes
				);
			}
		
			if ( createHeader ) {
				_fnDetectHeader( oSettings.aoHeader, thead );
			}
			
			/* ARIA role for the rows */
		 	$(thead).find('>tr').attr('role', 'row');
		
			/* Deal with the footer - add classes if required */
			$(thead).find('>tr>th, >tr>td').addClass( classes.sHeaderTH );
			$(tfoot).find('>tr>th, >tr>td').addClass( classes.sFooterTH );
		
			// Cache the footer cells. Note that we only take the cells from the first
			// row in the footer. If there is more than one row the user wants to
			// interact with, they need to use the table().foot() method. Note also this
			// allows cells to be used for multiple columns using colspan
			if ( tfoot !== null ) {
				var cells = oSettings.aoFooter[0];
		
				for ( i=0, ien=cells.length ; i<ien ; i++ ) {
					column = columns[i];
					column.nTf = cells[i].cell;
		
					if ( column.sClass ) {
						$(column.nTf).addClass( column.sClass );
					}
				}
			}
		}
		
		
		/**
		 * Draw the header (or footer) element based on the column visibility states. The
		 * methodology here is to use the layout array from _fnDetectHeader, modified for
		 * the instantaneous column visibility, to construct the new layout. The grid is
		 * traversed over cell at a time in a rows x columns grid fashion, although each
		 * cell insert can cover multiple elements in the grid - which is tracks using the
		 * aApplied array. Cell inserts in the grid will only occur where there isn't
		 * already a cell in that position.
		 *  @param {object} oSettings dataTables settings object
		 *  @param array {objects} aoSource Layout array from _fnDetectHeader
		 *  @param {boolean} [bIncludeHidden=false] If true then include the hidden columns in the calc,
		 *  @memberof DataTable#oApi
		 */
		function _fnDrawHead( oSettings, aoSource, bIncludeHidden )
		{
			var i, iLen, j, jLen, k, kLen, n, nLocalTr;
			var aoLocal = [];
			var aApplied = [];
			var iColumns = oSettings.aoColumns.length;
			var iRowspan, iColspan;
		
			if ( ! aoSource )
			{
				return;
			}
		
			if (  bIncludeHidden === undefined )
			{
				bIncludeHidden = false;
			}
		
			/* Make a copy of the master layout array, but without the visible columns in it */
			for ( i=0, iLen=aoSource.length ; i<iLen ; i++ )
			{
				aoLocal[i] = aoSource[i].slice();
				aoLocal[i].nTr = aoSource[i].nTr;
		
				/* Remove any columns which are currently hidden */
				for ( j=iColumns-1 ; j>=0 ; j-- )
				{
					if ( !oSettings.aoColumns[j].bVisible && !bIncludeHidden )
					{
						aoLocal[i].splice( j, 1 );
					}
				}
		
				/* Prep the applied array - it needs an element for each row */
				aApplied.push( [] );
			}
		
			for ( i=0, iLen=aoLocal.length ; i<iLen ; i++ )
			{
				nLocalTr = aoLocal[i].nTr;
		
				/* All cells are going to be replaced, so empty out the row */
				if ( nLocalTr )
				{
					while( (n = nLocalTr.firstChild) )
					{
						nLocalTr.removeChild( n );
					}
				}
		
				for ( j=0, jLen=aoLocal[i].length ; j<jLen ; j++ )
				{
					iRowspan = 1;
					iColspan = 1;
		
					/* Check to see if there is already a cell (row/colspan) covering our target
					 * insert point. If there is, then there is nothing to do.
					 */
					if ( aApplied[i][j] === undefined )
					{
						nLocalTr.appendChild( aoLocal[i][j].cell );
						aApplied[i][j] = 1;
		
						/* Expand the cell to cover as many rows as needed */
						while ( aoLocal[i+iRowspan] !== undefined &&
						        aoLocal[i][j].cell == aoLocal[i+iRowspan][j].cell )
						{
							aApplied[i+iRowspan][j] = 1;
							iRowspan++;
						}
		
						/* Expand the cell to cover as many columns as needed */
						while ( aoLocal[i][j+iColspan] !== undefined &&
						        aoLocal[i][j].cell == aoLocal[i][j+iColspan].cell )
						{
							/* Must update the applied array over the rows for the columns */
							for ( k=0 ; k<iRowspan ; k++ )
							{
								aApplied[i+k][j+iColspan] = 1;
							}
							iColspan++;
						}
		
						/* Do the actual expansion in the DOM */
						$(aoLocal[i][j].cell)
							.attr('rowspan', iRowspan)
							.attr('colspan', iColspan);
					}
				}
			}
		}
		
		
		/**
		 * Insert the required TR nodes into the table for display
		 *  @param {object} oSettings dataTables settings object
		 *  @memberof DataTable#oApi
		 */
		function _fnDraw( oSettings )
		{
			/* Provide a pre-callback function which can be used to cancel the draw is false is returned */
			var aPreDraw = _fnCallbackFire( oSettings, 'aoPreDrawCallback', 'preDraw', [oSettings] );
			if ( $.inArray( false, aPreDraw ) !== -1 )
			{
				_fnProcessingDisplay( oSettings, false );
				return;
			}
		
			var i, iLen, n;
			var anRows = [];
			var iRowCount = 0;
			var asStripeClasses = oSettings.asStripeClasses;
			var iStripes = asStripeClasses.length;
			var iOpenRows = oSettings.aoOpenRows.length;
			var oLang = oSettings.oLanguage;
			var iInitDisplayStart = oSettings.iInitDisplayStart;
			var bServerSide = _fnDataSource( oSettings ) == 'ssp';
			var aiDisplay = oSettings.aiDisplay;
		
			oSettings.bDrawing = true;
		
			/* Check and see if we have an initial draw position from state saving */
			if ( iInitDisplayStart !== undefined && iInitDisplayStart !== -1 )
			{
				oSettings._iDisplayStart = bServerSide ?
					iInitDisplayStart :
					iInitDisplayStart >= oSettings.fnRecordsDisplay() ?
						0 :
						iInitDisplayStart;
		
				oSettings.iInitDisplayStart = -1;
			}
		
			var iDisplayStart = oSettings._iDisplayStart;
			var iDisplayEnd = oSettings.fnDisplayEnd();
		
			/* Server-side processing draw intercept */
			if ( oSettings.bDeferLoading )
			{
				oSettings.bDeferLoading = false;
				oSettings.iDraw++;
				_fnProcessingDisplay( oSettings, false );
			}
			else if ( !bServerSide )
			{
				oSettings.iDraw++;
			}
			else if ( !oSettings.bDestroying && !_fnAjaxUpdate( oSettings ) )
			{
				return;
			}
		
			if ( aiDisplay.length !== 0 )
			{
				var iStart = bServerSide ? 0 : iDisplayStart;
				var iEnd = bServerSide ? oSettings.aoData.length : iDisplayEnd;
		
				for ( var j=iStart ; j<iEnd ; j++ )
				{
					var iDataIndex = aiDisplay[j];
					var aoData = oSettings.aoData[ iDataIndex ];
					if ( aoData.nTr === null )
					{
						_fnCreateTr( oSettings, iDataIndex );
					}
		
					var nRow = aoData.nTr;
		
					/* Remove the old striping classes and then add the new one */
					if ( iStripes !== 0 )
					{
						var sStripe = asStripeClasses[ iRowCount % iStripes ];
						if ( aoData._sRowStripe != sStripe )
						{
							$(nRow).removeClass( aoData._sRowStripe ).addClass( sStripe );
							aoData._sRowStripe = sStripe;
						}
					}
		
					// Row callback functions - might want to manipulate the row
					// iRowCount and j are not currently documented. Are they at all
					// useful?
					_fnCallbackFire( oSettings, 'aoRowCallback', null,
						[nRow, aoData._aData, iRowCount, j] );
		
					anRows.push( nRow );
					iRowCount++;
				}
			}
			else
			{
				/* Table is empty - create a row with an empty message in it */
				var sZero = oLang.sZeroRecords;
				if ( oSettings.iDraw == 1 &&  _fnDataSource( oSettings ) == 'ajax' )
				{
					sZero = oLang.sLoadingRecords;
				}
				else if ( oLang.sEmptyTable && oSettings.fnRecordsTotal() === 0 )
				{
					sZero = oLang.sEmptyTable;
				}
		
				anRows[ 0 ] = $( '<tr/>', { 'class': iStripes ? asStripeClasses[0] : '' } )
					.append( $('<td />', {
						'valign':  'top',
						'colSpan': _fnVisbleColumns( oSettings ),
						'class':   oSettings.oClasses.sRowEmpty
					} ).html( sZero ) )[0];
			}
		
			/* Header and footer callbacks */
			_fnCallbackFire( oSettings, 'aoHeaderCallback', 'header', [ $(oSettings.nTHead).children('tr')[0],
				_fnGetDataMaster( oSettings ), iDisplayStart, iDisplayEnd, aiDisplay ] );
		
			_fnCallbackFire( oSettings, 'aoFooterCallback', 'footer', [ $(oSettings.nTFoot).children('tr')[0],
				_fnGetDataMaster( oSettings ), iDisplayStart, iDisplayEnd, aiDisplay ] );
		
			var body = $(oSettings.nTBody);
		
			body.children().detach();
			body.append( $(anRows) );
		
			/* Call all required callback functions for the end of a draw */
			_fnCallbackFire( oSettings, 'aoDrawCallback', 'draw', [oSettings] );
		
			/* Draw is complete, sorting and filtering must be as well */
			oSettings.bSorted = false;
			oSettings.bFiltered = false;
			oSettings.bDrawing = false;
		}
		
		
		/**
		 * Redraw the table - taking account of the various features which are enabled
		 *  @param {object} oSettings dataTables settings object
		 *  @param {boolean} [holdPosition] Keep the current paging position. By default
		 *    the paging is reset to the first page
		 *  @memberof DataTable#oApi
		 */
		function _fnReDraw( settings, holdPosition )
		{
			var
				features = settings.oFeatures,
				sort     = features.bSort,
				filter   = features.bFilter;
		
			if ( sort ) {
				_fnSort( settings );
			}
		
			if ( filter ) {
				_fnFilterComplete( settings, settings.oPreviousSearch );
			}
			else {
				// No filtering, so we want to just use the display master
				settings.aiDisplay = settings.aiDisplayMaster.slice();
			}
		
			if ( holdPosition !== true ) {
				settings._iDisplayStart = 0;
			}
		
			// Let any modules know about the draw hold position state (used by
			// scrolling internally)
			settings._drawHold = holdPosition;
		
			_fnDraw( settings );
		
			settings._drawHold = false;
		}
		
		
		/**
		 * Add the options to the page HTML for the table
		 *  @param {object} oSettings dataTables settings object
		 *  @memberof DataTable#oApi
		 */
		function _fnAddOptionsHtml ( oSettings )
		{
			var classes = oSettings.oClasses;
			var table = $(oSettings.nTable);
			var holding = $('<div/>').insertBefore( table ); // Holding element for speed
			var features = oSettings.oFeatures;
		
			// All DataTables are wrapped in a div
			var insert = $('<div/>', {
				id:      oSettings.sTableId+'_wrapper',
				'class': classes.sWrapper + (oSettings.nTFoot ? '' : ' '+classes.sNoFooter)
			} );
		
			oSettings.nHolding = holding[0];
			oSettings.nTableWrapper = insert[0];
			oSettings.nTableReinsertBefore = oSettings.nTable.nextSibling;
		
			/* Loop over the user set positioning and place the elements as needed */
			var aDom = oSettings.sDom.split('');
			var featureNode, cOption, nNewNode, cNext, sAttr, j;
			for ( var i=0 ; i<aDom.length ; i++ )
			{
				featureNode = null;
				cOption = aDom[i];
		
				if ( cOption == '<' )
				{
					/* New container div */
					nNewNode = $('<div/>')[0];
		
					/* Check to see if we should append an id and/or a class name to the container */
					cNext = aDom[i+1];
					if ( cNext == "'" || cNext == '"' )
					{
						sAttr = "";
						j = 2;
						while ( aDom[i+j] != cNext )
						{
							sAttr += aDom[i+j];
							j++;
						}
		
						/* Replace jQuery UI constants @todo depreciated */
						if ( sAttr == "H" )
						{
							sAttr = classes.sJUIHeader;
						}
						else if ( sAttr == "F" )
						{
							sAttr = classes.sJUIFooter;
						}
		
						/* The attribute can be in the format of "#id.class", "#id" or "class" This logic
						 * breaks the string into parts and applies them as needed
						 */
						if ( sAttr.indexOf('.') != -1 )
						{
							var aSplit = sAttr.split('.');
							nNewNode.id = aSplit[0].substr(1, aSplit[0].length-1);
							nNewNode.className = aSplit[1];
						}
						else if ( sAttr.charAt(0) == "#" )
						{
							nNewNode.id = sAttr.substr(1, sAttr.length-1);
						}
						else
						{
							nNewNode.className = sAttr;
						}
		
						i += j; /* Move along the position array */
					}
		
					insert.append( nNewNode );
					insert = $(nNewNode);
				}
				else if ( cOption == '>' )
				{
					/* End container div */
					insert = insert.parent();
				}
				// @todo Move options into their own plugins?
				else if ( cOption == 'l' && features.bPaginate && features.bLengthChange )
				{
					/* Length */
					featureNode = _fnFeatureHtmlLength( oSettings );
				}
				else if ( cOption == 'f' && features.bFilter )
				{
					/* Filter */
					featureNode = _fnFeatureHtmlFilter( oSettings );
				}
				else if ( cOption == 'r' && features.bProcessing )
				{
					/* pRocessing */
					featureNode = _fnFeatureHtmlProcessing( oSettings );
				}
				else if ( cOption == 't' )
				{
					/* Table */
					featureNode = _fnFeatureHtmlTable( oSettings );
				}
				else if ( cOption ==  'i' && features.bInfo )
				{
					/* Info */
					featureNode = _fnFeatureHtmlInfo( oSettings );
				}
				else if ( cOption == 'p' && features.bPaginate )
				{
					/* Pagination */
					featureNode = _fnFeatureHtmlPaginate( oSettings );
				}
				else if ( DataTable.ext.feature.length !== 0 )
				{
					/* Plug-in features */
					var aoFeatures = DataTable.ext.feature;
					for ( var k=0, kLen=aoFeatures.length ; k<kLen ; k++ )
					{
						if ( cOption == aoFeatures[k].cFeature )
						{
							featureNode = aoFeatures[k].fnInit( oSettings );
							break;
						}
					}
				}
		
				/* Add to the 2D features array */
				if ( featureNode )
				{
					var aanFeatures = oSettings.aanFeatures;
		
					if ( ! aanFeatures[cOption] )
					{
						aanFeatures[cOption] = [];
					}
		
					aanFeatures[cOption].push( featureNode );
					insert.append( featureNode );
				}
			}
		
			/* Built our DOM structure - replace the holding div with what we want */
			holding.replaceWith( insert );
			oSettings.nHolding = null;
		}
		
		
		/**
		 * Use the DOM source to create up an array of header cells. The idea here is to
		 * create a layout grid (array) of rows x columns, which contains a reference
		 * to the cell that that point in the grid (regardless of col/rowspan), such that
		 * any column / row could be removed and the new grid constructed
		 *  @param array {object} aLayout Array to store the calculated layout in
		 *  @param {node} nThead The header/footer element for the table
		 *  @memberof DataTable#oApi
		 */
		function _fnDetectHeader ( aLayout, nThead )
		{
			var nTrs = $(nThead).children('tr');
			var nTr, nCell;
			var i, k, l, iLen, jLen, iColShifted, iColumn, iColspan, iRowspan;
			var bUnique;
			var fnShiftCol = function ( a, i, j ) {
				var k = a[i];
		                while ( k[j] ) {
					j++;
				}
				return j;
			};
		
			aLayout.splice( 0, aLayout.length );
		
			/* We know how many rows there are in the layout - so prep it */
			for ( i=0, iLen=nTrs.length ; i<iLen ; i++ )
			{
				aLayout.push( [] );
			}
		
			/* Calculate a layout array */
			for ( i=0, iLen=nTrs.length ; i<iLen ; i++ )
			{
				nTr = nTrs[i];
				iColumn = 0;
		
				/* For every cell in the row... */
				nCell = nTr.firstChild;
				while ( nCell ) {
					if ( nCell.nodeName.toUpperCase() == "TD" ||
					     nCell.nodeName.toUpperCase() == "TH" )
					{
						/* Get the col and rowspan attributes from the DOM and sanitise them */
						iColspan = nCell.getAttribute('colspan') * 1;
						iRowspan = nCell.getAttribute('rowspan') * 1;
						iColspan = (!iColspan || iColspan===0 || iColspan===1) ? 1 : iColspan;
						iRowspan = (!iRowspan || iRowspan===0 || iRowspan===1) ? 1 : iRowspan;
		
						/* There might be colspan cells already in this row, so shift our target
						 * accordingly
						 */
						iColShifted = fnShiftCol( aLayout, i, iColumn );
		
						/* Cache calculation for unique columns */
						bUnique = iColspan === 1 ? true : false;
		
						/* If there is col / rowspan, copy the information into the layout grid */
						for ( l=0 ; l<iColspan ; l++ )
						{
							for ( k=0 ; k<iRowspan ; k++ )
							{
								aLayout[i+k][iColShifted+l] = {
									"cell": nCell,
									"unique": bUnique
								};
								aLayout[i+k].nTr = nTr;
							}
						}
					}
					nCell = nCell.nextSibling;
				}
			}
		}
		
		
		/**
		 * Get an array of unique th elements, one for each column
		 *  @param {object} oSettings dataTables settings object
		 *  @param {node} nHeader automatically detect the layout from this node - optional
		 *  @param {array} aLayout thead/tfoot layout from _fnDetectHeader - optional
		 *  @returns array {node} aReturn list of unique th's
		 *  @memberof DataTable#oApi
		 */
		function _fnGetUniqueThs ( oSettings, nHeader, aLayout )
		{
			var aReturn = [];
			if ( !aLayout )
			{
				aLayout = oSettings.aoHeader;
				if ( nHeader )
				{
					aLayout = [];
					_fnDetectHeader( aLayout, nHeader );
				}
			}
		
			for ( var i=0, iLen=aLayout.length ; i<iLen ; i++ )
			{
				for ( var j=0, jLen=aLayout[i].length ; j<jLen ; j++ )
				{
					if ( aLayout[i][j].unique &&
						 (!aReturn[j] || !oSettings.bSortCellsTop) )
					{
						aReturn[j] = aLayout[i][j].cell;
					}
				}
			}
		
			return aReturn;
		}
		
		/**
		 * Create an Ajax call based on the table's settings, taking into account that
		 * parameters can have multiple forms, and backwards compatibility.
		 *
		 * @param {object} oSettings dataTables settings object
		 * @param {array} data Data to send to the server, required by
		 *     DataTables - may be augmented by developer callbacks
		 * @param {function} fn Callback function to run when data is obtained
		 */
		function _fnBuildAjax( oSettings, data, fn )
		{
			// Compatibility with 1.9-, allow fnServerData and event to manipulate
			_fnCallbackFire( oSettings, 'aoServerParams', 'serverParams', [data] );
		
			// Convert to object based for 1.10+ if using the old array scheme which can
			// come from server-side processing or serverParams
			if ( data && $.isArray(data) ) {
				var tmp = {};
				var rbracket = /(.*?)\[\]$/;
		
				$.each( data, function (key, val) {
					var match = val.name.match(rbracket);
		
					if ( match ) {
						// Support for arrays
						var name = match[0];
		
						if ( ! tmp[ name ] ) {
							tmp[ name ] = [];
						}
						tmp[ name ].push( val.value );
					}
					else {
						tmp[val.name] = val.value;
					}
				} );
				data = tmp;
			}
		
			var ajaxData;
			var ajax = oSettings.ajax;
			var instance = oSettings.oInstance;
			var callback = function ( json ) {
				_fnCallbackFire( oSettings, null, 'xhr', [oSettings, json, oSettings.jqXHR] );
				fn( json );
			};
		
			if ( $.isPlainObject( ajax ) && ajax.data )
			{
				ajaxData = ajax.data;
		
				var newData = $.isFunction( ajaxData ) ?
					ajaxData( data, oSettings ) :  // fn can manipulate data or return
					ajaxData;                      // an object object or array to merge
		
				// If the function returned something, use that alone
				data = $.isFunction( ajaxData ) && newData ?
					newData :
					$.extend( true, data, newData );
		
				// Remove the data property as we've resolved it already and don't want
				// jQuery to do it again (it is restored at the end of the function)
				delete ajax.data;
			}
		
			var baseAjax = {
				"data": data,
				"success": function (json) {
					var error = json.error || json.sError;
					if ( error ) {
						_fnLog( oSettings, 0, error );
					}
		
					oSettings.json = json;
					callback( json );
				},
				"dataType": "json",
				"cache": false,
				"type": oSettings.sServerMethod,
				"error": function (xhr, error, thrown) {
					var ret = _fnCallbackFire( oSettings, null, 'xhr', [oSettings, null, oSettings.jqXHR] );
		
					if ( $.inArray( true, ret ) === -1 ) {
						if ( error == "parsererror" ) {
							_fnLog( oSettings, 0, 'Invalid JSON response', 1 );
						}
						else if ( xhr.readyState === 4 ) {
							_fnLog( oSettings, 0, 'Ajax error', 7 );
						}
					}
		
					_fnProcessingDisplay( oSettings, false );
				}
			};
		
			// Store the data submitted for the API
			oSettings.oAjaxData = data;
		
			// Allow plug-ins and external processes to modify the data
			_fnCallbackFire( oSettings, null, 'preXhr', [oSettings, data] );
		
			if ( oSettings.fnServerData )
			{
				// DataTables 1.9- compatibility
				oSettings.fnServerData.call( instance,
					oSettings.sAjaxSource,
					$.map( data, function (val, key) { // Need to convert back to 1.9 trad format
						return { name: key, value: val };
					} ),
					callback,
					oSettings
				);
			}
			else if ( oSettings.sAjaxSource || typeof ajax === 'string' )
			{
				// DataTables 1.9- compatibility
				oSettings.jqXHR = $.ajax( $.extend( baseAjax, {
					url: ajax || oSettings.sAjaxSource
				} ) );
			}
			else if ( $.isFunction( ajax ) )
			{
				// Is a function - let the caller define what needs to be done
				oSettings.jqXHR = ajax.call( instance, data, callback, oSettings );
			}
			else
			{
				// Object to extend the base settings
				oSettings.jqXHR = $.ajax( $.extend( baseAjax, ajax ) );
		
				// Restore for next time around
				ajax.data = ajaxData;
			}
		}
		
		
		/**
		 * Update the table using an Ajax call
		 *  @param {object} settings dataTables settings object
		 *  @returns {boolean} Block the table drawing or not
		 *  @memberof DataTable#oApi
		 */
		function _fnAjaxUpdate( settings )
		{
			if ( settings.bAjaxDataGet ) {
				settings.iDraw++;
				_fnProcessingDisplay( settings, true );
		
				_fnBuildAjax(
					settings,
					_fnAjaxParameters( settings ),
					function(json) {
						_fnAjaxUpdateDraw( settings, json );
					}
				);
		
				return false;
			}
			return true;
		}
		
		
		/**
		 * Build up the parameters in an object needed for a server-side processing
		 * request. Note that this is basically done twice, is different ways - a modern
		 * method which is used by default in DataTables 1.10 which uses objects and
		 * arrays, or the 1.9- method with is name / value pairs. 1.9 method is used if
		 * the sAjaxSource option is used in the initialisation, or the legacyAjax
		 * option is set.
		 *  @param {object} oSettings dataTables settings object
		 *  @returns {bool} block the table drawing or not
		 *  @memberof DataTable#oApi
		 */
		function _fnAjaxParameters( settings )
		{
			var
				columns = settings.aoColumns,
				columnCount = columns.length,
				features = settings.oFeatures,
				preSearch = settings.oPreviousSearch,
				preColSearch = settings.aoPreSearchCols,
				i, data = [], dataProp, column, columnSearch,
				sort = _fnSortFlatten( settings ),
				displayStart = settings._iDisplayStart,
				displayLength = features.bPaginate !== false ?
					settings._iDisplayLength :
					-1;
		
			var param = function ( name, value ) {
				data.push( { 'name': name, 'value': value } );
			};
		
			// DataTables 1.9- compatible method
			param( 'sEcho',          settings.iDraw );
			param( 'iColumns',       columnCount );
			param( 'sColumns',       _pluck( columns, 'sName' ).join(',') );
			param( 'iDisplayStart',  displayStart );
			param( 'iDisplayLength', displayLength );
		
			// DataTables 1.10+ method
			var d = {
				draw:    settings.iDraw,
				columns: [],
				order:   [],
				start:   displayStart,
				length:  displayLength,
				search:  {
					value: preSearch.sSearch,
					regex: preSearch.bRegex
				}
			};
		
			for ( i=0 ; i<columnCount ; i++ ) {
				column = columns[i];
				columnSearch = preColSearch[i];
				dataProp = typeof column.mData=="function" ? 'function' : column.mData ;
		
				d.columns.push( {
					data:       dataProp,
					name:       column.sName,
					searchable: column.bSearchable,
					orderable:  column.bSortable,
					search:     {
						value: columnSearch.sSearch,
						regex: columnSearch.bRegex
					}
				} );
		
				param( "mDataProp_"+i, dataProp );
		
				if ( features.bFilter ) {
					param( 'sSearch_'+i,     columnSearch.sSearch );
					param( 'bRegex_'+i,      columnSearch.bRegex );
					param( 'bSearchable_'+i, column.bSearchable );
				}
		
				if ( features.bSort ) {
					param( 'bSortable_'+i, column.bSortable );
				}
			}
		
			if ( features.bFilter ) {
				param( 'sSearch', preSearch.sSearch );
				param( 'bRegex', preSearch.bRegex );
			}
		
			if ( features.bSort ) {
				$.each( sort, function ( i, val ) {
					d.order.push( { column: val.col, dir: val.dir } );
		
					param( 'iSortCol_'+i, val.col );
					param( 'sSortDir_'+i, val.dir );
				} );
		
				param( 'iSortingCols', sort.length );
			}
		
			// If the legacy.ajax parameter is null, then we automatically decide which
			// form to use, based on sAjaxSource
			var legacy = DataTable.ext.legacy.ajax;
			if ( legacy === null ) {
				return settings.sAjaxSource ? data : d;
			}
		
			// Otherwise, if legacy has been specified then we use that to decide on the
			// form
			return legacy ? data : d;
		}
		
		
		/**
		 * Data the data from the server (nuking the old) and redraw the table
		 *  @param {object} oSettings dataTables settings object
		 *  @param {object} json json data return from the server.
		 *  @param {string} json.sEcho Tracking flag for DataTables to match requests
		 *  @param {int} json.iTotalRecords Number of records in the data set, not accounting for filtering
		 *  @param {int} json.iTotalDisplayRecords Number of records in the data set, accounting for filtering
		 *  @param {array} json.aaData The data to display on this page
		 *  @param {string} [json.sColumns] Column ordering (sName, comma separated)
		 *  @memberof DataTable#oApi
		 */
		function _fnAjaxUpdateDraw ( settings, json )
		{
			// v1.10 uses camelCase variables, while 1.9 uses Hungarian notation.
			// Support both
			var compat = function ( old, modern ) {
				return json[old] !== undefined ? json[old] : json[modern];
			};
		
			var data = _fnAjaxDataSrc( settings, json );
			var draw            = compat( 'sEcho',                'draw' );
			var recordsTotal    = compat( 'iTotalRecords',        'recordsTotal' );
			var recordsFiltered = compat( 'iTotalDisplayRecords', 'recordsFiltered' );
		
			if ( draw ) {
				// Protect against out of sequence returns
				if ( draw*1 < settings.iDraw ) {
					return;
				}
				settings.iDraw = draw * 1;
			}
		
			_fnClearTable( settings );
			settings._iRecordsTotal   = parseInt(recordsTotal, 10);
			settings._iRecordsDisplay = parseInt(recordsFiltered, 10);
		
			for ( var i=0, ien=data.length ; i<ien ; i++ ) {
				_fnAddData( settings, data[i] );
			}
			settings.aiDisplay = settings.aiDisplayMaster.slice();
		
			settings.bAjaxDataGet = false;
			_fnDraw( settings );
		
			if ( ! settings._bInitComplete ) {
				_fnInitComplete( settings, json );
			}
		
			settings.bAjaxDataGet = true;
			_fnProcessingDisplay( settings, false );
		}
		
		
		/**
		 * Get the data from the JSON data source to use for drawing a table. Using
		 * `_fnGetObjectDataFn` allows the data to be sourced from a property of the
		 * source object, or from a processing function.
		 *  @param {object} oSettings dataTables settings object
		 *  @param  {object} json Data source object / array from the server
		 *  @return {array} Array of data to use
		 */
		function _fnAjaxDataSrc ( oSettings, json )
		{
			var dataSrc = $.isPlainObject( oSettings.ajax ) && oSettings.ajax.dataSrc !== undefined ?
				oSettings.ajax.dataSrc :
				oSettings.sAjaxDataProp; // Compatibility with 1.9-.
		
			// Compatibility with 1.9-. In order to read from aaData, check if the
			// default has been changed, if not, check for aaData
			if ( dataSrc === 'data' ) {
				return json.aaData || json[dataSrc];
			}
		
			return dataSrc !== "" ?
				_fnGetObjectDataFn( dataSrc )( json ) :
				json;
		}
		
		/**
		 * Generate the node required for filtering text
		 *  @returns {node} Filter control element
		 *  @param {object} oSettings dataTables settings object
		 *  @memberof DataTable#oApi
		 */
		function _fnFeatureHtmlFilter ( settings )
		{
			var classes = settings.oClasses;
			var tableId = settings.sTableId;
			var language = settings.oLanguage;
			var previousSearch = settings.oPreviousSearch;
			var features = settings.aanFeatures;
			var input = '<input type="search" class="'+classes.sFilterInput+'"/>';
		
			var str = language.sSearch;
			str = str.match(/_INPUT_/) ?
				str.replace('_INPUT_', input) :
				str+input;
		
			var filter = $('<div/>', {
					'id': ! features.f ? tableId+'_filter' : null,
					'class': classes.sFilter
				} )
				.append( $('<label/>' ).append( str ) );
		
			var searchFn = function() {
				/* Update all other filter input elements for the new display */
				var n = features.f;
				var val = !this.value ? "" : this.value; // mental IE8 fix :-(
		
				/* Now do the filter */
				if ( val != previousSearch.sSearch ) {
					_fnFilterComplete( settings, {
						"sSearch": val,
						"bRegex": previousSearch.bRegex,
						"bSmart": previousSearch.bSmart ,
						"bCaseInsensitive": previousSearch.bCaseInsensitive
					} );
		
					// Need to redraw, without resorting
					settings._iDisplayStart = 0;
					_fnDraw( settings );
				}
			};
		
			var searchDelay = settings.searchDelay !== null ?
				settings.searchDelay :
				_fnDataSource( settings ) === 'ssp' ?
					400 :
					0;
		
			var jqFilter = $('input', filter)
				.val( previousSearch.sSearch )
				.attr( 'placeholder', language.sSearchPlaceholder )
				.bind(
					'keyup.DT search.DT input.DT paste.DT cut.DT',
					searchDelay ?
						_fnThrottle( searchFn, searchDelay ) :
						searchFn
				)
				.bind( 'keypress.DT', function(e) {
					/* Prevent form submission */
					if ( e.keyCode == 13 ) {
						return false;
					}
				} )
				.attr('aria-controls', tableId);
		
			// Update the input elements whenever the table is filtered
			$(settings.nTable).on( 'search.dt.DT', function ( ev, s ) {
				if ( settings === s ) {
					// IE9 throws an 'unknown error' if document.activeElement is used
					// inside an iframe or frame...
					try {
						if ( jqFilter[0] !== document.activeElement ) {
							jqFilter.val( previousSearch.sSearch );
						}
					}
					catch ( e ) {}
				}
			} );
		
			return filter[0];
		}
		
		
		/**
		 * Filter the table using both the global filter and column based filtering
		 *  @param {object} oSettings dataTables settings object
		 *  @param {object} oSearch search information
		 *  @param {int} [iForce] force a research of the master array (1) or not (undefined or 0)
		 *  @memberof DataTable#oApi
		 */
		function _fnFilterComplete ( oSettings, oInput, iForce )
		{
			var oPrevSearch = oSettings.oPreviousSearch;
			var aoPrevSearch = oSettings.aoPreSearchCols;
			var fnSaveFilter = function ( oFilter ) {
				/* Save the filtering values */
				oPrevSearch.sSearch = oFilter.sSearch;
				oPrevSearch.bRegex = oFilter.bRegex;
				oPrevSearch.bSmart = oFilter.bSmart;
				oPrevSearch.bCaseInsensitive = oFilter.bCaseInsensitive;
			};
			var fnRegex = function ( o ) {
				// Backwards compatibility with the bEscapeRegex option
				return o.bEscapeRegex !== undefined ? !o.bEscapeRegex : o.bRegex;
			};
		
			// Resolve any column types that are unknown due to addition or invalidation
			// @todo As per sort - can this be moved into an event handler?
			_fnColumnTypes( oSettings );
		
			/* In server-side processing all filtering is done by the server, so no point hanging around here */
			if ( _fnDataSource( oSettings ) != 'ssp' )
			{
				/* Global filter */
				_fnFilter( oSettings, oInput.sSearch, iForce, fnRegex(oInput), oInput.bSmart, oInput.bCaseInsensitive );
				fnSaveFilter( oInput );
		
				/* Now do the individual column filter */
				for ( var i=0 ; i<aoPrevSearch.length ; i++ )
				{
					_fnFilterColumn( oSettings, aoPrevSearch[i].sSearch, i, fnRegex(aoPrevSearch[i]),
						aoPrevSearch[i].bSmart, aoPrevSearch[i].bCaseInsensitive );
				}
		
				/* Custom filtering */
				_fnFilterCustom( oSettings );
			}
			else
			{
				fnSaveFilter( oInput );
			}
		
			/* Tell the draw function we have been filtering */
			oSettings.bFiltered = true;
			_fnCallbackFire( oSettings, null, 'search', [oSettings] );
		}
		
		
		/**
		 * Apply custom filtering functions
		 *  @param {object} oSettings dataTables settings object
		 *  @memberof DataTable#oApi
		 */
		function _fnFilterCustom( settings )
		{
			var filters = DataTable.ext.search;
			var displayRows = settings.aiDisplay;
			var row, rowIdx;
		
			for ( var i=0, ien=filters.length ; i<ien ; i++ ) {
				var rows = [];
		
				// Loop over each row and see if it should be included
				for ( var j=0, jen=displayRows.length ; j<jen ; j++ ) {
					rowIdx = displayRows[ j ];
					row = settings.aoData[ rowIdx ];
		
					if ( filters[i]( settings, row._aFilterData, rowIdx, row._aData, j ) ) {
						rows.push( rowIdx );
					}
				}
		
				// So the array reference doesn't break set the results into the
				// existing array
				displayRows.length = 0;
				$.merge( displayRows, rows );
			}
		}
		
		
		/**
		 * Filter the table on a per-column basis
		 *  @param {object} oSettings dataTables settings object
		 *  @param {string} sInput string to filter on
		 *  @param {int} iColumn column to filter
		 *  @param {bool} bRegex treat search string as a regular expression or not
		 *  @param {bool} bSmart use smart filtering or not
		 *  @param {bool} bCaseInsensitive Do case insenstive matching or not
		 *  @memberof DataTable#oApi
		 */
		function _fnFilterColumn ( settings, searchStr, colIdx, regex, smart, caseInsensitive )
		{
			if ( searchStr === '' ) {
				return;
			}
		
			var data;
			var display = settings.aiDisplay;
			var rpSearch = _fnFilterCreateSearch( searchStr, regex, smart, caseInsensitive );
		
			for ( var i=display.length-1 ; i>=0 ; i-- ) {
				data = settings.aoData[ display[i] ]._aFilterData[ colIdx ];
		
				if ( ! rpSearch.test( data ) ) {
					display.splice( i, 1 );
				}
			}
		}
		
		
		/**
		 * Filter the data table based on user input and draw the table
		 *  @param {object} settings dataTables settings object
		 *  @param {string} input string to filter on
		 *  @param {int} force optional - force a research of the master array (1) or not (undefined or 0)
		 *  @param {bool} regex treat as a regular expression or not
		 *  @param {bool} smart perform smart filtering or not
		 *  @param {bool} caseInsensitive Do case insenstive matching or not
		 *  @memberof DataTable#oApi
		 */
		function _fnFilter( settings, input, force, regex, smart, caseInsensitive )
		{
			var rpSearch = _fnFilterCreateSearch( input, regex, smart, caseInsensitive );
			var prevSearch = settings.oPreviousSearch.sSearch;
			var displayMaster = settings.aiDisplayMaster;
			var display, invalidated, i;
		
			// Need to take account of custom filtering functions - always filter
			if ( DataTable.ext.search.length !== 0 ) {
				force = true;
			}
		
			// Check if any of the rows were invalidated
			invalidated = _fnFilterData( settings );
		
			// If the input is blank - we just want the full data set
			if ( input.length <= 0 ) {
				settings.aiDisplay = displayMaster.slice();
			}
			else {
				// New search - start from the master array
				if ( invalidated ||
					 force ||
					 prevSearch.length > input.length ||
					 input.indexOf(prevSearch) !== 0 ||
					 settings.bSorted // On resort, the display master needs to be
					                  // re-filtered since indexes will have changed
				) {
					settings.aiDisplay = displayMaster.slice();
				}
		
				// Search the display array
				display = settings.aiDisplay;
		
				for ( i=display.length-1 ; i>=0 ; i-- ) {
					if ( ! rpSearch.test( settings.aoData[ display[i] ]._sFilterRow ) ) {
						display.splice( i, 1 );
					}
				}
			}
		}
		
		
		/**
		 * Build a regular expression object suitable for searching a table
		 *  @param {string} sSearch string to search for
		 *  @param {bool} bRegex treat as a regular expression or not
		 *  @param {bool} bSmart perform smart filtering or not
		 *  @param {bool} bCaseInsensitive Do case insensitive matching or not
		 *  @returns {RegExp} constructed object
		 *  @memberof DataTable#oApi
		 */
		function _fnFilterCreateSearch( search, regex, smart, caseInsensitive )
		{
			search = regex ?
				search :
				_fnEscapeRegex( search );
			
			if ( smart ) {
				/* For smart filtering we want to allow the search to work regardless of
				 * word order. We also want double quoted text to be preserved, so word
				 * order is important - a la google. So this is what we want to
				 * generate:
				 * 
				 * ^(?=.*?\bone\b)(?=.*?\btwo three\b)(?=.*?\bfour\b).*$
				 */
				var a = $.map( search.match( /"[^"]+"|[^ ]+/g ) || [''], function ( word ) {
					if ( word.charAt(0) === '"' ) {
						var m = word.match( /^"(.*)"$/ );
						word = m ? m[1] : word;
					}
		
					return word.replace('"', '');
				} );
		
				search = '^(?=.*?'+a.join( ')(?=.*?' )+').*$';
			}
		
			return new RegExp( search, caseInsensitive ? 'i' : '' );
		}
		
		
		/**
		 * Escape a string such that it can be used in a regular expression
		 *  @param {string} sVal string to escape
		 *  @returns {string} escaped string
		 *  @memberof DataTable#oApi
		 */
		var _fnEscapeRegex = DataTable.util.escapeRegex;
		
		var __filter_div = $('<div>')[0];
		var __filter_div_textContent = __filter_div.textContent !== undefined;
		
		// Update the filtering data for each row if needed (by invalidation or first run)
		function _fnFilterData ( settings )
		{
			var columns = settings.aoColumns;
			var column;
			var i, j, ien, jen, filterData, cellData, row;
			var fomatters = DataTable.ext.type.search;
			var wasInvalidated = false;
		
			for ( i=0, ien=settings.aoData.length ; i<ien ; i++ ) {
				row = settings.aoData[i];
		
				if ( ! row._aFilterData ) {
					filterData = [];
		
					for ( j=0, jen=columns.length ; j<jen ; j++ ) {
						column = columns[j];
		
						if ( column.bSearchable ) {
							cellData = _fnGetCellData( settings, i, j, 'filter' );
		
							if ( fomatters[ column.sType ] ) {
								cellData = fomatters[ column.sType ]( cellData );
							}
		
							// Search in DataTables 1.10 is string based. In 1.11 this
							// should be altered to also allow strict type checking.
							if ( cellData === null ) {
								cellData = '';
							}
		
							if ( typeof cellData !== 'string' && cellData.toString ) {
								cellData = cellData.toString();
							}
						}
						else {
							cellData = '';
						}
		
						// If it looks like there is an HTML entity in the string,
						// attempt to decode it so sorting works as expected. Note that
						// we could use a single line of jQuery to do this, but the DOM
						// method used here is much faster http://jsperf.com/html-decode
						if ( cellData.indexOf && cellData.indexOf('&') !== -1 ) {
							__filter_div.innerHTML = cellData;
							cellData = __filter_div_textContent ?
								__filter_div.textContent :
								__filter_div.innerText;
						}
		
						if ( cellData.replace ) {
							cellData = cellData.replace(/[\r\n]/g, '');
						}
		
						filterData.push( cellData );
					}
		
					row._aFilterData = filterData;
					row._sFilterRow = filterData.join('  ');
					wasInvalidated = true;
				}
			}
		
			return wasInvalidated;
		}
		
		
		/**
		 * Convert from the internal Hungarian notation to camelCase for external
		 * interaction
		 *  @param {object} obj Object to convert
		 *  @returns {object} Inverted object
		 *  @memberof DataTable#oApi
		 */
		function _fnSearchToCamel ( obj )
		{
			return {
				search:          obj.sSearch,
				smart:           obj.bSmart,
				regex:           obj.bRegex,
				caseInsensitive: obj.bCaseInsensitive
			};
		}
		
		
		
		/**
		 * Convert from camelCase notation to the internal Hungarian. We could use the
		 * Hungarian convert function here, but this is cleaner
		 *  @param {object} obj Object to convert
		 *  @returns {object} Inverted object
		 *  @memberof DataTable#oApi
		 */
		function _fnSearchToHung ( obj )
		{
			return {
				sSearch:          obj.search,
				bSmart:           obj.smart,
				bRegex:           obj.regex,
				bCaseInsensitive: obj.caseInsensitive
			};
		}
		
		/**
		 * Generate the node required for the info display
		 *  @param {object} oSettings dataTables settings object
		 *  @returns {node} Information element
		 *  @memberof DataTable#oApi
		 */
		function _fnFeatureHtmlInfo ( settings )
		{
			var
				tid = settings.sTableId,
				nodes = settings.aanFeatures.i,
				n = $('<div/>', {
					'class': settings.oClasses.sInfo,
					'id': ! nodes ? tid+'_info' : null
				} );
		
			if ( ! nodes ) {
				// Update display on each draw
				settings.aoDrawCallback.push( {
					"fn": _fnUpdateInfo,
					"sName": "information"
				} );
		
				n
					.attr( 'role', 'status' )
					.attr( 'aria-live', 'polite' );
		
				// Table is described by our info div
				$(settings.nTable).attr( 'aria-describedby', tid+'_info' );
			}
		
			return n[0];
		}
		
		
		/**
		 * Update the information elements in the display
		 *  @param {object} settings dataTables settings object
		 *  @memberof DataTable#oApi
		 */
		function _fnUpdateInfo ( settings )
		{
			/* Show information about the table */
			var nodes = settings.aanFeatures.i;
			if ( nodes.length === 0 ) {
				return;
			}
		
			var
				lang  = settings.oLanguage,
				start = settings._iDisplayStart+1,
				end   = settings.fnDisplayEnd(),
				max   = settings.fnRecordsTotal(),
				total = settings.fnRecordsDisplay(),
				out   = total ?
					lang.sInfo :
					lang.sInfoEmpty;
		
			if ( total !== max ) {
				/* Record set after filtering */
				out += ' ' + lang.sInfoFiltered;
			}
		
			// Convert the macros
			out += lang.sInfoPostFix;
			out = _fnInfoMacros( settings, out );
		
			var callback = lang.fnInfoCallback;
			if ( callback !== null ) {
				out = callback.call( settings.oInstance,
					settings, start, end, max, total, out
				);
			}
		
			$(nodes).html( out );
		}
		
		
		function _fnInfoMacros ( settings, str )
		{
			// When infinite scrolling, we are always starting at 1. _iDisplayStart is used only
			// internally
			var
				formatter  = settings.fnFormatNumber,
				start      = settings._iDisplayStart+1,
				len        = settings._iDisplayLength,
				vis        = settings.fnRecordsDisplay(),
				all        = len === -1;
		
			return str.
				replace(/_START_/g, formatter.call( settings, start ) ).
				replace(/_END_/g,   formatter.call( settings, settings.fnDisplayEnd() ) ).
				replace(/_MAX_/g,   formatter.call( settings, settings.fnRecordsTotal() ) ).
				replace(/_TOTAL_/g, formatter.call( settings, vis ) ).
				replace(/_PAGE_/g,  formatter.call( settings, all ? 1 : Math.ceil( start / len ) ) ).
				replace(/_PAGES_/g, formatter.call( settings, all ? 1 : Math.ceil( vis / len ) ) );
		}
		
		
		
		/**
		 * Draw the table for the first time, adding all required features
		 *  @param {object} settings dataTables settings object
		 *  @memberof DataTable#oApi
		 */
		function _fnInitialise ( settings )
		{
			var i, iLen, iAjaxStart=settings.iInitDisplayStart;
			var columns = settings.aoColumns, column;
			var features = settings.oFeatures;
			var deferLoading = settings.bDeferLoading; // value modified by the draw
		
			/* Ensure that the table data is fully initialised */
			if ( ! settings.bInitialised ) {
				setTimeout( function(){ _fnInitialise( settings ); }, 200 );
				return;
			}
		
			/* Show the display HTML options */
			_fnAddOptionsHtml( settings );
		
			/* Build and draw the header / footer for the table */
			_fnBuildHead( settings );
			_fnDrawHead( settings, settings.aoHeader );
			_fnDrawHead( settings, settings.aoFooter );
		
			/* Okay to show that something is going on now */
			_fnProcessingDisplay( settings, true );
		
			/* Calculate sizes for columns */
			if ( features.bAutoWidth ) {
				_fnCalculateColumnWidths( settings );
			}
		
			for ( i=0, iLen=columns.length ; i<iLen ; i++ ) {
				column = columns[i];
		
				if ( column.sWidth ) {
					column.nTh.style.width = _fnStringToCss( column.sWidth );
				}
			}
		
			_fnCallbackFire( settings, null, 'preInit', [settings] );
		
			// If there is default sorting required - let's do it. The sort function
			// will do the drawing for us. Otherwise we draw the table regardless of the
			// Ajax source - this allows the table to look initialised for Ajax sourcing
			// data (show 'loading' message possibly)
			_fnReDraw( settings );
		
			// Server-side processing init complete is done by _fnAjaxUpdateDraw
			var dataSrc = _fnDataSource( settings );
			if ( dataSrc != 'ssp' || deferLoading ) {
				// if there is an ajax source load the data
				if ( dataSrc == 'ajax' ) {
					_fnBuildAjax( settings, [], function(json) {
						var aData = _fnAjaxDataSrc( settings, json );
		
						// Got the data - add it to the table
						for ( i=0 ; i<aData.length ; i++ ) {
							_fnAddData( settings, aData[i] );
						}
		
						// Reset the init display for cookie saving. We've already done
						// a filter, and therefore cleared it before. So we need to make
						// it appear 'fresh'
						settings.iInitDisplayStart = iAjaxStart;
		
						_fnReDraw( settings );
		
						_fnProcessingDisplay( settings, false );
						_fnInitComplete( settings, json );
					}, settings );
				}
				else {
					_fnProcessingDisplay( settings, false );
					_fnInitComplete( settings );
				}
			}
		}
		
		
		/**
		 * Draw the table for the first time, adding all required features
		 *  @param {object} oSettings dataTables settings object
		 *  @param {object} [json] JSON from the server that completed the table, if using Ajax source
		 *    with client-side processing (optional)
		 *  @memberof DataTable#oApi
		 */
		function _fnInitComplete ( settings, json )
		{
			settings._bInitComplete = true;
		
			// When data was added after the initialisation (data or Ajax) we need to
			// calculate the column sizing
			if ( json || settings.oInit.aaData ) {
				_fnAdjustColumnSizing( settings );
			}
		
			_fnCallbackFire( settings, null, 'plugin-init', [settings, json] );
			_fnCallbackFire( settings, 'aoInitComplete', 'init', [settings, json] );
		}
		
		
		function _fnLengthChange ( settings, val )
		{
			var len = parseInt( val, 10 );
			settings._iDisplayLength = len;
		
			_fnLengthOverflow( settings );
		
			// Fire length change event
			_fnCallbackFire( settings, null, 'length', [settings, len] );
		}
		
		
		/**
		 * Generate the node required for user display length changing
		 *  @param {object} settings dataTables settings object
		 *  @returns {node} Display length feature node
		 *  @memberof DataTable#oApi
		 */
		function _fnFeatureHtmlLength ( settings )
		{
			var
				classes  = settings.oClasses,
				tableId  = settings.sTableId,
				menu     = settings.aLengthMenu,
				d2       = $.isArray( menu[0] ),
				lengths  = d2 ? menu[0] : menu,
				language = d2 ? menu[1] : menu;
		
			var select = $('<select/>', {
				'name':          tableId+'_length',
				'aria-controls': tableId,
				'class':         classes.sLengthSelect
			} );
		
			for ( var i=0, ien=lengths.length ; i<ien ; i++ ) {
				select[0][ i ] = new Option( language[i], lengths[i] );
			}
		
			var div = $('<div><label/></div>').addClass( classes.sLength );
			if ( ! settings.aanFeatures.l ) {
				div[0].id = tableId+'_length';
			}
		
			div.children().append(
				settings.oLanguage.sLengthMenu.replace( '_MENU_', select[0].outerHTML )
			);
		
			// Can't use `select` variable as user might provide their own and the
			// reference is broken by the use of outerHTML
			$('select', div)
				.val( settings._iDisplayLength )
				.bind( 'change.DT', function(e) {
					_fnLengthChange( settings, $(this).val() );
					_fnDraw( settings );
				} );
		
			// Update node value whenever anything changes the table's length
			$(settings.nTable).bind( 'length.dt.DT', function (e, s, len) {
				if ( settings === s ) {
					$('select', div).val( len );
				}
			} );
		
			return div[0];
		}
		
		
		
		/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
		 * Note that most of the paging logic is done in
		 * DataTable.ext.pager
		 */
		
		/**
		 * Generate the node required for default pagination
		 *  @param {object} oSettings dataTables settings object
		 *  @returns {node} Pagination feature node
		 *  @memberof DataTable#oApi
		 */
		function _fnFeatureHtmlPaginate ( settings )
		{
			var
				type   = settings.sPaginationType,
				plugin = DataTable.ext.pager[ type ],
				modern = typeof plugin === 'function',
				redraw = function( settings ) {
					_fnDraw( settings );
				},
				node = $('<div/>').addClass( settings.oClasses.sPaging + type )[0],
				features = settings.aanFeatures;
		
			if ( ! modern ) {
				plugin.fnInit( settings, node, redraw );
			}
		
			/* Add a draw callback for the pagination on first instance, to update the paging display */
			if ( ! features.p )
			{
				node.id = settings.sTableId+'_paginate';
		
				settings.aoDrawCallback.push( {
					"fn": function( settings ) {
						if ( modern ) {
							var
								start      = settings._iDisplayStart,
								len        = settings._iDisplayLength,
								visRecords = settings.fnRecordsDisplay(),
								all        = len === -1,
								page = all ? 0 : Math.ceil( start / len ),
								pages = all ? 1 : Math.ceil( visRecords / len ),
								buttons = plugin(page, pages),
								i, ien;
		
							for ( i=0, ien=features.p.length ; i<ien ; i++ ) {
								_fnRenderer( settings, 'pageButton' )(
									settings, features.p[i], i, buttons, page, pages
								);
							}
						}
						else {
							plugin.fnUpdate( settings, redraw );
						}
					},
					"sName": "pagination"
				} );
			}
		
			return node;
		}
		
		
		/**
		 * Alter the display settings to change the page
		 *  @param {object} settings DataTables settings object
		 *  @param {string|int} action Paging action to take: "first", "previous",
		 *    "next" or "last" or page number to jump to (integer)
		 *  @param [bool] redraw Automatically draw the update or not
		 *  @returns {bool} true page has changed, false - no change
		 *  @memberof DataTable#oApi
		 */
		function _fnPageChange ( settings, action, redraw )
		{
			var
				start     = settings._iDisplayStart,
				len       = settings._iDisplayLength,
				records   = settings.fnRecordsDisplay();
		
			if ( records === 0 || len === -1 )
			{
				start = 0;
			}
			else if ( typeof action === "number" )
			{
				start = action * len;
		
				if ( start > records )
				{
					start = 0;
				}
			}
			else if ( action == "first" )
			{
				start = 0;
			}
			else if ( action == "previous" )
			{
				start = len >= 0 ?
					start - len :
					0;
		
				if ( start < 0 )
				{
				  start = 0;
				}
			}
			else if ( action == "next" )
			{
				if ( start + len < records )
				{
					start += len;
				}
			}
			else if ( action == "last" )
			{
				start = Math.floor( (records-1) / len) * len;
			}
			else
			{
				_fnLog( settings, 0, "Unknown paging action: "+action, 5 );
			}
		
			var changed = settings._iDisplayStart !== start;
			settings._iDisplayStart = start;
		
			if ( changed ) {
				_fnCallbackFire( settings, null, 'page', [settings] );
		
				if ( redraw ) {
					_fnDraw( settings );
				}
			}
		
			return changed;
		}
		
		
		
		/**
		 * Generate the node required for the processing node
		 *  @param {object} settings dataTables settings object
		 *  @returns {node} Processing element
		 *  @memberof DataTable#oApi
		 */
		function _fnFeatureHtmlProcessing ( settings )
		{
			return $('<div/>', {
					'id': ! settings.aanFeatures.r ? settings.sTableId+'_processing' : null,
					'class': settings.oClasses.sProcessing
				} )
				.html( settings.oLanguage.sProcessing )
				.insertBefore( settings.nTable )[0];
		}
		
		
		/**
		 * Display or hide the processing indicator
		 *  @param {object} settings dataTables settings object
		 *  @param {bool} show Show the processing indicator (true) or not (false)
		 *  @memberof DataTable#oApi
		 */
		function _fnProcessingDisplay ( settings, show )
		{
			if ( settings.oFeatures.bProcessing ) {
				$(settings.aanFeatures.r).css( 'display', show ? 'block' : 'none' );
			}
		
			_fnCallbackFire( settings, null, 'processing', [settings, show] );
		}
		
		/**
		 * Add any control elements for the table - specifically scrolling
		 *  @param {object} settings dataTables settings object
		 *  @returns {node} Node to add to the DOM
		 *  @memberof DataTable#oApi
		 */
		function _fnFeatureHtmlTable ( settings )
		{
			var table = $(settings.nTable);
		
			// Add the ARIA grid role to the table
			table.attr( 'role', 'grid' );
		
			// Scrolling from here on in
			var scroll = settings.oScroll;
		
			if ( scroll.sX === '' && scroll.sY === '' ) {
				return settings.nTable;
			}
		
			var scrollX = scroll.sX;
			var scrollY = scroll.sY;
			var classes = settings.oClasses;
			var caption = table.children('caption');
			var captionSide = caption.length ? caption[0]._captionSide : null;
			var headerClone = $( table[0].cloneNode(false) );
			var footerClone = $( table[0].cloneNode(false) );
			var footer = table.children('tfoot');
			var _div = '<div/>';
			var size = function ( s ) {
				return !s ? null : _fnStringToCss( s );
			};
		
			if ( ! footer.length ) {
				footer = null;
			}
		
			/*
			 * The HTML structure that we want to generate in this function is:
			 *  div - scroller
			 *    div - scroll head
			 *      div - scroll head inner
			 *        table - scroll head table
			 *          thead - thead
			 *    div - scroll body
			 *      table - table (master table)
			 *        thead - thead clone for sizing
			 *        tbody - tbody
			 *    div - scroll foot
			 *      div - scroll foot inner
			 *        table - scroll foot table
			 *          tfoot - tfoot
			 */
			var scroller = $( _div, { 'class': classes.sScrollWrapper } )
				.append(
					$(_div, { 'class': classes.sScrollHead } )
						.css( {
							overflow: 'hidden',
							position: 'relative',
							border: 0,
							width: scrollX ? size(scrollX) : '100%'
						} )
						.append(
							$(_div, { 'class': classes.sScrollHeadInner } )
								.css( {
									'box-sizing': 'content-box',
									width: scroll.sXInner || '100%'
								} )
								.append(
									headerClone
										.removeAttr('id')
										.css( 'margin-left', 0 )
										.append( captionSide === 'top' ? caption : null )
										.append(
											table.children('thead')
										)
								)
						)
				)
				.append(
					$(_div, { 'class': classes.sScrollBody } )
						.css( {
							position: 'relative',
							overflow: 'auto',
							width: size( scrollX )
						} )
						.append( table )
				);
		
			if ( footer ) {
				scroller.append(
					$(_div, { 'class': classes.sScrollFoot } )
						.css( {
							overflow: 'hidden',
							border: 0,
							width: scrollX ? size(scrollX) : '100%'
						} )
						.append(
							$(_div, { 'class': classes.sScrollFootInner } )
								.append(
									footerClone
										.removeAttr('id')
										.css( 'margin-left', 0 )
										.append( captionSide === 'bottom' ? caption : null )
										.append(
											table.children('tfoot')
										)
								)
						)
				);
			}
		
			var children = scroller.children();
			var scrollHead = children[0];
			var scrollBody = children[1];
			var scrollFoot = footer ? children[2] : null;
		
			// When the body is scrolled, then we also want to scroll the headers
			if ( scrollX ) {
				$(scrollBody).on( 'scroll.DT', function (e) {
					var scrollLeft = this.scrollLeft;
		
					scrollHead.scrollLeft = scrollLeft;
		
					if ( footer ) {
						scrollFoot.scrollLeft = scrollLeft;
					}
				} );
			}
		
			$(scrollBody).css(
				scrollY && scroll.bCollapse ? 'max-height' : 'height', 
				scrollY
			);
		
			settings.nScrollHead = scrollHead;
			settings.nScrollBody = scrollBody;
			settings.nScrollFoot = scrollFoot;
		
			// On redraw - align columns
			settings.aoDrawCallback.push( {
				"fn": _fnScrollDraw,
				"sName": "scrolling"
			} );
		
			return scroller[0];
		}
		
		
		
		/**
		 * Update the header, footer and body tables for resizing - i.e. column
		 * alignment.
		 *
		 * Welcome to the most horrible function DataTables. The process that this
		 * function follows is basically:
		 *   1. Re-create the table inside the scrolling div
		 *   2. Take live measurements from the DOM
		 *   3. Apply the measurements to align the columns
		 *   4. Clean up
		 *
		 *  @param {object} settings dataTables settings object
		 *  @memberof DataTable#oApi
		 */
		function _fnScrollDraw ( settings )
		{
			// Given that this is such a monster function, a lot of variables are use
			// to try and keep the minimised size as small as possible
			var
				scroll         = settings.oScroll,
				scrollX        = scroll.sX,
				scrollXInner   = scroll.sXInner,
				scrollY        = scroll.sY,
				barWidth       = scroll.iBarWidth,
				divHeader      = $(settings.nScrollHead),
				divHeaderStyle = divHeader[0].style,
				divHeaderInner = divHeader.children('div'),
				divHeaderInnerStyle = divHeaderInner[0].style,
				divHeaderTable = divHeaderInner.children('table'),
				divBodyEl      = settings.nScrollBody,
				divBody        = $(divBodyEl),
				divBodyStyle   = divBodyEl.style,
				divFooter      = $(settings.nScrollFoot),
				divFooterInner = divFooter.children('div'),
				divFooterTable = divFooterInner.children('table'),
				header         = $(settings.nTHead),
				table          = $(settings.nTable),
				tableEl        = table[0],
				tableStyle     = tableEl.style,
				footer         = settings.nTFoot ? $(settings.nTFoot) : null,
				browser        = settings.oBrowser,
				ie67           = browser.bScrollOversize,
				dtHeaderCells  = _pluck( settings.aoColumns, 'nTh' ),
				headerTrgEls, footerTrgEls,
				headerSrcEls, footerSrcEls,
				headerCopy, footerCopy,
				headerWidths=[], footerWidths=[],
				headerContent=[], footerContent=[],
				idx, correction, sanityWidth,
				zeroOut = function(nSizer) {
					var style = nSizer.style;
					style.paddingTop = "0";
					style.paddingBottom = "0";
					style.borderTopWidth = "0";
					style.borderBottomWidth = "0";
					style.height = 0;
				};
		
			// If the scrollbar visibility has changed from the last draw, we need to
			// adjust the column sizes as the table width will have changed to account
			// for the scrollbar
			var scrollBarVis = divBodyEl.scrollHeight > divBodyEl.clientHeight;
			
			if ( settings.scrollBarVis !== scrollBarVis && settings.scrollBarVis !== undefined ) {
				settings.scrollBarVis = scrollBarVis;
				_fnAdjustColumnSizing( settings );
				return; // adjust column sizing will call this function again
			}
			else {
				settings.scrollBarVis = scrollBarVis;
			}
		
			/*
			 * 1. Re-create the table inside the scrolling div
			 */
		
			// Remove the old minimised thead and tfoot elements in the inner table
			table.children('thead, tfoot').remove();
		
			if ( footer ) {
				footerCopy = footer.clone().prependTo( table );
				footerTrgEls = footer.find('tr'); // the original tfoot is in its own table and must be sized
				footerSrcEls = footerCopy.find('tr');
			}
		
			// Clone the current header and footer elements and then place it into the inner table
			headerCopy = header.clone().prependTo( table );
			headerTrgEls = header.find('tr'); // original header is in its own table
			headerSrcEls = headerCopy.find('tr');
			headerCopy.find('th, td').removeAttr('tabindex');
		
		
			/*
			 * 2. Take live measurements from the DOM - do not alter the DOM itself!
			 */
		
			// Remove old sizing and apply the calculated column widths
			// Get the unique column headers in the newly created (cloned) header. We want to apply the
			// calculated sizes to this header
			if ( ! scrollX )
			{
				divBodyStyle.width = '100%';
				divHeader[0].style.width = '100%';
			}
		
			$.each( _fnGetUniqueThs( settings, headerCopy ), function ( i, el ) {
				idx = _fnVisibleToColumnIndex( settings, i );
				el.style.width = settings.aoColumns[idx].sWidth;
			} );
		
			if ( footer ) {
				_fnApplyToChildren( function(n) {
					n.style.width = "";
				}, footerSrcEls );
			}
		
			// Size the table as a whole
			sanityWidth = table.outerWidth();
			if ( scrollX === "" ) {
				// No x scrolling
				tableStyle.width = "100%";
		
				// IE7 will make the width of the table when 100% include the scrollbar
				// - which is shouldn't. When there is a scrollbar we need to take this
				// into account.
				if ( ie67 && (table.find('tbody').height() > divBodyEl.offsetHeight ||
					divBody.css('overflow-y') == "scroll")
				) {
					tableStyle.width = _fnStringToCss( table.outerWidth() - barWidth);
				}
		
				// Recalculate the sanity width
				sanityWidth = table.outerWidth();
			}
			else if ( scrollXInner !== "" ) {
				// legacy x scroll inner has been given - use it
				tableStyle.width = _fnStringToCss(scrollXInner);
		
				// Recalculate the sanity width
				sanityWidth = table.outerWidth();
			}
		
			// Hidden header should have zero height, so remove padding and borders. Then
			// set the width based on the real headers
		
			// Apply all styles in one pass
			_fnApplyToChildren( zeroOut, headerSrcEls );
		
			// Read all widths in next pass
			_fnApplyToChildren( function(nSizer) {
				headerContent.push( nSizer.innerHTML );
				headerWidths.push( _fnStringToCss( $(nSizer).css('width') ) );
			}, headerSrcEls );
		
			// Apply all widths in final pass
			_fnApplyToChildren( function(nToSize, i) {
				// Only apply widths to the DataTables detected header cells - this
				// prevents complex headers from having contradictory sizes applied
				if ( $.inArray( nToSize, dtHeaderCells ) !== -1 ) {
					nToSize.style.width = headerWidths[i];
				}
			}, headerTrgEls );
		
			$(headerSrcEls).height(0);
		
			/* Same again with the footer if we have one */
			if ( footer )
			{
				_fnApplyToChildren( zeroOut, footerSrcEls );
		
				_fnApplyToChildren( function(nSizer) {
					footerContent.push( nSizer.innerHTML );
					footerWidths.push( _fnStringToCss( $(nSizer).css('width') ) );
				}, footerSrcEls );
		
				_fnApplyToChildren( function(nToSize, i) {
					nToSize.style.width = footerWidths[i];
				}, footerTrgEls );
		
				$(footerSrcEls).height(0);
			}
		
		
			/*
			 * 3. Apply the measurements
			 */
		
			// "Hide" the header and footer that we used for the sizing. We need to keep
			// the content of the cell so that the width applied to the header and body
			// both match, but we want to hide it completely. We want to also fix their
			// width to what they currently are
			_fnApplyToChildren( function(nSizer, i) {
				nSizer.innerHTML = '<div class="dataTables_sizing" style="height:0;overflow:hidden;">'+headerContent[i]+'</div>';
				nSizer.style.width = headerWidths[i];
			}, headerSrcEls );
		
			if ( footer )
			{
				_fnApplyToChildren( function(nSizer, i) {
					nSizer.innerHTML = '<div class="dataTables_sizing" style="height:0;overflow:hidden;">'+footerContent[i]+'</div>';
					nSizer.style.width = footerWidths[i];
				}, footerSrcEls );
			}
		
			// Sanity check that the table is of a sensible width. If not then we are going to get
			// misalignment - try to prevent this by not allowing the table to shrink below its min width
			if ( table.outerWidth() < sanityWidth )
			{
				// The min width depends upon if we have a vertical scrollbar visible or not */
				correction = ((divBodyEl.scrollHeight > divBodyEl.offsetHeight ||
					divBody.css('overflow-y') == "scroll")) ?
						sanityWidth+barWidth :
						sanityWidth;
		
				// IE6/7 are a law unto themselves...
				if ( ie67 && (divBodyEl.scrollHeight >
					divBodyEl.offsetHeight || divBody.css('overflow-y') == "scroll")
				) {
					tableStyle.width = _fnStringToCss( correction-barWidth );
				}
		
				// And give the user a warning that we've stopped the table getting too small
				if ( scrollX === "" || scrollXInner !== "" ) {
					_fnLog( settings, 1, 'Possible column misalignment', 6 );
				}
			}
			else
			{
				correction = '100%';
			}
		
			// Apply to the container elements
			divBodyStyle.width = _fnStringToCss( correction );
			divHeaderStyle.width = _fnStringToCss( correction );
		
			if ( footer ) {
				settings.nScrollFoot.style.width = _fnStringToCss( correction );
			}
		
		
			/*
			 * 4. Clean up
			 */
			if ( ! scrollY ) {
				/* IE7< puts a vertical scrollbar in place (when it shouldn't be) due to subtracting
				 * the scrollbar height from the visible display, rather than adding it on. We need to
				 * set the height in order to sort this. Don't want to do it in any other browsers.
				 */
				if ( ie67 ) {
					divBodyStyle.height = _fnStringToCss( tableEl.offsetHeight+barWidth );
				}
			}
		
			/* Finally set the width's of the header and footer tables */
			var iOuterWidth = table.outerWidth();
			divHeaderTable[0].style.width = _fnStringToCss( iOuterWidth );
			divHeaderInnerStyle.width = _fnStringToCss( iOuterWidth );
		
			// Figure out if there are scrollbar present - if so then we need a the header and footer to
			// provide a bit more space to allow "overflow" scrolling (i.e. past the scrollbar)
			var bScrolling = table.height() > divBodyEl.clientHeight || divBody.css('overflow-y') == "scroll";
			var padding = 'padding' + (browser.bScrollbarLeft ? 'Left' : 'Right' );
			divHeaderInnerStyle[ padding ] = bScrolling ? barWidth+"px" : "0px";
		
			if ( footer ) {
				divFooterTable[0].style.width = _fnStringToCss( iOuterWidth );
				divFooterInner[0].style.width = _fnStringToCss( iOuterWidth );
				divFooterInner[0].style[padding] = bScrolling ? barWidth+"px" : "0px";
			}
		
			// Correct DOM ordering for colgroup - comes before the thead
			table.children('colgroup').insertBefore( table.children('thead') );
		
			/* Adjust the position of the header in case we loose the y-scrollbar */
			divBody.scroll();
		
			// If sorting or filtering has occurred, jump the scrolling back to the top
			// only if we aren't holding the position
			if ( (settings.bSorted || settings.bFiltered) && ! settings._drawHold ) {
				divBodyEl.scrollTop = 0;
			}
		}
		
		
		
		/**
		 * Apply a given function to the display child nodes of an element array (typically
		 * TD children of TR rows
		 *  @param {function} fn Method to apply to the objects
		 *  @param array {nodes} an1 List of elements to look through for display children
		 *  @param array {nodes} an2 Another list (identical structure to the first) - optional
		 *  @memberof DataTable#oApi
		 */
		function _fnApplyToChildren( fn, an1, an2 )
		{
			var index=0, i=0, iLen=an1.length;
			var nNode1, nNode2;
		
			while ( i < iLen ) {
				nNode1 = an1[i].firstChild;
				nNode2 = an2 ? an2[i].firstChild : null;
		
				while ( nNode1 ) {
					if ( nNode1.nodeType === 1 ) {
						if ( an2 ) {
							fn( nNode1, nNode2, index );
						}
						else {
							fn( nNode1, index );
						}
		
						index++;
					}
		
					nNode1 = nNode1.nextSibling;
					nNode2 = an2 ? nNode2.nextSibling : null;
				}
		
				i++;
			}
		}
		
		
		
		var __re_html_remove = /<.*?>/g;
		
		
		/**
		 * Calculate the width of columns for the table
		 *  @param {object} oSettings dataTables settings object
		 *  @memberof DataTable#oApi
		 */
		function _fnCalculateColumnWidths ( oSettings )
		{
			var
				table = oSettings.nTable,
				columns = oSettings.aoColumns,
				scroll = oSettings.oScroll,
				scrollY = scroll.sY,
				scrollX = scroll.sX,
				scrollXInner = scroll.sXInner,
				columnCount = columns.length,
				visibleColumns = _fnGetColumns( oSettings, 'bVisible' ),
				headerCells = $('th', oSettings.nTHead),
				tableWidthAttr = table.getAttribute('width'), // from DOM element
				tableContainer = table.parentNode,
				userInputs = false,
				i, column, columnIdx, width, outerWidth,
				browser = oSettings.oBrowser,
				ie67 = browser.bScrollOversize;
		
			var styleWidth = table.style.width;
			if ( styleWidth && styleWidth.indexOf('%') !== -1 ) {
				tableWidthAttr = styleWidth;
			}
		
			/* Convert any user input sizes into pixel sizes */
			for ( i=0 ; i<visibleColumns.length ; i++ ) {
				column = columns[ visibleColumns[i] ];
		
				if ( column.sWidth !== null ) {
					column.sWidth = _fnConvertToWidth( column.sWidthOrig, tableContainer );
		
					userInputs = true;
				}
			}
		
			/* If the number of columns in the DOM equals the number that we have to
			 * process in DataTables, then we can use the offsets that are created by
			 * the web- browser. No custom sizes can be set in order for this to happen,
			 * nor scrolling used
			 */
			if ( ie67 || ! userInputs && ! scrollX && ! scrollY &&
			     columnCount == _fnVisbleColumns( oSettings ) &&
			     columnCount == headerCells.length
			) {
				for ( i=0 ; i<columnCount ; i++ ) {
					var colIdx = _fnVisibleToColumnIndex( oSettings, i );
		
					if ( colIdx !== null ) {
						columns[ colIdx ].sWidth = _fnStringToCss( headerCells.eq(i).width() );
					}
				}
			}
			else
			{
				// Otherwise construct a single row, worst case, table with the widest
				// node in the data, assign any user defined widths, then insert it into
				// the DOM and allow the browser to do all the hard work of calculating
				// table widths
				var tmpTable = $(table).clone() // don't use cloneNode - IE8 will remove events on the main table
					.css( 'visibility', 'hidden' )
					.removeAttr( 'id' );
		
				// Clean up the table body
				tmpTable.find('tbody tr').remove();
				var tr = $('<tr/>').appendTo( tmpTable.find('tbody') );
		
				// Clone the table header and footer - we can't use the header / footer
				// from the cloned table, since if scrolling is active, the table's
				// real header and footer are contained in different table tags
				tmpTable.find('thead, tfoot').remove();
				tmpTable
					.append( $(oSettings.nTHead).clone() )
					.append( $(oSettings.nTFoot).clone() );
		
				// Remove any assigned widths from the footer (from scrolling)
				tmpTable.find('tfoot th, tfoot td').css('width', '');
		
				// Apply custom sizing to the cloned header
				headerCells = _fnGetUniqueThs( oSettings, tmpTable.find('thead')[0] );
		
				for ( i=0 ; i<visibleColumns.length ; i++ ) {
					column = columns[ visibleColumns[i] ];
		
					headerCells[i].style.width = column.sWidthOrig !== null && column.sWidthOrig !== '' ?
						_fnStringToCss( column.sWidthOrig ) :
						'';
		
					// For scrollX we need to force the column width otherwise the
					// browser will collapse it. If this width is smaller than the
					// width the column requires, then it will have no effect
					if ( column.sWidthOrig && scrollX ) {
						$( headerCells[i] ).append( $('<div/>').css( {
							width: column.sWidthOrig,
							margin: 0,
							padding: 0,
							border: 0,
							height: 1
						} ) );
					}
				}
		
				// Find the widest cell for each column and put it into the table
				if ( oSettings.aoData.length ) {
					for ( i=0 ; i<visibleColumns.length ; i++ ) {
						columnIdx = visibleColumns[i];
						column = columns[ columnIdx ];
		
						$( _fnGetWidestNode( oSettings, columnIdx ) )
							.clone( false )
							.append( column.sContentPadding )
							.appendTo( tr );
					}
				}
		
				// Tidy the temporary table - remove name attributes so there aren't
				// duplicated in the dom (radio elements for example)
				$('[name]', tmpTable).removeAttr('name');
		
				// Table has been built, attach to the document so we can work with it.
				// A holding element is used, positioned at the top of the container
				// with minimal height, so it has no effect on if the container scrolls
				// or not. Otherwise it might trigger scrolling when it actually isn't
				// needed
				var holder = $('<div/>').css( scrollX || scrollY ?
						{
							position: 'absolute',
							top: 0,
							left: 0,
							height: 1,
							right: 0,
							overflow: 'hidden'
						} :
						{}
					)
					.append( tmpTable )
					.appendTo( tableContainer );
		
				// When scrolling (X or Y) we want to set the width of the table as 
				// appropriate. However, when not scrolling leave the table width as it
				// is. This results in slightly different, but I think correct behaviour
				if ( scrollX && scrollXInner ) {
					tmpTable.width( scrollXInner );
				}
				else if ( scrollX ) {
					tmpTable.css( 'width', 'auto' );
					tmpTable.removeAttr('width');
		
					// If there is no width attribute or style, then allow the table to
					// collapse
					if ( tmpTable.width() < tableContainer.clientWidth && tableWidthAttr ) {
						tmpTable.width( tableContainer.clientWidth );
					}
				}
				else if ( scrollY ) {
					tmpTable.width( tableContainer.clientWidth );
				}
				else if ( tableWidthAttr ) {
					tmpTable.width( tableWidthAttr );
				}
		
				// Get the width of each column in the constructed table - we need to
				// know the inner width (so it can be assigned to the other table's
				// cells) and the outer width so we can calculate the full width of the
				// table. This is safe since DataTables requires a unique cell for each
				// column, but if ever a header can span multiple columns, this will
				// need to be modified.
				var total = 0;
				for ( i=0 ; i<visibleColumns.length ; i++ ) {
					var cell = $(headerCells[i]);
					var border = cell.outerWidth() - cell.width();
		
					// Use getBounding... where possible (not IE8-) because it can give
					// sub-pixel accuracy, which we then want to round up!
					var bounding = browser.bBounding ?
						Math.ceil( headerCells[i].getBoundingClientRect().width ) :
						cell.outerWidth();
		
					// Total is tracked to remove any sub-pixel errors as the outerWidth
					// of the table might not equal the total given here (IE!).
					total += bounding;
		
					// Width for each column to use
					columns[ visibleColumns[i] ].sWidth = _fnStringToCss( bounding - border );
				}
		
				table.style.width = _fnStringToCss( total );
		
				// Finished with the table - ditch it
				holder.remove();
			}
		
			// If there is a width attr, we want to attach an event listener which
			// allows the table sizing to automatically adjust when the window is
			// resized. Use the width attr rather than CSS, since we can't know if the
			// CSS is a relative value or absolute - DOM read is always px.
			if ( tableWidthAttr ) {
				table.style.width = _fnStringToCss( tableWidthAttr );
			}
		
			if ( (tableWidthAttr || scrollX) && ! oSettings._reszEvt ) {
				var bindResize = function () {
					$(window).bind('resize.DT-'+oSettings.sInstance, _fnThrottle( function () {
						_fnAdjustColumnSizing( oSettings );
					} ) );
				};
		
				// IE6/7 will crash if we bind a resize event handler on page load.
				// To be removed in 1.11 which drops IE6/7 support
				if ( ie67 ) {
					setTimeout( bindResize, 1000 );
				}
				else {
					bindResize();
				}
		
				oSettings._reszEvt = true;
			}
		}
		
		
		/**
		 * Throttle the calls to a function. Arguments and context are maintained for
		 * the throttled function
		 *  @param {function} fn Function to be called
		 *  @param {int} [freq=200] call frequency in mS
		 *  @returns {function} wrapped function
		 *  @memberof DataTable#oApi
		 */
		var _fnThrottle = DataTable.util.throttle;
		
		
		/**
		 * Convert a CSS unit width to pixels (e.g. 2em)
		 *  @param {string} width width to be converted
		 *  @param {node} parent parent to get the with for (required for relative widths) - optional
		 *  @returns {int} width in pixels
		 *  @memberof DataTable#oApi
		 */
		function _fnConvertToWidth ( width, parent )
		{
			if ( ! width ) {
				return 0;
			}
		
			var n = $('<div/>')
				.css( 'width', _fnStringToCss( width ) )
				.appendTo( parent || document.body );
		
			var val = n[0].offsetWidth;
			n.remove();
		
			return val;
		}
		
		
		/**
		 * Get the widest node
		 *  @param {object} settings dataTables settings object
		 *  @param {int} colIdx column of interest
		 *  @returns {node} widest table node
		 *  @memberof DataTable#oApi
		 */
		function _fnGetWidestNode( settings, colIdx )
		{
			var idx = _fnGetMaxLenString( settings, colIdx );
			if ( idx < 0 ) {
				return null;
			}
		
			var data = settings.aoData[ idx ];
			return ! data.nTr ? // Might not have been created when deferred rendering
				$('<td/>').html( _fnGetCellData( settings, idx, colIdx, 'display' ) )[0] :
				data.anCells[ colIdx ];
		}
		
		
		/**
		 * Get the maximum strlen for each data column
		 *  @param {object} settings dataTables settings object
		 *  @param {int} colIdx column of interest
		 *  @returns {string} max string length for each column
		 *  @memberof DataTable#oApi
		 */
		function _fnGetMaxLenString( settings, colIdx )
		{
			var s, max=-1, maxIdx = -1;
		
			for ( var i=0, ien=settings.aoData.length ; i<ien ; i++ ) {
				s = _fnGetCellData( settings, i, colIdx, 'display' )+'';
				s = s.replace( __re_html_remove, '' );
				s = s.replace( /&nbsp;/g, ' ' );
		
				if ( s.length > max ) {
					max = s.length;
					maxIdx = i;
				}
			}
		
			return maxIdx;
		}
		
		
		/**
		 * Append a CSS unit (only if required) to a string
		 *  @param {string} value to css-ify
		 *  @returns {string} value with css unit
		 *  @memberof DataTable#oApi
		 */
		function _fnStringToCss( s )
		{
			if ( s === null ) {
				return '0px';
			}
		
			if ( typeof s == 'number' ) {
				return s < 0 ?
					'0px' :
					s+'px';
			}
		
			// Check it has a unit character already
			return s.match(/\d$/) ?
				s+'px' :
				s;
		}
		
		
		
		function _fnSortFlatten ( settings )
		{
			var
				i, iLen, k, kLen,
				aSort = [],
				aiOrig = [],
				aoColumns = settings.aoColumns,
				aDataSort, iCol, sType, srcCol,
				fixed = settings.aaSortingFixed,
				fixedObj = $.isPlainObject( fixed ),
				nestedSort = [],
				add = function ( a ) {
					if ( a.length && ! $.isArray( a[0] ) ) {
						// 1D array
						nestedSort.push( a );
					}
					else {
						// 2D array
						$.merge( nestedSort, a );
					}
				};
		
			// Build the sort array, with pre-fix and post-fix options if they have been
			// specified
			if ( $.isArray( fixed ) ) {
				add( fixed );
			}
		
			if ( fixedObj && fixed.pre ) {
				add( fixed.pre );
			}
		
			add( settings.aaSorting );
		
			if (fixedObj && fixed.post ) {
				add( fixed.post );
			}
		
			for ( i=0 ; i<nestedSort.length ; i++ )
			{
				srcCol = nestedSort[i][0];
				aDataSort = aoColumns[ srcCol ].aDataSort;
		
				for ( k=0, kLen=aDataSort.length ; k<kLen ; k++ )
				{
					iCol = aDataSort[k];
					sType = aoColumns[ iCol ].sType || 'string';
		
					if ( nestedSort[i]._idx === undefined ) {
						nestedSort[i]._idx = $.inArray( nestedSort[i][1], aoColumns[iCol].asSorting );
					}
		
					aSort.push( {
						src:       srcCol,
						col:       iCol,
						dir:       nestedSort[i][1],
						index:     nestedSort[i]._idx,
						type:      sType,
						formatter: DataTable.ext.type.order[ sType+"-pre" ]
					} );
				}
			}
		
			return aSort;
		}
		
		/**
		 * Change the order of the table
		 *  @param {object} oSettings dataTables settings object
		 *  @memberof DataTable#oApi
		 *  @todo This really needs split up!
		 */
		function _fnSort ( oSettings )
		{
			var
				i, ien, iLen, j, jLen, k, kLen,
				sDataType, nTh,
				aiOrig = [],
				oExtSort = DataTable.ext.type.order,
				aoData = oSettings.aoData,
				aoColumns = oSettings.aoColumns,
				aDataSort, data, iCol, sType, oSort,
				formatters = 0,
				sortCol,
				displayMaster = oSettings.aiDisplayMaster,
				aSort;
		
			// Resolve any column types that are unknown due to addition or invalidation
			// @todo Can this be moved into a 'data-ready' handler which is called when
			//   data is going to be used in the table?
			_fnColumnTypes( oSettings );
		
			aSort = _fnSortFlatten( oSettings );
		
			for ( i=0, ien=aSort.length ; i<ien ; i++ ) {
				sortCol = aSort[i];
		
				// Track if we can use the fast sort algorithm
				if ( sortCol.formatter ) {
					formatters++;
				}
		
				// Load the data needed for the sort, for each cell
				_fnSortData( oSettings, sortCol.col );
			}
		
			/* No sorting required if server-side or no sorting array */
			if ( _fnDataSource( oSettings ) != 'ssp' && aSort.length !== 0 )
			{
				// Create a value - key array of the current row positions such that we can use their
				// current position during the sort, if values match, in order to perform stable sorting
				for ( i=0, iLen=displayMaster.length ; i<iLen ; i++ ) {
					aiOrig[ displayMaster[i] ] = i;
				}
		
				/* Do the sort - here we want multi-column sorting based on a given data source (column)
				 * and sorting function (from oSort) in a certain direction. It's reasonably complex to
				 * follow on it's own, but this is what we want (example two column sorting):
				 *  fnLocalSorting = function(a,b){
				 *    var iTest;
				 *    iTest = oSort['string-asc']('data11', 'data12');
				 *      if (iTest !== 0)
				 *        return iTest;
				 *    iTest = oSort['numeric-desc']('data21', 'data22');
				 *    if (iTest !== 0)
				 *      return iTest;
				 *    return oSort['numeric-asc']( aiOrig[a], aiOrig[b] );
				 *  }
				 * Basically we have a test for each sorting column, if the data in that column is equal,
				 * test the next column. If all columns match, then we use a numeric sort on the row
				 * positions in the original data array to provide a stable sort.
				 *
				 * Note - I know it seems excessive to have two sorting methods, but the first is around
				 * 15% faster, so the second is only maintained for backwards compatibility with sorting
				 * methods which do not have a pre-sort formatting function.
				 */
				if ( formatters === aSort.length ) {
					// All sort types have formatting functions
					displayMaster.sort( function ( a, b ) {
						var
							x, y, k, test, sort,
							len=aSort.length,
							dataA = aoData[a]._aSortData,
							dataB = aoData[b]._aSortData;
		
						for ( k=0 ; k<len ; k++ ) {
							sort = aSort[k];
		
							x = dataA[ sort.col ];
							y = dataB[ sort.col ];
		
							test = x<y ? -1 : x>y ? 1 : 0;
							if ( test !== 0 ) {
								return sort.dir === 'asc' ? test : -test;
							}
						}
		
						x = aiOrig[a];
						y = aiOrig[b];
						return x<y ? -1 : x>y ? 1 : 0;
					} );
				}
				else {
					// Depreciated - remove in 1.11 (providing a plug-in option)
					// Not all sort types have formatting methods, so we have to call their sorting
					// methods.
					displayMaster.sort( function ( a, b ) {
						var
							x, y, k, l, test, sort, fn,
							len=aSort.length,
							dataA = aoData[a]._aSortData,
							dataB = aoData[b]._aSortData;
		
						for ( k=0 ; k<len ; k++ ) {
							sort = aSort[k];
		
							x = dataA[ sort.col ];
							y = dataB[ sort.col ];
		
							fn = oExtSort[ sort.type+"-"+sort.dir ] || oExtSort[ "string-"+sort.dir ];
							test = fn( x, y );
							if ( test !== 0 ) {
								return test;
							}
						}
		
						x = aiOrig[a];
						y = aiOrig[b];
						return x<y ? -1 : x>y ? 1 : 0;
					} );
				}
			}
		
			/* Tell the draw function that we have sorted the data */
			oSettings.bSorted = true;
		}
		
		
		function _fnSortAria ( settings )
		{
			var label;
			var nextSort;
			var columns = settings.aoColumns;
			var aSort = _fnSortFlatten( settings );
			var oAria = settings.oLanguage.oAria;
		
			// ARIA attributes - need to loop all columns, to update all (removing old
			// attributes as needed)
			for ( var i=0, iLen=columns.length ; i<iLen ; i++ )
			{
				var col = columns[i];
				var asSorting = col.asSorting;
				var sTitle = col.sTitle.replace( /<.*?>/g, "" );
				var th = col.nTh;
		
				// IE7 is throwing an error when setting these properties with jQuery's
				// attr() and removeAttr() methods...
				th.removeAttribute('aria-sort');
		
				/* In ARIA only the first sorting column can be marked as sorting - no multi-sort option */
				if ( col.bSortable ) {
					if ( aSort.length > 0 && aSort[0].col == i ) {
						th.setAttribute('aria-sort', aSort[0].dir=="asc" ? "ascending" : "descending" );
						nextSort = asSorting[ aSort[0].index+1 ] || asSorting[0];
					}
					else {
						nextSort = asSorting[0];
					}
		
					label = sTitle + ( nextSort === "asc" ?
						oAria.sSortAscending :
						oAria.sSortDescending
					);
				}
				else {
					label = sTitle;
				}
		
				th.setAttribute('aria-label', label);
			}
		}
		
		
		/**
		 * Function to run on user sort request
		 *  @param {object} settings dataTables settings object
		 *  @param {node} attachTo node to attach the handler to
		 *  @param {int} colIdx column sorting index
		 *  @param {boolean} [append=false] Append the requested sort to the existing
		 *    sort if true (i.e. multi-column sort)
		 *  @param {function} [callback] callback function
		 *  @memberof DataTable#oApi
		 */
		function _fnSortListener ( settings, colIdx, append, callback )
		{
			var col = settings.aoColumns[ colIdx ];
			var sorting = settings.aaSorting;
			var asSorting = col.asSorting;
			var nextSortIdx;
			var next = function ( a, overflow ) {
				var idx = a._idx;
				if ( idx === undefined ) {
					idx = $.inArray( a[1], asSorting );
				}
		
				return idx+1 < asSorting.length ?
					idx+1 :
					overflow ?
						null :
						0;
			};
		
			// Convert to 2D array if needed
			if ( typeof sorting[0] === 'number' ) {
				sorting = settings.aaSorting = [ sorting ];
			}
		
			// If appending the sort then we are multi-column sorting
			if ( append && settings.oFeatures.bSortMulti ) {
				// Are we already doing some kind of sort on this column?
				var sortIdx = $.inArray( colIdx, _pluck(sorting, '0') );
		
				if ( sortIdx !== -1 ) {
					// Yes, modify the sort
					nextSortIdx = next( sorting[sortIdx], true );
		
					if ( nextSortIdx === null && sorting.length === 1 ) {
						nextSortIdx = 0; // can't remove sorting completely
					}
		
					if ( nextSortIdx === null ) {
						sorting.splice( sortIdx, 1 );
					}
					else {
						sorting[sortIdx][1] = asSorting[ nextSortIdx ];
						sorting[sortIdx]._idx = nextSortIdx;
					}
				}
				else {
					// No sort on this column yet
					sorting.push( [ colIdx, asSorting[0], 0 ] );
					sorting[sorting.length-1]._idx = 0;
				}
			}
			else if ( sorting.length && sorting[0][0] == colIdx ) {
				// Single column - already sorting on this column, modify the sort
				nextSortIdx = next( sorting[0] );
		
				sorting.length = 1;
				sorting[0][1] = asSorting[ nextSortIdx ];
				sorting[0]._idx = nextSortIdx;
			}
			else {
				// Single column - sort only on this column
				sorting.length = 0;
				sorting.push( [ colIdx, asSorting[0] ] );
				sorting[0]._idx = 0;
			}
		
			// Run the sort by calling a full redraw
			_fnReDraw( settings );
		
			// callback used for async user interaction
			if ( typeof callback == 'function' ) {
				callback( settings );
			}
		}
		
		
		/**
		 * Attach a sort handler (click) to a node
		 *  @param {object} settings dataTables settings object
		 *  @param {node} attachTo node to attach the handler to
		 *  @param {int} colIdx column sorting index
		 *  @param {function} [callback] callback function
		 *  @memberof DataTable#oApi
		 */
		function _fnSortAttachListener ( settings, attachTo, colIdx, callback )
		{
			var col = settings.aoColumns[ colIdx ];
		
			_fnBindAction( attachTo, {}, function (e) {
				/* If the column is not sortable - don't to anything */
				if ( col.bSortable === false ) {
					return;
				}
		
				// If processing is enabled use a timeout to allow the processing
				// display to be shown - otherwise to it synchronously
				if ( settings.oFeatures.bProcessing ) {
					_fnProcessingDisplay( settings, true );
		
					setTimeout( function() {
						_fnSortListener( settings, colIdx, e.shiftKey, callback );
		
						// In server-side processing, the draw callback will remove the
						// processing display
						if ( _fnDataSource( settings ) !== 'ssp' ) {
							_fnProcessingDisplay( settings, false );
						}
					}, 0 );
				}
				else {
					_fnSortListener( settings, colIdx, e.shiftKey, callback );
				}
			} );
		}
		
		
		/**
		 * Set the sorting classes on table's body, Note: it is safe to call this function
		 * when bSort and bSortClasses are false
		 *  @param {object} oSettings dataTables settings object
		 *  @memberof DataTable#oApi
		 */
		function _fnSortingClasses( settings )
		{
			var oldSort = settings.aLastSort;
			var sortClass = settings.oClasses.sSortColumn;
			var sort = _fnSortFlatten( settings );
			var features = settings.oFeatures;
			var i, ien, colIdx;
		
			if ( features.bSort && features.bSortClasses ) {
				// Remove old sorting classes
				for ( i=0, ien=oldSort.length ; i<ien ; i++ ) {
					colIdx = oldSort[i].src;
		
					// Remove column sorting
					$( _pluck( settings.aoData, 'anCells', colIdx ) )
						.removeClass( sortClass + (i<2 ? i+1 : 3) );
				}
		
				// Add new column sorting
				for ( i=0, ien=sort.length ; i<ien ; i++ ) {
					colIdx = sort[i].src;
		
					$( _pluck( settings.aoData, 'anCells', colIdx ) )
						.addClass( sortClass + (i<2 ? i+1 : 3) );
				}
			}
		
			settings.aLastSort = sort;
		}
		
		
		// Get the data to sort a column, be it from cache, fresh (populating the
		// cache), or from a sort formatter
		function _fnSortData( settings, idx )
		{
			// Custom sorting function - provided by the sort data type
			var column = settings.aoColumns[ idx ];
			var customSort = DataTable.ext.order[ column.sSortDataType ];
			var customData;
		
			if ( customSort ) {
				customData = customSort.call( settings.oInstance, settings, idx,
					_fnColumnIndexToVisible( settings, idx )
				);
			}
		
			// Use / populate cache
			var row, cellData;
			var formatter = DataTable.ext.type.order[ column.sType+"-pre" ];
		
			for ( var i=0, ien=settings.aoData.length ; i<ien ; i++ ) {
				row = settings.aoData[i];
		
				if ( ! row._aSortData ) {
					row._aSortData = [];
				}
		
				if ( ! row._aSortData[idx] || customSort ) {
					cellData = customSort ?
						customData[i] : // If there was a custom sort function, use data from there
						_fnGetCellData( settings, i, idx, 'sort' );
		
					row._aSortData[ idx ] = formatter ?
						formatter( cellData ) :
						cellData;
				}
			}
		}
		
		
		
		/**
		 * Save the state of a table
		 *  @param {object} oSettings dataTables settings object
		 *  @memberof DataTable#oApi
		 */
		function _fnSaveState ( settings )
		{
			if ( !settings.oFeatures.bStateSave || settings.bDestroying )
			{
				return;
			}
		
			/* Store the interesting variables */
			var state = {
				time:    +new Date(),
				start:   settings._iDisplayStart,
				length:  settings._iDisplayLength,
				order:   $.extend( true, [], settings.aaSorting ),
				search:  _fnSearchToCamel( settings.oPreviousSearch ),
				columns: $.map( settings.aoColumns, function ( col, i ) {
					return {
						visible: col.bVisible,
						search: _fnSearchToCamel( settings.aoPreSearchCols[i] )
					};
				} )
			};
		
			_fnCallbackFire( settings, "aoStateSaveParams", 'stateSaveParams', [settings, state] );
		
			settings.oSavedState = state;
			settings.fnStateSaveCallback.call( settings.oInstance, settings, state );
		}
		
		
		/**
		 * Attempt to load a saved table state
		 *  @param {object} oSettings dataTables settings object
		 *  @param {object} oInit DataTables init object so we can override settings
		 *  @memberof DataTable#oApi
		 */
		function _fnLoadState ( settings, oInit )
		{
			var i, ien;
			var columns = settings.aoColumns;
		
			if ( ! settings.oFeatures.bStateSave ) {
				return;
			}
		
			var state = settings.fnStateLoadCallback.call( settings.oInstance, settings );
			if ( ! state || ! state.time ) {
				return;
			}
		
			/* Allow custom and plug-in manipulation functions to alter the saved data set and
			 * cancelling of loading by returning false
			 */
			var abStateLoad = _fnCallbackFire( settings, 'aoStateLoadParams', 'stateLoadParams', [settings, state] );
			if ( $.inArray( false, abStateLoad ) !== -1 ) {
				return;
			}
		
			/* Reject old data */
			var duration = settings.iStateDuration;
			if ( duration > 0 && state.time < +new Date() - (duration*1000) ) {
				return;
			}
		
			// Number of columns have changed - all bets are off, no restore of settings
			if ( columns.length !== state.columns.length ) {
				return;
			}
		
			// Store the saved state so it might be accessed at any time
			settings.oLoadedState = $.extend( true, {}, state );
		
			// Restore key features - todo - for 1.11 this needs to be done by
			// subscribed events
			if ( state.start !== undefined ) {
				settings._iDisplayStart    = state.start;
				settings.iInitDisplayStart = state.start;
			}
			if ( state.length !== undefined ) {
				settings._iDisplayLength   = state.length;
			}
		
			// Order
			if ( state.order !== undefined ) {
				settings.aaSorting = [];
				$.each( state.order, function ( i, col ) {
					settings.aaSorting.push( col[0] >= columns.length ?
						[ 0, col[1] ] :
						col
					);
				} );
			}
		
			// Search
			if ( state.search !== undefined ) {
				$.extend( settings.oPreviousSearch, _fnSearchToHung( state.search ) );
			}
		
			// Columns
			for ( i=0, ien=state.columns.length ; i<ien ; i++ ) {
				var col = state.columns[i];
		
				// Visibility
				if ( col.visible !== undefined ) {
					columns[i].bVisible = col.visible;
				}
		
				// Search
				if ( col.search !== undefined ) {
					$.extend( settings.aoPreSearchCols[i], _fnSearchToHung( col.search ) );
				}
			}
		
			_fnCallbackFire( settings, 'aoStateLoaded', 'stateLoaded', [settings, state] );
		}
		
		
		/**
		 * Return the settings object for a particular table
		 *  @param {node} table table we are using as a dataTable
		 *  @returns {object} Settings object - or null if not found
		 *  @memberof DataTable#oApi
		 */
		function _fnSettingsFromNode ( table )
		{
			var settings = DataTable.settings;
			var idx = $.inArray( table, _pluck( settings, 'nTable' ) );
		
			return idx !== -1 ?
				settings[ idx ] :
				null;
		}
		
		
		/**
		 * Log an error message
		 *  @param {object} settings dataTables settings object
		 *  @param {int} level log error messages, or display them to the user
		 *  @param {string} msg error message
		 *  @param {int} tn Technical note id to get more information about the error.
		 *  @memberof DataTable#oApi
		 */
		function _fnLog( settings, level, msg, tn )
		{
			msg = 'DataTables warning: '+
				(settings ? 'table id='+settings.sTableId+' - ' : '')+msg;
		
			if ( tn ) {
				msg += '. For more information about this error, please see '+
				'http://datatables.net/tn/'+tn;
			}
		
			if ( ! level  ) {
				// Backwards compatibility pre 1.10
				var ext = DataTable.ext;
				var type = ext.sErrMode || ext.errMode;
		
				if ( settings ) {
					_fnCallbackFire( settings, null, 'error', [ settings, tn, msg ] );
				}
		
				if ( type == 'alert' ) {
					alert( msg );
				}
				else if ( type == 'throw' ) {
					throw new Error(msg);
				}
				else if ( typeof type == 'function' ) {
					type( settings, tn, msg );
				}
			}
			else if ( window.console && console.log ) {
				console.log( msg );
			}
		}
		
		
		/**
		 * See if a property is defined on one object, if so assign it to the other object
		 *  @param {object} ret target object
		 *  @param {object} src source object
		 *  @param {string} name property
		 *  @param {string} [mappedName] name to map too - optional, name used if not given
		 *  @memberof DataTable#oApi
		 */
		function _fnMap( ret, src, name, mappedName )
		{
			if ( $.isArray( name ) ) {
				$.each( name, function (i, val) {
					if ( $.isArray( val ) ) {
						_fnMap( ret, src, val[0], val[1] );
					}
					else {
						_fnMap( ret, src, val );
					}
				} );
		
				return;
			}
		
			if ( mappedName === undefined ) {
				mappedName = name;
			}
		
			if ( src[name] !== undefined ) {
				ret[mappedName] = src[name];
			}
		}
		
		
		/**
		 * Extend objects - very similar to jQuery.extend, but deep copy objects, and
		 * shallow copy arrays. The reason we need to do this, is that we don't want to
		 * deep copy array init values (such as aaSorting) since the dev wouldn't be
		 * able to override them, but we do want to deep copy arrays.
		 *  @param {object} out Object to extend
		 *  @param {object} extender Object from which the properties will be applied to
		 *      out
		 *  @param {boolean} breakRefs If true, then arrays will be sliced to take an
		 *      independent copy with the exception of the `data` or `aaData` parameters
		 *      if they are present. This is so you can pass in a collection to
		 *      DataTables and have that used as your data source without breaking the
		 *      references
		 *  @returns {object} out Reference, just for convenience - out === the return.
		 *  @memberof DataTable#oApi
		 *  @todo This doesn't take account of arrays inside the deep copied objects.
		 */
		function _fnExtend( out, extender, breakRefs )
		{
			var val;
		
			for ( var prop in extender ) {
				if ( extender.hasOwnProperty(prop) ) {
					val = extender[prop];
		
					if ( $.isPlainObject( val ) ) {
						if ( ! $.isPlainObject( out[prop] ) ) {
							out[prop] = {};
						}
						$.extend( true, out[prop], val );
					}
					else if ( breakRefs && prop !== 'data' && prop !== 'aaData' && $.isArray(val) ) {
						out[prop] = val.slice();
					}
					else {
						out[prop] = val;
					}
				}
			}
		
			return out;
		}
		
		
		/**
		 * Bind an event handers to allow a click or return key to activate the callback.
		 * This is good for accessibility since a return on the keyboard will have the
		 * same effect as a click, if the element has focus.
		 *  @param {element} n Element to bind the action to
		 *  @param {object} oData Data object to pass to the triggered function
		 *  @param {function} fn Callback function for when the event is triggered
		 *  @memberof DataTable#oApi
		 */
		function _fnBindAction( n, oData, fn )
		{
			$(n)
				.bind( 'click.DT', oData, function (e) {
						n.blur(); // Remove focus outline for mouse users
						fn(e);
					} )
				.bind( 'keypress.DT', oData, function (e){
						if ( e.which === 13 ) {
							e.preventDefault();
							fn(e);
						}
					} )
				.bind( 'selectstart.DT', function () {
						/* Take the brutal approach to cancelling text selection */
						return false;
					} );
		}
		
		
		/**
		 * Register a callback function. Easily allows a callback function to be added to
		 * an array store of callback functions that can then all be called together.
		 *  @param {object} oSettings dataTables settings object
		 *  @param {string} sStore Name of the array storage for the callbacks in oSettings
		 *  @param {function} fn Function to be called back
		 *  @param {string} sName Identifying name for the callback (i.e. a label)
		 *  @memberof DataTable#oApi
		 */
		function _fnCallbackReg( oSettings, sStore, fn, sName )
		{
			if ( fn )
			{
				oSettings[sStore].push( {
					"fn": fn,
					"sName": sName
				} );
			}
		}
		
		
		/**
		 * Fire callback functions and trigger events. Note that the loop over the
		 * callback array store is done backwards! Further note that you do not want to
		 * fire off triggers in time sensitive applications (for example cell creation)
		 * as its slow.
		 *  @param {object} settings dataTables settings object
		 *  @param {string} callbackArr Name of the array storage for the callbacks in
		 *      oSettings
		 *  @param {string} eventName Name of the jQuery custom event to trigger. If
		 *      null no trigger is fired
		 *  @param {array} args Array of arguments to pass to the callback function /
		 *      trigger
		 *  @memberof DataTable#oApi
		 */
		function _fnCallbackFire( settings, callbackArr, eventName, args )
		{
			var ret = [];
		
			if ( callbackArr ) {
				ret = $.map( settings[callbackArr].slice().reverse(), function (val, i) {
					return val.fn.apply( settings.oInstance, args );
				} );
			}
		
			if ( eventName !== null ) {
				var e = $.Event( eventName+'.dt' );
		
				$(settings.nTable).trigger( e, args );
		
				ret.push( e.result );
			}
		
			return ret;
		}
		
		
		function _fnLengthOverflow ( settings )
		{
			var
				start = settings._iDisplayStart,
				end = settings.fnDisplayEnd(),
				len = settings._iDisplayLength;
		
			/* If we have space to show extra rows (backing up from the end point - then do so */
			if ( start >= end )
			{
				start = end - len;
			}
		
			// Keep the start record on the current page
			start -= (start % len);
		
			if ( len === -1 || start < 0 )
			{
				start = 0;
			}
		
			settings._iDisplayStart = start;
		}
		
		
		function _fnRenderer( settings, type )
		{
			var renderer = settings.renderer;
			var host = DataTable.ext.renderer[type];
		
			if ( $.isPlainObject( renderer ) && renderer[type] ) {
				// Specific renderer for this type. If available use it, otherwise use
				// the default.
				return host[renderer[type]] || host._;
			}
			else if ( typeof renderer === 'string' ) {
				// Common renderer - if there is one available for this type use it,
				// otherwise use the default
				return host[renderer] || host._;
			}
		
			// Use the default
			return host._;
		}
		
		
		/**
		 * Detect the data source being used for the table. Used to simplify the code
		 * a little (ajax) and to make it compress a little smaller.
		 *
		 *  @param {object} settings dataTables settings object
		 *  @returns {string} Data source
		 *  @memberof DataTable#oApi
		 */
		function _fnDataSource ( settings )
		{
			if ( settings.oFeatures.bServerSide ) {
				return 'ssp';
			}
			else if ( settings.ajax || settings.sAjaxSource ) {
				return 'ajax';
			}
			return 'dom';
		}
		
	
		
		
		/**
		 * Computed structure of the DataTables API, defined by the options passed to
		 * `DataTable.Api.register()` when building the API.
		 *
		 * The structure is built in order to speed creation and extension of the Api
		 * objects since the extensions are effectively pre-parsed.
		 *
		 * The array is an array of objects with the following structure, where this
		 * base array represents the Api prototype base:
		 *
		 *     [
		 *       {
		 *         name:      'data'                -- string   - Property name
		 *         val:       function () {},       -- function - Api method (or undefined if just an object
		 *         methodExt: [ ... ],              -- array    - Array of Api object definitions to extend the method result
		 *         propExt:   [ ... ]               -- array    - Array of Api object definitions to extend the property
		 *       },
		 *       {
		 *         name:     'row'
		 *         val:       {},
		 *         methodExt: [ ... ],
		 *         propExt:   [
		 *           {
		 *             name:      'data'
		 *             val:       function () {},
		 *             methodExt: [ ... ],
		 *             propExt:   [ ... ]
		 *           },
		 *           ...
		 *         ]
		 *       }
		 *     ]
		 *
		 * @type {Array}
		 * @ignore
		 */
		var __apiStruct = [];
		
		
		/**
		 * `Array.prototype` reference.
		 *
		 * @type object
		 * @ignore
		 */
		var __arrayProto = Array.prototype;
		
		
		/**
		 * Abstraction for `context` parameter of the `Api` constructor to allow it to
		 * take several different forms for ease of use.
		 *
		 * Each of the input parameter types will be converted to a DataTables settings
		 * object where possible.
		 *
		 * @param  {string|node|jQuery|object} mixed DataTable identifier. Can be one
		 *   of:
		 *
		 *   * `string` - jQuery selector. Any DataTables' matching the given selector
		 *     with be found and used.
		 *   * `node` - `TABLE` node which has already been formed into a DataTable.
		 *   * `jQuery` - A jQuery object of `TABLE` nodes.
		 *   * `object` - DataTables settings object
		 *   * `DataTables.Api` - API instance
		 * @return {array|null} Matching DataTables settings objects. `null` or
		 *   `undefined` is returned if no matching DataTable is found.
		 * @ignore
		 */
		var _toSettings = function ( mixed )
		{
			var idx, jq;
			var settings = DataTable.settings;
			var tables = $.map( settings, function (el, i) {
				return el.nTable;
			} );
		
			if ( ! mixed ) {
				return [];
			}
			else if ( mixed.nTable && mixed.oApi ) {
				// DataTables settings object
				return [ mixed ];
			}
			else if ( mixed.nodeName && mixed.nodeName.toLowerCase() === 'table' ) {
				// Table node
				idx = $.inArray( mixed, tables );
				return idx !== -1 ? [ settings[idx] ] : null;
			}
			else if ( mixed && typeof mixed.settings === 'function' ) {
				return mixed.settings().toArray();
			}
			else if ( typeof mixed === 'string' ) {
				// jQuery selector
				jq = $(mixed);
			}
			else if ( mixed instanceof $ ) {
				// jQuery object (also DataTables instance)
				jq = mixed;
			}
		
			if ( jq ) {
				return jq.map( function(i) {
					idx = $.inArray( this, tables );
					return idx !== -1 ? settings[idx] : null;
				} ).toArray();
			}
		};
		
		
		/**
		 * DataTables API class - used to control and interface with  one or more
		 * DataTables enhanced tables.
		 *
		 * The API class is heavily based on jQuery, presenting a chainable interface
		 * that you can use to interact with tables. Each instance of the API class has
		 * a "context" - i.e. the tables that it will operate on. This could be a single
		 * table, all tables on a page or a sub-set thereof.
		 *
		 * Additionally the API is designed to allow you to easily work with the data in
		 * the tables, retrieving and manipulating it as required. This is done by
		 * presenting the API class as an array like interface. The contents of the
		 * array depend upon the actions requested by each method (for example
		 * `rows().nodes()` will return an array of nodes, while `rows().data()` will
		 * return an array of objects or arrays depending upon your table's
		 * configuration). The API object has a number of array like methods (`push`,
		 * `pop`, `reverse` etc) as well as additional helper methods (`each`, `pluck`,
		 * `unique` etc) to assist your working with the data held in a table.
		 *
		 * Most methods (those which return an Api instance) are chainable, which means
		 * the return from a method call also has all of the methods available that the
		 * top level object had. For example, these two calls are equivalent:
		 *
		 *     // Not chained
		 *     api.row.add( {...} );
		 *     api.draw();
		 *
		 *     // Chained
		 *     api.row.add( {...} ).draw();
		 *
		 * @class DataTable.Api
		 * @param {array|object|string|jQuery} context DataTable identifier. This is
		 *   used to define which DataTables enhanced tables this API will operate on.
		 *   Can be one of:
		 *
		 *   * `string` - jQuery selector. Any DataTables' matching the given selector
		 *     with be found and used.
		 *   * `node` - `TABLE` node which has already been formed into a DataTable.
		 *   * `jQuery` - A jQuery object of `TABLE` nodes.
		 *   * `object` - DataTables settings object
		 * @param {array} [data] Data to initialise the Api instance with.
		 *
		 * @example
		 *   // Direct initialisation during DataTables construction
		 *   var api = $('#example').DataTable();
		 *
		 * @example
		 *   // Initialisation using a DataTables jQuery object
		 *   var api = $('#example').dataTable().api();
		 *
		 * @example
		 *   // Initialisation as a constructor
		 *   var api = new $.fn.DataTable.Api( 'table.dataTable' );
		 */
		_Api = function ( context, data )
		{
			if ( ! (this instanceof _Api) ) {
				return new _Api( context, data );
			}
		
			var settings = [];
			var ctxSettings = function ( o ) {
				var a = _toSettings( o );
				if ( a ) {
					settings = settings.concat( a );
				}
			};
		
			if ( $.isArray( context ) ) {
				for ( var i=0, ien=context.length ; i<ien ; i++ ) {
					ctxSettings( context[i] );
				}
			}
			else {
				ctxSettings( context );
			}
		
			// Remove duplicates
			this.context = _unique( settings );
		
			// Initial data
			if ( data ) {
				$.merge( this, data );
			}
		
			// selector
			this.selector = {
				rows: null,
				cols: null,
				opts: null
			};
		
			_Api.extend( this, this, __apiStruct );
		};
		
		DataTable.Api = _Api;
		
		// Don't destroy the existing prototype, just extend it. Required for jQuery 2's
		// isPlainObject.
		$.extend( _Api.prototype, {
			any: function ()
			{
				return this.count() !== 0;
			},
		
		
			concat:  __arrayProto.concat,
		
		
			context: [], // array of table settings objects
		
		
			count: function ()
			{
				return this.flatten().length;
			},
		
		
			each: function ( fn )
			{
				for ( var i=0, ien=this.length ; i<ien; i++ ) {
					fn.call( this, this[i], i, this );
				}
		
				return this;
			},
		
		
			eq: function ( idx )
			{
				var ctx = this.context;
		
				return ctx.length > idx ?
					new _Api( ctx[idx], this[idx] ) :
					null;
			},
		
		
			filter: function ( fn )
			{
				var a = [];
		
				if ( __arrayProto.filter ) {
					a = __arrayProto.filter.call( this, fn, this );
				}
				else {
					// Compatibility for browsers without EMCA-252-5 (JS 1.6)
					for ( var i=0, ien=this.length ; i<ien ; i++ ) {
						if ( fn.call( this, this[i], i, this ) ) {
							a.push( this[i] );
						}
					}
				}
		
				return new _Api( this.context, a );
			},
		
		
			flatten: function ()
			{
				var a = [];
				return new _Api( this.context, a.concat.apply( a, this.toArray() ) );
			},
		
		
			join:    __arrayProto.join,
		
		
			indexOf: __arrayProto.indexOf || function (obj, start)
			{
				for ( var i=(start || 0), ien=this.length ; i<ien ; i++ ) {
					if ( this[i] === obj ) {
						return i;
					}
				}
				return -1;
			},
		
			iterator: function ( flatten, type, fn, alwaysNew ) {
				var
					a = [], ret,
					i, ien, j, jen,
					context = this.context,
					rows, items, item,
					selector = this.selector;
		
				// Argument shifting
				if ( typeof flatten === 'string' ) {
					alwaysNew = fn;
					fn = type;
					type = flatten;
					flatten = false;
				}
		
				for ( i=0, ien=context.length ; i<ien ; i++ ) {
					var apiInst = new _Api( context[i] );
		
					if ( type === 'table' ) {
						ret = fn.call( apiInst, context[i], i );
		
						if ( ret !== undefined ) {
							a.push( ret );
						}
					}
					else if ( type === 'columns' || type === 'rows' ) {
						// this has same length as context - one entry for each table
						ret = fn.call( apiInst, context[i], this[i], i );
		
						if ( ret !== undefined ) {
							a.push( ret );
						}
					}
					else if ( type === 'column' || type === 'column-rows' || type === 'row' || type === 'cell' ) {
						// columns and rows share the same structure.
						// 'this' is an array of column indexes for each context
						items = this[i];
		
						if ( type === 'column-rows' ) {
							rows = _selector_row_indexes( context[i], selector.opts );
						}
		
						for ( j=0, jen=items.length ; j<jen ; j++ ) {
							item = items[j];
		
							if ( type === 'cell' ) {
								ret = fn.call( apiInst, context[i], item.row, item.column, i, j );
							}
							else {
								ret = fn.call( apiInst, context[i], item, i, j, rows );
							}
		
							if ( ret !== undefined ) {
								a.push( ret );
							}
						}
					}
				}
		
				if ( a.length || alwaysNew ) {
					var api = new _Api( context, flatten ? a.concat.apply( [], a ) : a );
					var apiSelector = api.selector;
					apiSelector.rows = selector.rows;
					apiSelector.cols = selector.cols;
					apiSelector.opts = selector.opts;
					return api;
				}
				return this;
			},
		
		
			lastIndexOf: __arrayProto.lastIndexOf || function (obj, start)
			{
				// Bit cheeky...
				return this.indexOf.apply( this.toArray.reverse(), arguments );
			},
		
		
			length:  0,
		
		
			map: function ( fn )
			{
				var a = [];
		
				if ( __arrayProto.map ) {
					a = __arrayProto.map.call( this, fn, this );
				}
				else {
					// Compatibility for browsers without EMCA-252-5 (JS 1.6)
					for ( var i=0, ien=this.length ; i<ien ; i++ ) {
						a.push( fn.call( this, this[i], i ) );
					}
				}
		
				return new _Api( this.context, a );
			},
		
		
			pluck: function ( prop )
			{
				return this.map( function ( el ) {
					return el[ prop ];
				} );
			},
		
			pop:     __arrayProto.pop,
		
		
			push:    __arrayProto.push,
		
		
			// Does not return an API instance
			reduce: __arrayProto.reduce || function ( fn, init )
			{
				return _fnReduce( this, fn, init, 0, this.length, 1 );
			},
		
		
			reduceRight: __arrayProto.reduceRight || function ( fn, init )
			{
				return _fnReduce( this, fn, init, this.length-1, -1, -1 );
			},
		
		
			reverse: __arrayProto.reverse,
		
		
			// Object with rows, columns and opts
			selector: null,
		
		
			shift:   __arrayProto.shift,
		
		
			sort:    __arrayProto.sort, // ? name - order?
		
		
			splice:  __arrayProto.splice,
		
		
			toArray: function ()
			{
				return __arrayProto.slice.call( this );
			},
		
		
			to$: function ()
			{
				return $( this );
			},
		
		
			toJQuery: function ()
			{
				return $( this );
			},
		
		
			unique: function ()
			{
				return new _Api( this.context, _unique(this) );
			},
		
		
			unshift: __arrayProto.unshift
		} );
		
		
		_Api.extend = function ( scope, obj, ext )
		{
			// Only extend API instances and static properties of the API
			if ( ! ext.length || ! obj || ( ! (obj instanceof _Api) && ! obj.__dt_wrapper ) ) {
				return;
			}
		
			var
				i, ien,
				j, jen,
				struct, inner,
				methodScoping = function ( scope, fn, struc ) {
					return function () {
						var ret = fn.apply( scope, arguments );
		
						// Method extension
						_Api.extend( ret, ret, struc.methodExt );
						return ret;
					};
				};
		
			for ( i=0, ien=ext.length ; i<ien ; i++ ) {
				struct = ext[i];
		
				// Value
				obj[ struct.name ] = typeof struct.val === 'function' ?
					methodScoping( scope, struct.val, struct ) :
					$.isPlainObject( struct.val ) ?
						{} :
						struct.val;
		
				obj[ struct.name ].__dt_wrapper = true;
		
				// Property extension
				_Api.extend( scope, obj[ struct.name ], struct.propExt );
			}
		};
		
		
		// @todo - Is there need for an augment function?
		// _Api.augment = function ( inst, name )
		// {
		// 	// Find src object in the structure from the name
		// 	var parts = name.split('.');
		
		// 	_Api.extend( inst, obj );
		// };
		
		
		//     [
		//       {
		//         name:      'data'                -- string   - Property name
		//         val:       function () {},       -- function - Api method (or undefined if just an object
		//         methodExt: [ ... ],              -- array    - Array of Api object definitions to extend the method result
		//         propExt:   [ ... ]               -- array    - Array of Api object definitions to extend the property
		//       },
		//       {
		//         name:     'row'
		//         val:       {},
		//         methodExt: [ ... ],
		//         propExt:   [
		//           {
		//             name:      'data'
		//             val:       function () {},
		//             methodExt: [ ... ],
		//             propExt:   [ ... ]
		//           },
		//           ...
		//         ]
		//       }
		//     ]
		
		_Api.register = _api_register = function ( name, val )
		{
			if ( $.isArray( name ) ) {
				for ( var j=0, jen=name.length ; j<jen ; j++ ) {
					_Api.register( name[j], val );
				}
				return;
			}
		
			var
				i, ien,
				heir = name.split('.'),
				struct = __apiStruct,
				key, method;
		
			var find = function ( src, name ) {
				for ( var i=0, ien=src.length ; i<ien ; i++ ) {
					if ( src[i].name === name ) {
						return src[i];
					}
				}
				return null;
			};
		
			for ( i=0, ien=heir.length ; i<ien ; i++ ) {
				method = heir[i].indexOf('()') !== -1;
				key = method ?
					heir[i].replace('()', '') :
					heir[i];
		
				var src = find( struct, key );
				if ( ! src ) {
					src = {
						name:      key,
						val:       {},
						methodExt: [],
						propExt:   []
					};
					struct.push( src );
				}
		
				if ( i === ien-1 ) {
					src.val = val;
				}
				else {
					struct = method ?
						src.methodExt :
						src.propExt;
				}
			}
		};
		
		
		_Api.registerPlural = _api_registerPlural = function ( pluralName, singularName, val ) {
			_Api.register( pluralName, val );
		
			_Api.register( singularName, function () {
				var ret = val.apply( this, arguments );
		
				if ( ret === this ) {
					// Returned item is the API instance that was passed in, return it
					return this;
				}
				else if ( ret instanceof _Api ) {
					// New API instance returned, want the value from the first item
					// in the returned array for the singular result.
					return ret.length ?
						$.isArray( ret[0] ) ?
							new _Api( ret.context, ret[0] ) : // Array results are 'enhanced'
							ret[0] :
						undefined;
				}
		
				// Non-API return - just fire it back
				return ret;
			} );
		};
		
		
		/**
		 * Selector for HTML tables. Apply the given selector to the give array of
		 * DataTables settings objects.
		 *
		 * @param {string|integer} [selector] jQuery selector string or integer
		 * @param  {array} Array of DataTables settings objects to be filtered
		 * @return {array}
		 * @ignore
		 */
		var __table_selector = function ( selector, a )
		{
			// Integer is used to pick out a table by index
			if ( typeof selector === 'number' ) {
				return [ a[ selector ] ];
			}
		
			// Perform a jQuery selector on the table nodes
			var nodes = $.map( a, function (el, i) {
				return el.nTable;
			} );
		
			return $(nodes)
				.filter( selector )
				.map( function (i) {
					// Need to translate back from the table node to the settings
					var idx = $.inArray( this, nodes );
					return a[ idx ];
				} )
				.toArray();
		};
		
		
		
		/**
		 * Context selector for the API's context (i.e. the tables the API instance
		 * refers to.
		 *
		 * @name    DataTable.Api#tables
		 * @param {string|integer} [selector] Selector to pick which tables the iterator
		 *   should operate on. If not given, all tables in the current context are
		 *   used. This can be given as a jQuery selector (for example `':gt(0)'`) to
		 *   select multiple tables or as an integer to select a single table.
		 * @returns {DataTable.Api} Returns a new API instance if a selector is given.
		 */
		_api_register( 'tables()', function ( selector ) {
			// A new instance is created if there was a selector specified
			return selector ?
				new _Api( __table_selector( selector, this.context ) ) :
				this;
		} );
		
		
		_api_register( 'table()', function ( selector ) {
			var tables = this.tables( selector );
			var ctx = tables.context;
		
			// Truncate to the first matched table
			return ctx.length ?
				new _Api( ctx[0] ) :
				tables;
		} );
		
		
		_api_registerPlural( 'tables().nodes()', 'table().node()' , function () {
			return this.iterator( 'table', function ( ctx ) {
				return ctx.nTable;
			}, 1 );
		} );
		
		
		_api_registerPlural( 'tables().body()', 'table().body()' , function () {
			return this.iterator( 'table', function ( ctx ) {
				return ctx.nTBody;
			}, 1 );
		} );
		
		
		_api_registerPlural( 'tables().header()', 'table().header()' , function () {
			return this.iterator( 'table', function ( ctx ) {
				return ctx.nTHead;
			}, 1 );
		} );
		
		
		_api_registerPlural( 'tables().footer()', 'table().footer()' , function () {
			return this.iterator( 'table', function ( ctx ) {
				return ctx.nTFoot;
			}, 1 );
		} );
		
		
		_api_registerPlural( 'tables().containers()', 'table().container()' , function () {
			return this.iterator( 'table', function ( ctx ) {
				return ctx.nTableWrapper;
			}, 1 );
		} );
		
		
		
		/**
		 * Redraw the tables in the current context.
		 */
		_api_register( 'draw()', function ( paging ) {
			return this.iterator( 'table', function ( settings ) {
				if ( paging === 'page' ) {
					_fnDraw( settings );
				}
				else {
					if ( typeof paging === 'string' ) {
						paging = paging === 'full-hold' ?
							false :
							true;
					}
		
					_fnReDraw( settings, paging===false );
				}
			} );
		} );
		
		
		
		/**
		 * Get the current page index.
		 *
		 * @return {integer} Current page index (zero based)
		 *//**
		 * Set the current page.
		 *
		 * Note that if you attempt to show a page which does not exist, DataTables will
		 * not throw an error, but rather reset the paging.
		 *
		 * @param {integer|string} action The paging action to take. This can be one of:
		 *  * `integer` - The page index to jump to
		 *  * `string` - An action to take:
		 *    * `first` - Jump to first page.
		 *    * `next` - Jump to the next page
		 *    * `previous` - Jump to previous page
		 *    * `last` - Jump to the last page.
		 * @returns {DataTables.Api} this
		 */
		_api_register( 'page()', function ( action ) {
			if ( action === undefined ) {
				return this.page.info().page; // not an expensive call
			}
		
			// else, have an action to take on all tables
			return this.iterator( 'table', function ( settings ) {
				_fnPageChange( settings, action );
			} );
		} );
		
		
		/**
		 * Paging information for the first table in the current context.
		 *
		 * If you require paging information for another table, use the `table()` method
		 * with a suitable selector.
		 *
		 * @return {object} Object with the following properties set:
		 *  * `page` - Current page index (zero based - i.e. the first page is `0`)
		 *  * `pages` - Total number of pages
		 *  * `start` - Display index for the first record shown on the current page
		 *  * `end` - Display index for the last record shown on the current page
		 *  * `length` - Display length (number of records). Note that generally `start
		 *    + length = end`, but this is not always true, for example if there are
		 *    only 2 records to show on the final page, with a length of 10.
		 *  * `recordsTotal` - Full data set length
		 *  * `recordsDisplay` - Data set length once the current filtering criterion
		 *    are applied.
		 */
		_api_register( 'page.info()', function ( action ) {
			if ( this.context.length === 0 ) {
				return undefined;
			}
		
			var
				settings   = this.context[0],
				start      = settings._iDisplayStart,
				len        = settings.oFeatures.bPaginate ? settings._iDisplayLength : -1,
				visRecords = settings.fnRecordsDisplay(),
				all        = len === -1;
		
			return {
				"page":           all ? 0 : Math.floor( start / len ),
				"pages":          all ? 1 : Math.ceil( visRecords / len ),
				"start":          start,
				"end":            settings.fnDisplayEnd(),
				"length":         len,
				"recordsTotal":   settings.fnRecordsTotal(),
				"recordsDisplay": visRecords,
				"serverSide":     _fnDataSource( settings ) === 'ssp'
			};
		} );
		
		
		/**
		 * Get the current page length.
		 *
		 * @return {integer} Current page length. Note `-1` indicates that all records
		 *   are to be shown.
		 *//**
		 * Set the current page length.
		 *
		 * @param {integer} Page length to set. Use `-1` to show all records.
		 * @returns {DataTables.Api} this
		 */
		_api_register( 'page.len()', function ( len ) {
			// Note that we can't call this function 'length()' because `length`
			// is a Javascript property of functions which defines how many arguments
			// the function expects.
			if ( len === undefined ) {
				return this.context.length !== 0 ?
					this.context[0]._iDisplayLength :
					undefined;
			}
		
			// else, set the page length
			return this.iterator( 'table', function ( settings ) {
				_fnLengthChange( settings, len );
			} );
		} );
		
		
		
		var __reload = function ( settings, holdPosition, callback ) {
			// Use the draw event to trigger a callback
			if ( callback ) {
				var api = new _Api( settings );
		
				api.one( 'draw', function () {
					callback( api.ajax.json() );
				} );
			}
		
			if ( _fnDataSource( settings ) == 'ssp' ) {
				_fnReDraw( settings, holdPosition );
			}
			else {
				_fnProcessingDisplay( settings, true );
		
				// Cancel an existing request
				var xhr = settings.jqXHR;
				if ( xhr && xhr.readyState !== 4 ) {
					xhr.abort();
				}
		
				// Trigger xhr
				_fnBuildAjax( settings, [], function( json ) {
					_fnClearTable( settings );
		
					var data = _fnAjaxDataSrc( settings, json );
					for ( var i=0, ien=data.length ; i<ien ; i++ ) {
						_fnAddData( settings, data[i] );
					}
		
					_fnReDraw( settings, holdPosition );
					_fnProcessingDisplay( settings, false );
				} );
			}
		};
		
		
		/**
		 * Get the JSON response from the last Ajax request that DataTables made to the
		 * server. Note that this returns the JSON from the first table in the current
		 * context.
		 *
		 * @return {object} JSON received from the server.
		 */
		_api_register( 'ajax.json()', function () {
			var ctx = this.context;
		
			if ( ctx.length > 0 ) {
				return ctx[0].json;
			}
		
			// else return undefined;
		} );
		
		
		/**
		 * Get the data submitted in the last Ajax request
		 */
		_api_register( 'ajax.params()', function () {
			var ctx = this.context;
		
			if ( ctx.length > 0 ) {
				return ctx[0].oAjaxData;
			}
		
			// else return undefined;
		} );
		
		
		/**
		 * Reload tables from the Ajax data source. Note that this function will
		 * automatically re-draw the table when the remote data has been loaded.
		 *
		 * @param {boolean} [reset=true] Reset (default) or hold the current paging
		 *   position. A full re-sort and re-filter is performed when this method is
		 *   called, which is why the pagination reset is the default action.
		 * @returns {DataTables.Api} this
		 */
		_api_register( 'ajax.reload()', function ( callback, resetPaging ) {
			return this.iterator( 'table', function (settings) {
				__reload( settings, resetPaging===false, callback );
			} );
		} );
		
		
		/**
		 * Get the current Ajax URL. Note that this returns the URL from the first
		 * table in the current context.
		 *
		 * @return {string} Current Ajax source URL
		 *//**
		 * Set the Ajax URL. Note that this will set the URL for all tables in the
		 * current context.
		 *
		 * @param {string} url URL to set.
		 * @returns {DataTables.Api} this
		 */
		_api_register( 'ajax.url()', function ( url ) {
			var ctx = this.context;
		
			if ( url === undefined ) {
				// get
				if ( ctx.length === 0 ) {
					return undefined;
				}
				ctx = ctx[0];
		
				return ctx.ajax ?
					$.isPlainObject( ctx.ajax ) ?
						ctx.ajax.url :
						ctx.ajax :
					ctx.sAjaxSource;
			}
		
			// set
			return this.iterator( 'table', function ( settings ) {
				if ( $.isPlainObject( settings.ajax ) ) {
					settings.ajax.url = url;
				}
				else {
					settings.ajax = url;
				}
				// No need to consider sAjaxSource here since DataTables gives priority
				// to `ajax` over `sAjaxSource`. So setting `ajax` here, renders any
				// value of `sAjaxSource` redundant.
			} );
		} );
		
		
		/**
		 * Load data from the newly set Ajax URL. Note that this method is only
		 * available when `ajax.url()` is used to set a URL. Additionally, this method
		 * has the same effect as calling `ajax.reload()` but is provided for
		 * convenience when setting a new URL. Like `ajax.reload()` it will
		 * automatically redraw the table once the remote data has been loaded.
		 *
		 * @returns {DataTables.Api} this
		 */
		_api_register( 'ajax.url().load()', function ( callback, resetPaging ) {
			// Same as a reload, but makes sense to present it for easy access after a
			// url change
			return this.iterator( 'table', function ( ctx ) {
				__reload( ctx, resetPaging===false, callback );
			} );
		} );
		
		
		
		
		var _selector_run = function ( type, selector, selectFn, settings, opts )
		{
			var
				out = [], res,
				a, i, ien, j, jen,
				selectorType = typeof selector;
		
			// Can't just check for isArray here, as an API or jQuery instance might be
			// given with their array like look
			if ( ! selector || selectorType === 'string' || selectorType === 'function' || selector.length === undefined ) {
				selector = [ selector ];
			}
		
			for ( i=0, ien=selector.length ; i<ien ; i++ ) {
				a = selector[i] && selector[i].split ?
					selector[i].split(',') :
					[ selector[i] ];
		
				for ( j=0, jen=a.length ; j<jen ; j++ ) {
					res = selectFn( typeof a[j] === 'string' ? $.trim(a[j]) : a[j] );
		
					if ( res && res.length ) {
						out = out.concat( res );
					}
				}
			}
		
			// selector extensions
			var ext = _ext.selector[ type ];
			if ( ext.length ) {
				for ( i=0, ien=ext.length ; i<ien ; i++ ) {
					out = ext[i]( settings, opts, out );
				}
			}
		
			return _unique( out );
		};
		
		
		var _selector_opts = function ( opts )
		{
			if ( ! opts ) {
				opts = {};
			}
		
			// Backwards compatibility for 1.9- which used the terminology filter rather
			// than search
			if ( opts.filter && opts.search === undefined ) {
				opts.search = opts.filter;
			}
		
			return $.extend( {
				search: 'none',
				order: 'current',
				page: 'all'
			}, opts );
		};
		
		
		var _selector_first = function ( inst )
		{
			// Reduce the API instance to the first item found
			for ( var i=0, ien=inst.length ; i<ien ; i++ ) {
				if ( inst[i].length > 0 ) {
					// Assign the first element to the first item in the instance
					// and truncate the instance and context
					inst[0] = inst[i];
					inst[0].length = 1;
					inst.length = 1;
					inst.context = [ inst.context[i] ];
		
					return inst;
				}
			}
		
			// Not found - return an empty instance
			inst.length = 0;
			return inst;
		};
		
		
		var _selector_row_indexes = function ( settings, opts )
		{
			var
				i, ien, tmp, a=[],
				displayFiltered = settings.aiDisplay,
				displayMaster = settings.aiDisplayMaster;
		
			var
				search = opts.search,  // none, applied, removed
				order  = opts.order,   // applied, current, index (original - compatibility with 1.9)
				page   = opts.page;    // all, current
		
			if ( _fnDataSource( settings ) == 'ssp' ) {
				// In server-side processing mode, most options are irrelevant since
				// rows not shown don't exist and the index order is the applied order
				// Removed is a special case - for consistency just return an empty
				// array
				return search === 'removed' ?
					[] :
					_range( 0, displayMaster.length );
			}
			else if ( page == 'current' ) {
				// Current page implies that order=current and fitler=applied, since it is
				// fairly senseless otherwise, regardless of what order and search actually
				// are
				for ( i=settings._iDisplayStart, ien=settings.fnDisplayEnd() ; i<ien ; i++ ) {
					a.push( displayFiltered[i] );
				}
			}
			else if ( order == 'current' || order == 'applied' ) {
				a = search == 'none' ?
					displayMaster.slice() :                      // no search
					search == 'applied' ?
						displayFiltered.slice() :                // applied search
						$.map( displayMaster, function (el, i) { // removed search
							return $.inArray( el, displayFiltered ) === -1 ? el : null;
						} );
			}
			else if ( order == 'index' || order == 'original' ) {
				for ( i=0, ien=settings.aoData.length ; i<ien ; i++ ) {
					if ( search == 'none' ) {
						a.push( i );
					}
					else { // applied | removed
						tmp = $.inArray( i, displayFiltered );
		
						if ((tmp === -1 && search == 'removed') ||
							(tmp >= 0   && search == 'applied') )
						{
							a.push( i );
						}
					}
				}
			}
		
			return a;
		};
		
		
		/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
		 * Rows
		 *
		 * {}          - no selector - use all available rows
		 * {integer}   - row aoData index
		 * {node}      - TR node
		 * {string}    - jQuery selector to apply to the TR elements
		 * {array}     - jQuery array of nodes, or simply an array of TR nodes
		 *
		 */
		
		
		var __row_selector = function ( settings, selector, opts )
		{
			var run = function ( sel ) {
				var selInt = _intVal( sel );
				var i, ien;
		
				// Short cut - selector is a number and no options provided (default is
				// all records, so no need to check if the index is in there, since it
				// must be - dev error if the index doesn't exist).
				if ( selInt !== null && ! opts ) {
					return [ selInt ];
				}
		
				var rows = _selector_row_indexes( settings, opts );
		
				if ( selInt !== null && $.inArray( selInt, rows ) !== -1 ) {
					// Selector - integer
					return [ selInt ];
				}
				else if ( ! sel ) {
					// Selector - none
					return rows;
				}
		
				// Selector - function
				if ( typeof sel === 'function' ) {
					return $.map( rows, function (idx) {
						var row = settings.aoData[ idx ];
						return sel( idx, row._aData, row.nTr ) ? idx : null;
					} );
				}
		
				// Get nodes in the order from the `rows` array with null values removed
				var nodes = _removeEmpty(
					_pluck_order( settings.aoData, rows, 'nTr' )
				);
		
				// Selector - node
				if ( sel.nodeName ) {
					if ( sel._DT_RowIndex !== undefined ) {
						return [ sel._DT_RowIndex ]; // Property added by DT for fast lookup
					}
					else if ( sel._DT_CellIndex ) {
						return [ sel._DT_CellIndex.row ];
					}
					else {
						var host = $(sel).closest('*[data-dt-row]');
						return host.length ?
							[ host.data('dt-row') ] :
							[];
					}
				}
		
				// ID selector. Want to always be able to select rows by id, regardless
				// of if the tr element has been created or not, so can't rely upon
				// jQuery here - hence a custom implementation. This does not match
				// Sizzle's fast selector or HTML4 - in HTML5 the ID can be anything,
				// but to select it using a CSS selector engine (like Sizzle or
				// querySelect) it would need to need to be escaped for some characters.
				// DataTables simplifies this for row selectors since you can select
				// only a row. A # indicates an id any anything that follows is the id -
				// unescaped.
				if ( typeof sel === 'string' && sel.charAt(0) === '#' ) {
					// get row index from id
					var rowObj = settings.aIds[ sel.replace( /^#/, '' ) ];
					if ( rowObj !== undefined ) {
						return [ rowObj.idx ];
					}
		
					// need to fall through to jQuery in case there is DOM id that
					// matches
				}
		
				// Selector - jQuery selector string, array of nodes or jQuery object/
				// As jQuery's .filter() allows jQuery objects to be passed in filter,
				// it also allows arrays, so this will cope with all three options
				return $(nodes)
					.filter( sel )
					.map( function () {
						return this._DT_RowIndex;
					} )
					.toArray();
			};
		
			return _selector_run( 'row', selector, run, settings, opts );
		};
		
		
		_api_register( 'rows()', function ( selector, opts ) {
			// argument shifting
			if ( selector === undefined ) {
				selector = '';
			}
			else if ( $.isPlainObject( selector ) ) {
				opts = selector;
				selector = '';
			}
		
			opts = _selector_opts( opts );
		
			var inst = this.iterator( 'table', function ( settings ) {
				return __row_selector( settings, selector, opts );
			}, 1 );
		
			// Want argument shifting here and in __row_selector?
			inst.selector.rows = selector;
			inst.selector.opts = opts;
		
			return inst;
		} );
		
		_api_register( 'rows().nodes()', function () {
			return this.iterator( 'row', function ( settings, row ) {
				return settings.aoData[ row ].nTr || undefined;
			}, 1 );
		} );
		
		_api_register( 'rows().data()', function () {
			return this.iterator( true, 'rows', function ( settings, rows ) {
				return _pluck_order( settings.aoData, rows, '_aData' );
			}, 1 );
		} );
		
		_api_registerPlural( 'rows().cache()', 'row().cache()', function ( type ) {
			return this.iterator( 'row', function ( settings, row ) {
				var r = settings.aoData[ row ];
				return type === 'search' ? r._aFilterData : r._aSortData;
			}, 1 );
		} );
		
		_api_registerPlural( 'rows().invalidate()', 'row().invalidate()', function ( src ) {
			return this.iterator( 'row', function ( settings, row ) {
				_fnInvalidate( settings, row, src );
			} );
		} );
		
		_api_registerPlural( 'rows().indexes()', 'row().index()', function () {
			return this.iterator( 'row', function ( settings, row ) {
				return row;
			}, 1 );
		} );
		
		_api_registerPlural( 'rows().ids()', 'row().id()', function ( hash ) {
			var a = [];
			var context = this.context;
		
			// `iterator` will drop undefined values, but in this case we want them
			for ( var i=0, ien=context.length ; i<ien ; i++ ) {
				for ( var j=0, jen=this[i].length ; j<jen ; j++ ) {
					var id = context[i].rowIdFn( context[i].aoData[ this[i][j] ]._aData );
					a.push( (hash === true ? '#' : '' )+ id );
				}
			}
		
			return new _Api( context, a );
		} );
		
		_api_registerPlural( 'rows().remove()', 'row().remove()', function () {
			var that = this;
		
			this.iterator( 'row', function ( settings, row, thatIdx ) {
				var data = settings.aoData;
				var rowData = data[ row ];
				var i, ien, j, jen;
				var loopRow, loopCells;
		
				data.splice( row, 1 );
		
				// Update the cached indexes
				for ( i=0, ien=data.length ; i<ien ; i++ ) {
					loopRow = data[i];
					loopCells = loopRow.anCells;
		
					// Rows
					if ( loopRow.nTr !== null ) {
						loopRow.nTr._DT_RowIndex = i;
					}
		
					// Cells
					if ( loopCells !== null ) {
						for ( j=0, jen=loopCells.length ; j<jen ; j++ ) {
							loopCells[j]._DT_CellIndex.row = i;
						}
					}
				}
		
				// Delete from the display arrays
				_fnDeleteIndex( settings.aiDisplayMaster, row );
				_fnDeleteIndex( settings.aiDisplay, row );
				_fnDeleteIndex( that[ thatIdx ], row, false ); // maintain local indexes
		
				// Check for an 'overflow' they case for displaying the table
				_fnLengthOverflow( settings );
		
				// Remove the row's ID reference if there is one
				var id = settings.rowIdFn( rowData._aData );
				if ( id !== undefined ) {
					delete settings.aIds[ id ];
				}
			} );
		
			this.iterator( 'table', function ( settings ) {
				for ( var i=0, ien=settings.aoData.length ; i<ien ; i++ ) {
					settings.aoData[i].idx = i;
				}
			} );
		
			return this;
		} );
		
		
		_api_register( 'rows.add()', function ( rows ) {
			var newRows = this.iterator( 'table', function ( settings ) {
					var row, i, ien;
					var out = [];
		
					for ( i=0, ien=rows.length ; i<ien ; i++ ) {
						row = rows[i];
		
						if ( row.nodeName && row.nodeName.toUpperCase() === 'TR' ) {
							out.push( _fnAddTr( settings, row )[0] );
						}
						else {
							out.push( _fnAddData( settings, row ) );
						}
					}
		
					return out;
				}, 1 );
		
			// Return an Api.rows() extended instance, so rows().nodes() etc can be used
			var modRows = this.rows( -1 );
			modRows.pop();
			$.merge( modRows, newRows );
		
			return modRows;
		} );
		
		
		
		
		
		/**
		 *
		 */
		_api_register( 'row()', function ( selector, opts ) {
			return _selector_first( this.rows( selector, opts ) );
		} );
		
		
		_api_register( 'row().data()', function ( data ) {
			var ctx = this.context;
		
			if ( data === undefined ) {
				// Get
				return ctx.length && this.length ?
					ctx[0].aoData[ this[0] ]._aData :
					undefined;
			}
		
			// Set
			ctx[0].aoData[ this[0] ]._aData = data;
		
			// Automatically invalidate
			_fnInvalidate( ctx[0], this[0], 'data' );
		
			return this;
		} );
		
		
		_api_register( 'row().node()', function () {
			var ctx = this.context;
		
			return ctx.length && this.length ?
				ctx[0].aoData[ this[0] ].nTr || null :
				null;
		} );
		
		
		_api_register( 'row.add()', function ( row ) {
			// Allow a jQuery object to be passed in - only a single row is added from
			// it though - the first element in the set
			if ( row instanceof $ && row.length ) {
				row = row[0];
			}
		
			var rows = this.iterator( 'table', function ( settings ) {
				if ( row.nodeName && row.nodeName.toUpperCase() === 'TR' ) {
					return _fnAddTr( settings, row )[0];
				}
				return _fnAddData( settings, row );
			} );
		
			// Return an Api.rows() extended instance, with the newly added row selected
			return this.row( rows[0] );
		} );
		
		
		
		var __details_add = function ( ctx, row, data, klass )
		{
			// Convert to array of TR elements
			var rows = [];
			var addRow = function ( r, k ) {
				// Recursion to allow for arrays of jQuery objects
				if ( $.isArray( r ) || r instanceof $ ) {
					for ( var i=0, ien=r.length ; i<ien ; i++ ) {
						addRow( r[i], k );
					}
					return;
				}
		
				// If we get a TR element, then just add it directly - up to the dev
				// to add the correct number of columns etc
				if ( r.nodeName && r.nodeName.toLowerCase() === 'tr' ) {
					rows.push( r );
				}
				else {
					// Otherwise create a row with a wrapper
					var created = $('<tr><td/></tr>').addClass( k );
					$('td', created)
						.addClass( k )
						.html( r )
						[0].colSpan = _fnVisbleColumns( ctx );
		
					rows.push( created[0] );
				}
			};
		
			addRow( data, klass );
		
			if ( row._details ) {
				row._details.remove();
			}
		
			row._details = $(rows);
		
			// If the children were already shown, that state should be retained
			if ( row._detailsShow ) {
				row._details.insertAfter( row.nTr );
			}
		};
		
		
		var __details_remove = function ( api, idx )
		{
			var ctx = api.context;
		
			if ( ctx.length ) {
				var row = ctx[0].aoData[ idx !== undefined ? idx : api[0] ];
		
				if ( row && row._details ) {
					row._details.remove();
		
					row._detailsShow = undefined;
					row._details = undefined;
				}
			}
		};
		
		
		var __details_display = function ( api, show ) {
			var ctx = api.context;
		
			if ( ctx.length && api.length ) {
				var row = ctx[0].aoData[ api[0] ];
		
				if ( row._details ) {
					row._detailsShow = show;
		
					if ( show ) {
						row._details.insertAfter( row.nTr );
					}
					else {
						row._details.detach();
					}
		
					__details_events( ctx[0] );
				}
			}
		};
		
		
		var __details_events = function ( settings )
		{
			var api = new _Api( settings );
			var namespace = '.dt.DT_details';
			var drawEvent = 'draw'+namespace;
			var colvisEvent = 'column-visibility'+namespace;
			var destroyEvent = 'destroy'+namespace;
			var data = settings.aoData;
		
			api.off( drawEvent +' '+ colvisEvent +' '+ destroyEvent );
		
			if ( _pluck( data, '_details' ).length > 0 ) {
				// On each draw, insert the required elements into the document
				api.on( drawEvent, function ( e, ctx ) {
					if ( settings !== ctx ) {
						return;
					}
		
					api.rows( {page:'current'} ).eq(0).each( function (idx) {
						// Internal data grab
						var row = data[ idx ];
		
						if ( row._detailsShow ) {
							row._details.insertAfter( row.nTr );
						}
					} );
				} );
		
				// Column visibility change - update the colspan
				api.on( colvisEvent, function ( e, ctx, idx, vis ) {
					if ( settings !== ctx ) {
						return;
					}
		
					// Update the colspan for the details rows (note, only if it already has
					// a colspan)
					var row, visible = _fnVisbleColumns( ctx );
		
					for ( var i=0, ien=data.length ; i<ien ; i++ ) {
						row = data[i];
		
						if ( row._details ) {
							row._details.children('td[colspan]').attr('colspan', visible );
						}
					}
				} );
		
				// Table destroyed - nuke any child rows
				api.on( destroyEvent, function ( e, ctx ) {
					if ( settings !== ctx ) {
						return;
					}
		
					for ( var i=0, ien=data.length ; i<ien ; i++ ) {
						if ( data[i]._details ) {
							__details_remove( api, i );
						}
					}
				} );
			}
		};
		
		// Strings for the method names to help minification
		var _emp = '';
		var _child_obj = _emp+'row().child';
		var _child_mth = _child_obj+'()';
		
		// data can be:
		//  tr
		//  string
		//  jQuery or array of any of the above
		_api_register( _child_mth, function ( data, klass ) {
			var ctx = this.context;
		
			if ( data === undefined ) {
				// get
				return ctx.length && this.length ?
					ctx[0].aoData[ this[0] ]._details :
					undefined;
			}
			else if ( data === true ) {
				// show
				this.child.show();
			}
			else if ( data === false ) {
				// remove
				__details_remove( this );
			}
			else if ( ctx.length && this.length ) {
				// set
				__details_add( ctx[0], ctx[0].aoData[ this[0] ], data, klass );
			}
		
			return this;
		} );
		
		
		_api_register( [
			_child_obj+'.show()',
			_child_mth+'.show()' // only when `child()` was called with parameters (without
		], function ( show ) {   // it returns an object and this method is not executed)
			__details_display( this, true );
			return this;
		} );
		
		
		_api_register( [
			_child_obj+'.hide()',
			_child_mth+'.hide()' // only when `child()` was called with parameters (without
		], function () {         // it returns an object and this method is not executed)
			__details_display( this, false );
			return this;
		} );
		
		
		_api_register( [
			_child_obj+'.remove()',
			_child_mth+'.remove()' // only when `child()` was called with parameters (without
		], function () {           // it returns an object and this method is not executed)
			__details_remove( this );
			return this;
		} );
		
		
		_api_register( _child_obj+'.isShown()', function () {
			var ctx = this.context;
		
			if ( ctx.length && this.length ) {
				// _detailsShown as false or undefined will fall through to return false
				return ctx[0].aoData[ this[0] ]._detailsShow || false;
			}
			return false;
		} );
		
		
		
		/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
		 * Columns
		 *
		 * {integer}           - column index (>=0 count from left, <0 count from right)
		 * "{integer}:visIdx"  - visible column index (i.e. translate to column index)  (>=0 count from left, <0 count from right)
		 * "{integer}:visible" - alias for {integer}:visIdx  (>=0 count from left, <0 count from right)
		 * "{string}:name"     - column name
		 * "{string}"          - jQuery selector on column header nodes
		 *
		 */
		
		// can be an array of these items, comma separated list, or an array of comma
		// separated lists
		
		var __re_column_selector = /^(.+):(name|visIdx|visible)$/;
		
		
		// r1 and r2 are redundant - but it means that the parameters match for the
		// iterator callback in columns().data()
		var __columnData = function ( settings, column, r1, r2, rows ) {
			var a = [];
			for ( var row=0, ien=rows.length ; row<ien ; row++ ) {
				a.push( _fnGetCellData( settings, rows[row], column ) );
			}
			return a;
		};
		
		
		var __column_selector = function ( settings, selector, opts )
		{
			var
				columns = settings.aoColumns,
				names = _pluck( columns, 'sName' ),
				nodes = _pluck( columns, 'nTh' );
		
			var run = function ( s ) {
				var selInt = _intVal( s );
		
				// Selector - all
				if ( s === '' ) {
					return _range( columns.length );
				}
		
				// Selector - index
				if ( selInt !== null ) {
					return [ selInt >= 0 ?
						selInt : // Count from left
						columns.length + selInt // Count from right (+ because its a negative value)
					];
				}
		
				// Selector = function
				if ( typeof s === 'function' ) {
					var rows = _selector_row_indexes( settings, opts );
		
					return $.map( columns, function (col, idx) {
						return s(
								idx,
								__columnData( settings, idx, 0, 0, rows ),
								nodes[ idx ]
							) ? idx : null;
					} );
				}
		
				// jQuery or string selector
				var match = typeof s === 'string' ?
					s.match( __re_column_selector ) :
					'';
		
				if ( match ) {
					switch( match[2] ) {
						case 'visIdx':
						case 'visible':
							var idx = parseInt( match[1], 10 );
							// Visible index given, convert to column index
							if ( idx < 0 ) {
								// Counting from the right
								var visColumns = $.map( columns, function (col,i) {
									return col.bVisible ? i : null;
								} );
								return [ visColumns[ visColumns.length + idx ] ];
							}
							// Counting from the left
							return [ _fnVisibleToColumnIndex( settings, idx ) ];
		
						case 'name':
							// match by name. `names` is column index complete and in order
							return $.map( names, function (name, i) {
								return name === match[1] ? i : null;
							} );
		
						default:
							return [];
					}
				}
		
				// Cell in the table body
				if ( s.nodeName && s._DT_CellIndex ) {
					return [ s._DT_CellIndex.column ];
				}
		
				// jQuery selector on the TH elements for the columns
				var jqResult = $( nodes )
					.filter( s )
					.map( function () {
						return $.inArray( this, nodes ); // `nodes` is column index complete and in order
					} )
					.toArray();
		
				if ( jqResult.length || ! s.nodeName ) {
					return jqResult;
				}
		
				// Otherwise a node which might have a `dt-column` data attribute, or be
				// a child or such an element
				var host = $(s).closest('*[data-dt-column]');
				return host.length ?
					[ host.data('dt-column') ] :
					[];
			};
		
			return _selector_run( 'column', selector, run, settings, opts );
		};
		
		
		var __setColumnVis = function ( settings, column, vis ) {
			var
				cols = settings.aoColumns,
				col  = cols[ column ],
				data = settings.aoData,
				row, cells, i, ien, tr;
		
			// Get
			if ( vis === undefined ) {
				return col.bVisible;
			}
		
			// Set
			// No change
			if ( col.bVisible === vis ) {
				return;
			}
		
			if ( vis ) {
				// Insert column
				// Need to decide if we should use appendChild or insertBefore
				var insertBefore = $.inArray( true, _pluck(cols, 'bVisible'), column+1 );
		
				for ( i=0, ien=data.length ; i<ien ; i++ ) {
					tr = data[i].nTr;
					cells = data[i].anCells;
		
					if ( tr ) {
						// insertBefore can act like appendChild if 2nd arg is null
						tr.insertBefore( cells[ column ], cells[ insertBefore ] || null );
					}
				}
			}
			else {
				// Remove column
				$( _pluck( settings.aoData, 'anCells', column ) ).detach();
			}
		
			// Common actions
			col.bVisible = vis;
			_fnDrawHead( settings, settings.aoHeader );
			_fnDrawHead( settings, settings.aoFooter );
		
			_fnSaveState( settings );
		};
		
		
		_api_register( 'columns()', function ( selector, opts ) {
			// argument shifting
			if ( selector === undefined ) {
				selector = '';
			}
			else if ( $.isPlainObject( selector ) ) {
				opts = selector;
				selector = '';
			}
		
			opts = _selector_opts( opts );
		
			var inst = this.iterator( 'table', function ( settings ) {
				return __column_selector( settings, selector, opts );
			}, 1 );
		
			// Want argument shifting here and in _row_selector?
			inst.selector.cols = selector;
			inst.selector.opts = opts;
		
			return inst;
		} );
		
		_api_registerPlural( 'columns().header()', 'column().header()', function ( selector, opts ) {
			return this.iterator( 'column', function ( settings, column ) {
				return settings.aoColumns[column].nTh;
			}, 1 );
		} );
		
		_api_registerPlural( 'columns().footer()', 'column().footer()', function ( selector, opts ) {
			return this.iterator( 'column', function ( settings, column ) {
				return settings.aoColumns[column].nTf;
			}, 1 );
		} );
		
		_api_registerPlural( 'columns().data()', 'column().data()', function () {
			return this.iterator( 'column-rows', __columnData, 1 );
		} );
		
		_api_registerPlural( 'columns().dataSrc()', 'column().dataSrc()', function () {
			return this.iterator( 'column', function ( settings, column ) {
				return settings.aoColumns[column].mData;
			}, 1 );
		} );
		
		_api_registerPlural( 'columns().cache()', 'column().cache()', function ( type ) {
			return this.iterator( 'column-rows', function ( settings, column, i, j, rows ) {
				return _pluck_order( settings.aoData, rows,
					type === 'search' ? '_aFilterData' : '_aSortData', column
				);
			}, 1 );
		} );
		
		_api_registerPlural( 'columns().nodes()', 'column().nodes()', function () {
			return this.iterator( 'column-rows', function ( settings, column, i, j, rows ) {
				return _pluck_order( settings.aoData, rows, 'anCells', column ) ;
			}, 1 );
		} );
		
		_api_registerPlural( 'columns().visible()', 'column().visible()', function ( vis, calc ) {
			var ret = this.iterator( 'column', function ( settings, column ) {
				if ( vis === undefined ) {
					return settings.aoColumns[ column ].bVisible;
				} // else
				__setColumnVis( settings, column, vis );
			} );
		
			// Group the column visibility changes
			if ( vis !== undefined ) {
				// Second loop once the first is done for events
				this.iterator( 'column', function ( settings, column ) {
					_fnCallbackFire( settings, null, 'column-visibility', [settings, column, vis, calc] );
				} );
		
				if ( calc === undefined || calc ) {
					this.columns.adjust();
				}
			}
		
			return ret;
		} );
		
		_api_registerPlural( 'columns().indexes()', 'column().index()', function ( type ) {
			return this.iterator( 'column', function ( settings, column ) {
				return type === 'visible' ?
					_fnColumnIndexToVisible( settings, column ) :
					column;
			}, 1 );
		} );
		
		_api_register( 'columns.adjust()', function () {
			return this.iterator( 'table', function ( settings ) {
				_fnAdjustColumnSizing( settings );
			}, 1 );
		} );
		
		_api_register( 'column.index()', function ( type, idx ) {
			if ( this.context.length !== 0 ) {
				var ctx = this.context[0];
		
				if ( type === 'fromVisible' || type === 'toData' ) {
					return _fnVisibleToColumnIndex( ctx, idx );
				}
				else if ( type === 'fromData' || type === 'toVisible' ) {
					return _fnColumnIndexToVisible( ctx, idx );
				}
			}
		} );
		
		_api_register( 'column()', function ( selector, opts ) {
			return _selector_first( this.columns( selector, opts ) );
		} );
		
		
		
		var __cell_selector = function ( settings, selector, opts )
		{
			var data = settings.aoData;
			var rows = _selector_row_indexes( settings, opts );
			var cells = _removeEmpty( _pluck_order( data, rows, 'anCells' ) );
			var allCells = $( [].concat.apply([], cells) );
			var row;
			var columns = settings.aoColumns.length;
			var a, i, ien, j, o, host;
		
			var run = function ( s ) {
				var fnSelector = typeof s === 'function';
		
				if ( s === null || s === undefined || fnSelector ) {
					// All cells and function selectors
					a = [];
		
					for ( i=0, ien=rows.length ; i<ien ; i++ ) {
						row = rows[i];
		
						for ( j=0 ; j<columns ; j++ ) {
							o = {
								row: row,
								column: j
							};
		
							if ( fnSelector ) {
								// Selector - function
								host = data[ row ];
		
								if ( s( o, _fnGetCellData(settings, row, j), host.anCells ? host.anCells[j] : null ) ) {
									a.push( o );
								}
							}
							else {
								// Selector - all
								a.push( o );
							}
						}
					}
		
					return a;
				}
				
				// Selector - index
				if ( $.isPlainObject( s ) ) {
					return [s];
				}
		
				// Selector - jQuery filtered cells
				var jqResult = allCells
					.filter( s )
					.map( function (i, el) {
						return { // use a new object, in case someone changes the values
							row:    el._DT_CellIndex.row,
							column: el._DT_CellIndex.column
		 				};
					} )
					.toArray();
		
				if ( jqResult.length || ! s.nodeName ) {
					return jqResult;
				}
		
				// Otherwise the selector is a node, and there is one last option - the
				// element might be a child of an element which has dt-row and dt-column
				// data attributes
				host = $(s).closest('*[data-dt-row]');
				return host.length ?
					[ {
						row: host.data('dt-row'),
						column: host.data('dt-column')
					} ] :
					[];
			};
		
			return _selector_run( 'cell', selector, run, settings, opts );
		};
		
		
		
		
		_api_register( 'cells()', function ( rowSelector, columnSelector, opts ) {
			// Argument shifting
			if ( $.isPlainObject( rowSelector ) ) {
				// Indexes
				if ( rowSelector.row === undefined ) {
					// Selector options in first parameter
					opts = rowSelector;
					rowSelector = null;
				}
				else {
					// Cell index objects in first parameter
					opts = columnSelector;
					columnSelector = null;
				}
			}
			if ( $.isPlainObject( columnSelector ) ) {
				opts = columnSelector;
				columnSelector = null;
			}
		
			// Cell selector
			if ( columnSelector === null || columnSelector === undefined ) {
				return this.iterator( 'table', function ( settings ) {
					return __cell_selector( settings, rowSelector, _selector_opts( opts ) );
				} );
			}
		
			// Row + column selector
			var columns = this.columns( columnSelector, opts );
			var rows = this.rows( rowSelector, opts );
			var a, i, ien, j, jen;
		
			var cells = this.iterator( 'table', function ( settings, idx ) {
				a = [];
		
				for ( i=0, ien=rows[idx].length ; i<ien ; i++ ) {
					for ( j=0, jen=columns[idx].length ; j<jen ; j++ ) {
						a.push( {
							row:    rows[idx][i],
							column: columns[idx][j]
						} );
					}
				}
		
				return a;
			}, 1 );
		
			$.extend( cells.selector, {
				cols: columnSelector,
				rows: rowSelector,
				opts: opts
			} );
		
			return cells;
		} );
		
		
		_api_registerPlural( 'cells().nodes()', 'cell().node()', function () {
			return this.iterator( 'cell', function ( settings, row, column ) {
				var data = settings.aoData[ row ];
		
				return data && data.anCells ?
					data.anCells[ column ] :
					undefined;
			}, 1 );
		} );
		
		
		_api_register( 'cells().data()', function () {
			return this.iterator( 'cell', function ( settings, row, column ) {
				return _fnGetCellData( settings, row, column );
			}, 1 );
		} );
		
		
		_api_registerPlural( 'cells().cache()', 'cell().cache()', function ( type ) {
			type = type === 'search' ? '_aFilterData' : '_aSortData';
		
			return this.iterator( 'cell', function ( settings, row, column ) {
				return settings.aoData[ row ][ type ][ column ];
			}, 1 );
		} );
		
		
		_api_registerPlural( 'cells().render()', 'cell().render()', function ( type ) {
			return this.iterator( 'cell', function ( settings, row, column ) {
				return _fnGetCellData( settings, row, column, type );
			}, 1 );
		} );
		
		
		_api_registerPlural( 'cells().indexes()', 'cell().index()', function () {
			return this.iterator( 'cell', function ( settings, row, column ) {
				return {
					row: row,
					column: column,
					columnVisible: _fnColumnIndexToVisible( settings, column )
				};
			}, 1 );
		} );
		
		
		_api_registerPlural( 'cells().invalidate()', 'cell().invalidate()', function ( src ) {
			return this.iterator( 'cell', function ( settings, row, column ) {
				_fnInvalidate( settings, row, src, column );
			} );
		} );
		
		
		
		_api_register( 'cell()', function ( rowSelector, columnSelector, opts ) {
			return _selector_first( this.cells( rowSelector, columnSelector, opts ) );
		} );
		
		
		_api_register( 'cell().data()', function ( data ) {
			var ctx = this.context;
			var cell = this[0];
		
			if ( data === undefined ) {
				// Get
				return ctx.length && cell.length ?
					_fnGetCellData( ctx[0], cell[0].row, cell[0].column ) :
					undefined;
			}
		
			// Set
			_fnSetCellData( ctx[0], cell[0].row, cell[0].column, data );
			_fnInvalidate( ctx[0], cell[0].row, 'data', cell[0].column );
		
			return this;
		} );
		
		
		
		/**
		 * Get current ordering (sorting) that has been applied to the table.
		 *
		 * @returns {array} 2D array containing the sorting information for the first
		 *   table in the current context. Each element in the parent array represents
		 *   a column being sorted upon (i.e. multi-sorting with two columns would have
		 *   2 inner arrays). The inner arrays may have 2 or 3 elements. The first is
		 *   the column index that the sorting condition applies to, the second is the
		 *   direction of the sort (`desc` or `asc`) and, optionally, the third is the
		 *   index of the sorting order from the `column.sorting` initialisation array.
		 *//**
		 * Set the ordering for the table.
		 *
		 * @param {integer} order Column index to sort upon.
		 * @param {string} direction Direction of the sort to be applied (`asc` or `desc`)
		 * @returns {DataTables.Api} this
		 *//**
		 * Set the ordering for the table.
		 *
		 * @param {array} order 1D array of sorting information to be applied.
		 * @param {array} [...] Optional additional sorting conditions
		 * @returns {DataTables.Api} this
		 *//**
		 * Set the ordering for the table.
		 *
		 * @param {array} order 2D array of sorting information to be applied.
		 * @returns {DataTables.Api} this
		 */
		_api_register( 'order()', function ( order, dir ) {
			var ctx = this.context;
		
			if ( order === undefined ) {
				// get
				return ctx.length !== 0 ?
					ctx[0].aaSorting :
					undefined;
			}
		
			// set
			if ( typeof order === 'number' ) {
				// Simple column / direction passed in
				order = [ [ order, dir ] ];
			}
			else if ( order.length && ! $.isArray( order[0] ) ) {
				// Arguments passed in (list of 1D arrays)
				order = Array.prototype.slice.call( arguments );
			}
			// otherwise a 2D array was passed in
		
			return this.iterator( 'table', function ( settings ) {
				settings.aaSorting = order.slice();
			} );
		} );
		
		
		/**
		 * Attach a sort listener to an element for a given column
		 *
		 * @param {node|jQuery|string} node Identifier for the element(s) to attach the
		 *   listener to. This can take the form of a single DOM node, a jQuery
		 *   collection of nodes or a jQuery selector which will identify the node(s).
		 * @param {integer} column the column that a click on this node will sort on
		 * @param {function} [callback] callback function when sort is run
		 * @returns {DataTables.Api} this
		 */
		_api_register( 'order.listener()', function ( node, column, callback ) {
			return this.iterator( 'table', function ( settings ) {
				_fnSortAttachListener( settings, node, column, callback );
			} );
		} );
		
		
		_api_register( 'order.fixed()', function ( set ) {
			if ( ! set ) {
				var ctx = this.context;
				var fixed = ctx.length ?
					ctx[0].aaSortingFixed :
					undefined;
		
				return $.isArray( fixed ) ?
					{ pre: fixed } :
					fixed;
			}
		
			return this.iterator( 'table', function ( settings ) {
				settings.aaSortingFixed = $.extend( true, {}, set );
			} );
		} );
		
		
		// Order by the selected column(s)
		_api_register( [
			'columns().order()',
			'column().order()'
		], function ( dir ) {
			var that = this;
		
			return this.iterator( 'table', function ( settings, i ) {
				var sort = [];
		
				$.each( that[i], function (j, col) {
					sort.push( [ col, dir ] );
				} );
		
				settings.aaSorting = sort;
			} );
		} );
		
		
		
		_api_register( 'search()', function ( input, regex, smart, caseInsen ) {
			var ctx = this.context;
		
			if ( input === undefined ) {
				// get
				return ctx.length !== 0 ?
					ctx[0].oPreviousSearch.sSearch :
					undefined;
			}
		
			// set
			return this.iterator( 'table', function ( settings ) {
				if ( ! settings.oFeatures.bFilter ) {
					return;
				}
		
				_fnFilterComplete( settings, $.extend( {}, settings.oPreviousSearch, {
					"sSearch": input+"",
					"bRegex":  regex === null ? false : regex,
					"bSmart":  smart === null ? true  : smart,
					"bCaseInsensitive": caseInsen === null ? true : caseInsen
				} ), 1 );
			} );
		} );
		
		
		_api_registerPlural(
			'columns().search()',
			'column().search()',
			function ( input, regex, smart, caseInsen ) {
				return this.iterator( 'column', function ( settings, column ) {
					var preSearch = settings.aoPreSearchCols;
		
					if ( input === undefined ) {
						// get
						return preSearch[ column ].sSearch;
					}
		
					// set
					if ( ! settings.oFeatures.bFilter ) {
						return;
					}
		
					$.extend( preSearch[ column ], {
						"sSearch": input+"",
						"bRegex":  regex === null ? false : regex,
						"bSmart":  smart === null ? true  : smart,
						"bCaseInsensitive": caseInsen === null ? true : caseInsen
					} );
		
					_fnFilterComplete( settings, settings.oPreviousSearch, 1 );
				} );
			}
		);
		
		/*
		 * State API methods
		 */
		
		_api_register( 'state()', function () {
			return this.context.length ?
				this.context[0].oSavedState :
				null;
		} );
		
		
		_api_register( 'state.clear()', function () {
			return this.iterator( 'table', function ( settings ) {
				// Save an empty object
				settings.fnStateSaveCallback.call( settings.oInstance, settings, {} );
			} );
		} );
		
		
		_api_register( 'state.loaded()', function () {
			return this.context.length ?
				this.context[0].oLoadedState :
				null;
		} );
		
		
		_api_register( 'state.save()', function () {
			return this.iterator( 'table', function ( settings ) {
				_fnSaveState( settings );
			} );
		} );
		
		
		
		/**
		 * Provide a common method for plug-ins to check the version of DataTables being
		 * used, in order to ensure compatibility.
		 *
		 *  @param {string} version Version string to check for, in the format "X.Y.Z".
		 *    Note that the formats "X" and "X.Y" are also acceptable.
		 *  @returns {boolean} true if this version of DataTables is greater or equal to
		 *    the required version, or false if this version of DataTales is not
		 *    suitable
		 *  @static
		 *  @dtopt API-Static
		 *
		 *  @example
		 *    alert( $.fn.dataTable.versionCheck( '1.9.0' ) );
		 */
		DataTable.versionCheck = DataTable.fnVersionCheck = function( version )
		{
			var aThis = DataTable.version.split('.');
			var aThat = version.split('.');
			var iThis, iThat;
		
			for ( var i=0, iLen=aThat.length ; i<iLen ; i++ ) {
				iThis = parseInt( aThis[i], 10 ) || 0;
				iThat = parseInt( aThat[i], 10 ) || 0;
		
				// Parts are the same, keep comparing
				if (iThis === iThat) {
					continue;
				}
		
				// Parts are different, return immediately
				return iThis > iThat;
			}
		
			return true;
		};
		
		
		/**
		 * Check if a `<table>` node is a DataTable table already or not.
		 *
		 *  @param {node|jquery|string} table Table node, jQuery object or jQuery
		 *      selector for the table to test. Note that if more than more than one
		 *      table is passed on, only the first will be checked
		 *  @returns {boolean} true the table given is a DataTable, or false otherwise
		 *  @static
		 *  @dtopt API-Static
		 *
		 *  @example
		 *    if ( ! $.fn.DataTable.isDataTable( '#example' ) ) {
		 *      $('#example').dataTable();
		 *    }
		 */
		DataTable.isDataTable = DataTable.fnIsDataTable = function ( table )
		{
			var t = $(table).get(0);
			var is = false;
		
			$.each( DataTable.settings, function (i, o) {
				var head = o.nScrollHead ? $('table', o.nScrollHead)[0] : null;
				var foot = o.nScrollFoot ? $('table', o.nScrollFoot)[0] : null;
		
				if ( o.nTable === t || head === t || foot === t ) {
					is = true;
				}
			} );
		
			return is;
		};
		
		
		/**
		 * Get all DataTable tables that have been initialised - optionally you can
		 * select to get only currently visible tables.
		 *
		 *  @param {boolean} [visible=false] Flag to indicate if you want all (default)
		 *    or visible tables only.
		 *  @returns {array} Array of `table` nodes (not DataTable instances) which are
		 *    DataTables
		 *  @static
		 *  @dtopt API-Static
		 *
		 *  @example
		 *    $.each( $.fn.dataTable.tables(true), function () {
		 *      $(table).DataTable().columns.adjust();
		 *    } );
		 */
		DataTable.tables = DataTable.fnTables = function ( visible )
		{
			var api = false;
		
			if ( $.isPlainObject( visible ) ) {
				api = visible.api;
				visible = visible.visible;
			}
		
			var a = $.map( DataTable.settings, function (o) {
				if ( !visible || (visible && $(o.nTable).is(':visible')) ) {
					return o.nTable;
				}
			} );
		
			return api ?
				new _Api( a ) :
				a;
		};
		
		
		/**
		 * Convert from camel case parameters to Hungarian notation. This is made public
		 * for the extensions to provide the same ability as DataTables core to accept
		 * either the 1.9 style Hungarian notation, or the 1.10+ style camelCase
		 * parameters.
		 *
		 *  @param {object} src The model object which holds all parameters that can be
		 *    mapped.
		 *  @param {object} user The object to convert from camel case to Hungarian.
		 *  @param {boolean} force When set to `true`, properties which already have a
		 *    Hungarian value in the `user` object will be overwritten. Otherwise they
		 *    won't be.
		 */
		DataTable.camelToHungarian = _fnCamelToHungarian;
		
		
		
		/**
		 *
		 */
		_api_register( '$()', function ( selector, opts ) {
			var
				rows   = this.rows( opts ).nodes(), // Get all rows
				jqRows = $(rows);
		
			return $( [].concat(
				jqRows.filter( selector ).toArray(),
				jqRows.find( selector ).toArray()
			) );
		} );
		
		
		// jQuery functions to operate on the tables
		$.each( [ 'on', 'one', 'off' ], function (i, key) {
			_api_register( key+'()', function ( /* event, handler */ ) {
				var args = Array.prototype.slice.call(arguments);
		
				// Add the `dt` namespace automatically if it isn't already present
				if ( ! args[0].match(/\.dt\b/) ) {
					args[0] += '.dt';
				}
		
				var inst = $( this.tables().nodes() );
				inst[key].apply( inst, args );
				return this;
			} );
		} );
		
		
		_api_register( 'clear()', function () {
			return this.iterator( 'table', function ( settings ) {
				_fnClearTable( settings );
			} );
		} );
		
		
		_api_register( 'settings()', function () {
			return new _Api( this.context, this.context );
		} );
		
		
		_api_register( 'init()', function () {
			var ctx = this.context;
			return ctx.length ? ctx[0].oInit : null;
		} );
		
		
		_api_register( 'data()', function () {
			return this.iterator( 'table', function ( settings ) {
				return _pluck( settings.aoData, '_aData' );
			} ).flatten();
		} );
		
		
		_api_register( 'destroy()', function ( remove ) {
			remove = remove || false;
		
			return this.iterator( 'table', function ( settings ) {
				var orig      = settings.nTableWrapper.parentNode;
				var classes   = settings.oClasses;
				var table     = settings.nTable;
				var tbody     = settings.nTBody;
				var thead     = settings.nTHead;
				var tfoot     = settings.nTFoot;
				var jqTable   = $(table);
				var jqTbody   = $(tbody);
				var jqWrapper = $(settings.nTableWrapper);
				var rows      = $.map( settings.aoData, function (r) { return r.nTr; } );
				var i, ien;
		
				// Flag to note that the table is currently being destroyed - no action
				// should be taken
				settings.bDestroying = true;
		
				// Fire off the destroy callbacks for plug-ins etc
				_fnCallbackFire( settings, "aoDestroyCallback", "destroy", [settings] );
		
				// If not being removed from the document, make all columns visible
				if ( ! remove ) {
					new _Api( settings ).columns().visible( true );
				}
		
				// Blitz all `DT` namespaced events (these are internal events, the
				// lowercase, `dt` events are user subscribed and they are responsible
				// for removing them
				jqWrapper.unbind('.DT').find(':not(tbody *)').unbind('.DT');
				$(window).unbind('.DT-'+settings.sInstance);
		
				// When scrolling we had to break the table up - restore it
				if ( table != thead.parentNode ) {
					jqTable.children('thead').detach();
					jqTable.append( thead );
				}
		
				if ( tfoot && table != tfoot.parentNode ) {
					jqTable.children('tfoot').detach();
					jqTable.append( tfoot );
				}
		
				settings.aaSorting = [];
				settings.aaSortingFixed = [];
				_fnSortingClasses( settings );
		
				$( rows ).removeClass( settings.asStripeClasses.join(' ') );
		
				$('th, td', thead).removeClass( classes.sSortable+' '+
					classes.sSortableAsc+' '+classes.sSortableDesc+' '+classes.sSortableNone
				);
		
				if ( settings.bJUI ) {
					$('th span.'+classes.sSortIcon+ ', td span.'+classes.sSortIcon, thead).detach();
					$('th, td', thead).each( function () {
						var wrapper = $('div.'+classes.sSortJUIWrapper, this);
						$(this).append( wrapper.contents() );
						wrapper.detach();
					} );
				}
		
				// Add the TR elements back into the table in their original order
				jqTbody.children().detach();
				jqTbody.append( rows );
		
				// Remove the DataTables generated nodes, events and classes
				var removedMethod = remove ? 'remove' : 'detach';
				jqTable[ removedMethod ]();
				jqWrapper[ removedMethod ]();
		
				// If we need to reattach the table to the document
				if ( ! remove && orig ) {
					// insertBefore acts like appendChild if !arg[1]
					orig.insertBefore( table, settings.nTableReinsertBefore );
		
					// Restore the width of the original table - was read from the style property,
					// so we can restore directly to that
					jqTable
						.css( 'width', settings.sDestroyWidth )
						.removeClass( classes.sTable );
		
					// If the were originally stripe classes - then we add them back here.
					// Note this is not fool proof (for example if not all rows had stripe
					// classes - but it's a good effort without getting carried away
					ien = settings.asDestroyStripes.length;
		
					if ( ien ) {
						jqTbody.children().each( function (i) {
							$(this).addClass( settings.asDestroyStripes[i % ien] );
						} );
					}
				}
		
				/* Remove the settings object from the settings array */
				var idx = $.inArray( settings, DataTable.settings );
				if ( idx !== -1 ) {
					DataTable.settings.splice( idx, 1 );
				}
			} );
		} );
		
		
		// Add the `every()` method for rows, columns and cells in a compact form
		$.each( [ 'column', 'row', 'cell' ], function ( i, type ) {
			_api_register( type+'s().every()', function ( fn ) {
				var opts = this.selector.opts;
				var api = this;
		
				return this.iterator( type, function ( settings, arg1, arg2, arg3, arg4 ) {
					// Rows and columns:
					//  arg1 - index
					//  arg2 - table counter
					//  arg3 - loop counter
					//  arg4 - undefined
					// Cells:
					//  arg1 - row index
					//  arg2 - column index
					//  arg3 - table counter
					//  arg4 - loop counter
					fn.call(
						api[ type ](
							arg1,
							type==='cell' ? arg2 : opts,
							type==='cell' ? opts : undefined
						),
						arg1, arg2, arg3, arg4
					);
				} );
			} );
		} );
		
		
		// i18n method for extensions to be able to use the language object from the
		// DataTable
		_api_register( 'i18n()', function ( token, def, plural ) {
			var ctx = this.context[0];
			var resolved = _fnGetObjectDataFn( token )( ctx.oLanguage );
		
			if ( resolved === undefined ) {
				resolved = def;
			}
		
			if ( plural !== undefined && $.isPlainObject( resolved ) ) {
				resolved = resolved[ plural ] !== undefined ?
					resolved[ plural ] :
					resolved._;
			}
		
			return resolved.replace( '%d', plural ); // nb: plural might be undefined,
		} );
		/**
		 * Version string for plug-ins to check compatibility. Allowed format is
		 * `a.b.c-d` where: a:int, b:int, c:int, d:string(dev|beta|alpha). `d` is used
		 * only for non-release builds. See http://semver.org/ for more information.
		 *  @member
		 *  @type string
		 *  @default Version number
		 */
		DataTable.version = "1.10.12";
	
		/**
		 * Private data store, containing all of the settings objects that are
		 * created for the tables on a given page.
		 *
		 * Note that the `DataTable.settings` object is aliased to
		 * `jQuery.fn.dataTableExt` through which it may be accessed and
		 * manipulated, or `jQuery.fn.dataTable.settings`.
		 *  @member
		 *  @type array
		 *  @default []
		 *  @private
		 */
		DataTable.settings = [];
	
		/**
		 * Object models container, for the various models that DataTables has
		 * available to it. These models define the objects that are used to hold
		 * the active state and configuration of the table.
		 *  @namespace
		 */
		DataTable.models = {};
		
		
		
		/**
		 * Template object for the way in which DataTables holds information about
		 * search information for the global filter and individual column filters.
		 *  @namespace
		 */
		DataTable.models.oSearch = {
			/**
			 * Flag to indicate if the filtering should be case insensitive or not
			 *  @type boolean
			 *  @default true
			 */
			"bCaseInsensitive": true,
		
			/**
			 * Applied search term
			 *  @type string
			 *  @default <i>Empty string</i>
			 */
			"sSearch": "",
		
			/**
			 * Flag to indicate if the search term should be interpreted as a
			 * regular expression (true) or not (false) and therefore and special
			 * regex characters escaped.
			 *  @type boolean
			 *  @default false
			 */
			"bRegex": false,
		
			/**
			 * Flag to indicate if DataTables is to use its smart filtering or not.
			 *  @type boolean
			 *  @default true
			 */
			"bSmart": true
		};
		
		
		
		
		/**
		 * Template object for the way in which DataTables holds information about
		 * each individual row. This is the object format used for the settings
		 * aoData array.
		 *  @namespace
		 */
		DataTable.models.oRow = {
			/**
			 * TR element for the row
			 *  @type node
			 *  @default null
			 */
			"nTr": null,
		
			/**
			 * Array of TD elements for each row. This is null until the row has been
			 * created.
			 *  @type array nodes
			 *  @default []
			 */
			"anCells": null,
		
			/**
			 * Data object from the original data source for the row. This is either
			 * an array if using the traditional form of DataTables, or an object if
			 * using mData options. The exact type will depend on the passed in
			 * data from the data source, or will be an array if using DOM a data
			 * source.
			 *  @type array|object
			 *  @default []
			 */
			"_aData": [],
		
			/**
			 * Sorting data cache - this array is ostensibly the same length as the
			 * number of columns (although each index is generated only as it is
			 * needed), and holds the data that is used for sorting each column in the
			 * row. We do this cache generation at the start of the sort in order that
			 * the formatting of the sort data need be done only once for each cell
			 * per sort. This array should not be read from or written to by anything
			 * other than the master sorting methods.
			 *  @type array
			 *  @default null
			 *  @private
			 */
			"_aSortData": null,
		
			/**
			 * Per cell filtering data cache. As per the sort data cache, used to
			 * increase the performance of the filtering in DataTables
			 *  @type array
			 *  @default null
			 *  @private
			 */
			"_aFilterData": null,
		
			/**
			 * Filtering data cache. This is the same as the cell filtering cache, but
			 * in this case a string rather than an array. This is easily computed with
			 * a join on `_aFilterData`, but is provided as a cache so the join isn't
			 * needed on every search (memory traded for performance)
			 *  @type array
			 *  @default null
			 *  @private
			 */
			"_sFilterRow": null,
		
			/**
			 * Cache of the class name that DataTables has applied to the row, so we
			 * can quickly look at this variable rather than needing to do a DOM check
			 * on className for the nTr property.
			 *  @type string
			 *  @default <i>Empty string</i>
			 *  @private
			 */
			"_sRowStripe": "",
		
			/**
			 * Denote if the original data source was from the DOM, or the data source
			 * object. This is used for invalidating data, so DataTables can
			 * automatically read data from the original source, unless uninstructed
			 * otherwise.
			 *  @type string
			 *  @default null
			 *  @private
			 */
			"src": null,
		
			/**
			 * Index in the aoData array. This saves an indexOf lookup when we have the
			 * object, but want to know the index
			 *  @type integer
			 *  @default -1
			 *  @private
			 */
			"idx": -1
		};
		
		
		/**
		 * Template object for the column information object in DataTables. This object
		 * is held in the settings aoColumns array and contains all the information that
		 * DataTables needs about each individual column.
		 *
		 * Note that this object is related to {@link DataTable.defaults.column}
		 * but this one is the internal data store for DataTables's cache of columns.
		 * It should NOT be manipulated outside of DataTables. Any configuration should
		 * be done through the initialisation options.
		 *  @namespace
		 */
		DataTable.models.oColumn = {
			/**
			 * Column index. This could be worked out on-the-fly with $.inArray, but it
			 * is faster to just hold it as a variable
			 *  @type integer
			 *  @default null
			 */
			"idx": null,
		
			/**
			 * A list of the columns that sorting should occur on when this column
			 * is sorted. That this property is an array allows multi-column sorting
			 * to be defined for a column (for example first name / last name columns
			 * would benefit from this). The values are integers pointing to the
			 * columns to be sorted on (typically it will be a single integer pointing
			 * at itself, but that doesn't need to be the case).
			 *  @type array
			 */
			"aDataSort": null,
		
			/**
			 * Define the sorting directions that are applied to the column, in sequence
			 * as the column is repeatedly sorted upon - i.e. the first value is used
			 * as the sorting direction when the column if first sorted (clicked on).
			 * Sort it again (click again) and it will move on to the next index.
			 * Repeat until loop.
			 *  @type array
			 */
			"asSorting": null,
		
			/**
			 * Flag to indicate if the column is searchable, and thus should be included
			 * in the filtering or not.
			 *  @type boolean
			 */
			"bSearchable": null,
		
			/**
			 * Flag to indicate if the column is sortable or not.
			 *  @type boolean
			 */
			"bSortable": null,
		
			/**
			 * Flag to indicate if the column is currently visible in the table or not
			 *  @type boolean
			 */
			"bVisible": null,
		
			/**
			 * Store for manual type assignment using the `column.type` option. This
			 * is held in store so we can manipulate the column's `sType` property.
			 *  @type string
			 *  @default null
			 *  @private
			 */
			"_sManualType": null,
		
			/**
			 * Flag to indicate if HTML5 data attributes should be used as the data
			 * source for filtering or sorting. True is either are.
			 *  @type boolean
			 *  @default false
			 *  @private
			 */
			"_bAttrSrc": false,
		
			/**
			 * Developer definable function that is called whenever a cell is created (Ajax source,
			 * etc) or processed for input (DOM source). This can be used as a compliment to mRender
			 * allowing you to modify the DOM element (add background colour for example) when the
			 * element is available.
			 *  @type function
			 *  @param {element} nTd The TD node that has been created
			 *  @param {*} sData The Data for the cell
			 *  @param {array|object} oData The data for the whole row
			 *  @param {int} iRow The row index for the aoData data store
			 *  @default null
			 */
			"fnCreatedCell": null,
		
			/**
			 * Function to get data from a cell in a column. You should <b>never</b>
			 * access data directly through _aData internally in DataTables - always use
			 * the method attached to this property. It allows mData to function as
			 * required. This function is automatically assigned by the column
			 * initialisation method
			 *  @type function
			 *  @param {array|object} oData The data array/object for the array
			 *    (i.e. aoData[]._aData)
			 *  @param {string} sSpecific The specific data type you want to get -
			 *    'display', 'type' 'filter' 'sort'
			 *  @returns {*} The data for the cell from the given row's data
			 *  @default null
			 */
			"fnGetData": null,
		
			/**
			 * Function to set data for a cell in the column. You should <b>never</b>
			 * set the data directly to _aData internally in DataTables - always use
			 * this method. It allows mData to function as required. This function
			 * is automatically assigned by the column initialisation method
			 *  @type function
			 *  @param {array|object} oData The data array/object for the array
			 *    (i.e. aoData[]._aData)
			 *  @param {*} sValue Value to set
			 *  @default null
			 */
			"fnSetData": null,
		
			/**
			 * Property to read the value for the cells in the column from the data
			 * source array / object. If null, then the default content is used, if a
			 * function is given then the return from the function is used.
			 *  @type function|int|string|null
			 *  @default null
			 */
			"mData": null,
		
			/**
			 * Partner property to mData which is used (only when defined) to get
			 * the data - i.e. it is basically the same as mData, but without the
			 * 'set' option, and also the data fed to it is the result from mData.
			 * This is the rendering method to match the data method of mData.
			 *  @type function|int|string|null
			 *  @default null
			 */
			"mRender": null,
		
			/**
			 * Unique header TH/TD element for this column - this is what the sorting
			 * listener is attached to (if sorting is enabled.)
			 *  @type node
			 *  @default null
			 */
			"nTh": null,
		
			/**
			 * Unique footer TH/TD element for this column (if there is one). Not used
			 * in DataTables as such, but can be used for plug-ins to reference the
			 * footer for each column.
			 *  @type node
			 *  @default null
			 */
			"nTf": null,
		
			/**
			 * The class to apply to all TD elements in the table's TBODY for the column
			 *  @type string
			 *  @default null
			 */
			"sClass": null,
		
			/**
			 * When DataTables calculates the column widths to assign to each column,
			 * it finds the longest string in each column and then constructs a
			 * temporary table and reads the widths from that. The problem with this
			 * is that "mmm" is much wider then "iiii", but the latter is a longer
			 * string - thus the calculation can go wrong (doing it properly and putting
			 * it into an DOM object and measuring that is horribly(!) slow). Thus as
			 * a "work around" we provide this option. It will append its value to the
			 * text that is found to be the longest string for the column - i.e. padding.
			 *  @type string
			 */
			"sContentPadding": null,
		
			/**
			 * Allows a default value to be given for a column's data, and will be used
			 * whenever a null data source is encountered (this can be because mData
			 * is set to null, or because the data source itself is null).
			 *  @type string
			 *  @default null
			 */
			"sDefaultContent": null,
		
			/**
			 * Name for the column, allowing reference to the column by name as well as
			 * by index (needs a lookup to work by name).
			 *  @type string
			 */
			"sName": null,
		
			/**
			 * Custom sorting data type - defines which of the available plug-ins in
			 * afnSortData the custom sorting will use - if any is defined.
			 *  @type string
			 *  @default std
			 */
			"sSortDataType": 'std',
		
			/**
			 * Class to be applied to the header element when sorting on this column
			 *  @type string
			 *  @default null
			 */
			"sSortingClass": null,
		
			/**
			 * Class to be applied to the header element when sorting on this column -
			 * when jQuery UI theming is used.
			 *  @type string
			 *  @default null
			 */
			"sSortingClassJUI": null,
		
			/**
			 * Title of the column - what is seen in the TH element (nTh).
			 *  @type string
			 */
			"sTitle": null,
		
			/**
			 * Column sorting and filtering type
			 *  @type string
			 *  @default null
			 */
			"sType": null,
		
			/**
			 * Width of the column
			 *  @type string
			 *  @default null
			 */
			"sWidth": null,
		
			/**
			 * Width of the column when it was first "encountered"
			 *  @type string
			 *  @default null
			 */
			"sWidthOrig": null
		};
		
		
		/*
		 * Developer note: The properties of the object below are given in Hungarian
		 * notation, that was used as the interface for DataTables prior to v1.10, however
		 * from v1.10 onwards the primary interface is camel case. In order to avoid
		 * breaking backwards compatibility utterly with this change, the Hungarian
		 * version is still, internally the primary interface, but is is not documented
		 * - hence the @name tags in each doc comment. This allows a Javascript function
		 * to create a map from Hungarian notation to camel case (going the other direction
		 * would require each property to be listed, which would at around 3K to the size
		 * of DataTables, while this method is about a 0.5K hit.
		 *
		 * Ultimately this does pave the way for Hungarian notation to be dropped
		 * completely, but that is a massive amount of work and will break current
		 * installs (therefore is on-hold until v2).
		 */
		
		/**
		 * Initialisation options that can be given to DataTables at initialisation
		 * time.
		 *  @namespace
		 */
		DataTable.defaults = {
			/**
			 * An array of data to use for the table, passed in at initialisation which
			 * will be used in preference to any data which is already in the DOM. This is
			 * particularly useful for constructing tables purely in Javascript, for
			 * example with a custom Ajax call.
			 *  @type array
			 *  @default null
			 *
			 *  @dtopt Option
			 *  @name DataTable.defaults.data
			 *
			 *  @example
			 *    // Using a 2D array data source
			 *    $(document).ready( function () {
			 *      $('#example').dataTable( {
			 *        "data": [
			 *          ['Trident', 'Internet Explorer 4.0', 'Win 95+', 4, 'X'],
			 *          ['Trident', 'Internet Explorer 5.0', 'Win 95+', 5, 'C'],
			 *        ],
			 *        "columns": [
			 *          { "title": "Engine" },
			 *          { "title": "Browser" },
			 *          { "title": "Platform" },
			 *          { "title": "Version" },
			 *          { "title": "Grade" }
			 *        ]
			 *      } );
			 *    } );
			 *
			 *  @example
			 *    // Using an array of objects as a data source (`data`)
			 *    $(document).ready( function () {
			 *      $('#example').dataTable( {
			 *        "data": [
			 *          {
			 *            "engine":   "Trident",
			 *            "browser":  "Internet Explorer 4.0",
			 *            "platform": "Win 95+",
			 *            "version":  4,
			 *            "grade":    "X"
			 *          },
			 *          {
			 *            "engine":   "Trident",
			 *            "browser":  "Internet Explorer 5.0",
			 *            "platform": "Win 95+",
			 *            "version":  5,
			 *            "grade":    "C"
			 *          }
			 *        ],
			 *        "columns": [
			 *          { "title": "Engine",   "data": "engine" },
			 *          { "title": "Browser",  "data": "browser" },
			 *          { "title": "Platform", "data": "platform" },
			 *          { "title": "Version",  "data": "version" },
			 *          { "title": "Grade",    "data": "grade" }
			 *        ]
			 *      } );
			 *    } );
			 */
			"aaData": null,
		
		
			/**
			 * If ordering is enabled, then DataTables will perform a first pass sort on
			 * initialisation. You can define which column(s) the sort is performed
			 * upon, and the sorting direction, with this variable. The `sorting` array
			 * should contain an array for each column to be sorted initially containing
			 * the column's index and a direction string ('asc' or 'desc').
			 *  @type array
			 *  @default [[0,'asc']]
			 *
			 *  @dtopt Option
			 *  @name DataTable.defaults.order
			 *
			 *  @example
			 *    // Sort by 3rd column first, and then 4th column
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "order": [[2,'asc'], [3,'desc']]
			 *      } );
			 *    } );
			 *
			 *    // No initial sorting
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "order": []
			 *      } );
			 *    } );
			 */
			"aaSorting": [[0,'asc']],
		
		
			/**
			 * This parameter is basically identical to the `sorting` parameter, but
			 * cannot be overridden by user interaction with the table. What this means
			 * is that you could have a column (visible or hidden) which the sorting
			 * will always be forced on first - any sorting after that (from the user)
			 * will then be performed as required. This can be useful for grouping rows
			 * together.
			 *  @type array
			 *  @default null
			 *
			 *  @dtopt Option
			 *  @name DataTable.defaults.orderFixed
			 *
			 *  @example
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "orderFixed": [[0,'asc']]
			 *      } );
			 *    } )
			 */
			"aaSortingFixed": [],
		
		
			/**
			 * DataTables can be instructed to load data to display in the table from a
			 * Ajax source. This option defines how that Ajax call is made and where to.
			 *
			 * The `ajax` property has three different modes of operation, depending on
			 * how it is defined. These are:
			 *
			 * * `string` - Set the URL from where the data should be loaded from.
			 * * `object` - Define properties for `jQuery.ajax`.
			 * * `function` - Custom data get function
			 *
			 * `string`
			 * --------
			 *
			 * As a string, the `ajax` property simply defines the URL from which
			 * DataTables will load data.
			 *
			 * `object`
			 * --------
			 *
			 * As an object, the parameters in the object are passed to
			 * [jQuery.ajax](http://api.jquery.com/jQuery.ajax/) allowing fine control
			 * of the Ajax request. DataTables has a number of default parameters which
			 * you can override using this option. Please refer to the jQuery
			 * documentation for a full description of the options available, although
			 * the following parameters provide additional options in DataTables or
			 * require special consideration:
			 *
			 * * `data` - As with jQuery, `data` can be provided as an object, but it
			 *   can also be used as a function to manipulate the data DataTables sends
			 *   to the server. The function takes a single parameter, an object of
			 *   parameters with the values that DataTables has readied for sending. An
			 *   object may be returned which will be merged into the DataTables
			 *   defaults, or you can add the items to the object that was passed in and
			 *   not return anything from the function. This supersedes `fnServerParams`
			 *   from DataTables 1.9-.
			 *
			 * * `dataSrc` - By default DataTables will look for the property `data` (or
			 *   `aaData` for compatibility with DataTables 1.9-) when obtaining data
			 *   from an Ajax source or for server-side processing - this parameter
			 *   allows that property to be changed. You can use Javascript dotted
			 *   object notation to get a data source for multiple levels of nesting, or
			 *   it my be used as a function. As a function it takes a single parameter,
			 *   the JSON returned from the server, which can be manipulated as
			 *   required, with the returned value being that used by DataTables as the
			 *   data source for the table. This supersedes `sAjaxDataProp` from
			 *   DataTables 1.9-.
			 *
			 * * `success` - Should not be overridden it is used internally in
			 *   DataTables. To manipulate / transform the data returned by the server
			 *   use `ajax.dataSrc`, or use `ajax` as a function (see below).
			 *
			 * `function`
			 * ----------
			 *
			 * As a function, making the Ajax call is left up to yourself allowing
			 * complete control of the Ajax request. Indeed, if desired, a method other
			 * than Ajax could be used to obtain the required data, such as Web storage
			 * or an AIR database.
			 *
			 * The function is given four parameters and no return is required. The
			 * parameters are:
			 *
			 * 1. _object_ - Data to send to the server
			 * 2. _function_ - Callback function that must be executed when the required
			 *    data has been obtained. That data should be passed into the callback
			 *    as the only parameter
			 * 3. _object_ - DataTables settings object for the table
			 *
			 * Note that this supersedes `fnServerData` from DataTables 1.9-.
			 *
			 *  @type string|object|function
			 *  @default null
			 *
			 *  @dtopt Option
			 *  @name DataTable.defaults.ajax
			 *  @since 1.10.0
			 *
			 * @example
			 *   // Get JSON data from a file via Ajax.
			 *   // Note DataTables expects data in the form `{ data: [ ...data... ] }` by default).
			 *   $('#example').dataTable( {
			 *     "ajax": "data.json"
			 *   } );
			 *
			 * @example
			 *   // Get JSON data from a file via Ajax, using `dataSrc` to change
			 *   // `data` to `tableData` (i.e. `{ tableData: [ ...data... ] }`)
			 *   $('#example').dataTable( {
			 *     "ajax": {
			 *       "url": "data.json",
			 *       "dataSrc": "tableData"
			 *     }
			 *   } );
			 *
			 * @example
			 *   // Get JSON data from a file via Ajax, using `dataSrc` to read data
			 *   // from a plain array rather than an array in an object
			 *   $('#example').dataTable( {
			 *     "ajax": {
			 *       "url": "data.json",
			 *       "dataSrc": ""
			 *     }
			 *   } );
			 *
			 * @example
			 *   // Manipulate the data returned from the server - add a link to data
			 *   // (note this can, should, be done using `render` for the column - this
			 *   // is just a simple example of how the data can be manipulated).
			 *   $('#example').dataTable( {
			 *     "ajax": {
			 *       "url": "data.json",
			 *       "dataSrc": function ( json ) {
			 *         for ( var i=0, ien=json.length ; i<ien ; i++ ) {
			 *           json[i][0] = '<a href="/message/'+json[i][0]+'>View message</a>';
			 *         }
			 *         return json;
			 *       }
			 *     }
			 *   } );
			 *
			 * @example
			 *   // Add data to the request
			 *   $('#example').dataTable( {
			 *     "ajax": {
			 *       "url": "data.json",
			 *       "data": function ( d ) {
			 *         return {
			 *           "extra_search": $('#extra').val()
			 *         };
			 *       }
			 *     }
			 *   } );
			 *
			 * @example
			 *   // Send request as POST
			 *   $('#example').dataTable( {
			 *     "ajax": {
			 *       "url": "data.json",
			 *       "type": "POST"
			 *     }
			 *   } );
			 *
			 * @example
			 *   // Get the data from localStorage (could interface with a form for
			 *   // adding, editing and removing rows).
			 *   $('#example').dataTable( {
			 *     "ajax": function (data, callback, settings) {
			 *       callback(
			 *         JSON.parse( localStorage.getItem('dataTablesData') )
			 *       );
			 *     }
			 *   } );
			 */
			"ajax": null,
		
		
			/**
			 * This parameter allows you to readily specify the entries in the length drop
			 * down menu that DataTables shows when pagination is enabled. It can be
			 * either a 1D array of options which will be used for both the displayed
			 * option and the value, or a 2D array which will use the array in the first
			 * position as the value, and the array in the second position as the
			 * displayed options (useful for language strings such as 'All').
			 *
			 * Note that the `pageLength` property will be automatically set to the
			 * first value given in this array, unless `pageLength` is also provided.
			 *  @type array
			 *  @default [ 10, 25, 50, 100 ]
			 *
			 *  @dtopt Option
			 *  @name DataTable.defaults.lengthMenu
			 *
			 *  @example
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "lengthMenu": [[10, 25, 50, -1], [10, 25, 50, "All"]]
			 *      } );
			 *    } );
			 */
			"aLengthMenu": [ 10, 25, 50, 100 ],
		
		
			/**
			 * The `columns` option in the initialisation parameter allows you to define
			 * details about the way individual columns behave. For a full list of
			 * column options that can be set, please see
			 * {@link DataTable.defaults.column}. Note that if you use `columns` to
			 * define your columns, you must have an entry in the array for every single
			 * column that you have in your table (these can be null if you don't which
			 * to specify any options).
			 *  @member
			 *
			 *  @name DataTable.defaults.column
			 */
			"aoColumns": null,
		
			/**
			 * Very similar to `columns`, `columnDefs` allows you to target a specific
			 * column, multiple columns, or all columns, using the `targets` property of
			 * each object in the array. This allows great flexibility when creating
			 * tables, as the `columnDefs` arrays can be of any length, targeting the
			 * columns you specifically want. `columnDefs` may use any of the column
			 * options available: {@link DataTable.defaults.column}, but it _must_
			 * have `targets` defined in each object in the array. Values in the `targets`
			 * array may be:
			 *   <ul>
			 *     <li>a string - class name will be matched on the TH for the column</li>
			 *     <li>0 or a positive integer - column index counting from the left</li>
			 *     <li>a negative integer - column index counting from the right</li>
			 *     <li>the string "_all" - all columns (i.e. assign a default)</li>
			 *   </ul>
			 *  @member
			 *
			 *  @name DataTable.defaults.columnDefs
			 */
			"aoColumnDefs": null,
		
		
			/**
			 * Basically the same as `search`, this parameter defines the individual column
			 * filtering state at initialisation time. The array must be of the same size
			 * as the number of columns, and each element be an object with the parameters
			 * `search` and `escapeRegex` (the latter is optional). 'null' is also
			 * accepted and the default will be used.
			 *  @type array
			 *  @default []
			 *
			 *  @dtopt Option
			 *  @name DataTable.defaults.searchCols
			 *
			 *  @example
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "searchCols": [
			 *          null,
			 *          { "search": "My filter" },
			 *          null,
			 *          { "search": "^[0-9]", "escapeRegex": false }
			 *        ]
			 *      } );
			 *    } )
			 */
			"aoSearchCols": [],
		
		
			/**
			 * An array of CSS classes that should be applied to displayed rows. This
			 * array may be of any length, and DataTables will apply each class
			 * sequentially, looping when required.
			 *  @type array
			 *  @default null <i>Will take the values determined by the `oClasses.stripe*`
			 *    options</i>
			 *
			 *  @dtopt Option
			 *  @name DataTable.defaults.stripeClasses
			 *
			 *  @example
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "stripeClasses": [ 'strip1', 'strip2', 'strip3' ]
			 *      } );
			 *    } )
			 */
			"asStripeClasses": null,
		
		
			/**
			 * Enable or disable automatic column width calculation. This can be disabled
			 * as an optimisation (it takes some time to calculate the widths) if the
			 * tables widths are passed in using `columns`.
			 *  @type boolean
			 *  @default true
			 *
			 *  @dtopt Features
			 *  @name DataTable.defaults.autoWidth
			 *
			 *  @example
			 *    $(document).ready( function () {
			 *      $('#example').dataTable( {
			 *        "autoWidth": false
			 *      } );
			 *    } );
			 */
			"bAutoWidth": true,
		
		
			/**
			 * Deferred rendering can provide DataTables with a huge speed boost when you
			 * are using an Ajax or JS data source for the table. This option, when set to
			 * true, will cause DataTables to defer the creation of the table elements for
			 * each row until they are needed for a draw - saving a significant amount of
			 * time.
			 *  @type boolean
			 *  @default false
			 *
			 *  @dtopt Features
			 *  @name DataTable.defaults.deferRender
			 *
			 *  @example
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "ajax": "sources/arrays.txt",
			 *        "deferRender": true
			 *      } );
			 *    } );
			 */
			"bDeferRender": false,
		
		
			/**
			 * Replace a DataTable which matches the given selector and replace it with
			 * one which has the properties of the new initialisation object passed. If no
			 * table matches the selector, then the new DataTable will be constructed as
			 * per normal.
			 *  @type boolean
			 *  @default false
			 *
			 *  @dtopt Options
			 *  @name DataTable.defaults.destroy
			 *
			 *  @example
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "srollY": "200px",
			 *        "paginate": false
			 *      } );
			 *
			 *      // Some time later....
			 *      $('#example').dataTable( {
			 *        "filter": false,
			 *        "destroy": true
			 *      } );
			 *    } );
			 */
			"bDestroy": false,
		
		
			/**
			 * Enable or disable filtering of data. Filtering in DataTables is "smart" in
			 * that it allows the end user to input multiple words (space separated) and
			 * will match a row containing those words, even if not in the order that was
			 * specified (this allow matching across multiple columns). Note that if you
			 * wish to use filtering in DataTables this must remain 'true' - to remove the
			 * default filtering input box and retain filtering abilities, please use
			 * {@link DataTable.defaults.dom}.
			 *  @type boolean
			 *  @default true
			 *
			 *  @dtopt Features
			 *  @name DataTable.defaults.searching
			 *
			 *  @example
			 *    $(document).ready( function () {
			 *      $('#example').dataTable( {
			 *        "searching": false
			 *      } );
			 *    } );
			 */
			"bFilter": true,
		
		
			/**
			 * Enable or disable the table information display. This shows information
			 * about the data that is currently visible on the page, including information
			 * about filtered data if that action is being performed.
			 *  @type boolean
			 *  @default true
			 *
			 *  @dtopt Features
			 *  @name DataTable.defaults.info
			 *
			 *  @example
			 *    $(document).ready( function () {
			 *      $('#example').dataTable( {
			 *        "info": false
			 *      } );
			 *    } );
			 */
			"bInfo": true,
		
		
			/**
			 * Enable jQuery UI ThemeRoller support (required as ThemeRoller requires some
			 * slightly different and additional mark-up from what DataTables has
			 * traditionally used).
			 *  @type boolean
			 *  @default false
			 *
			 *  @dtopt Features
			 *  @name DataTable.defaults.jQueryUI
			 *
			 *  @example
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "jQueryUI": true
			 *      } );
			 *    } );
			 */
			"bJQueryUI": false,
		
		
			/**
			 * Allows the end user to select the size of a formatted page from a select
			 * menu (sizes are 10, 25, 50 and 100). Requires pagination (`paginate`).
			 *  @type boolean
			 *  @default true
			 *
			 *  @dtopt Features
			 *  @name DataTable.defaults.lengthChange
			 *
			 *  @example
			 *    $(document).ready( function () {
			 *      $('#example').dataTable( {
			 *        "lengthChange": false
			 *      } );
			 *    } );
			 */
			"bLengthChange": true,
		
		
			/**
			 * Enable or disable pagination.
			 *  @type boolean
			 *  @default true
			 *
			 *  @dtopt Features
			 *  @name DataTable.defaults.paging
			 *
			 *  @example
			 *    $(document).ready( function () {
			 *      $('#example').dataTable( {
			 *        "paging": false
			 *      } );
			 *    } );
			 */
			"bPaginate": true,
		
		
			/**
			 * Enable or disable the display of a 'processing' indicator when the table is
			 * being processed (e.g. a sort). This is particularly useful for tables with
			 * large amounts of data where it can take a noticeable amount of time to sort
			 * the entries.
			 *  @type boolean
			 *  @default false
			 *
			 *  @dtopt Features
			 *  @name DataTable.defaults.processing
			 *
			 *  @example
			 *    $(document).ready( function () {
			 *      $('#example').dataTable( {
			 *        "processing": true
			 *      } );
			 *    } );
			 */
			"bProcessing": false,
		
		
			/**
			 * Retrieve the DataTables object for the given selector. Note that if the
			 * table has already been initialised, this parameter will cause DataTables
			 * to simply return the object that has already been set up - it will not take
			 * account of any changes you might have made to the initialisation object
			 * passed to DataTables (setting this parameter to true is an acknowledgement
			 * that you understand this). `destroy` can be used to reinitialise a table if
			 * you need.
			 *  @type boolean
			 *  @default false
			 *
			 *  @dtopt Options
			 *  @name DataTable.defaults.retrieve
			 *
			 *  @example
			 *    $(document).ready( function() {
			 *      initTable();
			 *      tableActions();
			 *    } );
			 *
			 *    function initTable ()
			 *    {
			 *      return $('#example').dataTable( {
			 *        "scrollY": "200px",
			 *        "paginate": false,
			 *        "retrieve": true
			 *      } );
			 *    }
			 *
			 *    function tableActions ()
			 *    {
			 *      var table = initTable();
			 *      // perform API operations with oTable
			 *    }
			 */
			"bRetrieve": false,
		
		
			/**
			 * When vertical (y) scrolling is enabled, DataTables will force the height of
			 * the table's viewport to the given height at all times (useful for layout).
			 * However, this can look odd when filtering data down to a small data set,
			 * and the footer is left "floating" further down. This parameter (when
			 * enabled) will cause DataTables to collapse the table's viewport down when
			 * the result set will fit within the given Y height.
			 *  @type boolean
			 *  @default false
			 *
			 *  @dtopt Options
			 *  @name DataTable.defaults.scrollCollapse
			 *
			 *  @example
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "scrollY": "200",
			 *        "scrollCollapse": true
			 *      } );
			 *    } );
			 */
			"bScrollCollapse": false,
		
		
			/**
			 * Configure DataTables to use server-side processing. Note that the
			 * `ajax` parameter must also be given in order to give DataTables a
			 * source to obtain the required data for each draw.
			 *  @type boolean
			 *  @default false
			 *
			 *  @dtopt Features
			 *  @dtopt Server-side
			 *  @name DataTable.defaults.serverSide
			 *
			 *  @example
			 *    $(document).ready( function () {
			 *      $('#example').dataTable( {
			 *        "serverSide": true,
			 *        "ajax": "xhr.php"
			 *      } );
			 *    } );
			 */
			"bServerSide": false,
		
		
			/**
			 * Enable or disable sorting of columns. Sorting of individual columns can be
			 * disabled by the `sortable` option for each column.
			 *  @type boolean
			 *  @default true
			 *
			 *  @dtopt Features
			 *  @name DataTable.defaults.ordering
			 *
			 *  @example
			 *    $(document).ready( function () {
			 *      $('#example').dataTable( {
			 *        "ordering": false
			 *      } );
			 *    } );
			 */
			"bSort": true,
		
		
			/**
			 * Enable or display DataTables' ability to sort multiple columns at the
			 * same time (activated by shift-click by the user).
			 *  @type boolean
			 *  @default true
			 *
			 *  @dtopt Options
			 *  @name DataTable.defaults.orderMulti
			 *
			 *  @example
			 *    // Disable multiple column sorting ability
			 *    $(document).ready( function () {
			 *      $('#example').dataTable( {
			 *        "orderMulti": false
			 *      } );
			 *    } );
			 */
			"bSortMulti": true,
		
		
			/**
			 * Allows control over whether DataTables should use the top (true) unique
			 * cell that is found for a single column, or the bottom (false - default).
			 * This is useful when using complex headers.
			 *  @type boolean
			 *  @default false
			 *
			 *  @dtopt Options
			 *  @name DataTable.defaults.orderCellsTop
			 *
			 *  @example
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "orderCellsTop": true
			 *      } );
			 *    } );
			 */
			"bSortCellsTop": false,
		
		
			/**
			 * Enable or disable the addition of the classes `sorting\_1`, `sorting\_2` and
			 * `sorting\_3` to the columns which are currently being sorted on. This is
			 * presented as a feature switch as it can increase processing time (while
			 * classes are removed and added) so for large data sets you might want to
			 * turn this off.
			 *  @type boolean
			 *  @default true
			 *
			 *  @dtopt Features
			 *  @name DataTable.defaults.orderClasses
			 *
			 *  @example
			 *    $(document).ready( function () {
			 *      $('#example').dataTable( {
			 *        "orderClasses": false
			 *      } );
			 *    } );
			 */
			"bSortClasses": true,
		
		
			/**
			 * Enable or disable state saving. When enabled HTML5 `localStorage` will be
			 * used to save table display information such as pagination information,
			 * display length, filtering and sorting. As such when the end user reloads
			 * the page the display display will match what thy had previously set up.
			 *
			 * Due to the use of `localStorage` the default state saving is not supported
			 * in IE6 or 7. If state saving is required in those browsers, use
			 * `stateSaveCallback` to provide a storage solution such as cookies.
			 *  @type boolean
			 *  @default false
			 *
			 *  @dtopt Features
			 *  @name DataTable.defaults.stateSave
			 *
			 *  @example
			 *    $(document).ready( function () {
			 *      $('#example').dataTable( {
			 *        "stateSave": true
			 *      } );
			 *    } );
			 */
			"bStateSave": false,
		
		
			/**
			 * This function is called when a TR element is created (and all TD child
			 * elements have been inserted), or registered if using a DOM source, allowing
			 * manipulation of the TR element (adding classes etc).
			 *  @type function
			 *  @param {node} row "TR" element for the current row
			 *  @param {array} data Raw data array for this row
			 *  @param {int} dataIndex The index of this row in the internal aoData array
			 *
			 *  @dtopt Callbacks
			 *  @name DataTable.defaults.createdRow
			 *
			 *  @example
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "createdRow": function( row, data, dataIndex ) {
			 *          // Bold the grade for all 'A' grade browsers
			 *          if ( data[4] == "A" )
			 *          {
			 *            $('td:eq(4)', row).html( '<b>A</b>' );
			 *          }
			 *        }
			 *      } );
			 *    } );
			 */
			"fnCreatedRow": null,
		
		
			/**
			 * This function is called on every 'draw' event, and allows you to
			 * dynamically modify any aspect you want about the created DOM.
			 *  @type function
			 *  @param {object} settings DataTables settings object
			 *
			 *  @dtopt Callbacks
			 *  @name DataTable.defaults.drawCallback
			 *
			 *  @example
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "drawCallback": function( settings ) {
			 *          alert( 'DataTables has redrawn the table' );
			 *        }
			 *      } );
			 *    } );
			 */
			"fnDrawCallback": null,
		
		
			/**
			 * Identical to fnHeaderCallback() but for the table footer this function
			 * allows you to modify the table footer on every 'draw' event.
			 *  @type function
			 *  @param {node} foot "TR" element for the footer
			 *  @param {array} data Full table data (as derived from the original HTML)
			 *  @param {int} start Index for the current display starting point in the
			 *    display array
			 *  @param {int} end Index for the current display ending point in the
			 *    display array
			 *  @param {array int} display Index array to translate the visual position
			 *    to the full data array
			 *
			 *  @dtopt Callbacks
			 *  @name DataTable.defaults.footerCallback
			 *
			 *  @example
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "footerCallback": function( tfoot, data, start, end, display ) {
			 *          tfoot.getElementsByTagName('th')[0].innerHTML = "Starting index is "+start;
			 *        }
			 *      } );
			 *    } )
			 */
			"fnFooterCallback": null,
		
		
			/**
			 * When rendering large numbers in the information element for the table
			 * (i.e. "Showing 1 to 10 of 57 entries") DataTables will render large numbers
			 * to have a comma separator for the 'thousands' units (e.g. 1 million is
			 * rendered as "1,000,000") to help readability for the end user. This
			 * function will override the default method DataTables uses.
			 *  @type function
			 *  @member
			 *  @param {int} toFormat number to be formatted
			 *  @returns {string} formatted string for DataTables to show the number
			 *
			 *  @dtopt Callbacks
			 *  @name DataTable.defaults.formatNumber
			 *
			 *  @example
			 *    // Format a number using a single quote for the separator (note that
			 *    // this can also be done with the language.thousands option)
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "formatNumber": function ( toFormat ) {
			 *          return toFormat.toString().replace(
			 *            /\B(?=(\d{3})+(?!\d))/g, "'"
			 *          );
			 *        };
			 *      } );
			 *    } );
			 */
			"fnFormatNumber": function ( toFormat ) {
				return toFormat.toString().replace(
					/\B(?=(\d{3})+(?!\d))/g,
					this.oLanguage.sThousands
				);
			},
		
		
			/**
			 * This function is called on every 'draw' event, and allows you to
			 * dynamically modify the header row. This can be used to calculate and
			 * display useful information about the table.
			 *  @type function
			 *  @param {node} head "TR" element for the header
			 *  @param {array} data Full table data (as derived from the original HTML)
			 *  @param {int} start Index for the current display starting point in the
			 *    display array
			 *  @param {int} end Index for the current display ending point in the
			 *    display array
			 *  @param {array int} display Index array to translate the visual position
			 *    to the full data array
			 *
			 *  @dtopt Callbacks
			 *  @name DataTable.defaults.headerCallback
			 *
			 *  @example
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "fheaderCallback": function( head, data, start, end, display ) {
			 *          head.getElementsByTagName('th')[0].innerHTML = "Displaying "+(end-start)+" records";
			 *        }
			 *      } );
			 *    } )
			 */
			"fnHeaderCallback": null,
		
		
			/**
			 * The information element can be used to convey information about the current
			 * state of the table. Although the internationalisation options presented by
			 * DataTables are quite capable of dealing with most customisations, there may
			 * be times where you wish to customise the string further. This callback
			 * allows you to do exactly that.
			 *  @type function
			 *  @param {object} oSettings DataTables settings object
			 *  @param {int} start Starting position in data for the draw
			 *  @param {int} end End position in data for the draw
			 *  @param {int} max Total number of rows in the table (regardless of
			 *    filtering)
			 *  @param {int} total Total number of rows in the data set, after filtering
			 *  @param {string} pre The string that DataTables has formatted using it's
			 *    own rules
			 *  @returns {string} The string to be displayed in the information element.
			 *
			 *  @dtopt Callbacks
			 *  @name DataTable.defaults.infoCallback
			 *
			 *  @example
			 *    $('#example').dataTable( {
			 *      "infoCallback": function( settings, start, end, max, total, pre ) {
			 *        return start +" to "+ end;
			 *      }
			 *    } );
			 */
			"fnInfoCallback": null,
		
		
			/**
			 * Called when the table has been initialised. Normally DataTables will
			 * initialise sequentially and there will be no need for this function,
			 * however, this does not hold true when using external language information
			 * since that is obtained using an async XHR call.
			 *  @type function
			 *  @param {object} settings DataTables settings object
			 *  @param {object} json The JSON object request from the server - only
			 *    present if client-side Ajax sourced data is used
			 *
			 *  @dtopt Callbacks
			 *  @name DataTable.defaults.initComplete
			 *
			 *  @example
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "initComplete": function(settings, json) {
			 *          alert( 'DataTables has finished its initialisation.' );
			 *        }
			 *      } );
			 *    } )
			 */
			"fnInitComplete": null,
		
		
			/**
			 * Called at the very start of each table draw and can be used to cancel the
			 * draw by returning false, any other return (including undefined) results in
			 * the full draw occurring).
			 *  @type function
			 *  @param {object} settings DataTables settings object
			 *  @returns {boolean} False will cancel the draw, anything else (including no
			 *    return) will allow it to complete.
			 *
			 *  @dtopt Callbacks
			 *  @name DataTable.defaults.preDrawCallback
			 *
			 *  @example
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "preDrawCallback": function( settings ) {
			 *          if ( $('#test').val() == 1 ) {
			 *            return false;
			 *          }
			 *        }
			 *      } );
			 *    } );
			 */
			"fnPreDrawCallback": null,
		
		
			/**
			 * This function allows you to 'post process' each row after it have been
			 * generated for each table draw, but before it is rendered on screen. This
			 * function might be used for setting the row class name etc.
			 *  @type function
			 *  @param {node} row "TR" element for the current row
			 *  @param {array} data Raw data array for this row
			 *  @param {int} displayIndex The display index for the current table draw
			 *  @param {int} displayIndexFull The index of the data in the full list of
			 *    rows (after filtering)
			 *
			 *  @dtopt Callbacks
			 *  @name DataTable.defaults.rowCallback
			 *
			 *  @example
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "rowCallback": function( row, data, displayIndex, displayIndexFull ) {
			 *          // Bold the grade for all 'A' grade browsers
			 *          if ( data[4] == "A" ) {
			 *            $('td:eq(4)', row).html( '<b>A</b>' );
			 *          }
			 *        }
			 *      } );
			 *    } );
			 */
			"fnRowCallback": null,
		
		
			/**
			 * __Deprecated__ The functionality provided by this parameter has now been
			 * superseded by that provided through `ajax`, which should be used instead.
			 *
			 * This parameter allows you to override the default function which obtains
			 * the data from the server so something more suitable for your application.
			 * For example you could use POST data, or pull information from a Gears or
			 * AIR database.
			 *  @type function
			 *  @member
			 *  @param {string} source HTTP source to obtain the data from (`ajax`)
			 *  @param {array} data A key/value pair object containing the data to send
			 *    to the server
			 *  @param {function} callback to be called on completion of the data get
			 *    process that will draw the data on the page.
			 *  @param {object} settings DataTables settings object
			 *
			 *  @dtopt Callbacks
			 *  @dtopt Server-side
			 *  @name DataTable.defaults.serverData
			 *
			 *  @deprecated 1.10. Please use `ajax` for this functionality now.
			 */
			"fnServerData": null,
		
		
			/**
			 * __Deprecated__ The functionality provided by this parameter has now been
			 * superseded by that provided through `ajax`, which should be used instead.
			 *
			 *  It is often useful to send extra data to the server when making an Ajax
			 * request - for example custom filtering information, and this callback
			 * function makes it trivial to send extra information to the server. The
			 * passed in parameter is the data set that has been constructed by
			 * DataTables, and you can add to this or modify it as you require.
			 *  @type function
			 *  @param {array} data Data array (array of objects which are name/value
			 *    pairs) that has been constructed by DataTables and will be sent to the
			 *    server. In the case of Ajax sourced data with server-side processing
			 *    this will be an empty array, for server-side processing there will be a
			 *    significant number of parameters!
			 *  @returns {undefined} Ensure that you modify the data array passed in,
			 *    as this is passed by reference.
			 *
			 *  @dtopt Callbacks
			 *  @dtopt Server-side
			 *  @name DataTable.defaults.serverParams
			 *
			 *  @deprecated 1.10. Please use `ajax` for this functionality now.
			 */
			"fnServerParams": null,
		
		
			/**
			 * Load the table state. With this function you can define from where, and how, the
			 * state of a table is loaded. By default DataTables will load from `localStorage`
			 * but you might wish to use a server-side database or cookies.
			 *  @type function
			 *  @member
			 *  @param {object} settings DataTables settings object
			 *  @return {object} The DataTables state object to be loaded
			 *
			 *  @dtopt Callbacks
			 *  @name DataTable.defaults.stateLoadCallback
			 *
			 *  @example
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "stateSave": true,
			 *        "stateLoadCallback": function (settings) {
			 *          var o;
			 *
			 *          // Send an Ajax request to the server to get the data. Note that
			 *          // this is a synchronous request.
			 *          $.ajax( {
			 *            "url": "/state_load",
			 *            "async": false,
			 *            "dataType": "json",
			 *            "success": function (json) {
			 *              o = json;
			 *            }
			 *          } );
			 *
			 *          return o;
			 *        }
			 *      } );
			 *    } );
			 */
			"fnStateLoadCallback": function ( settings ) {
				try {
					return JSON.parse(
						(settings.iStateDuration === -1 ? sessionStorage : localStorage).getItem(
							'DataTables_'+settings.sInstance+'_'+location.pathname
						)
					);
				} catch (e) {}
			},
		
		
			/**
			 * Callback which allows modification of the saved state prior to loading that state.
			 * This callback is called when the table is loading state from the stored data, but
			 * prior to the settings object being modified by the saved state. Note that for
			 * plug-in authors, you should use the `stateLoadParams` event to load parameters for
			 * a plug-in.
			 *  @type function
			 *  @param {object} settings DataTables settings object
			 *  @param {object} data The state object that is to be loaded
			 *
			 *  @dtopt Callbacks
			 *  @name DataTable.defaults.stateLoadParams
			 *
			 *  @example
			 *    // Remove a saved filter, so filtering is never loaded
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "stateSave": true,
			 *        "stateLoadParams": function (settings, data) {
			 *          data.oSearch.sSearch = "";
			 *        }
			 *      } );
			 *    } );
			 *
			 *  @example
			 *    // Disallow state loading by returning false
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "stateSave": true,
			 *        "stateLoadParams": function (settings, data) {
			 *          return false;
			 *        }
			 *      } );
			 *    } );
			 */
			"fnStateLoadParams": null,
		
		
			/**
			 * Callback that is called when the state has been loaded from the state saving method
			 * and the DataTables settings object has been modified as a result of the loaded state.
			 *  @type function
			 *  @param {object} settings DataTables settings object
			 *  @param {object} data The state object that was loaded
			 *
			 *  @dtopt Callbacks
			 *  @name DataTable.defaults.stateLoaded
			 *
			 *  @example
			 *    // Show an alert with the filtering value that was saved
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "stateSave": true,
			 *        "stateLoaded": function (settings, data) {
			 *          alert( 'Saved filter was: '+data.oSearch.sSearch );
			 *        }
			 *      } );
			 *    } );
			 */
			"fnStateLoaded": null,
		
		
			/**
			 * Save the table state. This function allows you to define where and how the state
			 * information for the table is stored By default DataTables will use `localStorage`
			 * but you might wish to use a server-side database or cookies.
			 *  @type function
			 *  @member
			 *  @param {object} settings DataTables settings object
			 *  @param {object} data The state object to be saved
			 *
			 *  @dtopt Callbacks
			 *  @name DataTable.defaults.stateSaveCallback
			 *
			 *  @example
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "stateSave": true,
			 *        "stateSaveCallback": function (settings, data) {
			 *          // Send an Ajax request to the server with the state object
			 *          $.ajax( {
			 *            "url": "/state_save",
			 *            "data": data,
			 *            "dataType": "json",
			 *            "method": "POST"
			 *            "success": function () {}
			 *          } );
			 *        }
			 *      } );
			 *    } );
			 */
			"fnStateSaveCallback": function ( settings, data ) {
				try {
					(settings.iStateDuration === -1 ? sessionStorage : localStorage).setItem(
						'DataTables_'+settings.sInstance+'_'+location.pathname,
						JSON.stringify( data )
					);
				} catch (e) {}
			},
		
		
			/**
			 * Callback which allows modification of the state to be saved. Called when the table
			 * has changed state a new state save is required. This method allows modification of
			 * the state saving object prior to actually doing the save, including addition or
			 * other state properties or modification. Note that for plug-in authors, you should
			 * use the `stateSaveParams` event to save parameters for a plug-in.
			 *  @type function
			 *  @param {object} settings DataTables settings object
			 *  @param {object} data The state object to be saved
			 *
			 *  @dtopt Callbacks
			 *  @name DataTable.defaults.stateSaveParams
			 *
			 *  @example
			 *    // Remove a saved filter, so filtering is never saved
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "stateSave": true,
			 *        "stateSaveParams": function (settings, data) {
			 *          data.oSearch.sSearch = "";
			 *        }
			 *      } );
			 *    } );
			 */
			"fnStateSaveParams": null,
		
		
			/**
			 * Duration for which the saved state information is considered valid. After this period
			 * has elapsed the state will be returned to the default.
			 * Value is given in seconds.
			 *  @type int
			 *  @default 7200 <i>(2 hours)</i>
			 *
			 *  @dtopt Options
			 *  @name DataTable.defaults.stateDuration
			 *
			 *  @example
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "stateDuration": 60*60*24; // 1 day
			 *      } );
			 *    } )
			 */
			"iStateDuration": 7200,
		
		
			/**
			 * When enabled DataTables will not make a request to the server for the first
			 * page draw - rather it will use the data already on the page (no sorting etc
			 * will be applied to it), thus saving on an XHR at load time. `deferLoading`
			 * is used to indicate that deferred loading is required, but it is also used
			 * to tell DataTables how many records there are in the full table (allowing
			 * the information element and pagination to be displayed correctly). In the case
			 * where a filtering is applied to the table on initial load, this can be
			 * indicated by giving the parameter as an array, where the first element is
			 * the number of records available after filtering and the second element is the
			 * number of records without filtering (allowing the table information element
			 * to be shown correctly).
			 *  @type int | array
			 *  @default null
			 *
			 *  @dtopt Options
			 *  @name DataTable.defaults.deferLoading
			 *
			 *  @example
			 *    // 57 records available in the table, no filtering applied
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "serverSide": true,
			 *        "ajax": "scripts/server_processing.php",
			 *        "deferLoading": 57
			 *      } );
			 *    } );
			 *
			 *  @example
			 *    // 57 records after filtering, 100 without filtering (an initial filter applied)
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "serverSide": true,
			 *        "ajax": "scripts/server_processing.php",
			 *        "deferLoading": [ 57, 100 ],
			 *        "search": {
			 *          "search": "my_filter"
			 *        }
			 *      } );
			 *    } );
			 */
			"iDeferLoading": null,
		
		
			/**
			 * Number of rows to display on a single page when using pagination. If
			 * feature enabled (`lengthChange`) then the end user will be able to override
			 * this to a custom setting using a pop-up menu.
			 *  @type int
			 *  @default 10
			 *
			 *  @dtopt Options
			 *  @name DataTable.defaults.pageLength
			 *
			 *  @example
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "pageLength": 50
			 *      } );
			 *    } )
			 */
			"iDisplayLength": 10,
		
		
			/**
			 * Define the starting point for data display when using DataTables with
			 * pagination. Note that this parameter is the number of records, rather than
			 * the page number, so if you have 10 records per page and want to start on
			 * the third page, it should be "20".
			 *  @type int
			 *  @default 0
			 *
			 *  @dtopt Options
			 *  @name DataTable.defaults.displayStart
			 *
			 *  @example
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "displayStart": 20
			 *      } );
			 *    } )
			 */
			"iDisplayStart": 0,
		
		
			/**
			 * By default DataTables allows keyboard navigation of the table (sorting, paging,
			 * and filtering) by adding a `tabindex` attribute to the required elements. This
			 * allows you to tab through the controls and press the enter key to activate them.
			 * The tabindex is default 0, meaning that the tab follows the flow of the document.
			 * You can overrule this using this parameter if you wish. Use a value of -1 to
			 * disable built-in keyboard navigation.
			 *  @type int
			 *  @default 0
			 *
			 *  @dtopt Options
			 *  @name DataTable.defaults.tabIndex
			 *
			 *  @example
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "tabIndex": 1
			 *      } );
			 *    } );
			 */
			"iTabIndex": 0,
		
		
			/**
			 * Classes that DataTables assigns to the various components and features
			 * that it adds to the HTML table. This allows classes to be configured
			 * during initialisation in addition to through the static
			 * {@link DataTable.ext.oStdClasses} object).
			 *  @namespace
			 *  @name DataTable.defaults.classes
			 */
			"oClasses": {},
		
		
			/**
			 * All strings that DataTables uses in the user interface that it creates
			 * are defined in this object, allowing you to modified them individually or
			 * completely replace them all as required.
			 *  @namespace
			 *  @name DataTable.defaults.language
			 */
			"oLanguage": {
				/**
				 * Strings that are used for WAI-ARIA labels and controls only (these are not
				 * actually visible on the page, but will be read by screenreaders, and thus
				 * must be internationalised as well).
				 *  @namespace
				 *  @name DataTable.defaults.language.aria
				 */
				"oAria": {
					/**
					 * ARIA label that is added to the table headers when the column may be
					 * sorted ascending by activing the column (click or return when focused).
					 * Note that the column header is prefixed to this string.
					 *  @type string
					 *  @default : activate to sort column ascending
					 *
					 *  @dtopt Language
					 *  @name DataTable.defaults.language.aria.sortAscending
					 *
					 *  @example
					 *    $(document).ready( function() {
					 *      $('#example').dataTable( {
					 *        "language": {
					 *          "aria": {
					 *            "sortAscending": " - click/return to sort ascending"
					 *          }
					 *        }
					 *      } );
					 *    } );
					 */
					"sSortAscending": ": activate to sort column ascending",
		
					/**
					 * ARIA label that is added to the table headers when the column may be
					 * sorted descending by activing the column (click or return when focused).
					 * Note that the column header is prefixed to this string.
					 *  @type string
					 *  @default : activate to sort column ascending
					 *
					 *  @dtopt Language
					 *  @name DataTable.defaults.language.aria.sortDescending
					 *
					 *  @example
					 *    $(document).ready( function() {
					 *      $('#example').dataTable( {
					 *        "language": {
					 *          "aria": {
					 *            "sortDescending": " - click/return to sort descending"
					 *          }
					 *        }
					 *      } );
					 *    } );
					 */
					"sSortDescending": ": activate to sort column descending"
				},
		
				/**
				 * Pagination string used by DataTables for the built-in pagination
				 * control types.
				 *  @namespace
				 *  @name DataTable.defaults.language.paginate
				 */
				"oPaginate": {
					/**
					 * Text to use when using the 'full_numbers' type of pagination for the
					 * button to take the user to the first page.
					 *  @type string
					 *  @default First
					 *
					 *  @dtopt Language
					 *  @name DataTable.defaults.language.paginate.first
					 *
					 *  @example
					 *    $(document).ready( function() {
					 *      $('#example').dataTable( {
					 *        "language": {
					 *          "paginate": {
					 *            "first": "First page"
					 *          }
					 *        }
					 *      } );
					 *    } );
					 */
					"sFirst": "First",
		
		
					/**
					 * Text to use when using the 'full_numbers' type of pagination for the
					 * button to take the user to the last page.
					 *  @type string
					 *  @default Last
					 *
					 *  @dtopt Language
					 *  @name DataTable.defaults.language.paginate.last
					 *
					 *  @example
					 *    $(document).ready( function() {
					 *      $('#example').dataTable( {
					 *        "language": {
					 *          "paginate": {
					 *            "last": "Last page"
					 *          }
					 *        }
					 *      } );
					 *    } );
					 */
					"sLast": "Last",
		
		
					/**
					 * Text to use for the 'next' pagination button (to take the user to the
					 * next page).
					 *  @type string
					 *  @default Next
					 *
					 *  @dtopt Language
					 *  @name DataTable.defaults.language.paginate.next
					 *
					 *  @example
					 *    $(document).ready( function() {
					 *      $('#example').dataTable( {
					 *        "language": {
					 *          "paginate": {
					 *            "next": "Next page"
					 *          }
					 *        }
					 *      } );
					 *    } );
					 */
					"sNext": "Next",
		
		
					/**
					 * Text to use for the 'previous' pagination button (to take the user to
					 * the previous page).
					 *  @type string
					 *  @default Previous
					 *
					 *  @dtopt Language
					 *  @name DataTable.defaults.language.paginate.previous
					 *
					 *  @example
					 *    $(document).ready( function() {
					 *      $('#example').dataTable( {
					 *        "language": {
					 *          "paginate": {
					 *            "previous": "Previous page"
					 *          }
					 *        }
					 *      } );
					 *    } );
					 */
					"sPrevious": "Previous"
				},
		
				/**
				 * This string is shown in preference to `zeroRecords` when the table is
				 * empty of data (regardless of filtering). Note that this is an optional
				 * parameter - if it is not given, the value of `zeroRecords` will be used
				 * instead (either the default or given value).
				 *  @type string
				 *  @default No data available in table
				 *
				 *  @dtopt Language
				 *  @name DataTable.defaults.language.emptyTable
				 *
				 *  @example
				 *    $(document).ready( function() {
				 *      $('#example').dataTable( {
				 *        "language": {
				 *          "emptyTable": "No data available in table"
				 *        }
				 *      } );
				 *    } );
				 */
				"sEmptyTable": "No data available in table",
		
		
				/**
				 * This string gives information to the end user about the information
				 * that is current on display on the page. The following tokens can be
				 * used in the string and will be dynamically replaced as the table
				 * display updates. This tokens can be placed anywhere in the string, or
				 * removed as needed by the language requires:
				 *
				 * * `\_START\_` - Display index of the first record on the current page
				 * * `\_END\_` - Display index of the last record on the current page
				 * * `\_TOTAL\_` - Number of records in the table after filtering
				 * * `\_MAX\_` - Number of records in the table without filtering
				 * * `\_PAGE\_` - Current page number
				 * * `\_PAGES\_` - Total number of pages of data in the table
				 *
				 *  @type string
				 *  @default Showing _START_ to _END_ of _TOTAL_ entries
				 *
				 *  @dtopt Language
				 *  @name DataTable.defaults.language.info
				 *
				 *  @example
				 *    $(document).ready( function() {
				 *      $('#example').dataTable( {
				 *        "language": {
				 *          "info": "Showing page _PAGE_ of _PAGES_"
				 *        }
				 *      } );
				 *    } );
				 */
				"sInfo": "Showing _START_ to _END_ of _TOTAL_ entries",
		
		
				/**
				 * Display information string for when the table is empty. Typically the
				 * format of this string should match `info`.
				 *  @type string
				 *  @default Showing 0 to 0 of 0 entries
				 *
				 *  @dtopt Language
				 *  @name DataTable.defaults.language.infoEmpty
				 *
				 *  @example
				 *    $(document).ready( function() {
				 *      $('#example').dataTable( {
				 *        "language": {
				 *          "infoEmpty": "No entries to show"
				 *        }
				 *      } );
				 *    } );
				 */
				"sInfoEmpty": "Showing 0 to 0 of 0 entries",
		
		
				/**
				 * When a user filters the information in a table, this string is appended
				 * to the information (`info`) to give an idea of how strong the filtering
				 * is. The variable _MAX_ is dynamically updated.
				 *  @type string
				 *  @default (filtered from _MAX_ total entries)
				 *
				 *  @dtopt Language
				 *  @name DataTable.defaults.language.infoFiltered
				 *
				 *  @example
				 *    $(document).ready( function() {
				 *      $('#example').dataTable( {
				 *        "language": {
				 *          "infoFiltered": " - filtering from _MAX_ records"
				 *        }
				 *      } );
				 *    } );
				 */
				"sInfoFiltered": "(filtered from _MAX_ total entries)",
		
		
				/**
				 * If can be useful to append extra information to the info string at times,
				 * and this variable does exactly that. This information will be appended to
				 * the `info` (`infoEmpty` and `infoFiltered` in whatever combination they are
				 * being used) at all times.
				 *  @type string
				 *  @default <i>Empty string</i>
				 *
				 *  @dtopt Language
				 *  @name DataTable.defaults.language.infoPostFix
				 *
				 *  @example
				 *    $(document).ready( function() {
				 *      $('#example').dataTable( {
				 *        "language": {
				 *          "infoPostFix": "All records shown are derived from real information."
				 *        }
				 *      } );
				 *    } );
				 */
				"sInfoPostFix": "",
		
		
				/**
				 * This decimal place operator is a little different from the other
				 * language options since DataTables doesn't output floating point
				 * numbers, so it won't ever use this for display of a number. Rather,
				 * what this parameter does is modify the sort methods of the table so
				 * that numbers which are in a format which has a character other than
				 * a period (`.`) as a decimal place will be sorted numerically.
				 *
				 * Note that numbers with different decimal places cannot be shown in
				 * the same table and still be sortable, the table must be consistent.
				 * However, multiple different tables on the page can use different
				 * decimal place characters.
				 *  @type string
				 *  @default 
				 *
				 *  @dtopt Language
				 *  @name DataTable.defaults.language.decimal
				 *
				 *  @example
				 *    $(document).ready( function() {
				 *      $('#example').dataTable( {
				 *        "language": {
				 *          "decimal": ","
				 *          "thousands": "."
				 *        }
				 *      } );
				 *    } );
				 */
				"sDecimal": "",
		
		
				/**
				 * DataTables has a build in number formatter (`formatNumber`) which is
				 * used to format large numbers that are used in the table information.
				 * By default a comma is used, but this can be trivially changed to any
				 * character you wish with this parameter.
				 *  @type string
				 *  @default ,
				 *
				 *  @dtopt Language
				 *  @name DataTable.defaults.language.thousands
				 *
				 *  @example
				 *    $(document).ready( function() {
				 *      $('#example').dataTable( {
				 *        "language": {
				 *          "thousands": "'"
				 *        }
				 *      } );
				 *    } );
				 */
				"sThousands": ",",
		
		
				/**
				 * Detail the action that will be taken when the drop down menu for the
				 * pagination length option is changed. The '_MENU_' variable is replaced
				 * with a default select list of 10, 25, 50 and 100, and can be replaced
				 * with a custom select box if required.
				 *  @type string
				 *  @default Show _MENU_ entries
				 *
				 *  @dtopt Language
				 *  @name DataTable.defaults.language.lengthMenu
				 *
				 *  @example
				 *    // Language change only
				 *    $(document).ready( function() {
				 *      $('#example').dataTable( {
				 *        "language": {
				 *          "lengthMenu": "Display _MENU_ records"
				 *        }
				 *      } );
				 *    } );
				 *
				 *  @example
				 *    // Language and options change
				 *    $(document).ready( function() {
				 *      $('#example').dataTable( {
				 *        "language": {
				 *          "lengthMenu": 'Display <select>'+
				 *            '<option value="10">10</option>'+
				 *            '<option value="20">20</option>'+
				 *            '<option value="30">30</option>'+
				 *            '<option value="40">40</option>'+
				 *            '<option value="50">50</option>'+
				 *            '<option value="-1">All</option>'+
				 *            '</select> records'
				 *        }
				 *      } );
				 *    } );
				 */
				"sLengthMenu": "Show _MENU_ entries",
		
		
				/**
				 * When using Ajax sourced data and during the first draw when DataTables is
				 * gathering the data, this message is shown in an empty row in the table to
				 * indicate to the end user the the data is being loaded. Note that this
				 * parameter is not used when loading data by server-side processing, just
				 * Ajax sourced data with client-side processing.
				 *  @type string
				 *  @default Loading...
				 *
				 *  @dtopt Language
				 *  @name DataTable.defaults.language.loadingRecords
				 *
				 *  @example
				 *    $(document).ready( function() {
				 *      $('#example').dataTable( {
				 *        "language": {
				 *          "loadingRecords": "Please wait - loading..."
				 *        }
				 *      } );
				 *    } );
				 */
				"sLoadingRecords": "Loading...",
		
		
				/**
				 * Text which is displayed when the table is processing a user action
				 * (usually a sort command or similar).
				 *  @type string
				 *  @default Processing...
				 *
				 *  @dtopt Language
				 *  @name DataTable.defaults.language.processing
				 *
				 *  @example
				 *    $(document).ready( function() {
				 *      $('#example').dataTable( {
				 *        "language": {
				 *          "processing": "DataTables is currently busy"
				 *        }
				 *      } );
				 *    } );
				 */
				"sProcessing": "Processing...",
		
		
				/**
				 * Details the actions that will be taken when the user types into the
				 * filtering input text box. The variable "_INPUT_", if used in the string,
				 * is replaced with the HTML text box for the filtering input allowing
				 * control over where it appears in the string. If "_INPUT_" is not given
				 * then the input box is appended to the string automatically.
				 *  @type string
				 *  @default Search:
				 *
				 *  @dtopt Language
				 *  @name DataTable.defaults.language.search
				 *
				 *  @example
				 *    // Input text box will be appended at the end automatically
				 *    $(document).ready( function() {
				 *      $('#example').dataTable( {
				 *        "language": {
				 *          "search": "Filter records:"
				 *        }
				 *      } );
				 *    } );
				 *
				 *  @example
				 *    // Specify where the filter should appear
				 *    $(document).ready( function() {
				 *      $('#example').dataTable( {
				 *        "language": {
				 *          "search": "Apply filter _INPUT_ to table"
				 *        }
				 *      } );
				 *    } );
				 */
				"sSearch": "Search:",
		
		
				/**
				 * Assign a `placeholder` attribute to the search `input` element
				 *  @type string
				 *  @default 
				 *
				 *  @dtopt Language
				 *  @name DataTable.defaults.language.searchPlaceholder
				 */
				"sSearchPlaceholder": "",
		
		
				/**
				 * All of the language information can be stored in a file on the
				 * server-side, which DataTables will look up if this parameter is passed.
				 * It must store the URL of the language file, which is in a JSON format,
				 * and the object has the same properties as the oLanguage object in the
				 * initialiser object (i.e. the above parameters). Please refer to one of
				 * the example language files to see how this works in action.
				 *  @type string
				 *  @default <i>Empty string - i.e. disabled</i>
				 *
				 *  @dtopt Language
				 *  @name DataTable.defaults.language.url
				 *
				 *  @example
				 *    $(document).ready( function() {
				 *      $('#example').dataTable( {
				 *        "language": {
				 *          "url": "http://www.sprymedia.co.uk/dataTables/lang.txt"
				 *        }
				 *      } );
				 *    } );
				 */
				"sUrl": "",
		
		
				/**
				 * Text shown inside the table records when the is no information to be
				 * displayed after filtering. `emptyTable` is shown when there is simply no
				 * information in the table at all (regardless of filtering).
				 *  @type string
				 *  @default No matching records found
				 *
				 *  @dtopt Language
				 *  @name DataTable.defaults.language.zeroRecords
				 *
				 *  @example
				 *    $(document).ready( function() {
				 *      $('#example').dataTable( {
				 *        "language": {
				 *          "zeroRecords": "No records to display"
				 *        }
				 *      } );
				 *    } );
				 */
				"sZeroRecords": "No matching records found"
			},
		
		
			/**
			 * This parameter allows you to have define the global filtering state at
			 * initialisation time. As an object the `search` parameter must be
			 * defined, but all other parameters are optional. When `regex` is true,
			 * the search string will be treated as a regular expression, when false
			 * (default) it will be treated as a straight string. When `smart`
			 * DataTables will use it's smart filtering methods (to word match at
			 * any point in the data), when false this will not be done.
			 *  @namespace
			 *  @extends DataTable.models.oSearch
			 *
			 *  @dtopt Options
			 *  @name DataTable.defaults.search
			 *
			 *  @example
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "search": {"search": "Initial search"}
			 *      } );
			 *    } )
			 */
			"oSearch": $.extend( {}, DataTable.models.oSearch ),
		
		
			/**
			 * __Deprecated__ The functionality provided by this parameter has now been
			 * superseded by that provided through `ajax`, which should be used instead.
			 *
			 * By default DataTables will look for the property `data` (or `aaData` for
			 * compatibility with DataTables 1.9-) when obtaining data from an Ajax
			 * source or for server-side processing - this parameter allows that
			 * property to be changed. You can use Javascript dotted object notation to
			 * get a data source for multiple levels of nesting.
			 *  @type string
			 *  @default data
			 *
			 *  @dtopt Options
			 *  @dtopt Server-side
			 *  @name DataTable.defaults.ajaxDataProp
			 *
			 *  @deprecated 1.10. Please use `ajax` for this functionality now.
			 */
			"sAjaxDataProp": "data",
		
		
			/**
			 * __Deprecated__ The functionality provided by this parameter has now been
			 * superseded by that provided through `ajax`, which should be used instead.
			 *
			 * You can instruct DataTables to load data from an external
			 * source using this parameter (use aData if you want to pass data in you
			 * already have). Simply provide a url a JSON object can be obtained from.
			 *  @type string
			 *  @default null
			 *
			 *  @dtopt Options
			 *  @dtopt Server-side
			 *  @name DataTable.defaults.ajaxSource
			 *
			 *  @deprecated 1.10. Please use `ajax` for this functionality now.
			 */
			"sAjaxSource": null,
		
		
			/**
			 * This initialisation variable allows you to specify exactly where in the
			 * DOM you want DataTables to inject the various controls it adds to the page
			 * (for example you might want the pagination controls at the top of the
			 * table). DIV elements (with or without a custom class) can also be added to
			 * aid styling. The follow syntax is used:
			 *   <ul>
			 *     <li>The following options are allowed:
			 *       <ul>
			 *         <li>'l' - Length changing</li>
			 *         <li>'f' - Filtering input</li>
			 *         <li>'t' - The table!</li>
			 *         <li>'i' - Information</li>
			 *         <li>'p' - Pagination</li>
			 *         <li>'r' - pRocessing</li>
			 *       </ul>
			 *     </li>
			 *     <li>The following constants are allowed:
			 *       <ul>
			 *         <li>'H' - jQueryUI theme "header" classes ('fg-toolbar ui-widget-header ui-corner-tl ui-corner-tr ui-helper-clearfix')</li>
			 *         <li>'F' - jQueryUI theme "footer" classes ('fg-toolbar ui-widget-header ui-corner-bl ui-corner-br ui-helper-clearfix')</li>
			 *       </ul>
			 *     </li>
			 *     <li>The following syntax is expected:
			 *       <ul>
			 *         <li>'&lt;' and '&gt;' - div elements</li>
			 *         <li>'&lt;"class" and '&gt;' - div with a class</li>
			 *         <li>'&lt;"#id" and '&gt;' - div with an ID</li>
			 *       </ul>
			 *     </li>
			 *     <li>Examples:
			 *       <ul>
			 *         <li>'&lt;"wrapper"flipt&gt;'</li>
			 *         <li>'&lt;lf&lt;t&gt;ip&gt;'</li>
			 *       </ul>
			 *     </li>
			 *   </ul>
			 *  @type string
			 *  @default lfrtip <i>(when `jQueryUI` is false)</i> <b>or</b>
			 *    <"H"lfr>t<"F"ip> <i>(when `jQueryUI` is true)</i>
			 *
			 *  @dtopt Options
			 *  @name DataTable.defaults.dom
			 *
			 *  @example
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "dom": '&lt;"top"i&gt;rt&lt;"bottom"flp&gt;&lt;"clear"&gt;'
			 *      } );
			 *    } );
			 */
			"sDom": "lfrtip",
		
		
			/**
			 * Search delay option. This will throttle full table searches that use the
			 * DataTables provided search input element (it does not effect calls to
			 * `dt-api search()`, providing a delay before the search is made.
			 *  @type integer
			 *  @default 0
			 *
			 *  @dtopt Options
			 *  @name DataTable.defaults.searchDelay
			 *
			 *  @example
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "searchDelay": 200
			 *      } );
			 *    } )
			 */
			"searchDelay": null,
		
		
			/**
			 * DataTables features four different built-in options for the buttons to
			 * display for pagination control:
			 *
			 * * `simple` - 'Previous' and 'Next' buttons only
			 * * 'simple_numbers` - 'Previous' and 'Next' buttons, plus page numbers
			 * * `full` - 'First', 'Previous', 'Next' and 'Last' buttons
			 * * `full_numbers` - 'First', 'Previous', 'Next' and 'Last' buttons, plus
			 *   page numbers
			 *  
			 * Further methods can be added using {@link DataTable.ext.oPagination}.
			 *  @type string
			 *  @default simple_numbers
			 *
			 *  @dtopt Options
			 *  @name DataTable.defaults.pagingType
			 *
			 *  @example
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "pagingType": "full_numbers"
			 *      } );
			 *    } )
			 */
			"sPaginationType": "simple_numbers",
		
		
			/**
			 * Enable horizontal scrolling. When a table is too wide to fit into a
			 * certain layout, or you have a large number of columns in the table, you
			 * can enable x-scrolling to show the table in a viewport, which can be
			 * scrolled. This property can be `true` which will allow the table to
			 * scroll horizontally when needed, or any CSS unit, or a number (in which
			 * case it will be treated as a pixel measurement). Setting as simply `true`
			 * is recommended.
			 *  @type boolean|string
			 *  @default <i>blank string - i.e. disabled</i>
			 *
			 *  @dtopt Features
			 *  @name DataTable.defaults.scrollX
			 *
			 *  @example
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "scrollX": true,
			 *        "scrollCollapse": true
			 *      } );
			 *    } );
			 */
			"sScrollX": "",
		
		
			/**
			 * This property can be used to force a DataTable to use more width than it
			 * might otherwise do when x-scrolling is enabled. For example if you have a
			 * table which requires to be well spaced, this parameter is useful for
			 * "over-sizing" the table, and thus forcing scrolling. This property can by
			 * any CSS unit, or a number (in which case it will be treated as a pixel
			 * measurement).
			 *  @type string
			 *  @default <i>blank string - i.e. disabled</i>
			 *
			 *  @dtopt Options
			 *  @name DataTable.defaults.scrollXInner
			 *
			 *  @example
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "scrollX": "100%",
			 *        "scrollXInner": "110%"
			 *      } );
			 *    } );
			 */
			"sScrollXInner": "",
		
		
			/**
			 * Enable vertical scrolling. Vertical scrolling will constrain the DataTable
			 * to the given height, and enable scrolling for any data which overflows the
			 * current viewport. This can be used as an alternative to paging to display
			 * a lot of data in a small area (although paging and scrolling can both be
			 * enabled at the same time). This property can be any CSS unit, or a number
			 * (in which case it will be treated as a pixel measurement).
			 *  @type string
			 *  @default <i>blank string - i.e. disabled</i>
			 *
			 *  @dtopt Features
			 *  @name DataTable.defaults.scrollY
			 *
			 *  @example
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "scrollY": "200px",
			 *        "paginate": false
			 *      } );
			 *    } );
			 */
			"sScrollY": "",
		
		
			/**
			 * __Deprecated__ The functionality provided by this parameter has now been
			 * superseded by that provided through `ajax`, which should be used instead.
			 *
			 * Set the HTTP method that is used to make the Ajax call for server-side
			 * processing or Ajax sourced data.
			 *  @type string
			 *  @default GET
			 *
			 *  @dtopt Options
			 *  @dtopt Server-side
			 *  @name DataTable.defaults.serverMethod
			 *
			 *  @deprecated 1.10. Please use `ajax` for this functionality now.
			 */
			"sServerMethod": "GET",
		
		
			/**
			 * DataTables makes use of renderers when displaying HTML elements for
			 * a table. These renderers can be added or modified by plug-ins to
			 * generate suitable mark-up for a site. For example the Bootstrap
			 * integration plug-in for DataTables uses a paging button renderer to
			 * display pagination buttons in the mark-up required by Bootstrap.
			 *
			 * For further information about the renderers available see
			 * DataTable.ext.renderer
			 *  @type string|object
			 *  @default null
			 *
			 *  @name DataTable.defaults.renderer
			 *
			 */
			"renderer": null,
		
		
			/**
			 * Set the data property name that DataTables should use to get a row's id
			 * to set as the `id` property in the node.
			 *  @type string
			 *  @default DT_RowId
			 *
			 *  @name DataTable.defaults.rowId
			 */
			"rowId": "DT_RowId"
		};
		
		_fnHungarianMap( DataTable.defaults );
		
		
		
		/*
		 * Developer note - See note in model.defaults.js about the use of Hungarian
		 * notation and camel case.
		 */
		
		/**
		 * Column options that can be given to DataTables at initialisation time.
		 *  @namespace
		 */
		DataTable.defaults.column = {
			/**
			 * Define which column(s) an order will occur on for this column. This
			 * allows a column's ordering to take multiple columns into account when
			 * doing a sort or use the data from a different column. For example first
			 * name / last name columns make sense to do a multi-column sort over the
			 * two columns.
			 *  @type array|int
			 *  @default null <i>Takes the value of the column index automatically</i>
			 *
			 *  @name DataTable.defaults.column.orderData
			 *  @dtopt Columns
			 *
			 *  @example
			 *    // Using `columnDefs`
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "columnDefs": [
			 *          { "orderData": [ 0, 1 ], "targets": [ 0 ] },
			 *          { "orderData": [ 1, 0 ], "targets": [ 1 ] },
			 *          { "orderData": 2, "targets": [ 2 ] }
			 *        ]
			 *      } );
			 *    } );
			 *
			 *  @example
			 *    // Using `columns`
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "columns": [
			 *          { "orderData": [ 0, 1 ] },
			 *          { "orderData": [ 1, 0 ] },
			 *          { "orderData": 2 },
			 *          null,
			 *          null
			 *        ]
			 *      } );
			 *    } );
			 */
			"aDataSort": null,
			"iDataSort": -1,
		
		
			/**
			 * You can control the default ordering direction, and even alter the
			 * behaviour of the sort handler (i.e. only allow ascending ordering etc)
			 * using this parameter.
			 *  @type array
			 *  @default [ 'asc', 'desc' ]
			 *
			 *  @name DataTable.defaults.column.orderSequence
			 *  @dtopt Columns
			 *
			 *  @example
			 *    // Using `columnDefs`
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "columnDefs": [
			 *          { "orderSequence": [ "asc" ], "targets": [ 1 ] },
			 *          { "orderSequence": [ "desc", "asc", "asc" ], "targets": [ 2 ] },
			 *          { "orderSequence": [ "desc" ], "targets": [ 3 ] }
			 *        ]
			 *      } );
			 *    } );
			 *
			 *  @example
			 *    // Using `columns`
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "columns": [
			 *          null,
			 *          { "orderSequence": [ "asc" ] },
			 *          { "orderSequence": [ "desc", "asc", "asc" ] },
			 *          { "orderSequence": [ "desc" ] },
			 *          null
			 *        ]
			 *      } );
			 *    } );
			 */
			"asSorting": [ 'asc', 'desc' ],
		
		
			/**
			 * Enable or disable filtering on the data in this column.
			 *  @type boolean
			 *  @default true
			 *
			 *  @name DataTable.defaults.column.searchable
			 *  @dtopt Columns
			 *
			 *  @example
			 *    // Using `columnDefs`
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "columnDefs": [
			 *          { "searchable": false, "targets": [ 0 ] }
			 *        ] } );
			 *    } );
			 *
			 *  @example
			 *    // Using `columns`
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "columns": [
			 *          { "searchable": false },
			 *          null,
			 *          null,
			 *          null,
			 *          null
			 *        ] } );
			 *    } );
			 */
			"bSearchable": true,
		
		
			/**
			 * Enable or disable ordering on this column.
			 *  @type boolean
			 *  @default true
			 *
			 *  @name DataTable.defaults.column.orderable
			 *  @dtopt Columns
			 *
			 *  @example
			 *    // Using `columnDefs`
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "columnDefs": [
			 *          { "orderable": false, "targets": [ 0 ] }
			 *        ] } );
			 *    } );
			 *
			 *  @example
			 *    // Using `columns`
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "columns": [
			 *          { "orderable": false },
			 *          null,
			 *          null,
			 *          null,
			 *          null
			 *        ] } );
			 *    } );
			 */
			"bSortable": true,
		
		
			/**
			 * Enable or disable the display of this column.
			 *  @type boolean
			 *  @default true
			 *
			 *  @name DataTable.defaults.column.visible
			 *  @dtopt Columns
			 *
			 *  @example
			 *    // Using `columnDefs`
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "columnDefs": [
			 *          { "visible": false, "targets": [ 0 ] }
			 *        ] } );
			 *    } );
			 *
			 *  @example
			 *    // Using `columns`
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "columns": [
			 *          { "visible": false },
			 *          null,
			 *          null,
			 *          null,
			 *          null
			 *        ] } );
			 *    } );
			 */
			"bVisible": true,
		
		
			/**
			 * Developer definable function that is called whenever a cell is created (Ajax source,
			 * etc) or processed for input (DOM source). This can be used as a compliment to mRender
			 * allowing you to modify the DOM element (add background colour for example) when the
			 * element is available.
			 *  @type function
			 *  @param {element} td The TD node that has been created
			 *  @param {*} cellData The Data for the cell
			 *  @param {array|object} rowData The data for the whole row
			 *  @param {int} row The row index for the aoData data store
			 *  @param {int} col The column index for aoColumns
			 *
			 *  @name DataTable.defaults.column.createdCell
			 *  @dtopt Columns
			 *
			 *  @example
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "columnDefs": [ {
			 *          "targets": [3],
			 *          "createdCell": function (td, cellData, rowData, row, col) {
			 *            if ( cellData == "1.7" ) {
			 *              $(td).css('color', 'blue')
			 *            }
			 *          }
			 *        } ]
			 *      });
			 *    } );
			 */
			"fnCreatedCell": null,
		
		
			/**
			 * This parameter has been replaced by `data` in DataTables to ensure naming
			 * consistency. `dataProp` can still be used, as there is backwards
			 * compatibility in DataTables for this option, but it is strongly
			 * recommended that you use `data` in preference to `dataProp`.
			 *  @name DataTable.defaults.column.dataProp
			 */
		
		
			/**
			 * This property can be used to read data from any data source property,
			 * including deeply nested objects / properties. `data` can be given in a
			 * number of different ways which effect its behaviour:
			 *
			 * * `integer` - treated as an array index for the data source. This is the
			 *   default that DataTables uses (incrementally increased for each column).
			 * * `string` - read an object property from the data source. There are
			 *   three 'special' options that can be used in the string to alter how
			 *   DataTables reads the data from the source object:
			 *    * `.` - Dotted Javascript notation. Just as you use a `.` in
			 *      Javascript to read from nested objects, so to can the options
			 *      specified in `data`. For example: `browser.version` or
			 *      `browser.name`. If your object parameter name contains a period, use
			 *      `\\` to escape it - i.e. `first\\.name`.
			 *    * `[]` - Array notation. DataTables can automatically combine data
			 *      from and array source, joining the data with the characters provided
			 *      between the two brackets. For example: `name[, ]` would provide a
			 *      comma-space separated list from the source array. If no characters
			 *      are provided between the brackets, the original array source is
			 *      returned.
			 *    * `()` - Function notation. Adding `()` to the end of a parameter will
			 *      execute a function of the name given. For example: `browser()` for a
			 *      simple function on the data source, `browser.version()` for a
			 *      function in a nested property or even `browser().version` to get an
			 *      object property if the function called returns an object. Note that
			 *      function notation is recommended for use in `render` rather than
			 *      `data` as it is much simpler to use as a renderer.
			 * * `null` - use the original data source for the row rather than plucking
			 *   data directly from it. This action has effects on two other
			 *   initialisation options:
			 *    * `defaultContent` - When null is given as the `data` option and
			 *      `defaultContent` is specified for the column, the value defined by
			 *      `defaultContent` will be used for the cell.
			 *    * `render` - When null is used for the `data` option and the `render`
			 *      option is specified for the column, the whole data source for the
			 *      row is used for the renderer.
			 * * `function` - the function given will be executed whenever DataTables
			 *   needs to set or get the data for a cell in the column. The function
			 *   takes three parameters:
			 *    * Parameters:
			 *      * `{array|object}` The data source for the row
			 *      * `{string}` The type call data requested - this will be 'set' when
			 *        setting data or 'filter', 'display', 'type', 'sort' or undefined
			 *        when gathering data. Note that when `undefined` is given for the
			 *        type DataTables expects to get the raw data for the object back<
			 *      * `{*}` Data to set when the second parameter is 'set'.
			 *    * Return:
			 *      * The return value from the function is not required when 'set' is
			 *        the type of call, but otherwise the return is what will be used
			 *        for the data requested.
			 *
			 * Note that `data` is a getter and setter option. If you just require
			 * formatting of data for output, you will likely want to use `render` which
			 * is simply a getter and thus simpler to use.
			 *
			 * Note that prior to DataTables 1.9.2 `data` was called `mDataProp`. The
			 * name change reflects the flexibility of this property and is consistent
			 * with the naming of mRender. If 'mDataProp' is given, then it will still
			 * be used by DataTables, as it automatically maps the old name to the new
			 * if required.
			 *
			 *  @type string|int|function|null
			 *  @default null <i>Use automatically calculated column index</i>
			 *
			 *  @name DataTable.defaults.column.data
			 *  @dtopt Columns
			 *
			 *  @example
			 *    // Read table data from objects
			 *    // JSON structure for each row:
			 *    //   {
			 *    //      "engine": {value},
			 *    //      "browser": {value},
			 *    //      "platform": {value},
			 *    //      "version": {value},
			 *    //      "grade": {value}
			 *    //   }
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "ajaxSource": "sources/objects.txt",
			 *        "columns": [
			 *          { "data": "engine" },
			 *          { "data": "browser" },
			 *          { "data": "platform" },
			 *          { "data": "version" },
			 *          { "data": "grade" }
			 *        ]
			 *      } );
			 *    } );
			 *
			 *  @example
			 *    // Read information from deeply nested objects
			 *    // JSON structure for each row:
			 *    //   {
			 *    //      "engine": {value},
			 *    //      "browser": {value},
			 *    //      "platform": {
			 *    //         "inner": {value}
			 *    //      },
			 *    //      "details": [
			 *    //         {value}, {value}
			 *    //      ]
			 *    //   }
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "ajaxSource": "sources/deep.txt",
			 *        "columns": [
			 *          { "data": "engine" },
			 *          { "data": "browser" },
			 *          { "data": "platform.inner" },
			 *          { "data": "platform.details.0" },
			 *          { "data": "platform.details.1" }
			 *        ]
			 *      } );
			 *    } );
			 *
			 *  @example
			 *    // Using `data` as a function to provide different information for
			 *    // sorting, filtering and display. In this case, currency (price)
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "columnDefs": [ {
			 *          "targets": [ 0 ],
			 *          "data": function ( source, type, val ) {
			 *            if (type === 'set') {
			 *              source.price = val;
			 *              // Store the computed dislay and filter values for efficiency
			 *              source.price_display = val=="" ? "" : "$"+numberFormat(val);
			 *              source.price_filter  = val=="" ? "" : "$"+numberFormat(val)+" "+val;
			 *              return;
			 *            }
			 *            else if (type === 'display') {
			 *              return source.price_display;
			 *            }
			 *            else if (type === 'filter') {
			 *              return source.price_filter;
			 *            }
			 *            // 'sort', 'type' and undefined all just use the integer
			 *            return source.price;
			 *          }
			 *        } ]
			 *      } );
			 *    } );
			 *
			 *  @example
			 *    // Using default content
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "columnDefs": [ {
			 *          "targets": [ 0 ],
			 *          "data": null,
			 *          "defaultContent": "Click to edit"
			 *        } ]
			 *      } );
			 *    } );
			 *
			 *  @example
			 *    // Using array notation - outputting a list from an array
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "columnDefs": [ {
			 *          "targets": [ 0 ],
			 *          "data": "name[, ]"
			 *        } ]
			 *      } );
			 *    } );
			 *
			 */
			"mData": null,
		
		
			/**
			 * This property is the rendering partner to `data` and it is suggested that
			 * when you want to manipulate data for display (including filtering,
			 * sorting etc) without altering the underlying data for the table, use this
			 * property. `render` can be considered to be the the read only companion to
			 * `data` which is read / write (then as such more complex). Like `data`
			 * this option can be given in a number of different ways to effect its
			 * behaviour:
			 *
			 * * `integer` - treated as an array index for the data source. This is the
			 *   default that DataTables uses (incrementally increased for each column).
			 * * `string` - read an object property from the data source. There are
			 *   three 'special' options that can be used in the string to alter how
			 *   DataTables reads the data from the source object:
			 *    * `.` - Dotted Javascript notation. Just as you use a `.` in
			 *      Javascript to read from nested objects, so to can the options
			 *      specified in `data`. For example: `browser.version` or
			 *      `browser.name`. If your object parameter name contains a period, use
			 *      `\\` to escape it - i.e. `first\\.name`.
			 *    * `[]` - Array notation. DataTables can automatically combine data
			 *      from and array source, joining the data with the characters provided
			 *      between the two brackets. For example: `name[, ]` would provide a
			 *      comma-space separated list from the source array. If no characters
			 *      are provided between the brackets, the original array source is
			 *      returned.
			 *    * `()` - Function notation. Adding `()` to the end of a parameter will
			 *      execute a function of the name given. For example: `browser()` for a
			 *      simple function on the data source, `browser.version()` for a
			 *      function in a nested property or even `browser().version` to get an
			 *      object property if the function called returns an object.
			 * * `object` - use different data for the different data types requested by
			 *   DataTables ('filter', 'display', 'type' or 'sort'). The property names
			 *   of the object is the data type the property refers to and the value can
			 *   defined using an integer, string or function using the same rules as
			 *   `render` normally does. Note that an `_` option _must_ be specified.
			 *   This is the default value to use if you haven't specified a value for
			 *   the data type requested by DataTables.
			 * * `function` - the function given will be executed whenever DataTables
			 *   needs to set or get the data for a cell in the column. The function
			 *   takes three parameters:
			 *    * Parameters:
			 *      * {array|object} The data source for the row (based on `data`)
			 *      * {string} The type call data requested - this will be 'filter',
			 *        'display', 'type' or 'sort'.
			 *      * {array|object} The full data source for the row (not based on
			 *        `data`)
			 *    * Return:
			 *      * The return value from the function is what will be used for the
			 *        data requested.
			 *
			 *  @type string|int|function|object|null
			 *  @default null Use the data source value.
			 *
			 *  @name DataTable.defaults.column.render
			 *  @dtopt Columns
			 *
			 *  @example
			 *    // Create a comma separated list from an array of objects
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "ajaxSource": "sources/deep.txt",
			 *        "columns": [
			 *          { "data": "engine" },
			 *          { "data": "browser" },
			 *          {
			 *            "data": "platform",
			 *            "render": "[, ].name"
			 *          }
			 *        ]
			 *      } );
			 *    } );
			 *
			 *  @example
			 *    // Execute a function to obtain data
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "columnDefs": [ {
			 *          "targets": [ 0 ],
			 *          "data": null, // Use the full data source object for the renderer's source
			 *          "render": "browserName()"
			 *        } ]
			 *      } );
			 *    } );
			 *
			 *  @example
			 *    // As an object, extracting different data for the different types
			 *    // This would be used with a data source such as:
			 *    //   { "phone": 5552368, "phone_filter": "5552368 555-2368", "phone_display": "555-2368" }
			 *    // Here the `phone` integer is used for sorting and type detection, while `phone_filter`
			 *    // (which has both forms) is used for filtering for if a user inputs either format, while
			 *    // the formatted phone number is the one that is shown in the table.
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "columnDefs": [ {
			 *          "targets": [ 0 ],
			 *          "data": null, // Use the full data source object for the renderer's source
			 *          "render": {
			 *            "_": "phone",
			 *            "filter": "phone_filter",
			 *            "display": "phone_display"
			 *          }
			 *        } ]
			 *      } );
			 *    } );
			 *
			 *  @example
			 *    // Use as a function to create a link from the data source
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "columnDefs": [ {
			 *          "targets": [ 0 ],
			 *          "data": "download_link",
			 *          "render": function ( data, type, full ) {
			 *            return '<a href="'+data+'">Download</a>';
			 *          }
			 *        } ]
			 *      } );
			 *    } );
			 */
			"mRender": null,
		
		
			/**
			 * Change the cell type created for the column - either TD cells or TH cells. This
			 * can be useful as TH cells have semantic meaning in the table body, allowing them
			 * to act as a header for a row (you may wish to add scope='row' to the TH elements).
			 *  @type string
			 *  @default td
			 *
			 *  @name DataTable.defaults.column.cellType
			 *  @dtopt Columns
			 *
			 *  @example
			 *    // Make the first column use TH cells
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "columnDefs": [ {
			 *          "targets": [ 0 ],
			 *          "cellType": "th"
			 *        } ]
			 *      } );
			 *    } );
			 */
			"sCellType": "td",
		
		
			/**
			 * Class to give to each cell in this column.
			 *  @type string
			 *  @default <i>Empty string</i>
			 *
			 *  @name DataTable.defaults.column.class
			 *  @dtopt Columns
			 *
			 *  @example
			 *    // Using `columnDefs`
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "columnDefs": [
			 *          { "class": "my_class", "targets": [ 0 ] }
			 *        ]
			 *      } );
			 *    } );
			 *
			 *  @example
			 *    // Using `columns`
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "columns": [
			 *          { "class": "my_class" },
			 *          null,
			 *          null,
			 *          null,
			 *          null
			 *        ]
			 *      } );
			 *    } );
			 */
			"sClass": "",
		
			/**
			 * When DataTables calculates the column widths to assign to each column,
			 * it finds the longest string in each column and then constructs a
			 * temporary table and reads the widths from that. The problem with this
			 * is that "mmm" is much wider then "iiii", but the latter is a longer
			 * string - thus the calculation can go wrong (doing it properly and putting
			 * it into an DOM object and measuring that is horribly(!) slow). Thus as
			 * a "work around" we provide this option. It will append its value to the
			 * text that is found to be the longest string for the column - i.e. padding.
			 * Generally you shouldn't need this!
			 *  @type string
			 *  @default <i>Empty string<i>
			 *
			 *  @name DataTable.defaults.column.contentPadding
			 *  @dtopt Columns
			 *
			 *  @example
			 *    // Using `columns`
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "columns": [
			 *          null,
			 *          null,
			 *          null,
			 *          {
			 *            "contentPadding": "mmm"
			 *          }
			 *        ]
			 *      } );
			 *    } );
			 */
			"sContentPadding": "",
		
		
			/**
			 * Allows a default value to be given for a column's data, and will be used
			 * whenever a null data source is encountered (this can be because `data`
			 * is set to null, or because the data source itself is null).
			 *  @type string
			 *  @default null
			 *
			 *  @name DataTable.defaults.column.defaultContent
			 *  @dtopt Columns
			 *
			 *  @example
			 *    // Using `columnDefs`
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "columnDefs": [
			 *          {
			 *            "data": null,
			 *            "defaultContent": "Edit",
			 *            "targets": [ -1 ]
			 *          }
			 *        ]
			 *      } );
			 *    } );
			 *
			 *  @example
			 *    // Using `columns`
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "columns": [
			 *          null,
			 *          null,
			 *          null,
			 *          {
			 *            "data": null,
			 *            "defaultContent": "Edit"
			 *          }
			 *        ]
			 *      } );
			 *    } );
			 */
			"sDefaultContent": null,
		
		
			/**
			 * This parameter is only used in DataTables' server-side processing. It can
			 * be exceptionally useful to know what columns are being displayed on the
			 * client side, and to map these to database fields. When defined, the names
			 * also allow DataTables to reorder information from the server if it comes
			 * back in an unexpected order (i.e. if you switch your columns around on the
			 * client-side, your server-side code does not also need updating).
			 *  @type string
			 *  @default <i>Empty string</i>
			 *
			 *  @name DataTable.defaults.column.name
			 *  @dtopt Columns
			 *
			 *  @example
			 *    // Using `columnDefs`
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "columnDefs": [
			 *          { "name": "engine", "targets": [ 0 ] },
			 *          { "name": "browser", "targets": [ 1 ] },
			 *          { "name": "platform", "targets": [ 2 ] },
			 *          { "name": "version", "targets": [ 3 ] },
			 *          { "name": "grade", "targets": [ 4 ] }
			 *        ]
			 *      } );
			 *    } );
			 *
			 *  @example
			 *    // Using `columns`
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "columns": [
			 *          { "name": "engine" },
			 *          { "name": "browser" },
			 *          { "name": "platform" },
			 *          { "name": "version" },
			 *          { "name": "grade" }
			 *        ]
			 *      } );
			 *    } );
			 */
			"sName": "",
		
		
			/**
			 * Defines a data source type for the ordering which can be used to read
			 * real-time information from the table (updating the internally cached
			 * version) prior to ordering. This allows ordering to occur on user
			 * editable elements such as form inputs.
			 *  @type string
			 *  @default std
			 *
			 *  @name DataTable.defaults.column.orderDataType
			 *  @dtopt Columns
			 *
			 *  @example
			 *    // Using `columnDefs`
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "columnDefs": [
			 *          { "orderDataType": "dom-text", "targets": [ 2, 3 ] },
			 *          { "type": "numeric", "targets": [ 3 ] },
			 *          { "orderDataType": "dom-select", "targets": [ 4 ] },
			 *          { "orderDataType": "dom-checkbox", "targets": [ 5 ] }
			 *        ]
			 *      } );
			 *    } );
			 *
			 *  @example
			 *    // Using `columns`
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "columns": [
			 *          null,
			 *          null,
			 *          { "orderDataType": "dom-text" },
			 *          { "orderDataType": "dom-text", "type": "numeric" },
			 *          { "orderDataType": "dom-select" },
			 *          { "orderDataType": "dom-checkbox" }
			 *        ]
			 *      } );
			 *    } );
			 */
			"sSortDataType": "std",
		
		
			/**
			 * The title of this column.
			 *  @type string
			 *  @default null <i>Derived from the 'TH' value for this column in the
			 *    original HTML table.</i>
			 *
			 *  @name DataTable.defaults.column.title
			 *  @dtopt Columns
			 *
			 *  @example
			 *    // Using `columnDefs`
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "columnDefs": [
			 *          { "title": "My column title", "targets": [ 0 ] }
			 *        ]
			 *      } );
			 *    } );
			 *
			 *  @example
			 *    // Using `columns`
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "columns": [
			 *          { "title": "My column title" },
			 *          null,
			 *          null,
			 *          null,
			 *          null
			 *        ]
			 *      } );
			 *    } );
			 */
			"sTitle": null,
		
		
			/**
			 * The type allows you to specify how the data for this column will be
			 * ordered. Four types (string, numeric, date and html (which will strip
			 * HTML tags before ordering)) are currently available. Note that only date
			 * formats understood by Javascript's Date() object will be accepted as type
			 * date. For example: "Mar 26, 2008 5:03 PM". May take the values: 'string',
			 * 'numeric', 'date' or 'html' (by default). Further types can be adding
			 * through plug-ins.
			 *  @type string
			 *  @default null <i>Auto-detected from raw data</i>
			 *
			 *  @name DataTable.defaults.column.type
			 *  @dtopt Columns
			 *
			 *  @example
			 *    // Using `columnDefs`
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "columnDefs": [
			 *          { "type": "html", "targets": [ 0 ] }
			 *        ]
			 *      } );
			 *    } );
			 *
			 *  @example
			 *    // Using `columns`
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "columns": [
			 *          { "type": "html" },
			 *          null,
			 *          null,
			 *          null,
			 *          null
			 *        ]
			 *      } );
			 *    } );
			 */
			"sType": null,
		
		
			/**
			 * Defining the width of the column, this parameter may take any CSS value
			 * (3em, 20px etc). DataTables applies 'smart' widths to columns which have not
			 * been given a specific width through this interface ensuring that the table
			 * remains readable.
			 *  @type string
			 *  @default null <i>Automatic</i>
			 *
			 *  @name DataTable.defaults.column.width
			 *  @dtopt Columns
			 *
			 *  @example
			 *    // Using `columnDefs`
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "columnDefs": [
			 *          { "width": "20%", "targets": [ 0 ] }
			 *        ]
			 *      } );
			 *    } );
			 *
			 *  @example
			 *    // Using `columns`
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "columns": [
			 *          { "width": "20%" },
			 *          null,
			 *          null,
			 *          null,
			 *          null
			 *        ]
			 *      } );
			 *    } );
			 */
			"sWidth": null
		};
		
		_fnHungarianMap( DataTable.defaults.column );
		
		
		
		/**
		 * DataTables settings object - this holds all the information needed for a
		 * given table, including configuration, data and current application of the
		 * table options. DataTables does not have a single instance for each DataTable
		 * with the settings attached to that instance, but rather instances of the
		 * DataTable "class" are created on-the-fly as needed (typically by a
		 * $().dataTable() call) and the settings object is then applied to that
		 * instance.
		 *
		 * Note that this object is related to {@link DataTable.defaults} but this
		 * one is the internal data store for DataTables's cache of columns. It should
		 * NOT be manipulated outside of DataTables. Any configuration should be done
		 * through the initialisation options.
		 *  @namespace
		 *  @todo Really should attach the settings object to individual instances so we
		 *    don't need to create new instances on each $().dataTable() call (if the
		 *    table already exists). It would also save passing oSettings around and
		 *    into every single function. However, this is a very significant
		 *    architecture change for DataTables and will almost certainly break
		 *    backwards compatibility with older installations. This is something that
		 *    will be done in 2.0.
		 */
		DataTable.models.oSettings = {
			/**
			 * Primary features of DataTables and their enablement state.
			 *  @namespace
			 */
			"oFeatures": {
		
				/**
				 * Flag to say if DataTables should automatically try to calculate the
				 * optimum table and columns widths (true) or not (false).
				 * Note that this parameter will be set by the initialisation routine. To
				 * set a default use {@link DataTable.defaults}.
				 *  @type boolean
				 */
				"bAutoWidth": null,
		
				/**
				 * Delay the creation of TR and TD elements until they are actually
				 * needed by a driven page draw. This can give a significant speed
				 * increase for Ajax source and Javascript source data, but makes no
				 * difference at all fro DOM and server-side processing tables.
				 * Note that this parameter will be set by the initialisation routine. To
				 * set a default use {@link DataTable.defaults}.
				 *  @type boolean
				 */
				"bDeferRender": null,
		
				/**
				 * Enable filtering on the table or not. Note that if this is disabled
				 * then there is no filtering at all on the table, including fnFilter.
				 * To just remove the filtering input use sDom and remove the 'f' option.
				 * Note that this parameter will be set by the initialisation routine. To
				 * set a default use {@link DataTable.defaults}.
				 *  @type boolean
				 */
				"bFilter": null,
		
				/**
				 * Table information element (the 'Showing x of y records' div) enable
				 * flag.
				 * Note that this parameter will be set by the initialisation routine. To
				 * set a default use {@link DataTable.defaults}.
				 *  @type boolean
				 */
				"bInfo": null,
		
				/**
				 * Present a user control allowing the end user to change the page size
				 * when pagination is enabled.
				 * Note that this parameter will be set by the initialisation routine. To
				 * set a default use {@link DataTable.defaults}.
				 *  @type boolean
				 */
				"bLengthChange": null,
		
				/**
				 * Pagination enabled or not. Note that if this is disabled then length
				 * changing must also be disabled.
				 * Note that this parameter will be set by the initialisation routine. To
				 * set a default use {@link DataTable.defaults}.
				 *  @type boolean
				 */
				"bPaginate": null,
		
				/**
				 * Processing indicator enable flag whenever DataTables is enacting a
				 * user request - typically an Ajax request for server-side processing.
				 * Note that this parameter will be set by the initialisation routine. To
				 * set a default use {@link DataTable.defaults}.
				 *  @type boolean
				 */
				"bProcessing": null,
		
				/**
				 * Server-side processing enabled flag - when enabled DataTables will
				 * get all data from the server for every draw - there is no filtering,
				 * sorting or paging done on the client-side.
				 * Note that this parameter will be set by the initialisation routine. To
				 * set a default use {@link DataTable.defaults}.
				 *  @type boolean
				 */
				"bServerSide": null,
		
				/**
				 * Sorting enablement flag.
				 * Note that this parameter will be set by the initialisation routine. To
				 * set a default use {@link DataTable.defaults}.
				 *  @type boolean
				 */
				"bSort": null,
		
				/**
				 * Multi-column sorting
				 * Note that this parameter will be set by the initialisation routine. To
				 * set a default use {@link DataTable.defaults}.
				 *  @type boolean
				 */
				"bSortMulti": null,
		
				/**
				 * Apply a class to the columns which are being sorted to provide a
				 * visual highlight or not. This can slow things down when enabled since
				 * there is a lot of DOM interaction.
				 * Note that this parameter will be set by the initialisation routine. To
				 * set a default use {@link DataTable.defaults}.
				 *  @type boolean
				 */
				"bSortClasses": null,
		
				/**
				 * State saving enablement flag.
				 * Note that this parameter will be set by the initialisation routine. To
				 * set a default use {@link DataTable.defaults}.
				 *  @type boolean
				 */
				"bStateSave": null
			},
		
		
			/**
			 * Scrolling settings for a table.
			 *  @namespace
			 */
			"oScroll": {
				/**
				 * When the table is shorter in height than sScrollY, collapse the
				 * table container down to the height of the table (when true).
				 * Note that this parameter will be set by the initialisation routine. To
				 * set a default use {@link DataTable.defaults}.
				 *  @type boolean
				 */
				"bCollapse": null,
		
				/**
				 * Width of the scrollbar for the web-browser's platform. Calculated
				 * during table initialisation.
				 *  @type int
				 *  @default 0
				 */
				"iBarWidth": 0,
		
				/**
				 * Viewport width for horizontal scrolling. Horizontal scrolling is
				 * disabled if an empty string.
				 * Note that this parameter will be set by the initialisation routine. To
				 * set a default use {@link DataTable.defaults}.
				 *  @type string
				 */
				"sX": null,
		
				/**
				 * Width to expand the table to when using x-scrolling. Typically you
				 * should not need to use this.
				 * Note that this parameter will be set by the initialisation routine. To
				 * set a default use {@link DataTable.defaults}.
				 *  @type string
				 *  @deprecated
				 */
				"sXInner": null,
		
				/**
				 * Viewport height for vertical scrolling. Vertical scrolling is disabled
				 * if an empty string.
				 * Note that this parameter will be set by the initialisation routine. To
				 * set a default use {@link DataTable.defaults}.
				 *  @type string
				 */
				"sY": null
			},
		
			/**
			 * Language information for the table.
			 *  @namespace
			 *  @extends DataTable.defaults.oLanguage
			 */
			"oLanguage": {
				/**
				 * Information callback function. See
				 * {@link DataTable.defaults.fnInfoCallback}
				 *  @type function
				 *  @default null
				 */
				"fnInfoCallback": null
			},
		
			/**
			 * Browser support parameters
			 *  @namespace
			 */
			"oBrowser": {
				/**
				 * Indicate if the browser incorrectly calculates width:100% inside a
				 * scrolling element (IE6/7)
				 *  @type boolean
				 *  @default false
				 */
				"bScrollOversize": false,
		
				/**
				 * Determine if the vertical scrollbar is on the right or left of the
				 * scrolling container - needed for rtl language layout, although not
				 * all browsers move the scrollbar (Safari).
				 *  @type boolean
				 *  @default false
				 */
				"bScrollbarLeft": false,
		
				/**
				 * Flag for if `getBoundingClientRect` is fully supported or not
				 *  @type boolean
				 *  @default false
				 */
				"bBounding": false,
		
				/**
				 * Browser scrollbar width
				 *  @type integer
				 *  @default 0
				 */
				"barWidth": 0
			},
		
		
			"ajax": null,
		
		
			/**
			 * Array referencing the nodes which are used for the features. The
			 * parameters of this object match what is allowed by sDom - i.e.
			 *   <ul>
			 *     <li>'l' - Length changing</li>
			 *     <li>'f' - Filtering input</li>
			 *     <li>'t' - The table!</li>
			 *     <li>'i' - Information</li>
			 *     <li>'p' - Pagination</li>
			 *     <li>'r' - pRocessing</li>
			 *   </ul>
			 *  @type array
			 *  @default []
			 */
			"aanFeatures": [],
		
			/**
			 * Store data information - see {@link DataTable.models.oRow} for detailed
			 * information.
			 *  @type array
			 *  @default []
			 */
			"aoData": [],
		
			/**
			 * Array of indexes which are in the current display (after filtering etc)
			 *  @type array
			 *  @default []
			 */
			"aiDisplay": [],
		
			/**
			 * Array of indexes for display - no filtering
			 *  @type array
			 *  @default []
			 */
			"aiDisplayMaster": [],
		
			/**
			 * Map of row ids to data indexes
			 *  @type object
			 *  @default {}
			 */
			"aIds": {},
		
			/**
			 * Store information about each column that is in use
			 *  @type array
			 *  @default []
			 */
			"aoColumns": [],
		
			/**
			 * Store information about the table's header
			 *  @type array
			 *  @default []
			 */
			"aoHeader": [],
		
			/**
			 * Store information about the table's footer
			 *  @type array
			 *  @default []
			 */
			"aoFooter": [],
		
			/**
			 * Store the applied global search information in case we want to force a
			 * research or compare the old search to a new one.
			 * Note that this parameter will be set by the initialisation routine. To
			 * set a default use {@link DataTable.defaults}.
			 *  @namespace
			 *  @extends DataTable.models.oSearch
			 */
			"oPreviousSearch": {},
		
			/**
			 * Store the applied search for each column - see
			 * {@link DataTable.models.oSearch} for the format that is used for the
			 * filtering information for each column.
			 *  @type array
			 *  @default []
			 */
			"aoPreSearchCols": [],
		
			/**
			 * Sorting that is applied to the table. Note that the inner arrays are
			 * used in the following manner:
			 * <ul>
			 *   <li>Index 0 - column number</li>
			 *   <li>Index 1 - current sorting direction</li>
			 * </ul>
			 * Note that this parameter will be set by the initialisation routine. To
			 * set a default use {@link DataTable.defaults}.
			 *  @type array
			 *  @todo These inner arrays should really be objects
			 */
			"aaSorting": null,
		
			/**
			 * Sorting that is always applied to the table (i.e. prefixed in front of
			 * aaSorting).
			 * Note that this parameter will be set by the initialisation routine. To
			 * set a default use {@link DataTable.defaults}.
			 *  @type array
			 *  @default []
			 */
			"aaSortingFixed": [],
		
			/**
			 * Classes to use for the striping of a table.
			 * Note that this parameter will be set by the initialisation routine. To
			 * set a default use {@link DataTable.defaults}.
			 *  @type array
			 *  @default []
			 */
			"asStripeClasses": null,
		
			/**
			 * If restoring a table - we should restore its striping classes as well
			 *  @type array
			 *  @default []
			 */
			"asDestroyStripes": [],
		
			/**
			 * If restoring a table - we should restore its width
			 *  @type int
			 *  @default 0
			 */
			"sDestroyWidth": 0,
		
			/**
			 * Callback functions array for every time a row is inserted (i.e. on a draw).
			 *  @type array
			 *  @default []
			 */
			"aoRowCallback": [],
		
			/**
			 * Callback functions for the header on each draw.
			 *  @type array
			 *  @default []
			 */
			"aoHeaderCallback": [],
		
			/**
			 * Callback function for the footer on each draw.
			 *  @type array
			 *  @default []
			 */
			"aoFooterCallback": [],
		
			/**
			 * Array of callback functions for draw callback functions
			 *  @type array
			 *  @default []
			 */
			"aoDrawCallback": [],
		
			/**
			 * Array of callback functions for row created function
			 *  @type array
			 *  @default []
			 */
			"aoRowCreatedCallback": [],
		
			/**
			 * Callback functions for just before the table is redrawn. A return of
			 * false will be used to cancel the draw.
			 *  @type array
			 *  @default []
			 */
			"aoPreDrawCallback": [],
		
			/**
			 * Callback functions for when the table has been initialised.
			 *  @type array
			 *  @default []
			 */
			"aoInitComplete": [],
		
		
			/**
			 * Callbacks for modifying the settings to be stored for state saving, prior to
			 * saving state.
			 *  @type array
			 *  @default []
			 */
			"aoStateSaveParams": [],
		
			/**
			 * Callbacks for modifying the settings that have been stored for state saving
			 * prior to using the stored values to restore the state.
			 *  @type array
			 *  @default []
			 */
			"aoStateLoadParams": [],
		
			/**
			 * Callbacks for operating on the settings object once the saved state has been
			 * loaded
			 *  @type array
			 *  @default []
			 */
			"aoStateLoaded": [],
		
			/**
			 * Cache the table ID for quick access
			 *  @type string
			 *  @default <i>Empty string</i>
			 */
			"sTableId": "",
		
			/**
			 * The TABLE node for the main table
			 *  @type node
			 *  @default null
			 */
			"nTable": null,
		
			/**
			 * Permanent ref to the thead element
			 *  @type node
			 *  @default null
			 */
			"nTHead": null,
		
			/**
			 * Permanent ref to the tfoot element - if it exists
			 *  @type node
			 *  @default null
			 */
			"nTFoot": null,
		
			/**
			 * Permanent ref to the tbody element
			 *  @type node
			 *  @default null
			 */
			"nTBody": null,
		
			/**
			 * Cache the wrapper node (contains all DataTables controlled elements)
			 *  @type node
			 *  @default null
			 */
			"nTableWrapper": null,
		
			/**
			 * Indicate if when using server-side processing the loading of data
			 * should be deferred until the second draw.
			 * Note that this parameter will be set by the initialisation routine. To
			 * set a default use {@link DataTable.defaults}.
			 *  @type boolean
			 *  @default false
			 */
			"bDeferLoading": false,
		
			/**
			 * Indicate if all required information has been read in
			 *  @type boolean
			 *  @default false
			 */
			"bInitialised": false,
		
			/**
			 * Information about open rows. Each object in the array has the parameters
			 * 'nTr' and 'nParent'
			 *  @type array
			 *  @default []
			 */
			"aoOpenRows": [],
		
			/**
			 * Dictate the positioning of DataTables' control elements - see
			 * {@link DataTable.model.oInit.sDom}.
			 * Note that this parameter will be set by the initialisation routine. To
			 * set a default use {@link DataTable.defaults}.
			 *  @type string
			 *  @default null
			 */
			"sDom": null,
		
			/**
			 * Search delay (in mS)
			 *  @type integer
			 *  @default null
			 */
			"searchDelay": null,
		
			/**
			 * Which type of pagination should be used.
			 * Note that this parameter will be set by the initialisation routine. To
			 * set a default use {@link DataTable.defaults}.
			 *  @type string
			 *  @default two_button
			 */
			"sPaginationType": "two_button",
		
			/**
			 * The state duration (for `stateSave`) in seconds.
			 * Note that this parameter will be set by the initialisation routine. To
			 * set a default use {@link DataTable.defaults}.
			 *  @type int
			 *  @default 0
			 */
			"iStateDuration": 0,
		
			/**
			 * Array of callback functions for state saving. Each array element is an
			 * object with the following parameters:
			 *   <ul>
			 *     <li>function:fn - function to call. Takes two parameters, oSettings
			 *       and the JSON string to save that has been thus far created. Returns
			 *       a JSON string to be inserted into a json object
			 *       (i.e. '"param": [ 0, 1, 2]')</li>
			 *     <li>string:sName - name of callback</li>
			 *   </ul>
			 *  @type array
			 *  @default []
			 */
			"aoStateSave": [],
		
			/**
			 * Array of callback functions for state loading. Each array element is an
			 * object with the following parameters:
			 *   <ul>
			 *     <li>function:fn - function to call. Takes two parameters, oSettings
			 *       and the object stored. May return false to cancel state loading</li>
			 *     <li>string:sName - name of callback</li>
			 *   </ul>
			 *  @type array
			 *  @default []
			 */
			"aoStateLoad": [],
		
			/**
			 * State that was saved. Useful for back reference
			 *  @type object
			 *  @default null
			 */
			"oSavedState": null,
		
			/**
			 * State that was loaded. Useful for back reference
			 *  @type object
			 *  @default null
			 */
			"oLoadedState": null,
		
			/**
			 * Source url for AJAX data for the table.
			 * Note that this parameter will be set by the initialisation routine. To
			 * set a default use {@link DataTable.defaults}.
			 *  @type string
			 *  @default null
			 */
			"sAjaxSource": null,
		
			/**
			 * Property from a given object from which to read the table data from. This
			 * can be an empty string (when not server-side processing), in which case
			 * it is  assumed an an array is given directly.
			 * Note that this parameter will be set by the initialisation routine. To
			 * set a default use {@link DataTable.defaults}.
			 *  @type string
			 */
			"sAjaxDataProp": null,
		
			/**
			 * Note if draw should be blocked while getting data
			 *  @type boolean
			 *  @default true
			 */
			"bAjaxDataGet": true,
		
			/**
			 * The last jQuery XHR object that was used for server-side data gathering.
			 * This can be used for working with the XHR information in one of the
			 * callbacks
			 *  @type object
			 *  @default null
			 */
			"jqXHR": null,
		
			/**
			 * JSON returned from the server in the last Ajax request
			 *  @type object
			 *  @default undefined
			 */
			"json": undefined,
		
			/**
			 * Data submitted as part of the last Ajax request
			 *  @type object
			 *  @default undefined
			 */
			"oAjaxData": undefined,
		
			/**
			 * Function to get the server-side data.
			 * Note that this parameter will be set by the initialisation routine. To
			 * set a default use {@link DataTable.defaults}.
			 *  @type function
			 */
			"fnServerData": null,
		
			/**
			 * Functions which are called prior to sending an Ajax request so extra
			 * parameters can easily be sent to the server
			 *  @type array
			 *  @default []
			 */
			"aoServerParams": [],
		
			/**
			 * Send the XHR HTTP method - GET or POST (could be PUT or DELETE if
			 * required).
			 * Note that this parameter will be set by the initialisation routine. To
			 * set a default use {@link DataTable.defaults}.
			 *  @type string
			 */
			"sServerMethod": null,
		
			/**
			 * Format numbers for display.
			 * Note that this parameter will be set by the initialisation routine. To
			 * set a default use {@link DataTable.defaults}.
			 *  @type function
			 */
			"fnFormatNumber": null,
		
			/**
			 * List of options that can be used for the user selectable length menu.
			 * Note that this parameter will be set by the initialisation routine. To
			 * set a default use {@link DataTable.defaults}.
			 *  @type array
			 *  @default []
			 */
			"aLengthMenu": null,
		
			/**
			 * Counter for the draws that the table does. Also used as a tracker for
			 * server-side processing
			 *  @type int
			 *  @default 0
			 */
			"iDraw": 0,
		
			/**
			 * Indicate if a redraw is being done - useful for Ajax
			 *  @type boolean
			 *  @default false
			 */
			"bDrawing": false,
		
			/**
			 * Draw index (iDraw) of the last error when parsing the returned data
			 *  @type int
			 *  @default -1
			 */
			"iDrawError": -1,
		
			/**
			 * Paging display length
			 *  @type int
			 *  @default 10
			 */
			"_iDisplayLength": 10,
		
			/**
			 * Paging start point - aiDisplay index
			 *  @type int
			 *  @default 0
			 */
			"_iDisplayStart": 0,
		
			/**
			 * Server-side processing - number of records in the result set
			 * (i.e. before filtering), Use fnRecordsTotal rather than
			 * this property to get the value of the number of records, regardless of
			 * the server-side processing setting.
			 *  @type int
			 *  @default 0
			 *  @private
			 */
			"_iRecordsTotal": 0,
		
			/**
			 * Server-side processing - number of records in the current display set
			 * (i.e. after filtering). Use fnRecordsDisplay rather than
			 * this property to get the value of the number of records, regardless of
			 * the server-side processing setting.
			 *  @type boolean
			 *  @default 0
			 *  @private
			 */
			"_iRecordsDisplay": 0,
		
			/**
			 * Flag to indicate if jQuery UI marking and classes should be used.
			 * Note that this parameter will be set by the initialisation routine. To
			 * set a default use {@link DataTable.defaults}.
			 *  @type boolean
			 */
			"bJUI": null,
		
			/**
			 * The classes to use for the table
			 *  @type object
			 *  @default {}
			 */
			"oClasses": {},
		
			/**
			 * Flag attached to the settings object so you can check in the draw
			 * callback if filtering has been done in the draw. Deprecated in favour of
			 * events.
			 *  @type boolean
			 *  @default false
			 *  @deprecated
			 */
			"bFiltered": false,
		
			/**
			 * Flag attached to the settings object so you can check in the draw
			 * callback if sorting has been done in the draw. Deprecated in favour of
			 * events.
			 *  @type boolean
			 *  @default false
			 *  @deprecated
			 */
			"bSorted": false,
		
			/**
			 * Indicate that if multiple rows are in the header and there is more than
			 * one unique cell per column, if the top one (true) or bottom one (false)
			 * should be used for sorting / title by DataTables.
			 * Note that this parameter will be set by the initialisation routine. To
			 * set a default use {@link DataTable.defaults}.
			 *  @type boolean
			 */
			"bSortCellsTop": null,
		
			/**
			 * Initialisation object that is used for the table
			 *  @type object
			 *  @default null
			 */
			"oInit": null,
		
			/**
			 * Destroy callback functions - for plug-ins to attach themselves to the
			 * destroy so they can clean up markup and events.
			 *  @type array
			 *  @default []
			 */
			"aoDestroyCallback": [],
		
		
			/**
			 * Get the number of records in the current record set, before filtering
			 *  @type function
			 */
			"fnRecordsTotal": function ()
			{
				return _fnDataSource( this ) == 'ssp' ?
					this._iRecordsTotal * 1 :
					this.aiDisplayMaster.length;
			},
		
			/**
			 * Get the number of records in the current record set, after filtering
			 *  @type function
			 */
			"fnRecordsDisplay": function ()
			{
				return _fnDataSource( this ) == 'ssp' ?
					this._iRecordsDisplay * 1 :
					this.aiDisplay.length;
			},
		
			/**
			 * Get the display end point - aiDisplay index
			 *  @type function
			 */
			"fnDisplayEnd": function ()
			{
				var
					len      = this._iDisplayLength,
					start    = this._iDisplayStart,
					calc     = start + len,
					records  = this.aiDisplay.length,
					features = this.oFeatures,
					paginate = features.bPaginate;
		
				if ( features.bServerSide ) {
					return paginate === false || len === -1 ?
						start + records :
						Math.min( start+len, this._iRecordsDisplay );
				}
				else {
					return ! paginate || calc>records || len===-1 ?
						records :
						calc;
				}
			},
		
			/**
			 * The DataTables object for this table
			 *  @type object
			 *  @default null
			 */
			"oInstance": null,
		
			/**
			 * Unique identifier for each instance of the DataTables object. If there
			 * is an ID on the table node, then it takes that value, otherwise an
			 * incrementing internal counter is used.
			 *  @type string
			 *  @default null
			 */
			"sInstance": null,
		
			/**
			 * tabindex attribute value that is added to DataTables control elements, allowing
			 * keyboard navigation of the table and its controls.
			 */
			"iTabIndex": 0,
		
			/**
			 * DIV container for the footer scrolling table if scrolling
			 */
			"nScrollHead": null,
		
			/**
			 * DIV container for the footer scrolling table if scrolling
			 */
			"nScrollFoot": null,
		
			/**
			 * Last applied sort
			 *  @type array
			 *  @default []
			 */
			"aLastSort": [],
		
			/**
			 * Stored plug-in instances
			 *  @type object
			 *  @default {}
			 */
			"oPlugins": {},
		
			/**
			 * Function used to get a row's id from the row's data
			 *  @type function
			 *  @default null
			 */
			"rowIdFn": null,
		
			/**
			 * Data location where to store a row's id
			 *  @type string
			 *  @default null
			 */
			"rowId": null
		};
	
		/**
		 * Extension object for DataTables that is used to provide all extension
		 * options.
		 *
		 * Note that the `DataTable.ext` object is available through
		 * `jQuery.fn.dataTable.ext` where it may be accessed and manipulated. It is
		 * also aliased to `jQuery.fn.dataTableExt` for historic reasons.
		 *  @namespace
		 *  @extends DataTable.models.ext
		 */
		
		
		/**
		 * DataTables extensions
		 * 
		 * This namespace acts as a collection area for plug-ins that can be used to
		 * extend DataTables capabilities. Indeed many of the build in methods
		 * use this method to provide their own capabilities (sorting methods for
		 * example).
		 *
		 * Note that this namespace is aliased to `jQuery.fn.dataTableExt` for legacy
		 * reasons
		 *
		 *  @namespace
		 */
		DataTable.ext = _ext = {
			/**
			 * Buttons. For use with the Buttons extension for DataTables. This is
			 * defined here so other extensions can define buttons regardless of load
			 * order. It is _not_ used by DataTables core.
			 *
			 *  @type object
			 *  @default {}
			 */
			buttons: {},
		
		
			/**
			 * Element class names
			 *
			 *  @type object
			 *  @default {}
			 */
			classes: {},
		
		
			/**
			 * DataTables build type (expanded by the download builder)
			 *
			 *  @type string
			 */
			builder: "-source-",
		
		
			/**
			 * Error reporting.
			 * 
			 * How should DataTables report an error. Can take the value 'alert',
			 * 'throw', 'none' or a function.
			 *
			 *  @type string|function
			 *  @default alert
			 */
			errMode: "alert",
		
		
			/**
			 * Feature plug-ins.
			 * 
			 * This is an array of objects which describe the feature plug-ins that are
			 * available to DataTables. These feature plug-ins are then available for
			 * use through the `dom` initialisation option.
			 * 
			 * Each feature plug-in is described by an object which must have the
			 * following properties:
			 * 
			 * * `fnInit` - function that is used to initialise the plug-in,
			 * * `cFeature` - a character so the feature can be enabled by the `dom`
			 *   instillation option. This is case sensitive.
			 *
			 * The `fnInit` function has the following input parameters:
			 *
			 * 1. `{object}` DataTables settings object: see
			 *    {@link DataTable.models.oSettings}
			 *
			 * And the following return is expected:
			 * 
			 * * {node|null} The element which contains your feature. Note that the
			 *   return may also be void if your plug-in does not require to inject any
			 *   DOM elements into DataTables control (`dom`) - for example this might
			 *   be useful when developing a plug-in which allows table control via
			 *   keyboard entry
			 *
			 *  @type array
			 *
			 *  @example
			 *    $.fn.dataTable.ext.features.push( {
			 *      "fnInit": function( oSettings ) {
			 *        return new TableTools( { "oDTSettings": oSettings } );
			 *      },
			 *      "cFeature": "T"
			 *    } );
			 */
			feature: [],
		
		
			/**
			 * Row searching.
			 * 
			 * This method of searching is complimentary to the default type based
			 * searching, and a lot more comprehensive as it allows you complete control
			 * over the searching logic. Each element in this array is a function
			 * (parameters described below) that is called for every row in the table,
			 * and your logic decides if it should be included in the searching data set
			 * or not.
			 *
			 * Searching functions have the following input parameters:
			 *
			 * 1. `{object}` DataTables settings object: see
			 *    {@link DataTable.models.oSettings}
			 * 2. `{array|object}` Data for the row to be processed (same as the
			 *    original format that was passed in as the data source, or an array
			 *    from a DOM data source
			 * 3. `{int}` Row index ({@link DataTable.models.oSettings.aoData}), which
			 *    can be useful to retrieve the `TR` element if you need DOM interaction.
			 *
			 * And the following return is expected:
			 *
			 * * {boolean} Include the row in the searched result set (true) or not
			 *   (false)
			 *
			 * Note that as with the main search ability in DataTables, technically this
			 * is "filtering", since it is subtractive. However, for consistency in
			 * naming we call it searching here.
			 *
			 *  @type array
			 *  @default []
			 *
			 *  @example
			 *    // The following example shows custom search being applied to the
			 *    // fourth column (i.e. the data[3] index) based on two input values
			 *    // from the end-user, matching the data in a certain range.
			 *    $.fn.dataTable.ext.search.push(
			 *      function( settings, data, dataIndex ) {
			 *        var min = document.getElementById('min').value * 1;
			 *        var max = document.getElementById('max').value * 1;
			 *        var version = data[3] == "-" ? 0 : data[3]*1;
			 *
			 *        if ( min == "" && max == "" ) {
			 *          return true;
			 *        }
			 *        else if ( min == "" && version < max ) {
			 *          return true;
			 *        }
			 *        else if ( min < version && "" == max ) {
			 *          return true;
			 *        }
			 *        else if ( min < version && version < max ) {
			 *          return true;
			 *        }
			 *        return false;
			 *      }
			 *    );
			 */
			search: [],
		
		
			/**
			 * Selector extensions
			 *
			 * The `selector` option can be used to extend the options available for the
			 * selector modifier options (`selector-modifier` object data type) that
			 * each of the three built in selector types offer (row, column and cell +
			 * their plural counterparts). For example the Select extension uses this
			 * mechanism to provide an option to select only rows, columns and cells
			 * that have been marked as selected by the end user (`{selected: true}`),
			 * which can be used in conjunction with the existing built in selector
			 * options.
			 *
			 * Each property is an array to which functions can be pushed. The functions
			 * take three attributes:
			 *
			 * * Settings object for the host table
			 * * Options object (`selector-modifier` object type)
			 * * Array of selected item indexes
			 *
			 * The return is an array of the resulting item indexes after the custom
			 * selector has been applied.
			 *
			 *  @type object
			 */
			selector: {
				cell: [],
				column: [],
				row: []
			},
		
		
			/**
			 * Internal functions, exposed for used in plug-ins.
			 * 
			 * Please note that you should not need to use the internal methods for
			 * anything other than a plug-in (and even then, try to avoid if possible).
			 * The internal function may change between releases.
			 *
			 *  @type object
			 *  @default {}
			 */
			internal: {},
		
		
			/**
			 * Legacy configuration options. Enable and disable legacy options that
			 * are available in DataTables.
			 *
			 *  @type object
			 */
			legacy: {
				/**
				 * Enable / disable DataTables 1.9 compatible server-side processing
				 * requests
				 *
				 *  @type boolean
				 *  @default null
				 */
				ajax: null
			},
		
		
			/**
			 * Pagination plug-in methods.
			 * 
			 * Each entry in this object is a function and defines which buttons should
			 * be shown by the pagination rendering method that is used for the table:
			 * {@link DataTable.ext.renderer.pageButton}. The renderer addresses how the
			 * buttons are displayed in the document, while the functions here tell it
			 * what buttons to display. This is done by returning an array of button
			 * descriptions (what each button will do).
			 *
			 * Pagination types (the four built in options and any additional plug-in
			 * options defined here) can be used through the `paginationType`
			 * initialisation parameter.
			 *
			 * The functions defined take two parameters:
			 *
			 * 1. `{int} page` The current page index
			 * 2. `{int} pages` The number of pages in the table
			 *
			 * Each function is expected to return an array where each element of the
			 * array can be one of:
			 *
			 * * `first` - Jump to first page when activated
			 * * `last` - Jump to last page when activated
			 * * `previous` - Show previous page when activated
			 * * `next` - Show next page when activated
			 * * `{int}` - Show page of the index given
			 * * `{array}` - A nested array containing the above elements to add a
			 *   containing 'DIV' element (might be useful for styling).
			 *
			 * Note that DataTables v1.9- used this object slightly differently whereby
			 * an object with two functions would be defined for each plug-in. That
			 * ability is still supported by DataTables 1.10+ to provide backwards
			 * compatibility, but this option of use is now decremented and no longer
			 * documented in DataTables 1.10+.
			 *
			 *  @type object
			 *  @default {}
			 *
			 *  @example
			 *    // Show previous, next and current page buttons only
			 *    $.fn.dataTableExt.oPagination.current = function ( page, pages ) {
			 *      return [ 'previous', page, 'next' ];
			 *    };
			 */
			pager: {},
		
		
			renderer: {
				pageButton: {},
				header: {}
			},
		
		
			/**
			 * Ordering plug-ins - custom data source
			 * 
			 * The extension options for ordering of data available here is complimentary
			 * to the default type based ordering that DataTables typically uses. It
			 * allows much greater control over the the data that is being used to
			 * order a column, but is necessarily therefore more complex.
			 * 
			 * This type of ordering is useful if you want to do ordering based on data
			 * live from the DOM (for example the contents of an 'input' element) rather
			 * than just the static string that DataTables knows of.
			 * 
			 * The way these plug-ins work is that you create an array of the values you
			 * wish to be ordering for the column in question and then return that
			 * array. The data in the array much be in the index order of the rows in
			 * the table (not the currently ordering order!). Which order data gathering
			 * function is run here depends on the `dt-init columns.orderDataType`
			 * parameter that is used for the column (if any).
			 *
			 * The functions defined take two parameters:
			 *
			 * 1. `{object}` DataTables settings object: see
			 *    {@link DataTable.models.oSettings}
			 * 2. `{int}` Target column index
			 *
			 * Each function is expected to return an array:
			 *
			 * * `{array}` Data for the column to be ordering upon
			 *
			 *  @type array
			 *
			 *  @example
			 *    // Ordering using `input` node values
			 *    $.fn.dataTable.ext.order['dom-text'] = function  ( settings, col )
			 *    {
			 *      return this.api().column( col, {order:'index'} ).nodes().map( function ( td, i ) {
			 *        return $('input', td).val();
			 *      } );
			 *    }
			 */
			order: {},
		
		
			/**
			 * Type based plug-ins.
			 *
			 * Each column in DataTables has a type assigned to it, either by automatic
			 * detection or by direct assignment using the `type` option for the column.
			 * The type of a column will effect how it is ordering and search (plug-ins
			 * can also make use of the column type if required).
			 *
			 * @namespace
			 */
			type: {
				/**
				 * Type detection functions.
				 *
				 * The functions defined in this object are used to automatically detect
				 * a column's type, making initialisation of DataTables super easy, even
				 * when complex data is in the table.
				 *
				 * The functions defined take two parameters:
				 *
			     *  1. `{*}` Data from the column cell to be analysed
			     *  2. `{settings}` DataTables settings object. This can be used to
			     *     perform context specific type detection - for example detection
			     *     based on language settings such as using a comma for a decimal
			     *     place. Generally speaking the options from the settings will not
			     *     be required
				 *
				 * Each function is expected to return:
				 *
				 * * `{string|null}` Data type detected, or null if unknown (and thus
				 *   pass it on to the other type detection functions.
				 *
				 *  @type array
				 *
				 *  @example
				 *    // Currency type detection plug-in:
				 *    $.fn.dataTable.ext.type.detect.push(
				 *      function ( data, settings ) {
				 *        // Check the numeric part
				 *        if ( ! $.isNumeric( data.substring(1) ) ) {
				 *          return null;
				 *        }
				 *
				 *        // Check prefixed by currency
				 *        if ( data.charAt(0) == '$' || data.charAt(0) == '&pound;' ) {
				 *          return 'currency';
				 *        }
				 *        return null;
				 *      }
				 *    );
				 */
				detect: [],
		
		
				/**
				 * Type based search formatting.
				 *
				 * The type based searching functions can be used to pre-format the
				 * data to be search on. For example, it can be used to strip HTML
				 * tags or to de-format telephone numbers for numeric only searching.
				 *
				 * Note that is a search is not defined for a column of a given type,
				 * no search formatting will be performed.
				 * 
				 * Pre-processing of searching data plug-ins - When you assign the sType
				 * for a column (or have it automatically detected for you by DataTables
				 * or a type detection plug-in), you will typically be using this for
				 * custom sorting, but it can also be used to provide custom searching
				 * by allowing you to pre-processing the data and returning the data in
				 * the format that should be searched upon. This is done by adding
				 * functions this object with a parameter name which matches the sType
				 * for that target column. This is the corollary of <i>afnSortData</i>
				 * for searching data.
				 *
				 * The functions defined take a single parameter:
				 *
			     *  1. `{*}` Data from the column cell to be prepared for searching
				 *
				 * Each function is expected to return:
				 *
				 * * `{string|null}` Formatted string that will be used for the searching.
				 *
				 *  @type object
				 *  @default {}
				 *
				 *  @example
				 *    $.fn.dataTable.ext.type.search['title-numeric'] = function ( d ) {
				 *      return d.replace(/\n/g," ").replace( /<.*?>/g, "" );
				 *    }
				 */
				search: {},
		
		
				/**
				 * Type based ordering.
				 *
				 * The column type tells DataTables what ordering to apply to the table
				 * when a column is sorted upon. The order for each type that is defined,
				 * is defined by the functions available in this object.
				 *
				 * Each ordering option can be described by three properties added to
				 * this object:
				 *
				 * * `{type}-pre` - Pre-formatting function
				 * * `{type}-asc` - Ascending order function
				 * * `{type}-desc` - Descending order function
				 *
				 * All three can be used together, only `{type}-pre` or only
				 * `{type}-asc` and `{type}-desc` together. It is generally recommended
				 * that only `{type}-pre` is used, as this provides the optimal
				 * implementation in terms of speed, although the others are provided
				 * for compatibility with existing Javascript sort functions.
				 *
				 * `{type}-pre`: Functions defined take a single parameter:
				 *
			     *  1. `{*}` Data from the column cell to be prepared for ordering
				 *
				 * And return:
				 *
				 * * `{*}` Data to be sorted upon
				 *
				 * `{type}-asc` and `{type}-desc`: Functions are typical Javascript sort
				 * functions, taking two parameters:
				 *
			     *  1. `{*}` Data to compare to the second parameter
			     *  2. `{*}` Data to compare to the first parameter
				 *
				 * And returning:
				 *
				 * * `{*}` Ordering match: <0 if first parameter should be sorted lower
				 *   than the second parameter, ===0 if the two parameters are equal and
				 *   >0 if the first parameter should be sorted height than the second
				 *   parameter.
				 * 
				 *  @type object
				 *  @default {}
				 *
				 *  @example
				 *    // Numeric ordering of formatted numbers with a pre-formatter
				 *    $.extend( $.fn.dataTable.ext.type.order, {
				 *      "string-pre": function(x) {
				 *        a = (a === "-" || a === "") ? 0 : a.replace( /[^\d\-\.]/g, "" );
				 *        return parseFloat( a );
				 *      }
				 *    } );
				 *
				 *  @example
				 *    // Case-sensitive string ordering, with no pre-formatting method
				 *    $.extend( $.fn.dataTable.ext.order, {
				 *      "string-case-asc": function(x,y) {
				 *        return ((x < y) ? -1 : ((x > y) ? 1 : 0));
				 *      },
				 *      "string-case-desc": function(x,y) {
				 *        return ((x < y) ? 1 : ((x > y) ? -1 : 0));
				 *      }
				 *    } );
				 */
				order: {}
			},
		
			/**
			 * Unique DataTables instance counter
			 *
			 * @type int
			 * @private
			 */
			_unique: 0,
		
		
			//
			// Depreciated
			// The following properties are retained for backwards compatiblity only.
			// The should not be used in new projects and will be removed in a future
			// version
			//
		
			/**
			 * Version check function.
			 *  @type function
			 *  @depreciated Since 1.10
			 */
			fnVersionCheck: DataTable.fnVersionCheck,
		
		
			/**
			 * Index for what 'this' index API functions should use
			 *  @type int
			 *  @deprecated Since v1.10
			 */
			iApiIndex: 0,
		
		
			/**
			 * jQuery UI class container
			 *  @type object
			 *  @deprecated Since v1.10
			 */
			oJUIClasses: {},
		
		
			/**
			 * Software version
			 *  @type string
			 *  @deprecated Since v1.10
			 */
			sVersion: DataTable.version
		};
		
		
		//
		// Backwards compatibility. Alias to pre 1.10 Hungarian notation counter parts
		//
		$.extend( _ext, {
			afnFiltering: _ext.search,
			aTypes:       _ext.type.detect,
			ofnSearch:    _ext.type.search,
			oSort:        _ext.type.order,
			afnSortData:  _ext.order,
			aoFeatures:   _ext.feature,
			oApi:         _ext.internal,
			oStdClasses:  _ext.classes,
			oPagination:  _ext.pager
		} );
		
		
		$.extend( DataTable.ext.classes, {
			"sTable": "dataTable",
			"sNoFooter": "no-footer",
		
			/* Paging buttons */
			"sPageButton": "paginate_button",
			"sPageButtonActive": "current",
			"sPageButtonDisabled": "disabled",
		
			/* Striping classes */
			"sStripeOdd": "odd",
			"sStripeEven": "even",
		
			/* Empty row */
			"sRowEmpty": "dataTables_empty",
		
			/* Features */
			"sWrapper": "dataTables_wrapper",
			"sFilter": "dataTables_filter",
			"sInfo": "dataTables_info",
			"sPaging": "dataTables_paginate paging_", /* Note that the type is postfixed */
			"sLength": "dataTables_length",
			"sProcessing": "dataTables_processing",
		
			/* Sorting */
			"sSortAsc": "sorting_asc",
			"sSortDesc": "sorting_desc",
			"sSortable": "sorting", /* Sortable in both directions */
			"sSortableAsc": "sorting_asc_disabled",
			"sSortableDesc": "sorting_desc_disabled",
			"sSortableNone": "sorting_disabled",
			"sSortColumn": "sorting_", /* Note that an int is postfixed for the sorting order */
		
			/* Filtering */
			"sFilterInput": "",
		
			/* Page length */
			"sLengthSelect": "",
		
			/* Scrolling */
			"sScrollWrapper": "dataTables_scroll",
			"sScrollHead": "dataTables_scrollHead",
			"sScrollHeadInner": "dataTables_scrollHeadInner",
			"sScrollBody": "dataTables_scrollBody",
			"sScrollFoot": "dataTables_scrollFoot",
			"sScrollFootInner": "dataTables_scrollFootInner",
		
			/* Misc */
			"sHeaderTH": "",
			"sFooterTH": "",
		
			// Deprecated
			"sSortJUIAsc": "",
			"sSortJUIDesc": "",
			"sSortJUI": "",
			"sSortJUIAscAllowed": "",
			"sSortJUIDescAllowed": "",
			"sSortJUIWrapper": "",
			"sSortIcon": "",
			"sJUIHeader": "",
			"sJUIFooter": ""
		} );
		
		
		(function() {
		
		// Reused strings for better compression. Closure compiler appears to have a
		// weird edge case where it is trying to expand strings rather than use the
		// variable version. This results in about 200 bytes being added, for very
		// little preference benefit since it this run on script load only.
		var _empty = '';
		_empty = '';
		
		var _stateDefault = _empty + 'ui-state-default';
		var _sortIcon     = _empty + 'css_right ui-icon ui-icon-';
		var _headerFooter = _empty + 'fg-toolbar ui-toolbar ui-widget-header ui-helper-clearfix';
		
		$.extend( DataTable.ext.oJUIClasses, DataTable.ext.classes, {
			/* Full numbers paging buttons */
			"sPageButton":         "fg-button ui-button "+_stateDefault,
			"sPageButtonActive":   "ui-state-disabled",
			"sPageButtonDisabled": "ui-state-disabled",
		
			/* Features */
			"sPaging": "dataTables_paginate fg-buttonset ui-buttonset fg-buttonset-multi "+
				"ui-buttonset-multi paging_", /* Note that the type is postfixed */
		
			/* Sorting */
			"sSortAsc":            _stateDefault+" sorting_asc",
			"sSortDesc":           _stateDefault+" sorting_desc",
			"sSortable":           _stateDefault+" sorting",
			"sSortableAsc":        _stateDefault+" sorting_asc_disabled",
			"sSortableDesc":       _stateDefault+" sorting_desc_disabled",
			"sSortableNone":       _stateDefault+" sorting_disabled",
			"sSortJUIAsc":         _sortIcon+"triangle-1-n",
			"sSortJUIDesc":        _sortIcon+"triangle-1-s",
			"sSortJUI":            _sortIcon+"carat-2-n-s",
			"sSortJUIAscAllowed":  _sortIcon+"carat-1-n",
			"sSortJUIDescAllowed": _sortIcon+"carat-1-s",
			"sSortJUIWrapper":     "DataTables_sort_wrapper",
			"sSortIcon":           "DataTables_sort_icon",
		
			/* Scrolling */
			"sScrollHead": "dataTables_scrollHead "+_stateDefault,
			"sScrollFoot": "dataTables_scrollFoot "+_stateDefault,
		
			/* Misc */
			"sHeaderTH":  _stateDefault,
			"sFooterTH":  _stateDefault,
			"sJUIHeader": _headerFooter+" ui-corner-tl ui-corner-tr",
			"sJUIFooter": _headerFooter+" ui-corner-bl ui-corner-br"
		} );
		
		}());
		
		
		
		var extPagination = DataTable.ext.pager;
		
		function _numbers ( page, pages ) {
			var
				numbers = [],
				buttons = extPagination.numbers_length,
				half = Math.floor( buttons / 2 ),
				i = 1;
		
			if ( pages <= buttons ) {
				numbers = _range( 0, pages );
			}
			else if ( page <= half ) {
				numbers = _range( 0, buttons-2 );
				numbers.push( 'ellipsis' );
				numbers.push( pages-1 );
			}
			else if ( page >= pages - 1 - half ) {
				numbers = _range( pages-(buttons-2), pages );
				numbers.splice( 0, 0, 'ellipsis' ); // no unshift in ie6
				numbers.splice( 0, 0, 0 );
			}
			else {
				numbers = _range( page-half+2, page+half-1 );
				numbers.push( 'ellipsis' );
				numbers.push( pages-1 );
				numbers.splice( 0, 0, 'ellipsis' );
				numbers.splice( 0, 0, 0 );
			}
		
			numbers.DT_el = 'span';
			return numbers;
		}
		
		
		$.extend( extPagination, {
			simple: function ( page, pages ) {
				return [ 'previous', 'next' ];
			},
		
			full: function ( page, pages ) {
				return [  'first', 'previous', 'next', 'last' ];
			},
		
			numbers: function ( page, pages ) {
				return [ _numbers(page, pages) ];
			},
		
			simple_numbers: function ( page, pages ) {
				return [ 'previous', _numbers(page, pages), 'next' ];
			},
		
			full_numbers: function ( page, pages ) {
				return [ 'first', 'previous', _numbers(page, pages), 'next', 'last' ];
			},
		
			// For testing and plug-ins to use
			_numbers: _numbers,
		
			// Number of number buttons (including ellipsis) to show. _Must be odd!_
			numbers_length: 7
		} );
		
		
		$.extend( true, DataTable.ext.renderer, {
			pageButton: {
				_: function ( settings, host, idx, buttons, page, pages ) {
					var classes = settings.oClasses;
					var lang = settings.oLanguage.oPaginate;
					var aria = settings.oLanguage.oAria.paginate || {};
					var btnDisplay, btnClass, counter=0;
		
					var attach = function( container, buttons ) {
						var i, ien, node, button;
						var clickHandler = function ( e ) {
							_fnPageChange( settings, e.data.action, true );
						};
		
						for ( i=0, ien=buttons.length ; i<ien ; i++ ) {
							button = buttons[i];
		
							if ( $.isArray( button ) ) {
								var inner = $( '<'+(button.DT_el || 'div')+'/>' )
									.appendTo( container );
								attach( inner, button );
							}
							else {
								btnDisplay = null;
								btnClass = '';
		
								switch ( button ) {
									case 'ellipsis':
										container.append('<span class="ellipsis">&#x2026;</span>');
										break;
		
									case 'first':
										btnDisplay = lang.sFirst;
										btnClass = button + (page > 0 ?
											'' : ' '+classes.sPageButtonDisabled);
										break;
		
									case 'previous':
										btnDisplay = lang.sPrevious;
										btnClass = button + (page > 0 ?
											'' : ' '+classes.sPageButtonDisabled);
										break;
		
									case 'next':
										btnDisplay = lang.sNext;
										btnClass = button + (page < pages-1 ?
											'' : ' '+classes.sPageButtonDisabled);
										break;
		
									case 'last':
										btnDisplay = lang.sLast;
										btnClass = button + (page < pages-1 ?
											'' : ' '+classes.sPageButtonDisabled);
										break;
		
									default:
										btnDisplay = button + 1;
										btnClass = page === button ?
											classes.sPageButtonActive : '';
										break;
								}
		
								if ( btnDisplay !== null ) {
									node = $('<a>', {
											'class': classes.sPageButton+' '+btnClass,
											'aria-controls': settings.sTableId,
											'aria-label': aria[ button ],
											'data-dt-idx': counter,
											'tabindex': settings.iTabIndex,
											'id': idx === 0 && typeof button === 'string' ?
												settings.sTableId +'_'+ button :
												null
										} )
										.html( btnDisplay )
										.appendTo( container );
		
									_fnBindAction(
										node, {action: button}, clickHandler
									);
		
									counter++;
								}
							}
						}
					};
		
					// IE9 throws an 'unknown error' if document.activeElement is used
					// inside an iframe or frame. Try / catch the error. Not good for
					// accessibility, but neither are frames.
					var activeEl;
		
					try {
						// Because this approach is destroying and recreating the paging
						// elements, focus is lost on the select button which is bad for
						// accessibility. So we want to restore focus once the draw has
						// completed
						activeEl = $(host).find(document.activeElement).data('dt-idx');
					}
					catch (e) {}
		
					attach( $(host).empty(), buttons );
		
					if ( activeEl ) {
						$(host).find( '[data-dt-idx='+activeEl+']' ).focus();
					}
				}
			}
		} );
		
		
		
		// Built in type detection. See model.ext.aTypes for information about
		// what is required from this methods.
		$.extend( DataTable.ext.type.detect, [
			// Plain numbers - first since V8 detects some plain numbers as dates
			// e.g. Date.parse('55') (but not all, e.g. Date.parse('22')...).
			function ( d, settings )
			{
				var decimal = settings.oLanguage.sDecimal;
				return _isNumber( d, decimal ) ? 'num'+decimal : null;
			},
		
			// Dates (only those recognised by the browser's Date.parse)
			function ( d, settings )
			{
				// V8 will remove any unknown characters at the start and end of the
				// expression, leading to false matches such as `$245.12` or `10%` being
				// a valid date. See forum thread 18941 for detail.
				if ( d && !(d instanceof Date) && ( ! _re_date_start.test(d) || ! _re_date_end.test(d) ) ) {
					return null;
				}
				var parsed = Date.parse(d);
				return (parsed !== null && !isNaN(parsed)) || _empty(d) ? 'date' : null;
			},
		
			// Formatted numbers
			function ( d, settings )
			{
				var decimal = settings.oLanguage.sDecimal;
				return _isNumber( d, decimal, true ) ? 'num-fmt'+decimal : null;
			},
		
			// HTML numeric
			function ( d, settings )
			{
				var decimal = settings.oLanguage.sDecimal;
				return _htmlNumeric( d, decimal ) ? 'html-num'+decimal : null;
			},
		
			// HTML numeric, formatted
			function ( d, settings )
			{
				var decimal = settings.oLanguage.sDecimal;
				return _htmlNumeric( d, decimal, true ) ? 'html-num-fmt'+decimal : null;
			},
		
			// HTML (this is strict checking - there must be html)
			function ( d, settings )
			{
				return _empty( d ) || (typeof d === 'string' && d.indexOf('<') !== -1) ?
					'html' : null;
			}
		] );
		
		
		
		// Filter formatting functions. See model.ext.ofnSearch for information about
		// what is required from these methods.
		// 
		// Note that additional search methods are added for the html numbers and
		// html formatted numbers by `_addNumericSort()` when we know what the decimal
		// place is
		
		
		$.extend( DataTable.ext.type.search, {
			html: function ( data ) {
				return _empty(data) ?
					data :
					typeof data === 'string' ?
						data
							.replace( _re_new_lines, " " )
							.replace( _re_html, "" ) :
						'';
			},
		
			string: function ( data ) {
				return _empty(data) ?
					data :
					typeof data === 'string' ?
						data.replace( _re_new_lines, " " ) :
						data;
			}
		} );
		
		
		
		var __numericReplace = function ( d, decimalPlace, re1, re2 ) {
			if ( d !== 0 && (!d || d === '-') ) {
				return -Infinity;
			}
		
			// If a decimal place other than `.` is used, it needs to be given to the
			// function so we can detect it and replace with a `.` which is the only
			// decimal place Javascript recognises - it is not locale aware.
			if ( decimalPlace ) {
				d = _numToDecimal( d, decimalPlace );
			}
		
			if ( d.replace ) {
				if ( re1 ) {
					d = d.replace( re1, '' );
				}
		
				if ( re2 ) {
					d = d.replace( re2, '' );
				}
			}
		
			return d * 1;
		};
		
		
		// Add the numeric 'deformatting' functions for sorting and search. This is done
		// in a function to provide an easy ability for the language options to add
		// additional methods if a non-period decimal place is used.
		function _addNumericSort ( decimalPlace ) {
			$.each(
				{
					// Plain numbers
					"num": function ( d ) {
						return __numericReplace( d, decimalPlace );
					},
		
					// Formatted numbers
					"num-fmt": function ( d ) {
						return __numericReplace( d, decimalPlace, _re_formatted_numeric );
					},
		
					// HTML numeric
					"html-num": function ( d ) {
						return __numericReplace( d, decimalPlace, _re_html );
					},
		
					// HTML numeric, formatted
					"html-num-fmt": function ( d ) {
						return __numericReplace( d, decimalPlace, _re_html, _re_formatted_numeric );
					}
				},
				function ( key, fn ) {
					// Add the ordering method
					_ext.type.order[ key+decimalPlace+'-pre' ] = fn;
		
					// For HTML types add a search formatter that will strip the HTML
					if ( key.match(/^html\-/) ) {
						_ext.type.search[ key+decimalPlace ] = _ext.type.search.html;
					}
				}
			);
		}
		
		
		// Default sort methods
		$.extend( _ext.type.order, {
			// Dates
			"date-pre": function ( d ) {
				return Date.parse( d ) || 0;
			},
		
			// html
			"html-pre": function ( a ) {
				return _empty(a) ?
					'' :
					a.replace ?
						a.replace( /<.*?>/g, "" ).toLowerCase() :
						a+'';
			},
		
			// string
			"string-pre": function ( a ) {
				// This is a little complex, but faster than always calling toString,
				// http://jsperf.com/tostring-v-check
				return _empty(a) ?
					'' :
					typeof a === 'string' ?
						a.toLowerCase() :
						! a.toString ?
							'' :
							a.toString();
			},
		
			// string-asc and -desc are retained only for compatibility with the old
			// sort methods
			"string-asc": function ( x, y ) {
				return ((x < y) ? -1 : ((x > y) ? 1 : 0));
			},
		
			"string-desc": function ( x, y ) {
				return ((x < y) ? 1 : ((x > y) ? -1 : 0));
			}
		} );
		
		
		// Numeric sorting types - order doesn't matter here
		_addNumericSort( '' );
		
		
		$.extend( true, DataTable.ext.renderer, {
			header: {
				_: function ( settings, cell, column, classes ) {
					// No additional mark-up required
					// Attach a sort listener to update on sort - note that using the
					// `DT` namespace will allow the event to be removed automatically
					// on destroy, while the `dt` namespaced event is the one we are
					// listening for
					$(settings.nTable).on( 'order.dt.DT', function ( e, ctx, sorting, columns ) {
						if ( settings !== ctx ) { // need to check this this is the host
							return;               // table, not a nested one
						}
		
						var colIdx = column.idx;
		
						cell
							.removeClass(
								column.sSortingClass +' '+
								classes.sSortAsc +' '+
								classes.sSortDesc
							)
							.addClass( columns[ colIdx ] == 'asc' ?
								classes.sSortAsc : columns[ colIdx ] == 'desc' ?
									classes.sSortDesc :
									column.sSortingClass
							);
					} );
				},
		
				jqueryui: function ( settings, cell, column, classes ) {
					$('<div/>')
						.addClass( classes.sSortJUIWrapper )
						.append( cell.contents() )
						.append( $('<span/>')
							.addClass( classes.sSortIcon+' '+column.sSortingClassJUI )
						)
						.appendTo( cell );
		
					// Attach a sort listener to update on sort
					$(settings.nTable).on( 'order.dt.DT', function ( e, ctx, sorting, columns ) {
						if ( settings !== ctx ) {
							return;
						}
		
						var colIdx = column.idx;
		
						cell
							.removeClass( classes.sSortAsc +" "+classes.sSortDesc )
							.addClass( columns[ colIdx ] == 'asc' ?
								classes.sSortAsc : columns[ colIdx ] == 'desc' ?
									classes.sSortDesc :
									column.sSortingClass
							);
		
						cell
							.find( 'span.'+classes.sSortIcon )
							.removeClass(
								classes.sSortJUIAsc +" "+
								classes.sSortJUIDesc +" "+
								classes.sSortJUI +" "+
								classes.sSortJUIAscAllowed +" "+
								classes.sSortJUIDescAllowed
							)
							.addClass( columns[ colIdx ] == 'asc' ?
								classes.sSortJUIAsc : columns[ colIdx ] == 'desc' ?
									classes.sSortJUIDesc :
									column.sSortingClassJUI
							);
					} );
				}
			}
		} );
		
		/*
		 * Public helper functions. These aren't used internally by DataTables, or
		 * called by any of the options passed into DataTables, but they can be used
		 * externally by developers working with DataTables. They are helper functions
		 * to make working with DataTables a little bit easier.
		 */
		
		var __htmlEscapeEntities = function ( d ) {
			return typeof d === 'string' ?
				d.replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;') :
				d;
		};
		
		/**
		 * Helpers for `columns.render`.
		 *
		 * The options defined here can be used with the `columns.render` initialisation
		 * option to provide a display renderer. The following functions are defined:
		 *
		 * * `number` - Will format numeric data (defined by `columns.data`) for
		 *   display, retaining the original unformatted data for sorting and filtering.
		 *   It takes 5 parameters:
		 *   * `string` - Thousands grouping separator
		 *   * `string` - Decimal point indicator
		 *   * `integer` - Number of decimal points to show
		 *   * `string` (optional) - Prefix.
		 *   * `string` (optional) - Postfix (/suffix).
		 * * `text` - Escape HTML to help prevent XSS attacks. It has no optional
		 *   parameters.
		 *
		 * @example
		 *   // Column definition using the number renderer
		 *   {
		 *     data: "salary",
		 *     render: $.fn.dataTable.render.number( '\'', '.', 0, '$' )
		 *   }
		 *
		 * @namespace
		 */
		DataTable.render = {
			number: function ( thousands, decimal, precision, prefix, postfix ) {
				return {
					display: function ( d ) {
						if ( typeof d !== 'number' && typeof d !== 'string' ) {
							return d;
						}
		
						var negative = d < 0 ? '-' : '';
						var flo = parseFloat( d );
		
						// If NaN then there isn't much formatting that we can do - just
						// return immediately, escaping any HTML (this was supposed to
						// be a number after all)
						if ( isNaN( flo ) ) {
							return __htmlEscapeEntities( d );
						}
		
						d = Math.abs( flo );
		
						var intPart = parseInt( d, 10 );
						var floatPart = precision ?
							decimal+(d - intPart).toFixed( precision ).substring( 2 ):
							'';
		
						return negative + (prefix||'') +
							intPart.toString().replace(
								/\B(?=(\d{3})+(?!\d))/g, thousands
							) +
							floatPart +
							(postfix||'');
					}
				};
			},
		
			text: function () {
				return {
					display: __htmlEscapeEntities
				};
			}
		};
		
		
		/*
		 * This is really a good bit rubbish this method of exposing the internal methods
		 * publicly... - To be fixed in 2.0 using methods on the prototype
		 */
		
		
		/**
		 * Create a wrapper function for exporting an internal functions to an external API.
		 *  @param {string} fn API function name
		 *  @returns {function} wrapped function
		 *  @memberof DataTable#internal
		 */
		function _fnExternApiFunc (fn)
		{
			return function() {
				var args = [_fnSettingsFromNode( this[DataTable.ext.iApiIndex] )].concat(
					Array.prototype.slice.call(arguments)
				);
				return DataTable.ext.internal[fn].apply( this, args );
			};
		}
		
		
		/**
		 * Reference to internal functions for use by plug-in developers. Note that
		 * these methods are references to internal functions and are considered to be
		 * private. If you use these methods, be aware that they are liable to change
		 * between versions.
		 *  @namespace
		 */
		$.extend( DataTable.ext.internal, {
			_fnExternApiFunc: _fnExternApiFunc,
			_fnBuildAjax: _fnBuildAjax,
			_fnAjaxUpdate: _fnAjaxUpdate,
			_fnAjaxParameters: _fnAjaxParameters,
			_fnAjaxUpdateDraw: _fnAjaxUpdateDraw,
			_fnAjaxDataSrc: _fnAjaxDataSrc,
			_fnAddColumn: _fnAddColumn,
			_fnColumnOptions: _fnColumnOptions,
			_fnAdjustColumnSizing: _fnAdjustColumnSizing,
			_fnVisibleToColumnIndex: _fnVisibleToColumnIndex,
			_fnColumnIndexToVisible: _fnColumnIndexToVisible,
			_fnVisbleColumns: _fnVisbleColumns,
			_fnGetColumns: _fnGetColumns,
			_fnColumnTypes: _fnColumnTypes,
			_fnApplyColumnDefs: _fnApplyColumnDefs,
			_fnHungarianMap: _fnHungarianMap,
			_fnCamelToHungarian: _fnCamelToHungarian,
			_fnLanguageCompat: _fnLanguageCompat,
			_fnBrowserDetect: _fnBrowserDetect,
			_fnAddData: _fnAddData,
			_fnAddTr: _fnAddTr,
			_fnNodeToDataIndex: _fnNodeToDataIndex,
			_fnNodeToColumnIndex: _fnNodeToColumnIndex,
			_fnGetCellData: _fnGetCellData,
			_fnSetCellData: _fnSetCellData,
			_fnSplitObjNotation: _fnSplitObjNotation,
			_fnGetObjectDataFn: _fnGetObjectDataFn,
			_fnSetObjectDataFn: _fnSetObjectDataFn,
			_fnGetDataMaster: _fnGetDataMaster,
			_fnClearTable: _fnClearTable,
			_fnDeleteIndex: _fnDeleteIndex,
			_fnInvalidate: _fnInvalidate,
			_fnGetRowElements: _fnGetRowElements,
			_fnCreateTr: _fnCreateTr,
			_fnBuildHead: _fnBuildHead,
			_fnDrawHead: _fnDrawHead,
			_fnDraw: _fnDraw,
			_fnReDraw: _fnReDraw,
			_fnAddOptionsHtml: _fnAddOptionsHtml,
			_fnDetectHeader: _fnDetectHeader,
			_fnGetUniqueThs: _fnGetUniqueThs,
			_fnFeatureHtmlFilter: _fnFeatureHtmlFilter,
			_fnFilterComplete: _fnFilterComplete,
			_fnFilterCustom: _fnFilterCustom,
			_fnFilterColumn: _fnFilterColumn,
			_fnFilter: _fnFilter,
			_fnFilterCreateSearch: _fnFilterCreateSearch,
			_fnEscapeRegex: _fnEscapeRegex,
			_fnFilterData: _fnFilterData,
			_fnFeatureHtmlInfo: _fnFeatureHtmlInfo,
			_fnUpdateInfo: _fnUpdateInfo,
			_fnInfoMacros: _fnInfoMacros,
			_fnInitialise: _fnInitialise,
			_fnInitComplete: _fnInitComplete,
			_fnLengthChange: _fnLengthChange,
			_fnFeatureHtmlLength: _fnFeatureHtmlLength,
			_fnFeatureHtmlPaginate: _fnFeatureHtmlPaginate,
			_fnPageChange: _fnPageChange,
			_fnFeatureHtmlProcessing: _fnFeatureHtmlProcessing,
			_fnProcessingDisplay: _fnProcessingDisplay,
			_fnFeatureHtmlTable: _fnFeatureHtmlTable,
			_fnScrollDraw: _fnScrollDraw,
			_fnApplyToChildren: _fnApplyToChildren,
			_fnCalculateColumnWidths: _fnCalculateColumnWidths,
			_fnThrottle: _fnThrottle,
			_fnConvertToWidth: _fnConvertToWidth,
			_fnGetWidestNode: _fnGetWidestNode,
			_fnGetMaxLenString: _fnGetMaxLenString,
			_fnStringToCss: _fnStringToCss,
			_fnSortFlatten: _fnSortFlatten,
			_fnSort: _fnSort,
			_fnSortAria: _fnSortAria,
			_fnSortListener: _fnSortListener,
			_fnSortAttachListener: _fnSortAttachListener,
			_fnSortingClasses: _fnSortingClasses,
			_fnSortData: _fnSortData,
			_fnSaveState: _fnSaveState,
			_fnLoadState: _fnLoadState,
			_fnSettingsFromNode: _fnSettingsFromNode,
			_fnLog: _fnLog,
			_fnMap: _fnMap,
			_fnBindAction: _fnBindAction,
			_fnCallbackReg: _fnCallbackReg,
			_fnCallbackFire: _fnCallbackFire,
			_fnLengthOverflow: _fnLengthOverflow,
			_fnRenderer: _fnRenderer,
			_fnDataSource: _fnDataSource,
			_fnRowAttributes: _fnRowAttributes,
			_fnCalculateEnd: function () {} // Used by a lot of plug-ins, but redundant
			                                // in 1.10, so this dead-end function is
			                                // added to prevent errors
		} );
		
	
		// jQuery access
		$.fn.dataTable = DataTable;
	
		// Provide access to the host jQuery object (circular reference)
		DataTable.$ = $;
	
		// Legacy aliases
		$.fn.dataTableSettings = DataTable.settings;
		$.fn.dataTableExt = DataTable.ext;
	
		// With a capital `D` we return a DataTables API instance rather than a
		// jQuery object
		$.fn.DataTable = function ( opts ) {
			return $(this).dataTable( opts ).api();
		};
	
		// All properties that are available to $.fn.dataTable should also be
		// available on $.fn.DataTable
		$.each( DataTable, function ( prop, val ) {
			$.fn.DataTable[ prop ] = val;
		} );
	
	
		// Information about events fired by DataTables - for documentation.
		/**
		 * Draw event, fired whenever the table is redrawn on the page, at the same
		 * point as fnDrawCallback. This may be useful for binding events or
		 * performing calculations when the table is altered at all.
		 *  @name DataTable#draw.dt
		 *  @event
		 *  @param {event} e jQuery event object
		 *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
		 */
	
		/**
		 * Search event, fired when the searching applied to the table (using the
		 * built-in global search, or column filters) is altered.
		 *  @name DataTable#search.dt
		 *  @event
		 *  @param {event} e jQuery event object
		 *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
		 */
	
		/**
		 * Page change event, fired when the paging of the table is altered.
		 *  @name DataTable#page.dt
		 *  @event
		 *  @param {event} e jQuery event object
		 *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
		 */
	
		/**
		 * Order event, fired when the ordering applied to the table is altered.
		 *  @name DataTable#order.dt
		 *  @event
		 *  @param {event} e jQuery event object
		 *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
		 */
	
		/**
		 * DataTables initialisation complete event, fired when the table is fully
		 * drawn, including Ajax data loaded, if Ajax data is required.
		 *  @name DataTable#init.dt
		 *  @event
		 *  @param {event} e jQuery event object
		 *  @param {object} oSettings DataTables settings object
		 *  @param {object} json The JSON object request from the server - only
		 *    present if client-side Ajax sourced data is used</li></ol>
		 */
	
		/**
		 * State save event, fired when the table has changed state a new state save
		 * is required. This event allows modification of the state saving object
		 * prior to actually doing the save, including addition or other state
		 * properties (for plug-ins) or modification of a DataTables core property.
		 *  @name DataTable#stateSaveParams.dt
		 *  @event
		 *  @param {event} e jQuery event object
		 *  @param {object} oSettings DataTables settings object
		 *  @param {object} json The state information to be saved
		 */
	
		/**
		 * State load event, fired when the table is loading state from the stored
		 * data, but prior to the settings object being modified by the saved state
		 * - allowing modification of the saved state is required or loading of
		 * state for a plug-in.
		 *  @name DataTable#stateLoadParams.dt
		 *  @event
		 *  @param {event} e jQuery event object
		 *  @param {object} oSettings DataTables settings object
		 *  @param {object} json The saved state information
		 */
	
		/**
		 * State loaded event, fired when state has been loaded from stored data and
		 * the settings object has been modified by the loaded data.
		 *  @name DataTable#stateLoaded.dt
		 *  @event
		 *  @param {event} e jQuery event object
		 *  @param {object} oSettings DataTables settings object
		 *  @param {object} json The saved state information
		 */
	
		/**
		 * Processing event, fired when DataTables is doing some kind of processing
		 * (be it, order, searcg or anything else). It can be used to indicate to
		 * the end user that there is something happening, or that something has
		 * finished.
		 *  @name DataTable#processing.dt
		 *  @event
		 *  @param {event} e jQuery event object
		 *  @param {object} oSettings DataTables settings object
		 *  @param {boolean} bShow Flag for if DataTables is doing processing or not
		 */
	
		/**
		 * Ajax (XHR) event, fired whenever an Ajax request is completed from a
		 * request to made to the server for new data. This event is called before
		 * DataTables processed the returned data, so it can also be used to pre-
		 * process the data returned from the server, if needed.
		 *
		 * Note that this trigger is called in `fnServerData`, if you override
		 * `fnServerData` and which to use this event, you need to trigger it in you
		 * success function.
		 *  @name DataTable#xhr.dt
		 *  @event
		 *  @param {event} e jQuery event object
		 *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
		 *  @param {object} json JSON returned from the server
		 *
		 *  @example
		 *     // Use a custom property returned from the server in another DOM element
		 *     $('#table').dataTable().on('xhr.dt', function (e, settings, json) {
		 *       $('#status').html( json.status );
		 *     } );
		 *
		 *  @example
		 *     // Pre-process the data returned from the server
		 *     $('#table').dataTable().on('xhr.dt', function (e, settings, json) {
		 *       for ( var i=0, ien=json.aaData.length ; i<ien ; i++ ) {
		 *         json.aaData[i].sum = json.aaData[i].one + json.aaData[i].two;
		 *       }
		 *       // Note no return - manipulate the data directly in the JSON object.
		 *     } );
		 */
	
		/**
		 * Destroy event, fired when the DataTable is destroyed by calling fnDestroy
		 * or passing the bDestroy:true parameter in the initialisation object. This
		 * can be used to remove bound events, added DOM nodes, etc.
		 *  @name DataTable#destroy.dt
		 *  @event
		 *  @param {event} e jQuery event object
		 *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
		 */
	
		/**
		 * Page length change event, fired when number of records to show on each
		 * page (the length) is changed.
		 *  @name DataTable#length.dt
		 *  @event
		 *  @param {event} e jQuery event object
		 *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
		 *  @param {integer} len New length
		 */
	
		/**
		 * Column sizing has changed.
		 *  @name DataTable#column-sizing.dt
		 *  @event
		 *  @param {event} e jQuery event object
		 *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
		 */
	
		/**
		 * Column visibility has changed.
		 *  @name DataTable#column-visibility.dt
		 *  @event
		 *  @param {event} e jQuery event object
		 *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
		 *  @param {int} column Column index
		 *  @param {bool} vis `false` if column now hidden, or `true` if visible
		 */
	
		return $.fn.dataTable;
	}));


/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

	/*** IMPORTS FROM imports-loader ***/
	var define = false;
	
	/*! Select for DataTables 1.2.0
	 * 2015-2016 SpryMedia Ltd - datatables.net/license/mit
	 */
	
	/**
	 * @summary     Select for DataTables
	 * @description A collection of API methods, events and buttons for DataTables
	 *   that provides selection options of the items in a DataTable
	 * @version     1.2.0
	 * @file        dataTables.select.js
	 * @author      SpryMedia Ltd (www.sprymedia.co.uk)
	 * @contact     datatables.net/forums
	 * @copyright   Copyright 2015-2016 SpryMedia Ltd.
	 *
	 * This source file is free software, available under the following license:
	 *   MIT license - http://datatables.net/license/mit
	 *
	 * This source file is distributed in the hope that it will be useful, but
	 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
	 * or FITNESS FOR A PARTICULAR PURPOSE. See the license files for details.
	 *
	 * For details please refer to: http://www.datatables.net/extensions/select
	 */
	(function( factory ){
		if ( typeof define === 'function' && define.amd ) {
			// AMD
			define( ['jquery', 'datatables.net'], function ( $ ) {
				return factory( $, window, document );
			} );
		}
		else if ( true ) {
			// CommonJS
			module.exports = function (root, $) {
				if ( ! root ) {
					root = window;
				}
	
				if ( ! $ || ! $.fn.dataTable ) {
					$ = __webpack_require__(4)(root, $).$;
				}
	
				return factory( $, root, root.document );
			};
		}
		else {
			// Browser
			factory( jQuery, window, document );
		}
	}(function( $, window, document, undefined ) {
	'use strict';
	var DataTable = $.fn.dataTable;
	
	
	// Version information for debugger
	DataTable.select = {};
	
	DataTable.select.version = '1.2.0';
	
	DataTable.select.init = function ( dt ) {
		var ctx = dt.settings()[0];
		var init = ctx.oInit.select;
		var defaults = DataTable.defaults.select;
		var opts = init === undefined ?
			defaults :
			init;
	
		// Set defaults
		var items = 'row';
		var style = 'api';
		var blurable = false;
		var info = true;
		var selector = 'td, th';
		var className = 'selected';
	
		ctx._select = {};
	
		// Initialisation customisations
		if ( opts === true ) {
			style = 'os';
		}
		else if ( typeof opts === 'string' ) {
			style = opts;
		}
		else if ( $.isPlainObject( opts ) ) {
			if ( opts.blurable !== undefined ) {
				blurable = opts.blurable;
			}
	
			if ( opts.info !== undefined ) {
				info = opts.info;
			}
	
			if ( opts.items !== undefined ) {
				items = opts.items;
			}
	
			if ( opts.style !== undefined ) {
				style = opts.style;
			}
	
			if ( opts.selector !== undefined ) {
				selector = opts.selector;
			}
	
			if ( opts.className !== undefined ) {
				className = opts.className;
			}
		}
	
		dt.select.selector( selector );
		dt.select.items( items );
		dt.select.style( style );
		dt.select.blurable( blurable );
		dt.select.info( info );
		ctx._select.className = className;
	
	
		// Sort table based on selected rows. Requires Select Datatables extension
		$.fn.dataTable.ext.order['select-checkbox'] = function ( settings, col ) {
			return this.api().column( col, {order: 'index'} ).nodes().map( function ( td ) {
				if ( settings._select.items === 'row' ) {
					return $( td ).parent().hasClass( settings._select.className );
				} else if ( settings._select.items === 'cell' ) {
					return $( td ).hasClass( settings._select.className );
				}
				return false;
			});
		};
	
		// If the init options haven't enabled select, but there is a selectable
		// class name, then enable
		if ( $( dt.table().node() ).hasClass( 'selectable' ) ) {
			dt.select.style( 'os' );
		}
	};
	
	/*
	
	Select is a collection of API methods, event handlers, event emitters and
	buttons (for the `Buttons` extension) for DataTables. It provides the following
	features, with an overview of how they are implemented:
	
	## Selection of rows, columns and cells. Whether an item is selected or not is
	   stored in:
	
	* rows: a `_select_selected` property which contains a boolean value of the
	  DataTables' `aoData` object for each row
	* columns: a `_select_selected` property which contains a boolean value of the
	  DataTables' `aoColumns` object for each column
	* cells: a `_selected_cells` property which contains an array of boolean values
	  of the `aoData` object for each row. The array is the same length as the
	  columns array, with each element of it representing a cell.
	
	This method of using boolean flags allows Select to operate when nodes have not
	been created for rows / cells (DataTables' defer rendering feature).
	
	## API methods
	
	A range of API methods are available for triggering selection and de-selection
	of rows. Methods are also available to configure the selection events that can
	be triggered by an end user (such as which items are to be selected). To a large
	extent, these of API methods *is* Select. It is basically a collection of helper
	functions that can be used to select items in a DataTable.
	
	Configuration of select is held in the object `_select` which is attached to the
	DataTables settings object on initialisation. Select being available on a table
	is not optional when Select is loaded, but its default is for selection only to
	be available via the API - so the end user wouldn't be able to select rows
	without additional configuration.
	
	The `_select` object contains the following properties:
	
	```
	{
		items:string     - Can be `rows`, `columns` or `cells`. Defines what item 
		                   will be selected if the user is allowed to activate row
		                   selection using the mouse.
		style:string     - Can be `none`, `single`, `multi` or `os`. Defines the
		                   interaction style when selecting items
		blurable:boolean - If row selection can be cleared by clicking outside of
		                   the table
		info:boolean     - If the selection summary should be shown in the table
		                   information elements
	}
	```
	
	In addition to the API methods, Select also extends the DataTables selector
	options for rows, columns and cells adding a `selected` option to the selector
	options object, allowing the developer to select only selected items or
	unselected items.
	
	## Mouse selection of items
	
	Clicking on items can be used to select items. This is done by a simple event
	handler that will select the items using the API methods.
	
	 */
	
	
	/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	 * Local functions
	 */
	
	/**
	 * Add one or more cells to the selection when shift clicking in OS selection
	 * style cell selection.
	 *
	 * Cell range is more complicated than row and column as we want to select
	 * in the visible grid rather than by index in sequence. For example, if you
	 * click first in cell 1-1 and then shift click in 2-2 - cells 1-2 and 2-1
	 * should also be selected (and not 1-3, 1-4. etc)
	 * 
	 * @param  {DataTable.Api} dt   DataTable
	 * @param  {object}        idx  Cell index to select to
	 * @param  {object}        last Cell index to select from
	 * @private
	 */
	function cellRange( dt, idx, last )
	{
		var indexes;
		var columnIndexes;
		var rowIndexes;
		var selectColumns = function ( start, end ) {
			if ( start > end ) {
				var tmp = end;
				end = start;
				start = tmp;
			}
			
			var record = false;
			return dt.columns( ':visible' ).indexes().filter( function (i) {
				if ( i === start ) {
					record = true;
				}
				
				if ( i === end ) { // not else if, as start might === end
					record = false;
					return true;
				}
	
				return record;
			} );
		};
	
		var selectRows = function ( start, end ) {
			var indexes = dt.rows( { search: 'applied' } ).indexes();
	
			// Which comes first - might need to swap
			if ( indexes.indexOf( start ) > indexes.indexOf( end ) ) {
				var tmp = end;
				end = start;
				start = tmp;
			}
	
			var record = false;
			return indexes.filter( function (i) {
				if ( i === start ) {
					record = true;
				}
				
				if ( i === end ) {
					record = false;
					return true;
				}
	
				return record;
			} );
		};
	
		if ( ! dt.cells( { selected: true } ).any() && ! last ) {
			// select from the top left cell to this one
			columnIndexes = selectColumns( 0, idx.column );
			rowIndexes = selectRows( 0 , idx.row );
		}
		else {
			// Get column indexes between old and new
			columnIndexes = selectColumns( last.column, idx.column );
			rowIndexes = selectRows( last.row , idx.row );
		}
	
		indexes = dt.cells( rowIndexes, columnIndexes ).flatten();
	
		if ( ! dt.cells( idx, { selected: true } ).any() ) {
			// Select range
			dt.cells( indexes ).select();
		}
		else {
			// Deselect range
			dt.cells( indexes ).deselect();
		}
	}
	
	/**
	 * Disable mouse selection by removing the selectors
	 *
	 * @param {DataTable.Api} dt DataTable to remove events from
	 * @private
	 */
	function disableMouseSelection( dt )
	{
		var ctx = dt.settings()[0];
		var selector = ctx._select.selector;
	
		$( dt.table().body() )
			.off( 'mousedown.dtSelect', selector )
			.off( 'mouseup.dtSelect', selector )
			.off( 'click.dtSelect', selector );
	
		$('body').off( 'click.dtSelect' );
	}
	
	/**
	 * Attach mouse listeners to the table to allow mouse selection of items
	 *
	 * @param {DataTable.Api} dt DataTable to remove events from
	 * @private
	 */
	function enableMouseSelection ( dt )
	{
		var body = $( dt.table().body() );
		var ctx = dt.settings()[0];
		var selector = ctx._select.selector;
	
		body
			.on( 'mousedown.dtSelect', selector, function(e) {
				// Disallow text selection for shift clicking on the table so multi
				// element selection doesn't look terrible!
				if ( e.shiftKey || e.metaKey || e.ctrlKey ) {
					body
						.css( '-moz-user-select', 'none' )
						.one('selectstart.dtSelect', selector, function () {
							return false;
						} );
				}
			} )
			.on( 'mouseup.dtSelect', selector, function() {
				// Allow text selection to occur again, Mozilla style (tested in FF
				// 35.0.1 - still required)
				body.css( '-moz-user-select', '' );
			} )
			.on( 'click.dtSelect', selector, function ( e ) {
				var items = dt.select.items();
				var idx;
	
				// If text was selected (click and drag), then we shouldn't change
				// the row's selected state
				if ( window.getSelection && window.getSelection().toString() ) {
					return;
				}
	
				var ctx = dt.settings()[0];
	
				// Ignore clicks inside a sub-table
				if ( $(e.target).closest('div.dataTables_wrapper')[0] != dt.table().container() ) {
					return;
				}
	
				var cell = dt.cell( $(e.target).closest('td, th') );
	
				// Check the cell actually belongs to the host DataTable (so child
				// rows, etc, are ignored)
				if ( ! cell.any() ) {
					return;
				}
	
				var event = $.Event('user-select.dt');
				eventTrigger( dt, event, [ items, cell, e ] );
	
				if ( event.isDefaultPrevented() ) {
					return;
				}
	
				var cellIndex = cell.index();
				if ( items === 'row' ) {
					idx = cellIndex.row;
					typeSelect( e, dt, ctx, 'row', idx );
				}
				else if ( items === 'column' ) {
					idx = cell.index().column;
					typeSelect( e, dt, ctx, 'column', idx );
				}
				else if ( items === 'cell' ) {
					idx = cell.index();
					typeSelect( e, dt, ctx, 'cell', idx );
				}
	
				ctx._select_lastCell = cellIndex;
			} );
	
		// Blurable
		$('body').on( 'click.dtSelect', function ( e ) {
			if ( ctx._select.blurable ) {
				// If the click was inside the DataTables container, don't blur
				if ( $(e.target).parents().filter( dt.table().container() ).length ) {
					return;
				}
	
				// Don't blur in Editor form
				if ( $(e.target).parents('div.DTE').length ) {
					return;
				}
	
				clear( ctx, true );
			}
		} );
	}
	
	/**
	 * Trigger an event on a DataTable
	 *
	 * @param {DataTable.Api} api      DataTable to trigger events on
	 * @param  {boolean}      selected true if selected, false if deselected
	 * @param  {string}       type     Item type acting on
	 * @param  {boolean}      any      Require that there are values before
	 *     triggering
	 * @private
	 */
	function eventTrigger ( api, type, args, any )
	{
		if ( any && ! api.flatten().length ) {
			return;
		}
	
		if ( typeof type === 'string' ) {
			type = type +'.dt';
		}
	
		args.unshift( api );
	
		$(api.table().node()).triggerHandler( type, args );
	}
	
	/**
	 * Update the information element of the DataTable showing information about the
	 * items selected. This is done by adding tags to the existing text
	 * 
	 * @param {DataTable.Api} api DataTable to update
	 * @private
	 */
	function info ( api )
	{
		var ctx = api.settings()[0];
	
		if ( ! ctx._select.info || ! ctx.aanFeatures.i ) {
			return;
		}
	
		var output  = $('<span class="select-info"/>');
		var add = function ( name, num ) {
			output.append( $('<span class="select-item"/>').append( api.i18n(
				'select.'+name+'s',
				{ _: '%d '+name+'s selected', 0: '', 1: '1 '+name+' selected' },
				num
			) ) );
		};
	
		add( 'row',    api.rows( { selected: true } ).flatten().length );
		add( 'column', api.columns( { selected: true } ).flatten().length );
		add( 'cell',   api.cells( { selected: true } ).flatten().length );
	
		// Internal knowledge of DataTables to loop over all information elements
		$.each( ctx.aanFeatures.i, function ( i, el ) {
			el = $(el);
	
			var exisiting = el.children('span.select-info');
			if ( exisiting.length ) {
				exisiting.remove();
			}
	
			if ( output.text() !== '' ) {
				el.append( output );
			}
		} );
	}
	
	/**
	 * Initialisation of a new table. Attach event handlers and callbacks to allow
	 * Select to operate correctly.
	 *
	 * This will occur _after_ the initial DataTables initialisation, although
	 * before Ajax data is rendered, if there is ajax data
	 *
	 * @param  {DataTable.settings} ctx Settings object to operate on
	 * @private
	 */
	function init ( ctx ) {
		var api = new DataTable.Api( ctx );
	
		// Row callback so that classes can be added to rows and cells if the item
		// was selected before the element was created. This will happen with the
		// `deferRender` option enabled.
		// 
		// This method of attaching to `aoRowCreatedCallback` is a hack until
		// DataTables has proper events for row manipulation If you are reviewing
		// this code to create your own plug-ins, please do not do this!
		ctx.aoRowCreatedCallback.push( {
			fn: function ( row, data, index ) {
				var i, ien;
				var d = ctx.aoData[ index ];
	
				// Row
				if ( d._select_selected ) {
					$( row ).addClass( ctx._select.className );
				}
	
				// Cells and columns - if separated out, we would need to do two
				// loops, so it makes sense to combine them into a single one
				for ( i=0, ien=ctx.aoColumns.length ; i<ien ; i++ ) {
					if ( ctx.aoColumns[i]._select_selected || (d._selected_cells && d._selected_cells[i]) ) {
						$(d.anCells[i]).addClass( ctx._select.className );
					}
				}
			},
			sName: 'select-deferRender'
		} );
	
		// On Ajax reload we want to reselect all rows which are currently selected,
		// if there is an rowId (i.e. a unique value to identify each row with)
		api.on( 'preXhr.dt.dtSelect', function () {
			// note that column selection doesn't need to be cached and then
			// reselected, as they are already selected
			var rows = api.rows( { selected: true } ).ids( true ).filter( function ( d ) {
				return d !== undefined;
			} );
	
			var cells = api.cells( { selected: true } ).eq(0).map( function ( cellIdx ) {
				var id = api.row( cellIdx.row ).id( true );
				return id ?
					{ row: id, column: cellIdx.column } :
					undefined;
			} ).filter( function ( d ) {
				return d !== undefined;
			} );
	
			// On the next draw, reselect the currently selected items
			api.one( 'draw.dt.dtSelect', function () {
				api.rows( rows ).select();
	
				// `cells` is not a cell index selector, so it needs a loop
				if ( cells.any() ) {
					cells.each( function ( id ) {
						api.cells( id.row, id.column ).select();
					} );
				}
			} );
		} );
	
		// Update the table information element with selected item summary
		api.on( 'draw.dtSelect.dt select.dtSelect.dt deselect.dtSelect.dt info.dt', function () {
			info( api );
		} );
	
		// Clean up and release
		api.on( 'destroy.dtSelect', function () {
			disableMouseSelection( api );
			api.off( '.dtSelect' );
		} );
	}
	
	/**
	 * Add one or more items (rows or columns) to the selection when shift clicking
	 * in OS selection style
	 *
	 * @param  {DataTable.Api} dt   DataTable
	 * @param  {string}        type Row or column range selector
	 * @param  {object}        idx  Item index to select to
	 * @param  {object}        last Item index to select from
	 * @private
	 */
	function rowColumnRange( dt, type, idx, last )
	{
		// Add a range of rows from the last selected row to this one
		var indexes = dt[type+'s']( { search: 'applied' } ).indexes();
		var idx1 = $.inArray( last, indexes );
		var idx2 = $.inArray( idx, indexes );
	
		if ( ! dt[type+'s']( { selected: true } ).any() && idx1 === -1 ) {
			// select from top to here - slightly odd, but both Windows and Mac OS
			// do this
			indexes.splice( $.inArray( idx, indexes )+1, indexes.length );
		}
		else {
			// reverse so we can shift click 'up' as well as down
			if ( idx1 > idx2 ) {
				var tmp = idx2;
				idx2 = idx1;
				idx1 = tmp;
			}
	
			indexes.splice( idx2+1, indexes.length );
			indexes.splice( 0, idx1 );
		}
	
		if ( ! dt[type]( idx, { selected: true } ).any() ) {
			// Select range
			dt[type+'s']( indexes ).select();
		}
		else {
			// Deselect range - need to keep the clicked on row selected
			indexes.splice( $.inArray( idx, indexes ), 1 );
			dt[type+'s']( indexes ).deselect();
		}
	}
	
	/**
	 * Clear all selected items
	 *
	 * @param  {DataTable.settings} ctx Settings object of the host DataTable
	 * @param  {boolean} [force=false] Force the de-selection to happen, regardless
	 *     of selection style
	 * @private
	 */
	function clear( ctx, force )
	{
		if ( force || ctx._select.style === 'single' ) {
			var api = new DataTable.Api( ctx );
			
			api.rows( { selected: true } ).deselect();
			api.columns( { selected: true } ).deselect();
			api.cells( { selected: true } ).deselect();
		}
	}
	
	/**
	 * Select items based on the current configuration for style and items.
	 *
	 * @param  {object}             e    Mouse event object
	 * @param  {DataTables.Api}     dt   DataTable
	 * @param  {DataTable.settings} ctx  Settings object of the host DataTable
	 * @param  {string}             type Items to select
	 * @param  {int|object}         idx  Index of the item to select
	 * @private
	 */
	function typeSelect ( e, dt, ctx, type, idx )
	{
		var style = dt.select.style();
		var isSelected = dt[type]( idx, { selected: true } ).any();
	
		if ( style === 'os' ) {
			if ( e.ctrlKey || e.metaKey ) {
				// Add or remove from the selection
				dt[type]( idx ).select( ! isSelected );
			}
			else if ( e.shiftKey ) {
				if ( type === 'cell' ) {
					cellRange( dt, idx, ctx._select_lastCell || null );
				}
				else {
					rowColumnRange( dt, type, idx, ctx._select_lastCell ?
						ctx._select_lastCell[type] :
						null
					);
				}
			}
			else {
				// No cmd or shift click - deselect if selected, or select
				// this row only
				var selected = dt[type+'s']( { selected: true } );
	
				if ( isSelected && selected.flatten().length === 1 ) {
					dt[type]( idx ).deselect();
				}
				else {
					selected.deselect();
					dt[type]( idx ).select();
				}
			}
		} else if ( style == 'multi+shift' ) {
			if ( e.shiftKey ) {
				if ( type === 'cell' ) {
					cellRange( dt, idx, ctx._select_lastCell || null );
				}
				else {
					rowColumnRange( dt, type, idx, ctx._select_lastCell ?
						ctx._select_lastCell[type] :
						null
					);
				}
			}
			else {
				dt[ type ]( idx ).select( ! isSelected );
			}
		}
		else {
			dt[ type ]( idx ).select( ! isSelected );
		}
	}
	
	
	
	/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	 * DataTables selectors
	 */
	
	// row and column are basically identical just assigned to different properties
	// and checking a different array, so we can dynamically create the functions to
	// reduce the code size
	$.each( [
		{ type: 'row', prop: 'aoData' },
		{ type: 'column', prop: 'aoColumns' }
	], function ( i, o ) {
		DataTable.ext.selector[ o.type ].push( function ( settings, opts, indexes ) {
			var selected = opts.selected;
			var data;
			var out = [];
	
			if ( selected === undefined ) {
				return indexes;
			}
	
			for ( var i=0, ien=indexes.length ; i<ien ; i++ ) {
				data = settings[ o.prop ][ indexes[i] ];
	
				if ( (selected === true && data._select_selected === true) ||
				     (selected === false && ! data._select_selected )
				) {
					out.push( indexes[i] );
				}
			}
	
			return out;
		} );
	} );
	
	DataTable.ext.selector.cell.push( function ( settings, opts, cells ) {
		var selected = opts.selected;
		var rowData;
		var out = [];
	
		if ( selected === undefined ) {
			return cells;
		}
	
		for ( var i=0, ien=cells.length ; i<ien ; i++ ) {
			rowData = settings.aoData[ cells[i].row ];
	
			if ( (selected === true && rowData._selected_cells && rowData._selected_cells[ cells[i].column ] === true) ||
			     (selected === false && ( ! rowData._selected_cells || ! rowData._selected_cells[ cells[i].column ] ) )
			) {
				out.push( cells[i] );
			}
		}
	
		return out;
	} );
	
	
	
	/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	 * DataTables API
	 *
	 * For complete documentation, please refer to the docs/api directory or the
	 * DataTables site
	 */
	
	// Local variables to improve compression
	var apiRegister = DataTable.Api.register;
	var apiRegisterPlural = DataTable.Api.registerPlural;
	
	apiRegister( 'select()', function () {
		return this.iterator( 'table', function ( ctx ) {
			DataTable.select.init( new DataTable.Api( ctx ) );
		} );
	} );
	
	apiRegister( 'select.blurable()', function ( flag ) {
		if ( flag === undefined ) {
			return this.context[0]._select.blurable;
		}
	
		return this.iterator( 'table', function ( ctx ) {
			ctx._select.blurable = flag;
		} );
	} );
	
	apiRegister( 'select.info()', function ( flag ) {
		if ( info === undefined ) {
			return this.context[0]._select.info;
		}
	
		return this.iterator( 'table', function ( ctx ) {
			ctx._select.info = flag;
		} );
	} );
	
	apiRegister( 'select.items()', function ( items ) {
		if ( items === undefined ) {
			return this.context[0]._select.items;
		}
	
		return this.iterator( 'table', function ( ctx ) {
			ctx._select.items = items;
	
			eventTrigger( new DataTable.Api( ctx ), 'selectItems', [ items ] );
		} );
	} );
	
	// Takes effect from the _next_ selection. None disables future selection, but
	// does not clear the current selection. Use the `deselect` methods for that
	apiRegister( 'select.style()', function ( style ) {
		if ( style === undefined ) {
			return this.context[0]._select.style;
		}
	
		return this.iterator( 'table', function ( ctx ) {
			ctx._select.style = style;
	
			if ( ! ctx._select_init ) {
				init( ctx );
			}
	
			// Add / remove mouse event handlers. They aren't required when only
			// API selection is available
			var dt = new DataTable.Api( ctx );
			disableMouseSelection( dt );
			
			if ( style !== 'api' ) {
				enableMouseSelection( dt );
			}
	
			eventTrigger( new DataTable.Api( ctx ), 'selectStyle', [ style ] );
		} );
	} );
	
	apiRegister( 'select.selector()', function ( selector ) {
		if ( selector === undefined ) {
			return this.context[0]._select.selector;
		}
	
		return this.iterator( 'table', function ( ctx ) {
			disableMouseSelection( new DataTable.Api( ctx ) );
	
			ctx._select.selector = selector;
	
			if ( ctx._select.style !== 'api' ) {
				enableMouseSelection( new DataTable.Api( ctx ) );
			}
		} );
	} );
	
	
	
	apiRegisterPlural( 'rows().select()', 'row().select()', function ( select ) {
		var api = this;
	
		if ( select === false ) {
			return this.deselect();
		}
	
		this.iterator( 'row', function ( ctx, idx ) {
			clear( ctx );
	
			ctx.aoData[ idx ]._select_selected = true;
			$( ctx.aoData[ idx ].nTr ).addClass( ctx._select.className );
		} );
	
		this.iterator( 'table', function ( ctx, i ) {
			eventTrigger( api, 'select', [ 'row', api[i] ], true );
		} );
	
		return this;
	} );
	
	apiRegisterPlural( 'columns().select()', 'column().select()', function ( select ) {
		var api = this;
	
		if ( select === false ) {
			return this.deselect();
		}
	
		this.iterator( 'column', function ( ctx, idx ) {
			clear( ctx );
	
			ctx.aoColumns[ idx ]._select_selected = true;
	
			var column = new DataTable.Api( ctx ).column( idx );
	
			$( column.header() ).addClass( ctx._select.className );
			$( column.footer() ).addClass( ctx._select.className );
	
			column.nodes().to$().addClass( ctx._select.className );
		} );
	
		this.iterator( 'table', function ( ctx, i ) {
			eventTrigger( api, 'select', [ 'column', api[i] ], true );
		} );
	
		return this;
	} );
	
	apiRegisterPlural( 'cells().select()', 'cell().select()', function ( select ) {
		var api = this;
	
		if ( select === false ) {
			return this.deselect();
		}
	
		this.iterator( 'cell', function ( ctx, rowIdx, colIdx ) {
			clear( ctx );
	
			var data = ctx.aoData[ rowIdx ];
	
			if ( data._selected_cells === undefined ) {
				data._selected_cells = [];
			}
	
			data._selected_cells[ colIdx ] = true;
	
			if ( data.anCells ) {
				$( data.anCells[ colIdx ] ).addClass( ctx._select.className );
			}
		} );
	
		this.iterator( 'table', function ( ctx, i ) {
			eventTrigger( api, 'select', [ 'cell', api[i] ], true );
		} );
	
		return this;
	} );
	
	
	apiRegisterPlural( 'rows().deselect()', 'row().deselect()', function () {
		var api = this;
	
		this.iterator( 'row', function ( ctx, idx ) {
			ctx.aoData[ idx ]._select_selected = false;
			$( ctx.aoData[ idx ].nTr ).removeClass( ctx._select.className );
		} );
	
		this.iterator( 'table', function ( ctx, i ) {
			eventTrigger( api, 'deselect', [ 'row', api[i] ], true );
		} );
	
		return this;
	} );
	
	apiRegisterPlural( 'columns().deselect()', 'column().deselect()', function () {
		var api = this;
	
		this.iterator( 'column', function ( ctx, idx ) {
			ctx.aoColumns[ idx ]._select_selected = false;
	
			var api = new DataTable.Api( ctx );
			var column = api.column( idx );
	
			$( column.header() ).removeClass( ctx._select.className );
			$( column.footer() ).removeClass( ctx._select.className );
	
			// Need to loop over each cell, rather than just using
			// `column().nodes()` as cells which are individually selected should
			// not have the `selected` class removed from them
			api.cells( null, idx ).indexes().each( function (cellIdx) {
				var data = ctx.aoData[ cellIdx.row ];
				var cellSelected = data._selected_cells;
	
				if ( data.anCells && (! cellSelected || ! cellSelected[ cellIdx.column ]) ) {
					$( data.anCells[ cellIdx.column  ] ).removeClass( ctx._select.className );
				}
			} );
		} );
	
		this.iterator( 'table', function ( ctx, i ) {
			eventTrigger( api, 'deselect', [ 'column', api[i] ], true );
		} );
	
		return this;
	} );
	
	apiRegisterPlural( 'cells().deselect()', 'cell().deselect()', function () {
		var api = this;
	
		this.iterator( 'cell', function ( ctx, rowIdx, colIdx ) {
			var data = ctx.aoData[ rowIdx ];
	
			data._selected_cells[ colIdx ] = false;
	
			// Remove class only if the cells exist, and the cell is not column
			// selected, in which case the class should remain (since it is selected
			// in the column)
			if ( data.anCells && ! ctx.aoColumns[ colIdx ]._select_selected ) {
				$( data.anCells[ colIdx ] ).removeClass( ctx._select.className );
			}
		} );
	
		this.iterator( 'table', function ( ctx, i ) {
			eventTrigger( api, 'deselect', [ 'cell', api[i] ], true );
		} );
	
		return this;
	} );
	
	
	
	/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	 * Buttons
	 */
	function i18n( label, def ) {
		return function (dt) {
			return dt.i18n( 'buttons.'+label, def );
		};
	}
	
	$.extend( DataTable.ext.buttons, {
		selected: {
			text: i18n( 'selected', 'Selected' ),
			className: 'buttons-selected',
			init: function ( dt ) {
				var that = this;
	
				// .DT namespace listeners are removed by DataTables automatically
				// on table destroy
				dt.on( 'draw.dt.DT select.dt.DT deselect.dt.DT', function () {
					var enable = that.rows( { selected: true } ).any() ||
					             that.columns( { selected: true } ).any() ||
					             that.cells( { selected: true } ).any();
	
					that.enable( enable );
				} );
	
				this.disable();
			}
		},
		selectedSingle: {
			text: i18n( 'selectedSingle', 'Selected single' ),
			className: 'buttons-selected-single',
			init: function ( dt ) {
				var that = this;
	
				dt.on( 'draw.dt.DT select.dt.DT deselect.dt.DT', function () {
					var count = dt.rows( { selected: true } ).flatten().length +
					            dt.columns( { selected: true } ).flatten().length +
					            dt.cells( { selected: true } ).flatten().length;
	
					that.enable( count === 1 );
				} );
	
				this.disable();
			}
		},
		selectAll: {
			text: i18n( 'selectAll', 'Select all' ),
			className: 'buttons-select-all',
			action: function () {
				var items = this.select.items();
				this[ items+'s' ]().select();
			}
		},
		selectNone: {
			text: i18n( 'selectNone', 'Deselect all' ),
			className: 'buttons-select-none',
			action: function () {
				clear( this.settings()[0], true );
			},
			init: function ( dt ) {
				var that = this;
	
				dt.on( 'draw.dt.DT select.dt.DT deselect.dt.DT', function () {
					var count = dt.rows( { selected: true } ).flatten().length +
					            dt.columns( { selected: true } ).flatten().length +
					            dt.cells( { selected: true } ).flatten().length;
	
					that.enable( count > 0 );
				} );
	
				this.disable();
			}
		}
	} );
	
	$.each( [ 'Row', 'Column', 'Cell' ], function ( i, item ) {
		var lc = item.toLowerCase();
	
		DataTable.ext.buttons[ 'select'+item+'s' ] = {
			text: i18n( 'select'+item+'s', 'Select '+lc+'s' ),
			className: 'buttons-select-'+lc+'s',
			action: function () {
				this.select.items( lc );
			},
			init: function ( dt ) {
				var that = this;
	
				dt.on( 'selectItems.dt.DT', function ( e, ctx, items ) {
					that.active( items === lc );
				} );
			}
		};
	} );
	
	
	
	/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	 * Initialisation
	 */
	
	// DataTables creation - check if select has been defined in the options. Note
	// this required that the table be in the document! If it isn't then something
	// needs to trigger this method unfortunately. The next major release of
	// DataTables will rework the events and address this.
	$(document).on( 'preInit.dt.dtSelect', function (e, ctx) {
		if ( e.namespace !== 'dt' ) {
			return;
		}
	
		DataTable.select.init( new DataTable.Api( ctx ) );
	} );
	
	
	return DataTable.select;
	}));
	


/***/ },
/* 6 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 7 */,
/* 8 */,
/* 9 */,
/* 10 */,
/* 11 */,
/* 12 */,
/* 13 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*! Select for DataTables 1.1.0
	 * 2015 SpryMedia Ltd - datatables.net/license/mit
	 */
	
	/**
	 * @summary     Select for DataTables
	 * @description A collection of API methods, events and buttons for DataTables
	 *   that provides selection options of the items in a DataTable
	 * @version     1.1.0
	 * @file        dataTables.select.js
	 * @author      SpryMedia Ltd (www.sprymedia.co.uk)
	 * @contact     datatables.net/forums
	 * @copyright   Copyright 2015 SpryMedia Ltd.
	 *
	 * This source file is free software, available under the following license:
	 *   MIT license - http://datatables.net/license/mit
	 *
	 * This source file is distributed in the hope that it will be useful, but
	 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
	 * or FITNESS FOR A PARTICULAR PURPOSE. See the license files for details.
	 *
	 * For details please refer to: http://www.datatables.net/extensions/select
	 */
	(function( factory ){
		if ( true ) {
			// AMD
			!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(1), __webpack_require__(14)], __WEBPACK_AMD_DEFINE_RESULT__ = function ( $ ) {
				return factory( $, window, document );
			}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
		}
		else if ( typeof exports === 'object' ) {
			// CommonJS
			module.exports = function (root, $) {
				if ( ! root ) {
					root = window;
				}
	
				if ( ! $ || ! $.fn.dataTable ) {
					$ = require('datatables')(root, $).$;
				}
	
				return factory( $, root, root.document );
			};
		}
		else {
			// Browser
			factory( jQuery, window, document );
		}
	}(function( $, window, document, undefined ) {
	'use strict';
	var DataTable = $.fn.dataTable;
	
	
	// Version information for debugger
	DataTable.select = {};
	DataTable.select.version = '1.1.0';
	
	/*
	
	Select is a collection of API methods, event handlers, event emitters and
	buttons (for the `Buttons` extension) for DataTables. It provides the following
	features, with an overview of how they are implemented:
	
	## Selection of rows, columns and cells. Whether an item is selected or not is
	   stored in:
	
	* rows: a `_select_selected` property which contains a boolean value of the
	  DataTables' `aoData` object for each row
	* columns: a `_select_selected` property which contains a boolean value of the
	  DataTables' `aoColumns` object for each column
	* cells: a `_selected_cells` property which contains an array of boolean values
	  of the `aoData` object for each row. The array is the same length as the
	  columns array, with each element of it representing a cell.
	
	This method of using boolean flags allows Select to operate when nodes have not
	been created for rows / cells (DataTables' defer rendering feature).
	
	## API methods
	
	A range of API methods are available for triggering selection and de-selection
	of rows. Methods are also available to configure the selection events that can
	be triggered by an end user (such as which items are to be selected). To a large
	extent, these of API methods *is* Select. It is basically a collection of helper
	functions that can be used to select items in a DataTable.
	
	Configuration of select is held in the object `_select` which is attached to the
	DataTables settings object on initialisation. Select being available on a table
	is not optional when Select is loaded, but its default is for selection only to
	be available via the API - so the end user wouldn't be able to select rows
	without additional configuration.
	
	The `_select` object contains the following properties:
	
	```
	{
		items:string     - Can be `rows`, `columns` or `cells`. Defines what item 
		                   will be selected if the user is allowed to activate row
		                   selection using the mouse.
		style:string     - Can be `none`, `single`, `multi` or `os`. Defines the
		                   interaction style when selecting items
		blurable:boolean - If row selection can be cleared by clicking outside of
		                   the table
		info:boolean     - If the selection summary should be shown in the table
		                   information elements
	}
	```
	
	In addition to the API methods, Select also extends the DataTables selector
	options for rows, columns and cells adding a `selected` option to the selector
	options object, allowing the developer to select only selected items or
	unselected items.
	
	## Mouse selection of items
	
	Clicking on items can be used to select items. This is done by a simple event
	handler that will select the items using the API methods.
	
	 */
	
	
	/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	 * Local functions
	 */
	
	/**
	 * Add one or more cells to the selection when shift clicking in OS selection
	 * style cell selection.
	 *
	 * Cell range is more complicated than row and column as we want to select
	 * in the visible grid rather than by index in sequence. For example, if you
	 * click first in cell 1-1 and then shift click in 2-2 - cells 1-2 and 2-1
	 * should also be selected (and not 1-3, 1-4. etc)
	 * 
	 * @param  {DataTable.Api} dt   DataTable
	 * @param  {object}        idx  Cell index to select to
	 * @param  {object}        last Cell index to select from
	 * @private
	 */
	function cellRange( dt, idx, last )
	{
		var indexes;
		var columnIndexes;
		var rowIndexes;
		var selectColumns = function ( start, end ) {
			if ( start > end ) {
				var tmp = end;
				end = start;
				start = tmp;
			}
			
			var record = false;
			return dt.columns( ':visible' ).indexes().filter( function (i) {
				if ( i === start ) {
					record = true;
				}
				
				if ( i === end ) { // not else if, as start might === end
					record = false;
					return true;
				}
	
				return record;
			} );
		};
	
		var selectRows = function ( start, end ) {
			var indexes = dt.rows( { search: 'applied' } ).indexes();
	
			// Which comes first - might need to swap
			if ( indexes.indexOf( start ) > indexes.indexOf( end ) ) {
				var tmp = end;
				end = start;
				start = tmp;
			}
	
			var record = false;
			return indexes.filter( function (i) {
				if ( i === start ) {
					record = true;
				}
				
				if ( i === end ) {
					record = false;
					return true;
				}
	
				return record;
			} );
		};
	
		if ( ! dt.cells( { selected: true } ).any() && ! last ) {
			// select from the top left cell to this one
			columnIndexes = selectColumns( 0, idx.column );
			rowIndexes = selectRows( 0 , idx.row );
		}
		else {
			// Get column indexes between old and new
			columnIndexes = selectColumns( last.column, idx.column );
			rowIndexes = selectRows( last.row , idx.row );
		}
	
		indexes = dt.cells( rowIndexes, columnIndexes ).flatten();
	
		if ( ! dt.cells( idx, { selected: true } ).any() ) {
			// Select range
			dt.cells( indexes ).select();
		}
		else {
			// Deselect range
			dt.cells( indexes ).deselect();
		}
	}
	
	/**
	 * Disable mouse selection by removing the selectors
	 *
	 * @param {DataTable.Api} dt DataTable to remove events from
	 * @private
	 */
	function disableMouseSelection( dt )
	{
		var ctx = dt.settings()[0];
		var selector = ctx._select.selector;
	
		$( dt.table().body() )
			.off( 'mousedown.dtSelect', selector )
			.off( 'mouseup.dtSelect', selector )
			.off( 'click.dtSelect', selector );
	
		$('body').off( 'click.dtSelect' );
	}
	
	/**
	 * Attach mouse listeners to the table to allow mouse selection of items
	 *
	 * @param {DataTable.Api} dt DataTable to remove events from
	 * @private
	 */
	function enableMouseSelection ( dt )
	{
		var body = $( dt.table().body() );
		var ctx = dt.settings()[0];
		var selector = ctx._select.selector;
	
		body
			.on( 'mousedown.dtSelect', selector, function(e) {
				// Disallow text selection for shift clicking on the table so multi
				// element selection doesn't look terrible!
				if ( e.shiftKey ) {
					body
						.css( '-moz-user-select', 'none' )
						.one('selectstart.dtSelect', selector, function () {
							return false;
						} );
				}
			} )
			.on( 'mouseup.dtSelect', selector, function(e) {
				// Allow text selection to occur again, Mozilla style (tested in FF
				// 35.0.1 - still required)
				body.css( '-moz-user-select', '' );
			} )
			.on( 'click.dtSelect', selector, function ( e ) {
				var items = dt.select.items();
				var idx;
	
				var ctx = dt.settings()[0];
	
				// Ignore clicks inside a sub-table
				if ( $(e.target).closest('tbody')[0] != body[0] ) {
					return;
				}
	
				var cell = $(e.target).closest('td, th');
				var cellIndex = dt.cell( cell ).index();
	
				// Check the cell actually belongs to the host DataTable (so child rows,
				// etc, are ignored)
				if ( ! dt.cell( cell ).any() ) {
					return;
				}
	
				if ( items === 'row' ) {
					idx = cellIndex.row;
					typeSelect( e, dt, ctx, 'row', idx );
				}
				else if ( items === 'column' ) {
					idx = dt.cell( cell ).index().column;
					typeSelect( e, dt, ctx, 'column', idx );
				}
				else if ( items === 'cell' ) {
					idx = dt.cell( cell ).index();
					typeSelect( e, dt, ctx, 'cell', idx );
				}
	
				ctx._select_lastCell = cellIndex;
			} );
	
		// Blurable
		$('body').on( 'click.dtSelect', function ( e ) {
			if ( ctx._select.blurable ) {
				// If the click was inside the DataTables container, don't blur
				if ( $(e.target).parents().filter( dt.table().container() ).length ) {
					return;
				}
	
				// Don't blur in Editor form
				if ( $(e.target).parents('div.DTE').length ) {
					return;
				}
	
				clear( ctx, true );
			}
		} );
	}
	
	/**
	 * Trigger an event on a DataTable
	 *
	 * @param {DataTable.Api} api      DataTable to trigger events on
	 * @param  {boolean}      selected true if selected, false if deselected
	 * @param  {string}       type     Item type acting on
	 * @param  {boolean}      any      Require that there are values before
	 *     triggering
	 * @private
	 */
	function eventTrigger ( api, type, args, any )
	{
		if ( any && ! api.flatten().length ) {
			return;
		}
	
		args.unshift( api );
	
		$(api.table().node()).triggerHandler( type+'.dt', args );
	}
	
	/**
	 * Update the information element of the DataTable showing information about the
	 * items selected. This is done by adding tags to the existing text
	 * 
	 * @param {DataTable.Api} api DataTable to update
	 * @private
	 */
	function info ( api )
	{
		var ctx = api.settings()[0];
	
		if ( ! ctx._select.info || ! ctx.aanFeatures.i ) {
			return;
		}
	
		var output  = $('<span class="select-info"/>');
		var add = function ( name, num ) {
			output.append( $('<span class="select-item"/>').append( api.i18n(
				'select.'+name+'s',
				{ _: '%d '+name+'s selected', 0: '', 1: '1 '+name+' selected' },
				num
			) ) );
		};
	
		add( 'row',    api.rows( { selected: true } ).flatten().length );
		add( 'column', api.columns( { selected: true } ).flatten().length );
		add( 'cell',   api.cells( { selected: true } ).flatten().length );
	
		// Internal knowledge of DataTables to loop over all information elements
		$.each( ctx.aanFeatures.i, function ( i, el ) {
			el = $(el);
	
			var exisiting = el.children('span.select-info');
			if ( exisiting.length ) {
				exisiting.remove();
			}
	
			if ( output.text() !== '' ) {
				el.append( output );
			}
		} );
	}
	
	/**
	 * Initialisation of a new table. Attach event handlers and callbacks to allow
	 * Select to operate correctly.
	 *
	 * This will occur _after_ the initial DataTables initialisation, although
	 * before Ajax data is rendered, if there is ajax data
	 *
	 * @param  {DataTable.settings} ctx Settings object to operate on
	 * @private
	 */
	function init ( ctx ) {
		var api = new DataTable.Api( ctx );
	
		// Row callback so that classes can be added to rows and cells if the item
		// was selected before the element was created. This will happen with the
		// `deferRender` option enabled.
		// 
		// This method of attaching to `aoRowCreatedCallback` is a hack until
		// DataTables has proper events for row manipulation If you are reviewing
		// this code to create your own plug-ins, please do not do this!
		ctx.aoRowCreatedCallback.push( {
			fn: function ( row, data, index ) {
				var i, ien;
				var d = ctx.aoData[ index ];
	
				// Row
				if ( d._select_selected ) {
					$( row ).addClass( ctx._select.className );
				}
	
				// Cells and columns - if separated out, we would need to do two
				// loops, so it makes sense to combine them into a single one
				for ( i=0, ien=ctx.aoColumns.length ; i<ien ; i++ ) {
					if ( ctx.aoColumns[i]._select_selected || (d._selected_cells && d._selected_cells[i]) ) {
						$(d.anCells[i]).addClass( ctx._select.className );
					}
				}
			},
			sName: 'select-deferRender'
		} );
	
		// On Ajax reload we want to reselect all rows which are currently selected,
		// if there is an rowId (i.e. a unique value to identify each row with)
		api.on( 'preXhr.dt.dtSelect', function () {
			// note that column selection doesn't need to be cached and then
			// reselected, as they are already selected
			var rows = api.rows( { selected: true } ).ids( true ).filter( function ( d ) {
				return d !== undefined;
			} );
	
			var cells = api.cells( { selected: true } ).eq(0).map( function ( cellIdx ) {
				var id = api.row( cellIdx.row ).id( true );
				return id ?
					{ row: id, column: cellIdx.column } :
					undefined;
			} ).filter( function ( d ) {
				return d !== undefined;
			} );
	
			// On the next draw, reselect the currently selected items
			api.one( 'draw.dt.dtSelect', function () {
				api.rows( rows ).select();
	
				// `cells` is not a cell index selector, so it needs a loop
				if ( cells.any() ) {
					cells.each( function ( id ) {
						api.cells( id.row, id.column ).select();
					} );
				}
			} );
		} );
	
		// Update the table information element with selected item summary
		api.on( 'draw.dtSelect.dt select.dtSelect.dt deselect.dtSelect.dt', function () {
			info( api );
		} );
	
		// Clean up and release
		api.on( 'destroy.dtSelect', function () {
			disableMouseSelection( api );
			api.off( '.dtSelect' );
		} );
	}
	
	/**
	 * Add one or more items (rows or columns) to the selection when shift clicking
	 * in OS selection style
	 *
	 * @param  {DataTable.Api} dt   DataTable
	 * @param  {string}        type Row or column range selector
	 * @param  {object}        idx  Item index to select to
	 * @param  {object}        last Item index to select from
	 * @private
	 */
	function rowColumnRange( dt, type, idx, last )
	{
		// Add a range of rows from the last selected row to this one
		var indexes = dt[type+'s']( { search: 'applied' } ).indexes();
		var idx1 = $.inArray( last, indexes );
		var idx2 = $.inArray( idx, indexes );
	
		if ( ! dt[type+'s']( { selected: true } ).any() && idx1 === -1 ) {
			// select from top to here - slightly odd, but both Windows and Mac OS
			// do this
			indexes.splice( $.inArray( idx, indexes )+1, indexes.length );
		}
		else {
			// reverse so we can shift click 'up' as well as down
			if ( idx1 > idx2 ) {
				var tmp = idx2;
				idx2 = idx1;
				idx1 = tmp;
			}
	
			indexes.splice( idx2+1, indexes.length );
			indexes.splice( 0, idx1 );
		}
	
		if ( ! dt[type]( idx, { selected: true } ).any() ) {
			// Select range
			dt[type+'s']( indexes ).select();
		}
		else {
			// Deselect range - need to keep the clicked on row selected
			indexes.splice( $.inArray( idx, indexes ), 1 );
			dt[type+'s']( indexes ).deselect();
		}
	}
	
	/**
	 * Clear all selected items
	 *
	 * @param  {DataTable.settings} ctx Settings object of the host DataTable
	 * @param  {boolean} [force=false] Force the de-selection to happen, regardless
	 *     of selection style
	 * @private
	 */
	function clear( ctx, force )
	{
		if ( force || ctx._select.style === 'single' ) {
			var api = new DataTable.Api( ctx );
			
			api.rows( { selected: true } ).deselect();
			api.columns( { selected: true } ).deselect();
			api.cells( { selected: true } ).deselect();
		}
	}
	
	/**
	 * Select items based on the current configuration for style and items.
	 *
	 * @param  {object}             e    Mouse event object
	 * @param  {DataTables.Api}     dt   DataTable
	 * @param  {DataTable.settings} ctx  Settings object of the host DataTable
	 * @param  {string}             type Items to select
	 * @param  {int|object}         idx  Index of the item to select
	 * @private
	 */
	function typeSelect ( e, dt, ctx, type, idx )
	{
		var style = dt.select.style();
		var isSelected = dt[type]( idx, { selected: true } ).any();
	
		if ( style === 'os' ) {
			if ( e.ctrlKey || e.metaKey ) {
				// Add or remove from the selection
				dt[type]( idx ).select( ! isSelected );
			}
			else if ( e.shiftKey ) {
				if ( type === 'cell' ) {
					cellRange( dt, idx, ctx._select_lastCell || null );
				}
				else {
					rowColumnRange( dt, type, idx, ctx._select_lastCell ?
						ctx._select_lastCell[type] :
						null
					);
				}
			}
			else {
				// No cmd or shift click - deselect if selected, or select
				// this row only
				var selected = dt[type+'s']( { selected: true } );
	
				if ( isSelected && selected.flatten().length === 1 ) {
					dt[type]( idx ).deselect();
				}
				else {
					selected.deselect();
					dt[type]( idx ).select();
				}
			}
		}
		else {
			dt[ type ]( idx ).select( ! isSelected );
		}
	}
	
	
	
	/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	 * DataTables selectors
	 */
	
	// row and column are basically identical just assigned to different properties
	// and checking a different array, so we can dynamically create the functions to
	// reduce the code size
	$.each( [
		{ type: 'row', prop: 'aoData' },
		{ type: 'column', prop: 'aoColumns' }
	], function ( i, o ) {
		DataTable.ext.selector[ o.type ].push( function ( settings, opts, indexes ) {
			var selected = opts.selected;
			var data;
			var out = [];
	
			if ( selected === undefined ) {
				return indexes;
			}
	
			for ( var i=0, ien=indexes.length ; i<ien ; i++ ) {
				data = settings[ o.prop ][ indexes[i] ];
	
				if ( (selected === true && data._select_selected === true) ||
					 (selected === false && ! data._select_selected )
				) {
					out.push( indexes[i] );
				}
			}
	
			return out;
		} );
	} );
	
	DataTable.ext.selector.cell.push( function ( settings, opts, cells ) {
		var selected = opts.selected;
		var rowData;
		var out = [];
	
		if ( selected === undefined ) {
			return cells;
		}
	
		for ( var i=0, ien=cells.length ; i<ien ; i++ ) {
			rowData = settings.aoData[ cells[i].row ];
	
			if ( (selected === true && rowData._selected_cells && rowData._selected_cells[ cells[i].column ] === true) ||
				 (selected === false && ( ! rowData._selected_cells || ! rowData._selected_cells[ cells[i].column ] ) )
			) {
				out.push( cells[i] );
			}
		}
	
		return out;
	} );
	
	
	
	/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	 * DataTables API
	 *
	 * For complete documentation, please refer to the docs/api directory or the
	 * DataTables site
	 */
	
	// Local variables to improve compression
	var apiRegister = DataTable.Api.register;
	var apiRegisterPlural = DataTable.Api.registerPlural;
	
	apiRegister( 'select()', function () {} );
	
	apiRegister( 'select.blurable()', function ( flag ) {
		if ( flag === undefined ) {
			return this.context[0]._select.blurable;
		}
	
		return this.iterator( 'table', function ( ctx ) {
			ctx._select.blurable = flag;
		} );
	} );
	
	apiRegister( 'select.info()', function ( flag ) {
		if ( info === undefined ) {
			return this.context[0]._select.info;
		}
	
		return this.iterator( 'table', function ( ctx ) {
			ctx._select.info = flag;
		} );
	} );
	
	apiRegister( 'select.items()', function ( items ) {
		if ( items === undefined ) {
			return this.context[0]._select.items;
		}
	
		return this.iterator( 'table', function ( ctx ) {
			ctx._select.items = items;
	
			eventTrigger( new DataTable.Api( ctx ), 'selectItems', [ items ] );
		} );
	} );
	
	// Takes effect from the _next_ selection. None disables future selection, but
	// does not clear the current selection. Use the `deselect` methods for that
	apiRegister( 'select.style()', function ( style ) {
		if ( style === undefined ) {
			return this.context[0]._select.style;
		}
	
		return this.iterator( 'table', function ( ctx ) {
			ctx._select.style = style;
	
			if ( ! ctx._select_init ) {
				init( ctx );
			}
	
			// Add / remove mouse event handlers. They aren't required when only
			// API selection is available
			var dt = new DataTable.Api( ctx );
			disableMouseSelection( dt );
			
			if ( style !== 'api' ) {
				enableMouseSelection( dt );
			}
	
			eventTrigger( new DataTable.Api( ctx ), 'selectStyle', [ style ] );
		} );
	} );
	
	apiRegister( 'select.selector()', function ( selector ) {
		if ( selector === undefined ) {
			return this.context[0]._select.selector;
		}
	
		return this.iterator( 'table', function ( ctx ) {
			disableMouseSelection( new DataTable.Api( ctx ) );
	
			ctx._select.selector = selector;
	
			if ( ctx._select.style !== 'api' ) {
				enableMouseSelection( new DataTable.Api( ctx ) );
			}
		} );
	} );
	
	
	
	apiRegisterPlural( 'rows().select()', 'row().select()', function ( select ) {
		var api = this;
	
		if ( select === false ) {
			return this.deselect();
		}
	
		this.iterator( 'row', function ( ctx, idx ) {
			clear( ctx );
	
			ctx.aoData[ idx ]._select_selected = true;
			$( ctx.aoData[ idx ].nTr ).addClass( ctx._select.className );
		} );
	
		this.iterator( 'table', function ( ctx, i ) {
			eventTrigger( api, 'select', [ 'row', api[i] ], true );
		} );
	
		return this;
	} );
	
	apiRegisterPlural( 'columns().select()', 'column().select()', function ( select ) {
		var api = this;
	
		if ( select === false ) {
			return this.deselect();
		}
	
		this.iterator( 'column', function ( ctx, idx ) {
			clear( ctx );
	
			ctx.aoColumns[ idx ]._select_selected = true;
	
			var column = new DataTable.Api( ctx ).column( idx );
	
			$( column.header() ).addClass( ctx._select.className );
			$( column.footer() ).addClass( ctx._select.className );
	
			column.nodes().to$().addClass( ctx._select.className );
		} );
	
		this.iterator( 'table', function ( ctx, i ) {
			eventTrigger( api, 'select', [ 'column', api[i] ], true );
		} );
	
		return this;
	} );
	
	apiRegisterPlural( 'cells().select()', 'cell().select()', function ( select ) {
		var api = this;
	
		if ( select === false ) {
			return this.deselect();
		}
	
		this.iterator( 'cell', function ( ctx, rowIdx, colIdx ) {
			clear( ctx );
	
			var data = ctx.aoData[ rowIdx ];
	
			if ( data._selected_cells === undefined ) {
				data._selected_cells = [];
			}
	
			data._selected_cells[ colIdx ] = true;
	
			if ( data.anCells ) {
				$( data.anCells[ colIdx ] ).addClass( ctx._select.className );
			}
		} );
	
		this.iterator( 'table', function ( ctx, i ) {
			eventTrigger( api, 'select', [ 'cell', api[i] ], true );
		} );
	
		return this;
	} );
	
	
	apiRegisterPlural( 'rows().deselect()', 'row().deselect()', function () {
		var api = this;
	
		this.iterator( 'row', function ( ctx, idx ) {
			ctx.aoData[ idx ]._select_selected = false;
			$( ctx.aoData[ idx ].nTr ).removeClass( ctx._select.className );
		} );
	
		this.iterator( 'table', function ( ctx, i ) {
			eventTrigger( api, 'deselect', [ 'row', api[i] ], true );
		} );
	
		return this;
	} );
	
	apiRegisterPlural( 'columns().deselect()', 'column().deselect()', function () {
		var api = this;
	
		this.iterator( 'column', function ( ctx, idx ) {
			ctx.aoColumns[ idx ]._select_selected = false;
	
			var api = new DataTable.Api( ctx );
			var column = api.column( idx );
	
			$( column.header() ).removeClass( ctx._select.className );
			$( column.footer() ).removeClass( ctx._select.className );
	
			// Need to loop over each cell, rather than just using
			// `column().nodes()` as cells which are individually selected should
			// not have the `selected` class removed from them
			api.cells( null, idx ).indexes().each( function (cellIdx) {
				var data = ctx.aoData[ cellIdx.row ];
				var cellSelected = data._selected_cells;
	
				if ( data.anCells && (! cellSelected || ! cellSelected[ cellIdx.column ]) ) {
					$( data.anCells[ cellIdx.column  ] ).removeClass( ctx._select.className );
				}
			} );
		} );
	
		this.iterator( 'table', function ( ctx, i ) {
			eventTrigger( api, 'deselect', [ 'column', api[i] ], true );
		} );
	
		return this;
	} );
	
	apiRegisterPlural( 'cells().deselect()', 'cell().deselect()', function () {
		var api = this;
	
		this.iterator( 'cell', function ( ctx, rowIdx, colIdx ) {
			var data = ctx.aoData[ rowIdx ];
	
			data._selected_cells[ colIdx ] = false;
	
			// Remove class only if the cells exist, and the cell is not column
			// selected, in which case the class should remain (since it is selected
			// in the column)
			if ( data.anCells && ! ctx.aoColumns[ colIdx ]._select_selected ) {
				$( data.anCells[ colIdx ] ).removeClass( ctx._select.className );
			}
		} );
	
		this.iterator( 'table', function ( ctx, i ) {
			eventTrigger( api, 'deselect', [ 'cell', api[i] ], true );
		} );
	
		return this;
	} );
	
	
	
	/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	 * Buttons
	 */
	function i18n( label, def ) {
		return function (dt) {
			return dt.i18n( 'buttons.'+label, def );
		};
	}
	
	$.extend( DataTable.ext.buttons, {
		selected: {
			text: i18n( 'selected', 'Selected' ),
			className: 'buttons-selected',
			init: function ( dt, button, config ) {
				var that = this;
	
				// .DT namespace listeners are removed by DataTables automatically
				// on table destroy
				dt.on( 'draw.dt.DT select.dt.DT deselect.dt.DT', function () {
					var enable = that.rows( { selected: true } ).any() ||
					             that.columns( { selected: true } ).any() ||
					             that.cells( { selected: true } ).any();
	
					that.enable( enable );
				} );
	
				this.disable();
			}
		},
		selectedSingle: {
			text: i18n( 'selectedSingle', 'Selected single' ),
			className: 'buttons-selected-single',
			init: function ( dt, button, config ) {
				var that = this;
	
				dt.on( 'draw.dt.DT select.dt.DT deselect.dt.DT', function () {
					var count = dt.rows( { selected: true } ).flatten().length +
					            dt.columns( { selected: true } ).flatten().length +
					            dt.cells( { selected: true } ).flatten().length;
	
					that.enable( count === 1 );
				} );
	
				this.disable();
			}
		},
		selectAll: {
			text: i18n( 'selectAll', 'Select all' ),
			className: 'buttons-select-all',
			action: function () {
				var items = this.select.items();
				this[ items+'s' ]().select();
			}
		},
		selectNone: {
			text: i18n( 'selectNone', 'Deselect all' ),
			className: 'buttons-select-none',
			action: function () {
				clear( this.settings()[0], true );
			}
		}
	} );
	
	$.each( [ 'Row', 'Column', 'Cell' ], function ( i, item ) {
		var lc = item.toLowerCase();
	
		DataTable.ext.buttons[ 'select'+item+'s' ] = {
			text: i18n( 'select'+item+'s', 'Select '+lc+'s' ),
			className: 'buttons-select-'+lc+'s',
			action: function () {
				this.select.items( lc );
			},
			init: function ( dt, button, config ) {
				var that = this;
	
				dt.on( 'selectItems.dt.DT', function ( e, ctx, items ) {
					that.active( items === lc );
				} );
			}
		};
	} );
	
	
	
	/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	 * Initialisation
	 */
	
	// DataTables creation - check if the buttons have been defined for this table,
	// they will have been if the `B` option was used in `dom`, otherwise we should
	// create the buttons instance here so they can be inserted into the document
	// using the API
	$(document).on( 'preInit.dt.dtSelect', function (e, ctx, json) {
		if ( e.namespace !== 'dt' ) {
			return;
		}
	
		var opts = ctx.oInit.select || DataTable.defaults.select;
		var dt = new DataTable.Api( ctx );
	
		// Set defaults
		var items = 'row';
		var style = 'api';
		var blurable = false;
		var info = true;
		var selector = 'td, th';
		var className = 'selected';
	
		ctx._select = {};
	
		// Initialisation customisations
		if ( opts === true ) {
			style = 'os';
		}
		else if ( typeof opts === 'string' ) {
			style = opts;
		}
		else if ( $.isPlainObject( opts ) ) {
			if ( opts.blurable !== undefined ) {
				blurable = opts.blurable;
			}
	
			if ( opts.info !== undefined ) {
				info = opts.info;
			}
	
			if ( opts.items !== undefined ) {
				items = opts.items;
			}
	
			if ( opts.style !== undefined ) {
				style = opts.style;
			}
	
			if ( opts.selector !== undefined ) {
				selector = opts.selector;
			}
	
			if ( opts.className !== undefined ) {
				className = opts.className;
			}
		}
	
		dt.select.selector( selector );
		dt.select.items( items );
		dt.select.style( style );
		dt.select.blurable( blurable );
		dt.select.info( info );
		ctx._select.className = className;
	
		// If the init options haven't enabled select, but there is a selectable
		// class name, then enable
		if ( $( dt.table().node() ).hasClass( 'selectable' ) ) {
			dt.select.style( 'os' );
		}
	} );
	
	
	return DataTable.select;
	}));


/***/ },
/* 14 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*! DataTables 1.10.12
	 * Â©2008-2015 SpryMedia Ltd - datatables.net/license
	 */
	
	/**
	 * @summary     DataTables
	 * @description Paginate, search and order HTML tables
	 * @version     1.10.12
	 * @file        jquery.dataTables.js
	 * @author      SpryMedia Ltd (www.sprymedia.co.uk)
	 * @contact     www.sprymedia.co.uk/contact
	 * @copyright   Copyright 2008-2015 SpryMedia Ltd.
	 *
	 * This source file is free software, available under the following license:
	 *   MIT license - http://datatables.net/license
	 *
	 * This source file is distributed in the hope that it will be useful, but
	 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
	 * or FITNESS FOR A PARTICULAR PURPOSE. See the license files for details.
	 *
	 * For details please refer to: http://www.datatables.net
	 */
	
	/*jslint evil: true, undef: true, browser: true */
	/*globals $,require,jQuery,define,_selector_run,_selector_opts,_selector_first,_selector_row_indexes,_ext,_Api,_api_register,_api_registerPlural,_re_new_lines,_re_html,_re_formatted_numeric,_re_escape_regex,_empty,_intVal,_numToDecimal,_isNumber,_isHtml,_htmlNumeric,_pluck,_pluck_order,_range,_stripHtml,_unique,_fnBuildAjax,_fnAjaxUpdate,_fnAjaxParameters,_fnAjaxUpdateDraw,_fnAjaxDataSrc,_fnAddColumn,_fnColumnOptions,_fnAdjustColumnSizing,_fnVisibleToColumnIndex,_fnColumnIndexToVisible,_fnVisbleColumns,_fnGetColumns,_fnColumnTypes,_fnApplyColumnDefs,_fnHungarianMap,_fnCamelToHungarian,_fnLanguageCompat,_fnBrowserDetect,_fnAddData,_fnAddTr,_fnNodeToDataIndex,_fnNodeToColumnIndex,_fnGetCellData,_fnSetCellData,_fnSplitObjNotation,_fnGetObjectDataFn,_fnSetObjectDataFn,_fnGetDataMaster,_fnClearTable,_fnDeleteIndex,_fnInvalidate,_fnGetRowElements,_fnCreateTr,_fnBuildHead,_fnDrawHead,_fnDraw,_fnReDraw,_fnAddOptionsHtml,_fnDetectHeader,_fnGetUniqueThs,_fnFeatureHtmlFilter,_fnFilterComplete,_fnFilterCustom,_fnFilterColumn,_fnFilter,_fnFilterCreateSearch,_fnEscapeRegex,_fnFilterData,_fnFeatureHtmlInfo,_fnUpdateInfo,_fnInfoMacros,_fnInitialise,_fnInitComplete,_fnLengthChange,_fnFeatureHtmlLength,_fnFeatureHtmlPaginate,_fnPageChange,_fnFeatureHtmlProcessing,_fnProcessingDisplay,_fnFeatureHtmlTable,_fnScrollDraw,_fnApplyToChildren,_fnCalculateColumnWidths,_fnThrottle,_fnConvertToWidth,_fnGetWidestNode,_fnGetMaxLenString,_fnStringToCss,_fnSortFlatten,_fnSort,_fnSortAria,_fnSortListener,_fnSortAttachListener,_fnSortingClasses,_fnSortData,_fnSaveState,_fnLoadState,_fnSettingsFromNode,_fnLog,_fnMap,_fnBindAction,_fnCallbackReg,_fnCallbackFire,_fnLengthOverflow,_fnRenderer,_fnDataSource,_fnRowAttributes*/
	
	(function( factory ) {
		"use strict";
	
		if ( true ) {
			// AMD
			!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(1)], __WEBPACK_AMD_DEFINE_RESULT__ = function ( $ ) {
				return factory( $, window, document );
			}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
		}
		else if ( typeof exports === 'object' ) {
			// CommonJS
			module.exports = function (root, $) {
				if ( ! root ) {
					// CommonJS environments without a window global must pass a
					// root. This will give an error otherwise
					root = window;
				}
	
				if ( ! $ ) {
					$ = typeof window !== 'undefined' ? // jQuery's factory checks for a global window
						require('jquery') :
						require('jquery')( root );
				}
	
				return factory( $, root, root.document );
			};
		}
		else {
			// Browser
			factory( jQuery, window, document );
		}
	}
	(function( $, window, document, undefined ) {
		"use strict";
	
		/**
		 * DataTables is a plug-in for the jQuery Javascript library. It is a highly
		 * flexible tool, based upon the foundations of progressive enhancement,
		 * which will add advanced interaction controls to any HTML table. For a
		 * full list of features please refer to
		 * [DataTables.net](href="http://datatables.net).
		 *
		 * Note that the `DataTable` object is not a global variable but is aliased
		 * to `jQuery.fn.DataTable` and `jQuery.fn.dataTable` through which it may
		 * be  accessed.
		 *
		 *  @class
		 *  @param {object} [init={}] Configuration object for DataTables. Options
		 *    are defined by {@link DataTable.defaults}
		 *  @requires jQuery 1.7+
		 *
		 *  @example
		 *    // Basic initialisation
		 *    $(document).ready( function {
		 *      $('#example').dataTable();
		 *    } );
		 *
		 *  @example
		 *    // Initialisation with configuration options - in this case, disable
		 *    // pagination and sorting.
		 *    $(document).ready( function {
		 *      $('#example').dataTable( {
		 *        "paginate": false,
		 *        "sort": false
		 *      } );
		 *    } );
		 */
		var DataTable = function ( options )
		{
			/**
			 * Perform a jQuery selector action on the table's TR elements (from the tbody) and
			 * return the resulting jQuery object.
			 *  @param {string|node|jQuery} sSelector jQuery selector or node collection to act on
			 *  @param {object} [oOpts] Optional parameters for modifying the rows to be included
			 *  @param {string} [oOpts.filter=none] Select TR elements that meet the current filter
			 *    criterion ("applied") or all TR elements (i.e. no filter).
			 *  @param {string} [oOpts.order=current] Order of the TR elements in the processed array.
			 *    Can be either 'current', whereby the current sorting of the table is used, or
			 *    'original' whereby the original order the data was read into the table is used.
			 *  @param {string} [oOpts.page=all] Limit the selection to the currently displayed page
			 *    ("current") or not ("all"). If 'current' is given, then order is assumed to be
			 *    'current' and filter is 'applied', regardless of what they might be given as.
			 *  @returns {object} jQuery object, filtered by the given selector.
			 *  @dtopt API
			 *  @deprecated Since v1.10
			 *
			 *  @example
			 *    $(document).ready(function() {
			 *      var oTable = $('#example').dataTable();
			 *
			 *      // Highlight every second row
			 *      oTable.$('tr:odd').css('backgroundColor', 'blue');
			 *    } );
			 *
			 *  @example
			 *    $(document).ready(function() {
			 *      var oTable = $('#example').dataTable();
			 *
			 *      // Filter to rows with 'Webkit' in them, add a background colour and then
			 *      // remove the filter, thus highlighting the 'Webkit' rows only.
			 *      oTable.fnFilter('Webkit');
			 *      oTable.$('tr', {"search": "applied"}).css('backgroundColor', 'blue');
			 *      oTable.fnFilter('');
			 *    } );
			 */
			this.$ = function ( sSelector, oOpts )
			{
				return this.api(true).$( sSelector, oOpts );
			};
			
			
			/**
			 * Almost identical to $ in operation, but in this case returns the data for the matched
			 * rows - as such, the jQuery selector used should match TR row nodes or TD/TH cell nodes
			 * rather than any descendants, so the data can be obtained for the row/cell. If matching
			 * rows are found, the data returned is the original data array/object that was used to
			 * create the row (or a generated array if from a DOM source).
			 *
			 * This method is often useful in-combination with $ where both functions are given the
			 * same parameters and the array indexes will match identically.
			 *  @param {string|node|jQuery} sSelector jQuery selector or node collection to act on
			 *  @param {object} [oOpts] Optional parameters for modifying the rows to be included
			 *  @param {string} [oOpts.filter=none] Select elements that meet the current filter
			 *    criterion ("applied") or all elements (i.e. no filter).
			 *  @param {string} [oOpts.order=current] Order of the data in the processed array.
			 *    Can be either 'current', whereby the current sorting of the table is used, or
			 *    'original' whereby the original order the data was read into the table is used.
			 *  @param {string} [oOpts.page=all] Limit the selection to the currently displayed page
			 *    ("current") or not ("all"). If 'current' is given, then order is assumed to be
			 *    'current' and filter is 'applied', regardless of what they might be given as.
			 *  @returns {array} Data for the matched elements. If any elements, as a result of the
			 *    selector, were not TR, TD or TH elements in the DataTable, they will have a null
			 *    entry in the array.
			 *  @dtopt API
			 *  @deprecated Since v1.10
			 *
			 *  @example
			 *    $(document).ready(function() {
			 *      var oTable = $('#example').dataTable();
			 *
			 *      // Get the data from the first row in the table
			 *      var data = oTable._('tr:first');
			 *
			 *      // Do something useful with the data
			 *      alert( "First cell is: "+data[0] );
			 *    } );
			 *
			 *  @example
			 *    $(document).ready(function() {
			 *      var oTable = $('#example').dataTable();
			 *
			 *      // Filter to 'Webkit' and get all data for
			 *      oTable.fnFilter('Webkit');
			 *      var data = oTable._('tr', {"search": "applied"});
			 *
			 *      // Do something with the data
			 *      alert( data.length+" rows matched the search" );
			 *    } );
			 */
			this._ = function ( sSelector, oOpts )
			{
				return this.api(true).rows( sSelector, oOpts ).data();
			};
			
			
			/**
			 * Create a DataTables Api instance, with the currently selected tables for
			 * the Api's context.
			 * @param {boolean} [traditional=false] Set the API instance's context to be
			 *   only the table referred to by the `DataTable.ext.iApiIndex` option, as was
			 *   used in the API presented by DataTables 1.9- (i.e. the traditional mode),
			 *   or if all tables captured in the jQuery object should be used.
			 * @return {DataTables.Api}
			 */
			this.api = function ( traditional )
			{
				return traditional ?
					new _Api(
						_fnSettingsFromNode( this[ _ext.iApiIndex ] )
					) :
					new _Api( this );
			};
			
			
			/**
			 * Add a single new row or multiple rows of data to the table. Please note
			 * that this is suitable for client-side processing only - if you are using
			 * server-side processing (i.e. "bServerSide": true), then to add data, you
			 * must add it to the data source, i.e. the server-side, through an Ajax call.
			 *  @param {array|object} data The data to be added to the table. This can be:
			 *    <ul>
			 *      <li>1D array of data - add a single row with the data provided</li>
			 *      <li>2D array of arrays - add multiple rows in a single call</li>
			 *      <li>object - data object when using <i>mData</i></li>
			 *      <li>array of objects - multiple data objects when using <i>mData</i></li>
			 *    </ul>
			 *  @param {bool} [redraw=true] redraw the table or not
			 *  @returns {array} An array of integers, representing the list of indexes in
			 *    <i>aoData</i> ({@link DataTable.models.oSettings}) that have been added to
			 *    the table.
			 *  @dtopt API
			 *  @deprecated Since v1.10
			 *
			 *  @example
			 *    // Global var for counter
			 *    var giCount = 2;
			 *
			 *    $(document).ready(function() {
			 *      $('#example').dataTable();
			 *    } );
			 *
			 *    function fnClickAddRow() {
			 *      $('#example').dataTable().fnAddData( [
			 *        giCount+".1",
			 *        giCount+".2",
			 *        giCount+".3",
			 *        giCount+".4" ]
			 *      );
			 *
			 *      giCount++;
			 *    }
			 */
			this.fnAddData = function( data, redraw )
			{
				var api = this.api( true );
			
				/* Check if we want to add multiple rows or not */
				var rows = $.isArray(data) && ( $.isArray(data[0]) || $.isPlainObject(data[0]) ) ?
					api.rows.add( data ) :
					api.row.add( data );
			
				if ( redraw === undefined || redraw ) {
					api.draw();
				}
			
				return rows.flatten().toArray();
			};
			
			
			/**
			 * This function will make DataTables recalculate the column sizes, based on the data
			 * contained in the table and the sizes applied to the columns (in the DOM, CSS or
			 * through the sWidth parameter). This can be useful when the width of the table's
			 * parent element changes (for example a window resize).
			 *  @param {boolean} [bRedraw=true] Redraw the table or not, you will typically want to
			 *  @dtopt API
			 *  @deprecated Since v1.10
			 *
			 *  @example
			 *    $(document).ready(function() {
			 *      var oTable = $('#example').dataTable( {
			 *        "sScrollY": "200px",
			 *        "bPaginate": false
			 *      } );
			 *
			 *      $(window).bind('resize', function () {
			 *        oTable.fnAdjustColumnSizing();
			 *      } );
			 *    } );
			 */
			this.fnAdjustColumnSizing = function ( bRedraw )
			{
				var api = this.api( true ).columns.adjust();
				var settings = api.settings()[0];
				var scroll = settings.oScroll;
			
				if ( bRedraw === undefined || bRedraw ) {
					api.draw( false );
				}
				else if ( scroll.sX !== "" || scroll.sY !== "" ) {
					/* If not redrawing, but scrolling, we want to apply the new column sizes anyway */
					_fnScrollDraw( settings );
				}
			};
			
			
			/**
			 * Quickly and simply clear a table
			 *  @param {bool} [bRedraw=true] redraw the table or not
			 *  @dtopt API
			 *  @deprecated Since v1.10
			 *
			 *  @example
			 *    $(document).ready(function() {
			 *      var oTable = $('#example').dataTable();
			 *
			 *      // Immediately 'nuke' the current rows (perhaps waiting for an Ajax callback...)
			 *      oTable.fnClearTable();
			 *    } );
			 */
			this.fnClearTable = function( bRedraw )
			{
				var api = this.api( true ).clear();
			
				if ( bRedraw === undefined || bRedraw ) {
					api.draw();
				}
			};
			
			
			/**
			 * The exact opposite of 'opening' a row, this function will close any rows which
			 * are currently 'open'.
			 *  @param {node} nTr the table row to 'close'
			 *  @returns {int} 0 on success, or 1 if failed (can't find the row)
			 *  @dtopt API
			 *  @deprecated Since v1.10
			 *
			 *  @example
			 *    $(document).ready(function() {
			 *      var oTable;
			 *
			 *      // 'open' an information row when a row is clicked on
			 *      $('#example tbody tr').click( function () {
			 *        if ( oTable.fnIsOpen(this) ) {
			 *          oTable.fnClose( this );
			 *        } else {
			 *          oTable.fnOpen( this, "Temporary row opened", "info_row" );
			 *        }
			 *      } );
			 *
			 *      oTable = $('#example').dataTable();
			 *    } );
			 */
			this.fnClose = function( nTr )
			{
				this.api( true ).row( nTr ).child.hide();
			};
			
			
			/**
			 * Remove a row for the table
			 *  @param {mixed} target The index of the row from aoData to be deleted, or
			 *    the TR element you want to delete
			 *  @param {function|null} [callBack] Callback function
			 *  @param {bool} [redraw=true] Redraw the table or not
			 *  @returns {array} The row that was deleted
			 *  @dtopt API
			 *  @deprecated Since v1.10
			 *
			 *  @example
			 *    $(document).ready(function() {
			 *      var oTable = $('#example').dataTable();
			 *
			 *      // Immediately remove the first row
			 *      oTable.fnDeleteRow( 0 );
			 *    } );
			 */
			this.fnDeleteRow = function( target, callback, redraw )
			{
				var api = this.api( true );
				var rows = api.rows( target );
				var settings = rows.settings()[0];
				var data = settings.aoData[ rows[0][0] ];
			
				rows.remove();
			
				if ( callback ) {
					callback.call( this, settings, data );
				}
			
				if ( redraw === undefined || redraw ) {
					api.draw();
				}
			
				return data;
			};
			
			
			/**
			 * Restore the table to it's original state in the DOM by removing all of DataTables
			 * enhancements, alterations to the DOM structure of the table and event listeners.
			 *  @param {boolean} [remove=false] Completely remove the table from the DOM
			 *  @dtopt API
			 *  @deprecated Since v1.10
			 *
			 *  @example
			 *    $(document).ready(function() {
			 *      // This example is fairly pointless in reality, but shows how fnDestroy can be used
			 *      var oTable = $('#example').dataTable();
			 *      oTable.fnDestroy();
			 *    } );
			 */
			this.fnDestroy = function ( remove )
			{
				this.api( true ).destroy( remove );
			};
			
			
			/**
			 * Redraw the table
			 *  @param {bool} [complete=true] Re-filter and resort (if enabled) the table before the draw.
			 *  @dtopt API
			 *  @deprecated Since v1.10
			 *
			 *  @example
			 *    $(document).ready(function() {
			 *      var oTable = $('#example').dataTable();
			 *
			 *      // Re-draw the table - you wouldn't want to do it here, but it's an example :-)
			 *      oTable.fnDraw();
			 *    } );
			 */
			this.fnDraw = function( complete )
			{
				// Note that this isn't an exact match to the old call to _fnDraw - it takes
				// into account the new data, but can hold position.
				this.api( true ).draw( complete );
			};
			
			
			/**
			 * Filter the input based on data
			 *  @param {string} sInput String to filter the table on
			 *  @param {int|null} [iColumn] Column to limit filtering to
			 *  @param {bool} [bRegex=false] Treat as regular expression or not
			 *  @param {bool} [bSmart=true] Perform smart filtering or not
			 *  @param {bool} [bShowGlobal=true] Show the input global filter in it's input box(es)
			 *  @param {bool} [bCaseInsensitive=true] Do case-insensitive matching (true) or not (false)
			 *  @dtopt API
			 *  @deprecated Since v1.10
			 *
			 *  @example
			 *    $(document).ready(function() {
			 *      var oTable = $('#example').dataTable();
			 *
			 *      // Sometime later - filter...
			 *      oTable.fnFilter( 'test string' );
			 *    } );
			 */
			this.fnFilter = function( sInput, iColumn, bRegex, bSmart, bShowGlobal, bCaseInsensitive )
			{
				var api = this.api( true );
			
				if ( iColumn === null || iColumn === undefined ) {
					api.search( sInput, bRegex, bSmart, bCaseInsensitive );
				}
				else {
					api.column( iColumn ).search( sInput, bRegex, bSmart, bCaseInsensitive );
				}
			
				api.draw();
			};
			
			
			/**
			 * Get the data for the whole table, an individual row or an individual cell based on the
			 * provided parameters.
			 *  @param {int|node} [src] A TR row node, TD/TH cell node or an integer. If given as
			 *    a TR node then the data source for the whole row will be returned. If given as a
			 *    TD/TH cell node then iCol will be automatically calculated and the data for the
			 *    cell returned. If given as an integer, then this is treated as the aoData internal
			 *    data index for the row (see fnGetPosition) and the data for that row used.
			 *  @param {int} [col] Optional column index that you want the data of.
			 *  @returns {array|object|string} If mRow is undefined, then the data for all rows is
			 *    returned. If mRow is defined, just data for that row, and is iCol is
			 *    defined, only data for the designated cell is returned.
			 *  @dtopt API
			 *  @deprecated Since v1.10
			 *
			 *  @example
			 *    // Row data
			 *    $(document).ready(function() {
			 *      oTable = $('#example').dataTable();
			 *
			 *      oTable.$('tr').click( function () {
			 *        var data = oTable.fnGetData( this );
			 *        // ... do something with the array / object of data for the row
			 *      } );
			 *    } );
			 *
			 *  @example
			 *    // Individual cell data
			 *    $(document).ready(function() {
			 *      oTable = $('#example').dataTable();
			 *
			 *      oTable.$('td').click( function () {
			 *        var sData = oTable.fnGetData( this );
			 *        alert( 'The cell clicked on had the value of '+sData );
			 *      } );
			 *    } );
			 */
			this.fnGetData = function( src, col )
			{
				var api = this.api( true );
			
				if ( src !== undefined ) {
					var type = src.nodeName ? src.nodeName.toLowerCase() : '';
			
					return col !== undefined || type == 'td' || type == 'th' ?
						api.cell( src, col ).data() :
						api.row( src ).data() || null;
				}
			
				return api.data().toArray();
			};
			
			
			/**
			 * Get an array of the TR nodes that are used in the table's body. Note that you will
			 * typically want to use the '$' API method in preference to this as it is more
			 * flexible.
			 *  @param {int} [iRow] Optional row index for the TR element you want
			 *  @returns {array|node} If iRow is undefined, returns an array of all TR elements
			 *    in the table's body, or iRow is defined, just the TR element requested.
			 *  @dtopt API
			 *  @deprecated Since v1.10
			 *
			 *  @example
			 *    $(document).ready(function() {
			 *      var oTable = $('#example').dataTable();
			 *
			 *      // Get the nodes from the table
			 *      var nNodes = oTable.fnGetNodes( );
			 *    } );
			 */
			this.fnGetNodes = function( iRow )
			{
				var api = this.api( true );
			
				return iRow !== undefined ?
					api.row( iRow ).node() :
					api.rows().nodes().flatten().toArray();
			};
			
			
			/**
			 * Get the array indexes of a particular cell from it's DOM element
			 * and column index including hidden columns
			 *  @param {node} node this can either be a TR, TD or TH in the table's body
			 *  @returns {int} If nNode is given as a TR, then a single index is returned, or
			 *    if given as a cell, an array of [row index, column index (visible),
			 *    column index (all)] is given.
			 *  @dtopt API
			 *  @deprecated Since v1.10
			 *
			 *  @example
			 *    $(document).ready(function() {
			 *      $('#example tbody td').click( function () {
			 *        // Get the position of the current data from the node
			 *        var aPos = oTable.fnGetPosition( this );
			 *
			 *        // Get the data array for this row
			 *        var aData = oTable.fnGetData( aPos[0] );
			 *
			 *        // Update the data array and return the value
			 *        aData[ aPos[1] ] = 'clicked';
			 *        this.innerHTML = 'clicked';
			 *      } );
			 *
			 *      // Init DataTables
			 *      oTable = $('#example').dataTable();
			 *    } );
			 */
			this.fnGetPosition = function( node )
			{
				var api = this.api( true );
				var nodeName = node.nodeName.toUpperCase();
			
				if ( nodeName == 'TR' ) {
					return api.row( node ).index();
				}
				else if ( nodeName == 'TD' || nodeName == 'TH' ) {
					var cell = api.cell( node ).index();
			
					return [
						cell.row,
						cell.columnVisible,
						cell.column
					];
				}
				return null;
			};
			
			
			/**
			 * Check to see if a row is 'open' or not.
			 *  @param {node} nTr the table row to check
			 *  @returns {boolean} true if the row is currently open, false otherwise
			 *  @dtopt API
			 *  @deprecated Since v1.10
			 *
			 *  @example
			 *    $(document).ready(function() {
			 *      var oTable;
			 *
			 *      // 'open' an information row when a row is clicked on
			 *      $('#example tbody tr').click( function () {
			 *        if ( oTable.fnIsOpen(this) ) {
			 *          oTable.fnClose( this );
			 *        } else {
			 *          oTable.fnOpen( this, "Temporary row opened", "info_row" );
			 *        }
			 *      } );
			 *
			 *      oTable = $('#example').dataTable();
			 *    } );
			 */
			this.fnIsOpen = function( nTr )
			{
				return this.api( true ).row( nTr ).child.isShown();
			};
			
			
			/**
			 * This function will place a new row directly after a row which is currently
			 * on display on the page, with the HTML contents that is passed into the
			 * function. This can be used, for example, to ask for confirmation that a
			 * particular record should be deleted.
			 *  @param {node} nTr The table row to 'open'
			 *  @param {string|node|jQuery} mHtml The HTML to put into the row
			 *  @param {string} sClass Class to give the new TD cell
			 *  @returns {node} The row opened. Note that if the table row passed in as the
			 *    first parameter, is not found in the table, this method will silently
			 *    return.
			 *  @dtopt API
			 *  @deprecated Since v1.10
			 *
			 *  @example
			 *    $(document).ready(function() {
			 *      var oTable;
			 *
			 *      // 'open' an information row when a row is clicked on
			 *      $('#example tbody tr').click( function () {
			 *        if ( oTable.fnIsOpen(this) ) {
			 *          oTable.fnClose( this );
			 *        } else {
			 *          oTable.fnOpen( this, "Temporary row opened", "info_row" );
			 *        }
			 *      } );
			 *
			 *      oTable = $('#example').dataTable();
			 *    } );
			 */
			this.fnOpen = function( nTr, mHtml, sClass )
			{
				return this.api( true )
					.row( nTr )
					.child( mHtml, sClass )
					.show()
					.child()[0];
			};
			
			
			/**
			 * Change the pagination - provides the internal logic for pagination in a simple API
			 * function. With this function you can have a DataTables table go to the next,
			 * previous, first or last pages.
			 *  @param {string|int} mAction Paging action to take: "first", "previous", "next" or "last"
			 *    or page number to jump to (integer), note that page 0 is the first page.
			 *  @param {bool} [bRedraw=true] Redraw the table or not
			 *  @dtopt API
			 *  @deprecated Since v1.10
			 *
			 *  @example
			 *    $(document).ready(function() {
			 *      var oTable = $('#example').dataTable();
			 *      oTable.fnPageChange( 'next' );
			 *    } );
			 */
			this.fnPageChange = function ( mAction, bRedraw )
			{
				var api = this.api( true ).page( mAction );
			
				if ( bRedraw === undefined || bRedraw ) {
					api.draw(false);
				}
			};
			
			
			/**
			 * Show a particular column
			 *  @param {int} iCol The column whose display should be changed
			 *  @param {bool} bShow Show (true) or hide (false) the column
			 *  @param {bool} [bRedraw=true] Redraw the table or not
			 *  @dtopt API
			 *  @deprecated Since v1.10
			 *
			 *  @example
			 *    $(document).ready(function() {
			 *      var oTable = $('#example').dataTable();
			 *
			 *      // Hide the second column after initialisation
			 *      oTable.fnSetColumnVis( 1, false );
			 *    } );
			 */
			this.fnSetColumnVis = function ( iCol, bShow, bRedraw )
			{
				var api = this.api( true ).column( iCol ).visible( bShow );
			
				if ( bRedraw === undefined || bRedraw ) {
					api.columns.adjust().draw();
				}
			};
			
			
			/**
			 * Get the settings for a particular table for external manipulation
			 *  @returns {object} DataTables settings object. See
			 *    {@link DataTable.models.oSettings}
			 *  @dtopt API
			 *  @deprecated Since v1.10
			 *
			 *  @example
			 *    $(document).ready(function() {
			 *      var oTable = $('#example').dataTable();
			 *      var oSettings = oTable.fnSettings();
			 *
			 *      // Show an example parameter from the settings
			 *      alert( oSettings._iDisplayStart );
			 *    } );
			 */
			this.fnSettings = function()
			{
				return _fnSettingsFromNode( this[_ext.iApiIndex] );
			};
			
			
			/**
			 * Sort the table by a particular column
			 *  @param {int} iCol the data index to sort on. Note that this will not match the
			 *    'display index' if you have hidden data entries
			 *  @dtopt API
			 *  @deprecated Since v1.10
			 *
			 *  @example
			 *    $(document).ready(function() {
			 *      var oTable = $('#example').dataTable();
			 *
			 *      // Sort immediately with columns 0 and 1
			 *      oTable.fnSort( [ [0,'asc'], [1,'asc'] ] );
			 *    } );
			 */
			this.fnSort = function( aaSort )
			{
				this.api( true ).order( aaSort ).draw();
			};
			
			
			/**
			 * Attach a sort listener to an element for a given column
			 *  @param {node} nNode the element to attach the sort listener to
			 *  @param {int} iColumn the column that a click on this node will sort on
			 *  @param {function} [fnCallback] callback function when sort is run
			 *  @dtopt API
			 *  @deprecated Since v1.10
			 *
			 *  @example
			 *    $(document).ready(function() {
			 *      var oTable = $('#example').dataTable();
			 *
			 *      // Sort on column 1, when 'sorter' is clicked on
			 *      oTable.fnSortListener( document.getElementById('sorter'), 1 );
			 *    } );
			 */
			this.fnSortListener = function( nNode, iColumn, fnCallback )
			{
				this.api( true ).order.listener( nNode, iColumn, fnCallback );
			};
			
			
			/**
			 * Update a table cell or row - this method will accept either a single value to
			 * update the cell with, an array of values with one element for each column or
			 * an object in the same format as the original data source. The function is
			 * self-referencing in order to make the multi column updates easier.
			 *  @param {object|array|string} mData Data to update the cell/row with
			 *  @param {node|int} mRow TR element you want to update or the aoData index
			 *  @param {int} [iColumn] The column to update, give as null or undefined to
			 *    update a whole row.
			 *  @param {bool} [bRedraw=true] Redraw the table or not
			 *  @param {bool} [bAction=true] Perform pre-draw actions or not
			 *  @returns {int} 0 on success, 1 on error
			 *  @dtopt API
			 *  @deprecated Since v1.10
			 *
			 *  @example
			 *    $(document).ready(function() {
			 *      var oTable = $('#example').dataTable();
			 *      oTable.fnUpdate( 'Example update', 0, 0 ); // Single cell
			 *      oTable.fnUpdate( ['a', 'b', 'c', 'd', 'e'], $('tbody tr')[0] ); // Row
			 *    } );
			 */
			this.fnUpdate = function( mData, mRow, iColumn, bRedraw, bAction )
			{
				var api = this.api( true );
			
				if ( iColumn === undefined || iColumn === null ) {
					api.row( mRow ).data( mData );
				}
				else {
					api.cell( mRow, iColumn ).data( mData );
				}
			
				if ( bAction === undefined || bAction ) {
					api.columns.adjust();
				}
			
				if ( bRedraw === undefined || bRedraw ) {
					api.draw();
				}
				return 0;
			};
			
			
			/**
			 * Provide a common method for plug-ins to check the version of DataTables being used, in order
			 * to ensure compatibility.
			 *  @param {string} sVersion Version string to check for, in the format "X.Y.Z". Note that the
			 *    formats "X" and "X.Y" are also acceptable.
			 *  @returns {boolean} true if this version of DataTables is greater or equal to the required
			 *    version, or false if this version of DataTales is not suitable
			 *  @method
			 *  @dtopt API
			 *  @deprecated Since v1.10
			 *
			 *  @example
			 *    $(document).ready(function() {
			 *      var oTable = $('#example').dataTable();
			 *      alert( oTable.fnVersionCheck( '1.9.0' ) );
			 *    } );
			 */
			this.fnVersionCheck = _ext.fnVersionCheck;
			
	
			var _that = this;
			var emptyInit = options === undefined;
			var len = this.length;
	
			if ( emptyInit ) {
				options = {};
			}
	
			this.oApi = this.internal = _ext.internal;
	
			// Extend with old style plug-in API methods
			for ( var fn in DataTable.ext.internal ) {
				if ( fn ) {
					this[fn] = _fnExternApiFunc(fn);
				}
			}
	
			this.each(function() {
				// For each initialisation we want to give it a clean initialisation
				// object that can be bashed around
				var o = {};
				var oInit = len > 1 ? // optimisation for single table case
					_fnExtend( o, options, true ) :
					options;
	
				/*global oInit,_that,emptyInit*/
				var i=0, iLen, j, jLen, k, kLen;
				var sId = this.getAttribute( 'id' );
				var bInitHandedOff = false;
				var defaults = DataTable.defaults;
				var $this = $(this);
				
				
				/* Sanity check */
				if ( this.nodeName.toLowerCase() != 'table' )
				{
					_fnLog( null, 0, 'Non-table node initialisation ('+this.nodeName+')', 2 );
					return;
				}
				
				/* Backwards compatibility for the defaults */
				_fnCompatOpts( defaults );
				_fnCompatCols( defaults.column );
				
				/* Convert the camel-case defaults to Hungarian */
				_fnCamelToHungarian( defaults, defaults, true );
				_fnCamelToHungarian( defaults.column, defaults.column, true );
				
				/* Setting up the initialisation object */
				_fnCamelToHungarian( defaults, $.extend( oInit, $this.data() ) );
				
				
				
				/* Check to see if we are re-initialising a table */
				var allSettings = DataTable.settings;
				for ( i=0, iLen=allSettings.length ; i<iLen ; i++ )
				{
					var s = allSettings[i];
				
					/* Base check on table node */
					if ( s.nTable == this || s.nTHead.parentNode == this || (s.nTFoot && s.nTFoot.parentNode == this) )
					{
						var bRetrieve = oInit.bRetrieve !== undefined ? oInit.bRetrieve : defaults.bRetrieve;
						var bDestroy = oInit.bDestroy !== undefined ? oInit.bDestroy : defaults.bDestroy;
				
						if ( emptyInit || bRetrieve )
						{
							return s.oInstance;
						}
						else if ( bDestroy )
						{
							s.oInstance.fnDestroy();
							break;
						}
						else
						{
							_fnLog( s, 0, 'Cannot reinitialise DataTable', 3 );
							return;
						}
					}
				
					/* If the element we are initialising has the same ID as a table which was previously
					 * initialised, but the table nodes don't match (from before) then we destroy the old
					 * instance by simply deleting it. This is under the assumption that the table has been
					 * destroyed by other methods. Anyone using non-id selectors will need to do this manually
					 */
					if ( s.sTableId == this.id )
					{
						allSettings.splice( i, 1 );
						break;
					}
				}
				
				/* Ensure the table has an ID - required for accessibility */
				if ( sId === null || sId === "" )
				{
					sId = "DataTables_Table_"+(DataTable.ext._unique++);
					this.id = sId;
				}
				
				/* Create the settings object for this table and set some of the default parameters */
				var oSettings = $.extend( true, {}, DataTable.models.oSettings, {
					"sDestroyWidth": $this[0].style.width,
					"sInstance":     sId,
					"sTableId":      sId
				} );
				oSettings.nTable = this;
				oSettings.oApi   = _that.internal;
				oSettings.oInit  = oInit;
				
				allSettings.push( oSettings );
				
				// Need to add the instance after the instance after the settings object has been added
				// to the settings array, so we can self reference the table instance if more than one
				oSettings.oInstance = (_that.length===1) ? _that : $this.dataTable();
				
				// Backwards compatibility, before we apply all the defaults
				_fnCompatOpts( oInit );
				
				if ( oInit.oLanguage )
				{
					_fnLanguageCompat( oInit.oLanguage );
				}
				
				// If the length menu is given, but the init display length is not, use the length menu
				if ( oInit.aLengthMenu && ! oInit.iDisplayLength )
				{
					oInit.iDisplayLength = $.isArray( oInit.aLengthMenu[0] ) ?
						oInit.aLengthMenu[0][0] : oInit.aLengthMenu[0];
				}
				
				// Apply the defaults and init options to make a single init object will all
				// options defined from defaults and instance options.
				oInit = _fnExtend( $.extend( true, {}, defaults ), oInit );
				
				
				// Map the initialisation options onto the settings object
				_fnMap( oSettings.oFeatures, oInit, [
					"bPaginate",
					"bLengthChange",
					"bFilter",
					"bSort",
					"bSortMulti",
					"bInfo",
					"bProcessing",
					"bAutoWidth",
					"bSortClasses",
					"bServerSide",
					"bDeferRender"
				] );
				_fnMap( oSettings, oInit, [
					"asStripeClasses",
					"ajax",
					"fnServerData",
					"fnFormatNumber",
					"sServerMethod",
					"aaSorting",
					"aaSortingFixed",
					"aLengthMenu",
					"sPaginationType",
					"sAjaxSource",
					"sAjaxDataProp",
					"iStateDuration",
					"sDom",
					"bSortCellsTop",
					"iTabIndex",
					"fnStateLoadCallback",
					"fnStateSaveCallback",
					"renderer",
					"searchDelay",
					"rowId",
					[ "iCookieDuration", "iStateDuration" ], // backwards compat
					[ "oSearch", "oPreviousSearch" ],
					[ "aoSearchCols", "aoPreSearchCols" ],
					[ "iDisplayLength", "_iDisplayLength" ],
					[ "bJQueryUI", "bJUI" ]
				] );
				_fnMap( oSettings.oScroll, oInit, [
					[ "sScrollX", "sX" ],
					[ "sScrollXInner", "sXInner" ],
					[ "sScrollY", "sY" ],
					[ "bScrollCollapse", "bCollapse" ]
				] );
				_fnMap( oSettings.oLanguage, oInit, "fnInfoCallback" );
				
				/* Callback functions which are array driven */
				_fnCallbackReg( oSettings, 'aoDrawCallback',       oInit.fnDrawCallback,      'user' );
				_fnCallbackReg( oSettings, 'aoServerParams',       oInit.fnServerParams,      'user' );
				_fnCallbackReg( oSettings, 'aoStateSaveParams',    oInit.fnStateSaveParams,   'user' );
				_fnCallbackReg( oSettings, 'aoStateLoadParams',    oInit.fnStateLoadParams,   'user' );
				_fnCallbackReg( oSettings, 'aoStateLoaded',        oInit.fnStateLoaded,       'user' );
				_fnCallbackReg( oSettings, 'aoRowCallback',        oInit.fnRowCallback,       'user' );
				_fnCallbackReg( oSettings, 'aoRowCreatedCallback', oInit.fnCreatedRow,        'user' );
				_fnCallbackReg( oSettings, 'aoHeaderCallback',     oInit.fnHeaderCallback,    'user' );
				_fnCallbackReg( oSettings, 'aoFooterCallback',     oInit.fnFooterCallback,    'user' );
				_fnCallbackReg( oSettings, 'aoInitComplete',       oInit.fnInitComplete,      'user' );
				_fnCallbackReg( oSettings, 'aoPreDrawCallback',    oInit.fnPreDrawCallback,   'user' );
				
				oSettings.rowIdFn = _fnGetObjectDataFn( oInit.rowId );
				
				/* Browser support detection */
				_fnBrowserDetect( oSettings );
				
				var oClasses = oSettings.oClasses;
				
				// @todo Remove in 1.11
				if ( oInit.bJQueryUI )
				{
					/* Use the JUI classes object for display. You could clone the oStdClasses object if
					 * you want to have multiple tables with multiple independent classes
					 */
					$.extend( oClasses, DataTable.ext.oJUIClasses, oInit.oClasses );
				
					if ( oInit.sDom === defaults.sDom && defaults.sDom === "lfrtip" )
					{
						/* Set the DOM to use a layout suitable for jQuery UI's theming */
						oSettings.sDom = '<"H"lfr>t<"F"ip>';
					}
				
					if ( ! oSettings.renderer ) {
						oSettings.renderer = 'jqueryui';
					}
					else if ( $.isPlainObject( oSettings.renderer ) && ! oSettings.renderer.header ) {
						oSettings.renderer.header = 'jqueryui';
					}
				}
				else
				{
					$.extend( oClasses, DataTable.ext.classes, oInit.oClasses );
				}
				$this.addClass( oClasses.sTable );
				
				
				if ( oSettings.iInitDisplayStart === undefined )
				{
					/* Display start point, taking into account the save saving */
					oSettings.iInitDisplayStart = oInit.iDisplayStart;
					oSettings._iDisplayStart = oInit.iDisplayStart;
				}
				
				if ( oInit.iDeferLoading !== null )
				{
					oSettings.bDeferLoading = true;
					var tmp = $.isArray( oInit.iDeferLoading );
					oSettings._iRecordsDisplay = tmp ? oInit.iDeferLoading[0] : oInit.iDeferLoading;
					oSettings._iRecordsTotal = tmp ? oInit.iDeferLoading[1] : oInit.iDeferLoading;
				}
				
				/* Language definitions */
				var oLanguage = oSettings.oLanguage;
				$.extend( true, oLanguage, oInit.oLanguage );
				
				if ( oLanguage.sUrl !== "" )
				{
					/* Get the language definitions from a file - because this Ajax call makes the language
					 * get async to the remainder of this function we use bInitHandedOff to indicate that
					 * _fnInitialise will be fired by the returned Ajax handler, rather than the constructor
					 */
					$.ajax( {
						dataType: 'json',
						url: oLanguage.sUrl,
						success: function ( json ) {
							_fnLanguageCompat( json );
							_fnCamelToHungarian( defaults.oLanguage, json );
							$.extend( true, oLanguage, json );
							_fnInitialise( oSettings );
						},
						error: function () {
							// Error occurred loading language file, continue on as best we can
							_fnInitialise( oSettings );
						}
					} );
					bInitHandedOff = true;
				}
				
				/*
				 * Stripes
				 */
				if ( oInit.asStripeClasses === null )
				{
					oSettings.asStripeClasses =[
						oClasses.sStripeOdd,
						oClasses.sStripeEven
					];
				}
				
				/* Remove row stripe classes if they are already on the table row */
				var stripeClasses = oSettings.asStripeClasses;
				var rowOne = $this.children('tbody').find('tr').eq(0);
				if ( $.inArray( true, $.map( stripeClasses, function(el, i) {
					return rowOne.hasClass(el);
				} ) ) !== -1 ) {
					$('tbody tr', this).removeClass( stripeClasses.join(' ') );
					oSettings.asDestroyStripes = stripeClasses.slice();
				}
				
				/*
				 * Columns
				 * See if we should load columns automatically or use defined ones
				 */
				var anThs = [];
				var aoColumnsInit;
				var nThead = this.getElementsByTagName('thead');
				if ( nThead.length !== 0 )
				{
					_fnDetectHeader( oSettings.aoHeader, nThead[0] );
					anThs = _fnGetUniqueThs( oSettings );
				}
				
				/* If not given a column array, generate one with nulls */
				if ( oInit.aoColumns === null )
				{
					aoColumnsInit = [];
					for ( i=0, iLen=anThs.length ; i<iLen ; i++ )
					{
						aoColumnsInit.push( null );
					}
				}
				else
				{
					aoColumnsInit = oInit.aoColumns;
				}
				
				/* Add the columns */
				for ( i=0, iLen=aoColumnsInit.length ; i<iLen ; i++ )
				{
					_fnAddColumn( oSettings, anThs ? anThs[i] : null );
				}
				
				/* Apply the column definitions */
				_fnApplyColumnDefs( oSettings, oInit.aoColumnDefs, aoColumnsInit, function (iCol, oDef) {
					_fnColumnOptions( oSettings, iCol, oDef );
				} );
				
				/* HTML5 attribute detection - build an mData object automatically if the
				 * attributes are found
				 */
				if ( rowOne.length ) {
					var a = function ( cell, name ) {
						return cell.getAttribute( 'data-'+name ) !== null ? name : null;
					};
				
					$( rowOne[0] ).children('th, td').each( function (i, cell) {
						var col = oSettings.aoColumns[i];
				
						if ( col.mData === i ) {
							var sort = a( cell, 'sort' ) || a( cell, 'order' );
							var filter = a( cell, 'filter' ) || a( cell, 'search' );
				
							if ( sort !== null || filter !== null ) {
								col.mData = {
									_:      i+'.display',
									sort:   sort !== null   ? i+'.@data-'+sort   : undefined,
									type:   sort !== null   ? i+'.@data-'+sort   : undefined,
									filter: filter !== null ? i+'.@data-'+filter : undefined
								};
				
								_fnColumnOptions( oSettings, i );
							}
						}
					} );
				}
				
				var features = oSettings.oFeatures;
				
				/* Must be done after everything which can be overridden by the state saving! */
				if ( oInit.bStateSave )
				{
					features.bStateSave = true;
					_fnLoadState( oSettings, oInit );
					_fnCallbackReg( oSettings, 'aoDrawCallback', _fnSaveState, 'state_save' );
				}
				
				
				/*
				 * Sorting
				 * @todo For modularisation (1.11) this needs to do into a sort start up handler
				 */
				
				// If aaSorting is not defined, then we use the first indicator in asSorting
				// in case that has been altered, so the default sort reflects that option
				if ( oInit.aaSorting === undefined )
				{
					var sorting = oSettings.aaSorting;
					for ( i=0, iLen=sorting.length ; i<iLen ; i++ )
					{
						sorting[i][1] = oSettings.aoColumns[ i ].asSorting[0];
					}
				}
				
				/* Do a first pass on the sorting classes (allows any size changes to be taken into
				 * account, and also will apply sorting disabled classes if disabled
				 */
				_fnSortingClasses( oSettings );
				
				if ( features.bSort )
				{
					_fnCallbackReg( oSettings, 'aoDrawCallback', function () {
						if ( oSettings.bSorted ) {
							var aSort = _fnSortFlatten( oSettings );
							var sortedColumns = {};
				
							$.each( aSort, function (i, val) {
								sortedColumns[ val.src ] = val.dir;
							} );
				
							_fnCallbackFire( oSettings, null, 'order', [oSettings, aSort, sortedColumns] );
							_fnSortAria( oSettings );
						}
					} );
				}
				
				_fnCallbackReg( oSettings, 'aoDrawCallback', function () {
					if ( oSettings.bSorted || _fnDataSource( oSettings ) === 'ssp' || features.bDeferRender ) {
						_fnSortingClasses( oSettings );
					}
				}, 'sc' );
				
				
				/*
				 * Final init
				 * Cache the header, body and footer as required, creating them if needed
				 */
				
				// Work around for Webkit bug 83867 - store the caption-side before removing from doc
				var captions = $this.children('caption').each( function () {
					this._captionSide = $this.css('caption-side');
				} );
				
				var thead = $this.children('thead');
				if ( thead.length === 0 )
				{
					thead = $('<thead/>').appendTo(this);
				}
				oSettings.nTHead = thead[0];
				
				var tbody = $this.children('tbody');
				if ( tbody.length === 0 )
				{
					tbody = $('<tbody/>').appendTo(this);
				}
				oSettings.nTBody = tbody[0];
				
				var tfoot = $this.children('tfoot');
				if ( tfoot.length === 0 && captions.length > 0 && (oSettings.oScroll.sX !== "" || oSettings.oScroll.sY !== "") )
				{
					// If we are a scrolling table, and no footer has been given, then we need to create
					// a tfoot element for the caption element to be appended to
					tfoot = $('<tfoot/>').appendTo(this);
				}
				
				if ( tfoot.length === 0 || tfoot.children().length === 0 ) {
					$this.addClass( oClasses.sNoFooter );
				}
				else if ( tfoot.length > 0 ) {
					oSettings.nTFoot = tfoot[0];
					_fnDetectHeader( oSettings.aoFooter, oSettings.nTFoot );
				}
				
				/* Check if there is data passing into the constructor */
				if ( oInit.aaData )
				{
					for ( i=0 ; i<oInit.aaData.length ; i++ )
					{
						_fnAddData( oSettings, oInit.aaData[ i ] );
					}
				}
				else if ( oSettings.bDeferLoading || _fnDataSource( oSettings ) == 'dom' )
				{
					/* Grab the data from the page - only do this when deferred loading or no Ajax
					 * source since there is no point in reading the DOM data if we are then going
					 * to replace it with Ajax data
					 */
					_fnAddTr( oSettings, $(oSettings.nTBody).children('tr') );
				}
				
				/* Copy the data index array */
				oSettings.aiDisplay = oSettings.aiDisplayMaster.slice();
				
				/* Initialisation complete - table can be drawn */
				oSettings.bInitialised = true;
				
				/* Check if we need to initialise the table (it might not have been handed off to the
				 * language processor)
				 */
				if ( bInitHandedOff === false )
				{
					_fnInitialise( oSettings );
				}
			} );
			_that = null;
			return this;
		};
	
		
		/*
		 * It is useful to have variables which are scoped locally so only the
		 * DataTables functions can access them and they don't leak into global space.
		 * At the same time these functions are often useful over multiple files in the
		 * core and API, so we list, or at least document, all variables which are used
		 * by DataTables as private variables here. This also ensures that there is no
		 * clashing of variable names and that they can easily referenced for reuse.
		 */
		
		
		// Defined else where
		//  _selector_run
		//  _selector_opts
		//  _selector_first
		//  _selector_row_indexes
		
		var _ext; // DataTable.ext
		var _Api; // DataTable.Api
		var _api_register; // DataTable.Api.register
		var _api_registerPlural; // DataTable.Api.registerPlural
		
		var _re_dic = {};
		var _re_new_lines = /[\r\n]/g;
		var _re_html = /<.*?>/g;
		var _re_date_start = /^[\w\+\-]/;
		var _re_date_end = /[\w\+\-]$/;
		
		// Escape regular expression special characters
		var _re_escape_regex = new RegExp( '(\\' + [ '/', '.', '*', '+', '?', '|', '(', ')', '[', ']', '{', '}', '\\', '$', '^', '-' ].join('|\\') + ')', 'g' );
		
		// http://en.wikipedia.org/wiki/Foreign_exchange_market
		// - \u20BD - Russian ruble.
		// - \u20a9 - South Korean Won
		// - \u20BA - Turkish Lira
		// - \u20B9 - Indian Rupee
		// - R - Brazil (R$) and South Africa
		// - fr - Swiss Franc
		// - kr - Swedish krona, Norwegian krone and Danish krone
		// - \u2009 is thin space and \u202F is narrow no-break space, both used in many
		//   standards as thousands separators.
		var _re_formatted_numeric = /[',$Â£â¬Â¥%\u2009\u202F\u20BD\u20a9\u20BArfk]/gi;
		
		
		var _empty = function ( d ) {
			return !d || d === true || d === '-' ? true : false;
		};
		
		
		var _intVal = function ( s ) {
			var integer = parseInt( s, 10 );
			return !isNaN(integer) && isFinite(s) ? integer : null;
		};
		
		// Convert from a formatted number with characters other than `.` as the
		// decimal place, to a Javascript number
		var _numToDecimal = function ( num, decimalPoint ) {
			// Cache created regular expressions for speed as this function is called often
			if ( ! _re_dic[ decimalPoint ] ) {
				_re_dic[ decimalPoint ] = new RegExp( _fnEscapeRegex( decimalPoint ), 'g' );
			}
			return typeof num === 'string' && decimalPoint !== '.' ?
				num.replace( /\./g, '' ).replace( _re_dic[ decimalPoint ], '.' ) :
				num;
		};
		
		
		var _isNumber = function ( d, decimalPoint, formatted ) {
			var strType = typeof d === 'string';
		
			// If empty return immediately so there must be a number if it is a
			// formatted string (this stops the string "k", or "kr", etc being detected
			// as a formatted number for currency
			if ( _empty( d ) ) {
				return true;
			}
		
			if ( decimalPoint && strType ) {
				d = _numToDecimal( d, decimalPoint );
			}
		
			if ( formatted && strType ) {
				d = d.replace( _re_formatted_numeric, '' );
			}
		
			return !isNaN( parseFloat(d) ) && isFinite( d );
		};
		
		
		// A string without HTML in it can be considered to be HTML still
		var _isHtml = function ( d ) {
			return _empty( d ) || typeof d === 'string';
		};
		
		
		var _htmlNumeric = function ( d, decimalPoint, formatted ) {
			if ( _empty( d ) ) {
				return true;
			}
		
			var html = _isHtml( d );
			return ! html ?
				null :
				_isNumber( _stripHtml( d ), decimalPoint, formatted ) ?
					true :
					null;
		};
		
		
		var _pluck = function ( a, prop, prop2 ) {
			var out = [];
			var i=0, ien=a.length;
		
			// Could have the test in the loop for slightly smaller code, but speed
			// is essential here
			if ( prop2 !== undefined ) {
				for ( ; i<ien ; i++ ) {
					if ( a[i] && a[i][ prop ] ) {
						out.push( a[i][ prop ][ prop2 ] );
					}
				}
			}
			else {
				for ( ; i<ien ; i++ ) {
					if ( a[i] ) {
						out.push( a[i][ prop ] );
					}
				}
			}
		
			return out;
		};
		
		
		// Basically the same as _pluck, but rather than looping over `a` we use `order`
		// as the indexes to pick from `a`
		var _pluck_order = function ( a, order, prop, prop2 )
		{
			var out = [];
			var i=0, ien=order.length;
		
			// Could have the test in the loop for slightly smaller code, but speed
			// is essential here
			if ( prop2 !== undefined ) {
				for ( ; i<ien ; i++ ) {
					if ( a[ order[i] ][ prop ] ) {
						out.push( a[ order[i] ][ prop ][ prop2 ] );
					}
				}
			}
			else {
				for ( ; i<ien ; i++ ) {
					out.push( a[ order[i] ][ prop ] );
				}
			}
		
			return out;
		};
		
		
		var _range = function ( len, start )
		{
			var out = [];
			var end;
		
			if ( start === undefined ) {
				start = 0;
				end = len;
			}
			else {
				end = start;
				start = len;
			}
		
			for ( var i=start ; i<end ; i++ ) {
				out.push( i );
			}
		
			return out;
		};
		
		
		var _removeEmpty = function ( a )
		{
			var out = [];
		
			for ( var i=0, ien=a.length ; i<ien ; i++ ) {
				if ( a[i] ) { // careful - will remove all falsy values!
					out.push( a[i] );
				}
			}
		
			return out;
		};
		
		
		var _stripHtml = function ( d ) {
			return d.replace( _re_html, '' );
		};
		
		
		/**
		 * Find the unique elements in a source array.
		 *
		 * @param  {array} src Source array
		 * @return {array} Array of unique items
		 * @ignore
		 */
		var _unique = function ( src )
		{
			// A faster unique method is to use object keys to identify used values,
			// but this doesn't work with arrays or objects, which we must also
			// consider. See jsperf.com/compare-array-unique-versions/4 for more
			// information.
			var
				out = [],
				val,
				i, ien=src.length,
				j, k=0;
		
			again: for ( i=0 ; i<ien ; i++ ) {
				val = src[i];
		
				for ( j=0 ; j<k ; j++ ) {
					if ( out[j] === val ) {
						continue again;
					}
				}
		
				out.push( val );
				k++;
			}
		
			return out;
		};
		
		
		/**
		 * DataTables utility methods
		 * 
		 * This namespace provides helper methods that DataTables uses internally to
		 * create a DataTable, but which are not exclusively used only for DataTables.
		 * These methods can be used by extension authors to save the duplication of
		 * code.
		 *
		 *  @namespace
		 */
		DataTable.util = {
			/**
			 * Throttle the calls to a function. Arguments and context are maintained
			 * for the throttled function.
			 *
			 * @param {function} fn Function to be called
			 * @param {integer} freq Call frequency in mS
			 * @return {function} Wrapped function
			 */
			throttle: function ( fn, freq ) {
				var
					frequency = freq !== undefined ? freq : 200,
					last,
					timer;
		
				return function () {
					var
						that = this,
						now  = +new Date(),
						args = arguments;
		
					if ( last && now < last + frequency ) {
						clearTimeout( timer );
		
						timer = setTimeout( function () {
							last = undefined;
							fn.apply( that, args );
						}, frequency );
					}
					else {
						last = now;
						fn.apply( that, args );
					}
				};
			},
		
		
			/**
			 * Escape a string such that it can be used in a regular expression
			 *
			 *  @param {string} val string to escape
			 *  @returns {string} escaped string
			 */
			escapeRegex: function ( val ) {
				return val.replace( _re_escape_regex, '\\$1' );
			}
		};
		
		
		
		/**
		 * Create a mapping object that allows camel case parameters to be looked up
		 * for their Hungarian counterparts. The mapping is stored in a private
		 * parameter called `_hungarianMap` which can be accessed on the source object.
		 *  @param {object} o
		 *  @memberof DataTable#oApi
		 */
		function _fnHungarianMap ( o )
		{
			var
				hungarian = 'a aa ai ao as b fn i m o s ',
				match,
				newKey,
				map = {};
		
			$.each( o, function (key, val) {
				match = key.match(/^([^A-Z]+?)([A-Z])/);
		
				if ( match && hungarian.indexOf(match[1]+' ') !== -1 )
				{
					newKey = key.replace( match[0], match[2].toLowerCase() );
					map[ newKey ] = key;
		
					if ( match[1] === 'o' )
					{
						_fnHungarianMap( o[key] );
					}
				}
			} );
		
			o._hungarianMap = map;
		}
		
		
		/**
		 * Convert from camel case parameters to Hungarian, based on a Hungarian map
		 * created by _fnHungarianMap.
		 *  @param {object} src The model object which holds all parameters that can be
		 *    mapped.
		 *  @param {object} user The object to convert from camel case to Hungarian.
		 *  @param {boolean} force When set to `true`, properties which already have a
		 *    Hungarian value in the `user` object will be overwritten. Otherwise they
		 *    won't be.
		 *  @memberof DataTable#oApi
		 */
		function _fnCamelToHungarian ( src, user, force )
		{
			if ( ! src._hungarianMap ) {
				_fnHungarianMap( src );
			}
		
			var hungarianKey;
		
			$.each( user, function (key, val) {
				hungarianKey = src._hungarianMap[ key ];
		
				if ( hungarianKey !== undefined && (force || user[hungarianKey] === undefined) )
				{
					// For objects, we need to buzz down into the object to copy parameters
					if ( hungarianKey.charAt(0) === 'o' )
					{
						// Copy the camelCase options over to the hungarian
						if ( ! user[ hungarianKey ] ) {
							user[ hungarianKey ] = {};
						}
						$.extend( true, user[hungarianKey], user[key] );
		
						_fnCamelToHungarian( src[hungarianKey], user[hungarianKey], force );
					}
					else {
						user[hungarianKey] = user[ key ];
					}
				}
			} );
		}
		
		
		/**
		 * Language compatibility - when certain options are given, and others aren't, we
		 * need to duplicate the values over, in order to provide backwards compatibility
		 * with older language files.
		 *  @param {object} oSettings dataTables settings object
		 *  @memberof DataTable#oApi
		 */
		function _fnLanguageCompat( lang )
		{
			var defaults = DataTable.defaults.oLanguage;
			var zeroRecords = lang.sZeroRecords;
		
			/* Backwards compatibility - if there is no sEmptyTable given, then use the same as
			 * sZeroRecords - assuming that is given.
			 */
			if ( ! lang.sEmptyTable && zeroRecords &&
				defaults.sEmptyTable === "No data available in table" )
			{
				_fnMap( lang, lang, 'sZeroRecords', 'sEmptyTable' );
			}
		
			/* Likewise with loading records */
			if ( ! lang.sLoadingRecords && zeroRecords &&
				defaults.sLoadingRecords === "Loading..." )
			{
				_fnMap( lang, lang, 'sZeroRecords', 'sLoadingRecords' );
			}
		
			// Old parameter name of the thousands separator mapped onto the new
			if ( lang.sInfoThousands ) {
				lang.sThousands = lang.sInfoThousands;
			}
		
			var decimal = lang.sDecimal;
			if ( decimal ) {
				_addNumericSort( decimal );
			}
		}
		
		
		/**
		 * Map one parameter onto another
		 *  @param {object} o Object to map
		 *  @param {*} knew The new parameter name
		 *  @param {*} old The old parameter name
		 */
		var _fnCompatMap = function ( o, knew, old ) {
			if ( o[ knew ] !== undefined ) {
				o[ old ] = o[ knew ];
			}
		};
		
		
		/**
		 * Provide backwards compatibility for the main DT options. Note that the new
		 * options are mapped onto the old parameters, so this is an external interface
		 * change only.
		 *  @param {object} init Object to map
		 */
		function _fnCompatOpts ( init )
		{
			_fnCompatMap( init, 'ordering',      'bSort' );
			_fnCompatMap( init, 'orderMulti',    'bSortMulti' );
			_fnCompatMap( init, 'orderClasses',  'bSortClasses' );
			_fnCompatMap( init, 'orderCellsTop', 'bSortCellsTop' );
			_fnCompatMap( init, 'order',         'aaSorting' );
			_fnCompatMap( init, 'orderFixed',    'aaSortingFixed' );
			_fnCompatMap( init, 'paging',        'bPaginate' );
			_fnCompatMap( init, 'pagingType',    'sPaginationType' );
			_fnCompatMap( init, 'pageLength',    'iDisplayLength' );
			_fnCompatMap( init, 'searching',     'bFilter' );
		
			// Boolean initialisation of x-scrolling
			if ( typeof init.sScrollX === 'boolean' ) {
				init.sScrollX = init.sScrollX ? '100%' : '';
			}
			if ( typeof init.scrollX === 'boolean' ) {
				init.scrollX = init.scrollX ? '100%' : '';
			}
		
			// Column search objects are in an array, so it needs to be converted
			// element by element
			var searchCols = init.aoSearchCols;
		
			if ( searchCols ) {
				for ( var i=0, ien=searchCols.length ; i<ien ; i++ ) {
					if ( searchCols[i] ) {
						_fnCamelToHungarian( DataTable.models.oSearch, searchCols[i] );
					}
				}
			}
		}
		
		
		/**
		 * Provide backwards compatibility for column options. Note that the new options
		 * are mapped onto the old parameters, so this is an external interface change
		 * only.
		 *  @param {object} init Object to map
		 */
		function _fnCompatCols ( init )
		{
			_fnCompatMap( init, 'orderable',     'bSortable' );
			_fnCompatMap( init, 'orderData',     'aDataSort' );
			_fnCompatMap( init, 'orderSequence', 'asSorting' );
			_fnCompatMap( init, 'orderDataType', 'sortDataType' );
		
			// orderData can be given as an integer
			var dataSort = init.aDataSort;
			if ( dataSort && ! $.isArray( dataSort ) ) {
				init.aDataSort = [ dataSort ];
			}
		}
		
		
		/**
		 * Browser feature detection for capabilities, quirks
		 *  @param {object} settings dataTables settings object
		 *  @memberof DataTable#oApi
		 */
		function _fnBrowserDetect( settings )
		{
			// We don't need to do this every time DataTables is constructed, the values
			// calculated are specific to the browser and OS configuration which we
			// don't expect to change between initialisations
			if ( ! DataTable.__browser ) {
				var browser = {};
				DataTable.__browser = browser;
		
				// Scrolling feature / quirks detection
				var n = $('<div/>')
					.css( {
						position: 'fixed',
						top: 0,
						left: 0,
						height: 1,
						width: 1,
						overflow: 'hidden'
					} )
					.append(
						$('<div/>')
							.css( {
								position: 'absolute',
								top: 1,
								left: 1,
								width: 100,
								overflow: 'scroll'
							} )
							.append(
								$('<div/>')
									.css( {
										width: '100%',
										height: 10
									} )
							)
					)
					.appendTo( 'body' );
		
				var outer = n.children();
				var inner = outer.children();
		
				// Numbers below, in order, are:
				// inner.offsetWidth, inner.clientWidth, outer.offsetWidth, outer.clientWidth
				//
				// IE6 XP:                           100 100 100  83
				// IE7 Vista:                        100 100 100  83
				// IE 8+ Windows:                     83  83 100  83
				// Evergreen Windows:                 83  83 100  83
				// Evergreen Mac with scrollbars:     85  85 100  85
				// Evergreen Mac without scrollbars: 100 100 100 100
		
				// Get scrollbar width
				browser.barWidth = outer[0].offsetWidth - outer[0].clientWidth;
		
				// IE6/7 will oversize a width 100% element inside a scrolling element, to
				// include the width of the scrollbar, while other browsers ensure the inner
				// element is contained without forcing scrolling
				browser.bScrollOversize = inner[0].offsetWidth === 100 && outer[0].clientWidth !== 100;
		
				// In rtl text layout, some browsers (most, but not all) will place the
				// scrollbar on the left, rather than the right.
				browser.bScrollbarLeft = Math.round( inner.offset().left ) !== 1;
		
				// IE8- don't provide height and width for getBoundingClientRect
				browser.bBounding = n[0].getBoundingClientRect().width ? true : false;
		
				n.remove();
			}
		
			$.extend( settings.oBrowser, DataTable.__browser );
			settings.oScroll.iBarWidth = DataTable.__browser.barWidth;
		}
		
		
		/**
		 * Array.prototype reduce[Right] method, used for browsers which don't support
		 * JS 1.6. Done this way to reduce code size, since we iterate either way
		 *  @param {object} settings dataTables settings object
		 *  @memberof DataTable#oApi
		 */
		function _fnReduce ( that, fn, init, start, end, inc )
		{
			var
				i = start,
				value,
				isSet = false;
		
			if ( init !== undefined ) {
				value = init;
				isSet = true;
			}
		
			while ( i !== end ) {
				if ( ! that.hasOwnProperty(i) ) {
					continue;
				}
		
				value = isSet ?
					fn( value, that[i], i, that ) :
					that[i];
		
				isSet = true;
				i += inc;
			}
		
			return value;
		}
		
		/**
		 * Add a column to the list used for the table with default values
		 *  @param {object} oSettings dataTables settings object
		 *  @param {node} nTh The th element for this column
		 *  @memberof DataTable#oApi
		 */
		function _fnAddColumn( oSettings, nTh )
		{
			// Add column to aoColumns array
			var oDefaults = DataTable.defaults.column;
			var iCol = oSettings.aoColumns.length;
			var oCol = $.extend( {}, DataTable.models.oColumn, oDefaults, {
				"nTh": nTh ? nTh : document.createElement('th'),
				"sTitle":    oDefaults.sTitle    ? oDefaults.sTitle    : nTh ? nTh.innerHTML : '',
				"aDataSort": oDefaults.aDataSort ? oDefaults.aDataSort : [iCol],
				"mData": oDefaults.mData ? oDefaults.mData : iCol,
				idx: iCol
			} );
			oSettings.aoColumns.push( oCol );
		
			// Add search object for column specific search. Note that the `searchCols[ iCol ]`
			// passed into extend can be undefined. This allows the user to give a default
			// with only some of the parameters defined, and also not give a default
			var searchCols = oSettings.aoPreSearchCols;
			searchCols[ iCol ] = $.extend( {}, DataTable.models.oSearch, searchCols[ iCol ] );
		
			// Use the default column options function to initialise classes etc
			_fnColumnOptions( oSettings, iCol, $(nTh).data() );
		}
		
		
		/**
		 * Apply options for a column
		 *  @param {object} oSettings dataTables settings object
		 *  @param {int} iCol column index to consider
		 *  @param {object} oOptions object with sType, bVisible and bSearchable etc
		 *  @memberof DataTable#oApi
		 */
		function _fnColumnOptions( oSettings, iCol, oOptions )
		{
			var oCol = oSettings.aoColumns[ iCol ];
			var oClasses = oSettings.oClasses;
			var th = $(oCol.nTh);
		
			// Try to get width information from the DOM. We can't get it from CSS
			// as we'd need to parse the CSS stylesheet. `width` option can override
			if ( ! oCol.sWidthOrig ) {
				// Width attribute
				oCol.sWidthOrig = th.attr('width') || null;
		
				// Style attribute
				var t = (th.attr('style') || '').match(/width:\s*(\d+[pxem%]+)/);
				if ( t ) {
					oCol.sWidthOrig = t[1];
				}
			}
		
			/* User specified column options */
			if ( oOptions !== undefined && oOptions !== null )
			{
				// Backwards compatibility
				_fnCompatCols( oOptions );
		
				// Map camel case parameters to their Hungarian counterparts
				_fnCamelToHungarian( DataTable.defaults.column, oOptions );
		
				/* Backwards compatibility for mDataProp */
				if ( oOptions.mDataProp !== undefined && !oOptions.mData )
				{
					oOptions.mData = oOptions.mDataProp;
				}
		
				if ( oOptions.sType )
				{
					oCol._sManualType = oOptions.sType;
				}
		
				// `class` is a reserved word in Javascript, so we need to provide
				// the ability to use a valid name for the camel case input
				if ( oOptions.className && ! oOptions.sClass )
				{
					oOptions.sClass = oOptions.className;
				}
		
				$.extend( oCol, oOptions );
				_fnMap( oCol, oOptions, "sWidth", "sWidthOrig" );
		
				/* iDataSort to be applied (backwards compatibility), but aDataSort will take
				 * priority if defined
				 */
				if ( oOptions.iDataSort !== undefined )
				{
					oCol.aDataSort = [ oOptions.iDataSort ];
				}
				_fnMap( oCol, oOptions, "aDataSort" );
			}
		
			/* Cache the data get and set functions for speed */
			var mDataSrc = oCol.mData;
			var mData = _fnGetObjectDataFn( mDataSrc );
			var mRender = oCol.mRender ? _fnGetObjectDataFn( oCol.mRender ) : null;
		
			var attrTest = function( src ) {
				return typeof src === 'string' && src.indexOf('@') !== -1;
			};
			oCol._bAttrSrc = $.isPlainObject( mDataSrc ) && (
				attrTest(mDataSrc.sort) || attrTest(mDataSrc.type) || attrTest(mDataSrc.filter)
			);
			oCol._setter = null;
		
			oCol.fnGetData = function (rowData, type, meta) {
				var innerData = mData( rowData, type, undefined, meta );
		
				return mRender && type ?
					mRender( innerData, type, rowData, meta ) :
					innerData;
			};
			oCol.fnSetData = function ( rowData, val, meta ) {
				return _fnSetObjectDataFn( mDataSrc )( rowData, val, meta );
			};
		
			// Indicate if DataTables should read DOM data as an object or array
			// Used in _fnGetRowElements
			if ( typeof mDataSrc !== 'number' ) {
				oSettings._rowReadObject = true;
			}
		
			/* Feature sorting overrides column specific when off */
			if ( !oSettings.oFeatures.bSort )
			{
				oCol.bSortable = false;
				th.addClass( oClasses.sSortableNone ); // Have to add class here as order event isn't called
			}
		
			/* Check that the class assignment is correct for sorting */
			var bAsc = $.inArray('asc', oCol.asSorting) !== -1;
			var bDesc = $.inArray('desc', oCol.asSorting) !== -1;
			if ( !oCol.bSortable || (!bAsc && !bDesc) )
			{
				oCol.sSortingClass = oClasses.sSortableNone;
				oCol.sSortingClassJUI = "";
			}
			else if ( bAsc && !bDesc )
			{
				oCol.sSortingClass = oClasses.sSortableAsc;
				oCol.sSortingClassJUI = oClasses.sSortJUIAscAllowed;
			}
			else if ( !bAsc && bDesc )
			{
				oCol.sSortingClass = oClasses.sSortableDesc;
				oCol.sSortingClassJUI = oClasses.sSortJUIDescAllowed;
			}
			else
			{
				oCol.sSortingClass = oClasses.sSortable;
				oCol.sSortingClassJUI = oClasses.sSortJUI;
			}
		}
		
		
		/**
		 * Adjust the table column widths for new data. Note: you would probably want to
		 * do a redraw after calling this function!
		 *  @param {object} settings dataTables settings object
		 *  @memberof DataTable#oApi
		 */
		function _fnAdjustColumnSizing ( settings )
		{
			/* Not interested in doing column width calculation if auto-width is disabled */
			if ( settings.oFeatures.bAutoWidth !== false )
			{
				var columns = settings.aoColumns;
		
				_fnCalculateColumnWidths( settings );
				for ( var i=0 , iLen=columns.length ; i<iLen ; i++ )
				{
					columns[i].nTh.style.width = columns[i].sWidth;
				}
			}
		
			var scroll = settings.oScroll;
			if ( scroll.sY !== '' || scroll.sX !== '')
			{
				_fnScrollDraw( settings );
			}
		
			_fnCallbackFire( settings, null, 'column-sizing', [settings] );
		}
		
		
		/**
		 * Covert the index of a visible column to the index in the data array (take account
		 * of hidden columns)
		 *  @param {object} oSettings dataTables settings object
		 *  @param {int} iMatch Visible column index to lookup
		 *  @returns {int} i the data index
		 *  @memberof DataTable#oApi
		 */
		function _fnVisibleToColumnIndex( oSettings, iMatch )
		{
			var aiVis = _fnGetColumns( oSettings, 'bVisible' );
		
			return typeof aiVis[iMatch] === 'number' ?
				aiVis[iMatch] :
				null;
		}
		
		
		/**
		 * Covert the index of an index in the data array and convert it to the visible
		 *   column index (take account of hidden columns)
		 *  @param {int} iMatch Column index to lookup
		 *  @param {object} oSettings dataTables settings object
		 *  @returns {int} i the data index
		 *  @memberof DataTable#oApi
		 */
		function _fnColumnIndexToVisible( oSettings, iMatch )
		{
			var aiVis = _fnGetColumns( oSettings, 'bVisible' );
			var iPos = $.inArray( iMatch, aiVis );
		
			return iPos !== -1 ? iPos : null;
		}
		
		
		/**
		 * Get the number of visible columns
		 *  @param {object} oSettings dataTables settings object
		 *  @returns {int} i the number of visible columns
		 *  @memberof DataTable#oApi
		 */
		function _fnVisbleColumns( oSettings )
		{
			var vis = 0;
		
			// No reduce in IE8, use a loop for now
			$.each( oSettings.aoColumns, function ( i, col ) {
				if ( col.bVisible && $(col.nTh).css('display') !== 'none' ) {
					vis++;
				}
			} );
		
			return vis;
		}
		
		
		/**
		 * Get an array of column indexes that match a given property
		 *  @param {object} oSettings dataTables settings object
		 *  @param {string} sParam Parameter in aoColumns to look for - typically
		 *    bVisible or bSearchable
		 *  @returns {array} Array of indexes with matched properties
		 *  @memberof DataTable#oApi
		 */
		function _fnGetColumns( oSettings, sParam )
		{
			var a = [];
		
			$.map( oSettings.aoColumns, function(val, i) {
				if ( val[sParam] ) {
					a.push( i );
				}
			} );
		
			return a;
		}
		
		
		/**
		 * Calculate the 'type' of a column
		 *  @param {object} settings dataTables settings object
		 *  @memberof DataTable#oApi
		 */
		function _fnColumnTypes ( settings )
		{
			var columns = settings.aoColumns;
			var data = settings.aoData;
			var types = DataTable.ext.type.detect;
			var i, ien, j, jen, k, ken;
			var col, cell, detectedType, cache;
		
			// For each column, spin over the 
			for ( i=0, ien=columns.length ; i<ien ; i++ ) {
				col = columns[i];
				cache = [];
		
				if ( ! col.sType && col._sManualType ) {
					col.sType = col._sManualType;
				}
				else if ( ! col.sType ) {
					for ( j=0, jen=types.length ; j<jen ; j++ ) {
						for ( k=0, ken=data.length ; k<ken ; k++ ) {
							// Use a cache array so we only need to get the type data
							// from the formatter once (when using multiple detectors)
							if ( cache[k] === undefined ) {
								cache[k] = _fnGetCellData( settings, k, i, 'type' );
							}
		
							detectedType = types[j]( cache[k], settings );
		
							// If null, then this type can't apply to this column, so
							// rather than testing all cells, break out. There is an
							// exception for the last type which is `html`. We need to
							// scan all rows since it is possible to mix string and HTML
							// types
							if ( ! detectedType && j !== types.length-1 ) {
								break;
							}
		
							// Only a single match is needed for html type since it is
							// bottom of the pile and very similar to string
							if ( detectedType === 'html' ) {
								break;
							}
						}
		
						// Type is valid for all data points in the column - use this
						// type
						if ( detectedType ) {
							col.sType = detectedType;
							break;
						}
					}
		
					// Fall back - if no type was detected, always use string
					if ( ! col.sType ) {
						col.sType = 'string';
					}
				}
			}
		}
		
		
		/**
		 * Take the column definitions and static columns arrays and calculate how
		 * they relate to column indexes. The callback function will then apply the
		 * definition found for a column to a suitable configuration object.
		 *  @param {object} oSettings dataTables settings object
		 *  @param {array} aoColDefs The aoColumnDefs array that is to be applied
		 *  @param {array} aoCols The aoColumns array that defines columns individually
		 *  @param {function} fn Callback function - takes two parameters, the calculated
		 *    column index and the definition for that column.
		 *  @memberof DataTable#oApi
		 */
		function _fnApplyColumnDefs( oSettings, aoColDefs, aoCols, fn )
		{
			var i, iLen, j, jLen, k, kLen, def;
			var columns = oSettings.aoColumns;
		
			// Column definitions with aTargets
			if ( aoColDefs )
			{
				/* Loop over the definitions array - loop in reverse so first instance has priority */
				for ( i=aoColDefs.length-1 ; i>=0 ; i-- )
				{
					def = aoColDefs[i];
		
					/* Each definition can target multiple columns, as it is an array */
					var aTargets = def.targets !== undefined ?
						def.targets :
						def.aTargets;
		
					if ( ! $.isArray( aTargets ) )
					{
						aTargets = [ aTargets ];
					}
		
					for ( j=0, jLen=aTargets.length ; j<jLen ; j++ )
					{
						if ( typeof aTargets[j] === 'number' && aTargets[j] >= 0 )
						{
							/* Add columns that we don't yet know about */
							while( columns.length <= aTargets[j] )
							{
								_fnAddColumn( oSettings );
							}
		
							/* Integer, basic index */
							fn( aTargets[j], def );
						}
						else if ( typeof aTargets[j] === 'number' && aTargets[j] < 0 )
						{
							/* Negative integer, right to left column counting */
							fn( columns.length+aTargets[j], def );
						}
						else if ( typeof aTargets[j] === 'string' )
						{
							/* Class name matching on TH element */
							for ( k=0, kLen=columns.length ; k<kLen ; k++ )
							{
								if ( aTargets[j] == "_all" ||
								     $(columns[k].nTh).hasClass( aTargets[j] ) )
								{
									fn( k, def );
								}
							}
						}
					}
				}
			}
		
			// Statically defined columns array
			if ( aoCols )
			{
				for ( i=0, iLen=aoCols.length ; i<iLen ; i++ )
				{
					fn( i, aoCols[i] );
				}
			}
		}
		
		/**
		 * Add a data array to the table, creating DOM node etc. This is the parallel to
		 * _fnGatherData, but for adding rows from a Javascript source, rather than a
		 * DOM source.
		 *  @param {object} oSettings dataTables settings object
		 *  @param {array} aData data array to be added
		 *  @param {node} [nTr] TR element to add to the table - optional. If not given,
		 *    DataTables will create a row automatically
		 *  @param {array} [anTds] Array of TD|TH elements for the row - must be given
		 *    if nTr is.
		 *  @returns {int} >=0 if successful (index of new aoData entry), -1 if failed
		 *  @memberof DataTable#oApi
		 */
		function _fnAddData ( oSettings, aDataIn, nTr, anTds )
		{
			/* Create the object for storing information about this new row */
			var iRow = oSettings.aoData.length;
			var oData = $.extend( true, {}, DataTable.models.oRow, {
				src: nTr ? 'dom' : 'data',
				idx: iRow
			} );
		
			oData._aData = aDataIn;
			oSettings.aoData.push( oData );
		
			/* Create the cells */
			var nTd, sThisType;
			var columns = oSettings.aoColumns;
		
			// Invalidate the column types as the new data needs to be revalidated
			for ( var i=0, iLen=columns.length ; i<iLen ; i++ )
			{
				columns[i].sType = null;
			}
		
			/* Add to the display array */
			oSettings.aiDisplayMaster.push( iRow );
		
			var id = oSettings.rowIdFn( aDataIn );
			if ( id !== undefined ) {
				oSettings.aIds[ id ] = oData;
			}
		
			/* Create the DOM information, or register it if already present */
			if ( nTr || ! oSettings.oFeatures.bDeferRender )
			{
				_fnCreateTr( oSettings, iRow, nTr, anTds );
			}
		
			return iRow;
		}
		
		
		/**
		 * Add one or more TR elements to the table. Generally we'd expect to
		 * use this for reading data from a DOM sourced table, but it could be
		 * used for an TR element. Note that if a TR is given, it is used (i.e.
		 * it is not cloned).
		 *  @param {object} settings dataTables settings object
		 *  @param {array|node|jQuery} trs The TR element(s) to add to the table
		 *  @returns {array} Array of indexes for the added rows
		 *  @memberof DataTable#oApi
		 */
		function _fnAddTr( settings, trs )
		{
			var row;
		
			// Allow an individual node to be passed in
			if ( ! (trs instanceof $) ) {
				trs = $(trs);
			}
		
			return trs.map( function (i, el) {
				row = _fnGetRowElements( settings, el );
				return _fnAddData( settings, row.data, el, row.cells );
			} );
		}
		
		
		/**
		 * Take a TR element and convert it to an index in aoData
		 *  @param {object} oSettings dataTables settings object
		 *  @param {node} n the TR element to find
		 *  @returns {int} index if the node is found, null if not
		 *  @memberof DataTable#oApi
		 */
		function _fnNodeToDataIndex( oSettings, n )
		{
			return (n._DT_RowIndex!==undefined) ? n._DT_RowIndex : null;
		}
		
		
		/**
		 * Take a TD element and convert it into a column data index (not the visible index)
		 *  @param {object} oSettings dataTables settings object
		 *  @param {int} iRow The row number the TD/TH can be found in
		 *  @param {node} n The TD/TH element to find
		 *  @returns {int} index if the node is found, -1 if not
		 *  @memberof DataTable#oApi
		 */
		function _fnNodeToColumnIndex( oSettings, iRow, n )
		{
			return $.inArray( n, oSettings.aoData[ iRow ].anCells );
		}
		
		
		/**
		 * Get the data for a given cell from the internal cache, taking into account data mapping
		 *  @param {object} settings dataTables settings object
		 *  @param {int} rowIdx aoData row id
		 *  @param {int} colIdx Column index
		 *  @param {string} type data get type ('display', 'type' 'filter' 'sort')
		 *  @returns {*} Cell data
		 *  @memberof DataTable#oApi
		 */
		function _fnGetCellData( settings, rowIdx, colIdx, type )
		{
			var draw           = settings.iDraw;
			var col            = settings.aoColumns[colIdx];
			var rowData        = settings.aoData[rowIdx]._aData;
			var defaultContent = col.sDefaultContent;
			var cellData       = col.fnGetData( rowData, type, {
				settings: settings,
				row:      rowIdx,
				col:      colIdx
			} );
		
			if ( cellData === undefined ) {
				if ( settings.iDrawError != draw && defaultContent === null ) {
					_fnLog( settings, 0, "Requested unknown parameter "+
						(typeof col.mData=='function' ? '{function}' : "'"+col.mData+"'")+
						" for row "+rowIdx+", column "+colIdx, 4 );
					settings.iDrawError = draw;
				}
				return defaultContent;
			}
		
			// When the data source is null and a specific data type is requested (i.e.
			// not the original data), we can use default column data
			if ( (cellData === rowData || cellData === null) && defaultContent !== null && type !== undefined ) {
				cellData = defaultContent;
			}
			else if ( typeof cellData === 'function' ) {
				// If the data source is a function, then we run it and use the return,
				// executing in the scope of the data object (for instances)
				return cellData.call( rowData );
			}
		
			if ( cellData === null && type == 'display' ) {
				return '';
			}
			return cellData;
		}
		
		
		/**
		 * Set the value for a specific cell, into the internal data cache
		 *  @param {object} settings dataTables settings object
		 *  @param {int} rowIdx aoData row id
		 *  @param {int} colIdx Column index
		 *  @param {*} val Value to set
		 *  @memberof DataTable#oApi
		 */
		function _fnSetCellData( settings, rowIdx, colIdx, val )
		{
			var col     = settings.aoColumns[colIdx];
			var rowData = settings.aoData[rowIdx]._aData;
		
			col.fnSetData( rowData, val, {
				settings: settings,
				row:      rowIdx,
				col:      colIdx
			}  );
		}
		
		
		// Private variable that is used to match action syntax in the data property object
		var __reArray = /\[.*?\]$/;
		var __reFn = /\(\)$/;
		
		/**
		 * Split string on periods, taking into account escaped periods
		 * @param  {string} str String to split
		 * @return {array} Split string
		 */
		function _fnSplitObjNotation( str )
		{
			return $.map( str.match(/(\\.|[^\.])+/g) || [''], function ( s ) {
				return s.replace(/\\./g, '.');
			} );
		}
		
		
		/**
		 * Return a function that can be used to get data from a source object, taking
		 * into account the ability to use nested objects as a source
		 *  @param {string|int|function} mSource The data source for the object
		 *  @returns {function} Data get function
		 *  @memberof DataTable#oApi
		 */
		function _fnGetObjectDataFn( mSource )
		{
			if ( $.isPlainObject( mSource ) )
			{
				/* Build an object of get functions, and wrap them in a single call */
				var o = {};
				$.each( mSource, function (key, val) {
					if ( val ) {
						o[key] = _fnGetObjectDataFn( val );
					}
				} );
		
				return function (data, type, row, meta) {
					var t = o[type] || o._;
					return t !== undefined ?
						t(data, type, row, meta) :
						data;
				};
			}
			else if ( mSource === null )
			{
				/* Give an empty string for rendering / sorting etc */
				return function (data) { // type, row and meta also passed, but not used
					return data;
				};
			}
			else if ( typeof mSource === 'function' )
			{
				return function (data, type, row, meta) {
					return mSource( data, type, row, meta );
				};
			}
			else if ( typeof mSource === 'string' && (mSource.indexOf('.') !== -1 ||
				      mSource.indexOf('[') !== -1 || mSource.indexOf('(') !== -1) )
			{
				/* If there is a . in the source string then the data source is in a
				 * nested object so we loop over the data for each level to get the next
				 * level down. On each loop we test for undefined, and if found immediately
				 * return. This allows entire objects to be missing and sDefaultContent to
				 * be used if defined, rather than throwing an error
				 */
				var fetchData = function (data, type, src) {
					var arrayNotation, funcNotation, out, innerSrc;
		
					if ( src !== "" )
					{
						var a = _fnSplitObjNotation( src );
		
						for ( var i=0, iLen=a.length ; i<iLen ; i++ )
						{
							// Check if we are dealing with special notation
							arrayNotation = a[i].match(__reArray);
							funcNotation = a[i].match(__reFn);
		
							if ( arrayNotation )
							{
								// Array notation
								a[i] = a[i].replace(__reArray, '');
		
								// Condition allows simply [] to be passed in
								if ( a[i] !== "" ) {
									data = data[ a[i] ];
								}
								out = [];
		
								// Get the remainder of the nested object to get
								a.splice( 0, i+1 );
								innerSrc = a.join('.');
		
								// Traverse each entry in the array getting the properties requested
								if ( $.isArray( data ) ) {
									for ( var j=0, jLen=data.length ; j<jLen ; j++ ) {
										out.push( fetchData( data[j], type, innerSrc ) );
									}
								}
		
								// If a string is given in between the array notation indicators, that
								// is used to join the strings together, otherwise an array is returned
								var join = arrayNotation[0].substring(1, arrayNotation[0].length-1);
								data = (join==="") ? out : out.join(join);
		
								// The inner call to fetchData has already traversed through the remainder
								// of the source requested, so we exit from the loop
								break;
							}
							else if ( funcNotation )
							{
								// Function call
								a[i] = a[i].replace(__reFn, '');
								data = data[ a[i] ]();
								continue;
							}
		
							if ( data === null || data[ a[i] ] === undefined )
							{
								return undefined;
							}
							data = data[ a[i] ];
						}
					}
		
					return data;
				};
		
				return function (data, type) { // row and meta also passed, but not used
					return fetchData( data, type, mSource );
				};
			}
			else
			{
				/* Array or flat object mapping */
				return function (data, type) { // row and meta also passed, but not used
					return data[mSource];
				};
			}
		}
		
		
		/**
		 * Return a function that can be used to set data from a source object, taking
		 * into account the ability to use nested objects as a source
		 *  @param {string|int|function} mSource The data source for the object
		 *  @returns {function} Data set function
		 *  @memberof DataTable#oApi
		 */
		function _fnSetObjectDataFn( mSource )
		{
			if ( $.isPlainObject( mSource ) )
			{
				/* Unlike get, only the underscore (global) option is used for for
				 * setting data since we don't know the type here. This is why an object
				 * option is not documented for `mData` (which is read/write), but it is
				 * for `mRender` which is read only.
				 */
				return _fnSetObjectDataFn( mSource._ );
			}
			else if ( mSource === null )
			{
				/* Nothing to do when the data source is null */
				return function () {};
			}
			else if ( typeof mSource === 'function' )
			{
				return function (data, val, meta) {
					mSource( data, 'set', val, meta );
				};
			}
			else if ( typeof mSource === 'string' && (mSource.indexOf('.') !== -1 ||
				      mSource.indexOf('[') !== -1 || mSource.indexOf('(') !== -1) )
			{
				/* Like the get, we need to get data from a nested object */
				var setData = function (data, val, src) {
					var a = _fnSplitObjNotation( src ), b;
					var aLast = a[a.length-1];
					var arrayNotation, funcNotation, o, innerSrc;
		
					for ( var i=0, iLen=a.length-1 ; i<iLen ; i++ )
					{
						// Check if we are dealing with an array notation request
						arrayNotation = a[i].match(__reArray);
						funcNotation = a[i].match(__reFn);
		
						if ( arrayNotation )
						{
							a[i] = a[i].replace(__reArray, '');
							data[ a[i] ] = [];
		
							// Get the remainder of the nested object to set so we can recurse
							b = a.slice();
							b.splice( 0, i+1 );
							innerSrc = b.join('.');
		
							// Traverse each entry in the array setting the properties requested
							if ( $.isArray( val ) )
							{
								for ( var j=0, jLen=val.length ; j<jLen ; j++ )
								{
									o = {};
									setData( o, val[j], innerSrc );
									data[ a[i] ].push( o );
								}
							}
							else
							{
								// We've been asked to save data to an array, but it
								// isn't array data to be saved. Best that can be done
								// is to just save the value.
								data[ a[i] ] = val;
							}
		
							// The inner call to setData has already traversed through the remainder
							// of the source and has set the data, thus we can exit here
							return;
						}
						else if ( funcNotation )
						{
							// Function call
							a[i] = a[i].replace(__reFn, '');
							data = data[ a[i] ]( val );
						}
		
						// If the nested object doesn't currently exist - since we are
						// trying to set the value - create it
						if ( data[ a[i] ] === null || data[ a[i] ] === undefined )
						{
							data[ a[i] ] = {};
						}
						data = data[ a[i] ];
					}
		
					// Last item in the input - i.e, the actual set
					if ( aLast.match(__reFn ) )
					{
						// Function call
						data = data[ aLast.replace(__reFn, '') ]( val );
					}
					else
					{
						// If array notation is used, we just want to strip it and use the property name
						// and assign the value. If it isn't used, then we get the result we want anyway
						data[ aLast.replace(__reArray, '') ] = val;
					}
				};
		
				return function (data, val) { // meta is also passed in, but not used
					return setData( data, val, mSource );
				};
			}
			else
			{
				/* Array or flat object mapping */
				return function (data, val) { // meta is also passed in, but not used
					data[mSource] = val;
				};
			}
		}
		
		
		/**
		 * Return an array with the full table data
		 *  @param {object} oSettings dataTables settings object
		 *  @returns array {array} aData Master data array
		 *  @memberof DataTable#oApi
		 */
		function _fnGetDataMaster ( settings )
		{
			return _pluck( settings.aoData, '_aData' );
		}
		
		
		/**
		 * Nuke the table
		 *  @param {object} oSettings dataTables settings object
		 *  @memberof DataTable#oApi
		 */
		function _fnClearTable( settings )
		{
			settings.aoData.length = 0;
			settings.aiDisplayMaster.length = 0;
			settings.aiDisplay.length = 0;
			settings.aIds = {};
		}
		
		
		 /**
		 * Take an array of integers (index array) and remove a target integer (value - not
		 * the key!)
		 *  @param {array} a Index array to target
		 *  @param {int} iTarget value to find
		 *  @memberof DataTable#oApi
		 */
		function _fnDeleteIndex( a, iTarget, splice )
		{
			var iTargetIndex = -1;
		
			for ( var i=0, iLen=a.length ; i<iLen ; i++ )
			{
				if ( a[i] == iTarget )
				{
					iTargetIndex = i;
				}
				else if ( a[i] > iTarget )
				{
					a[i]--;
				}
			}
		
			if ( iTargetIndex != -1 && splice === undefined )
			{
				a.splice( iTargetIndex, 1 );
			}
		}
		
		
		/**
		 * Mark cached data as invalid such that a re-read of the data will occur when
		 * the cached data is next requested. Also update from the data source object.
		 *
		 * @param {object} settings DataTables settings object
		 * @param {int}    rowIdx   Row index to invalidate
		 * @param {string} [src]    Source to invalidate from: undefined, 'auto', 'dom'
		 *     or 'data'
		 * @param {int}    [colIdx] Column index to invalidate. If undefined the whole
		 *     row will be invalidated
		 * @memberof DataTable#oApi
		 *
		 * @todo For the modularisation of v1.11 this will need to become a callback, so
		 *   the sort and filter methods can subscribe to it. That will required
		 *   initialisation options for sorting, which is why it is not already baked in
		 */
		function _fnInvalidate( settings, rowIdx, src, colIdx )
		{
			var row = settings.aoData[ rowIdx ];
			var i, ien;
			var cellWrite = function ( cell, col ) {
				// This is very frustrating, but in IE if you just write directly
				// to innerHTML, and elements that are overwritten are GC'ed,
				// even if there is a reference to them elsewhere
				while ( cell.childNodes.length ) {
					cell.removeChild( cell.firstChild );
				}
		
				cell.innerHTML = _fnGetCellData( settings, rowIdx, col, 'display' );
			};
		
			// Are we reading last data from DOM or the data object?
			if ( src === 'dom' || ((! src || src === 'auto') && row.src === 'dom') ) {
				// Read the data from the DOM
				row._aData = _fnGetRowElements(
						settings, row, colIdx, colIdx === undefined ? undefined : row._aData
					)
					.data;
			}
			else {
				// Reading from data object, update the DOM
				var cells = row.anCells;
		
				if ( cells ) {
					if ( colIdx !== undefined ) {
						cellWrite( cells[colIdx], colIdx );
					}
					else {
						for ( i=0, ien=cells.length ; i<ien ; i++ ) {
							cellWrite( cells[i], i );
						}
					}
				}
			}
		
			// For both row and cell invalidation, the cached data for sorting and
			// filtering is nulled out
			row._aSortData = null;
			row._aFilterData = null;
		
			// Invalidate the type for a specific column (if given) or all columns since
			// the data might have changed
			var cols = settings.aoColumns;
			if ( colIdx !== undefined ) {
				cols[ colIdx ].sType = null;
			}
			else {
				for ( i=0, ien=cols.length ; i<ien ; i++ ) {
					cols[i].sType = null;
				}
		
				// Update DataTables special `DT_*` attributes for the row
				_fnRowAttributes( settings, row );
			}
		}
		
		
		/**
		 * Build a data source object from an HTML row, reading the contents of the
		 * cells that are in the row.
		 *
		 * @param {object} settings DataTables settings object
		 * @param {node|object} TR element from which to read data or existing row
		 *   object from which to re-read the data from the cells
		 * @param {int} [colIdx] Optional column index
		 * @param {array|object} [d] Data source object. If `colIdx` is given then this
		 *   parameter should also be given and will be used to write the data into.
		 *   Only the column in question will be written
		 * @returns {object} Object with two parameters: `data` the data read, in
		 *   document order, and `cells` and array of nodes (they can be useful to the
		 *   caller, so rather than needing a second traversal to get them, just return
		 *   them from here).
		 * @memberof DataTable#oApi
		 */
		function _fnGetRowElements( settings, row, colIdx, d )
		{
			var
				tds = [],
				td = row.firstChild,
				name, col, o, i=0, contents,
				columns = settings.aoColumns,
				objectRead = settings._rowReadObject;
		
			// Allow the data object to be passed in, or construct
			d = d !== undefined ?
				d :
				objectRead ?
					{} :
					[];
		
			var attr = function ( str, td  ) {
				if ( typeof str === 'string' ) {
					var idx = str.indexOf('@');
		
					if ( idx !== -1 ) {
						var attr = str.substring( idx+1 );
						var setter = _fnSetObjectDataFn( str );
						setter( d, td.getAttribute( attr ) );
					}
				}
			};
		
			// Read data from a cell and store into the data object
			var cellProcess = function ( cell ) {
				if ( colIdx === undefined || colIdx === i ) {
					col = columns[i];
					contents = $.trim(cell.innerHTML);
		
					if ( col && col._bAttrSrc ) {
						var setter = _fnSetObjectDataFn( col.mData._ );
						setter( d, contents );
		
						attr( col.mData.sort, cell );
						attr( col.mData.type, cell );
						attr( col.mData.filter, cell );
					}
					else {
						// Depending on the `data` option for the columns the data can
						// be read to either an object or an array.
						if ( objectRead ) {
							if ( ! col._setter ) {
								// Cache the setter function
								col._setter = _fnSetObjectDataFn( col.mData );
							}
							col._setter( d, contents );
						}
						else {
							d[i] = contents;
						}
					}
				}
		
				i++;
			};
		
			if ( td ) {
				// `tr` element was passed in
				while ( td ) {
					name = td.nodeName.toUpperCase();
		
					if ( name == "TD" || name == "TH" ) {
						cellProcess( td );
						tds.push( td );
					}
		
					td = td.nextSibling;
				}
			}
			else {
				// Existing row object passed in
				tds = row.anCells;
		
				for ( var j=0, jen=tds.length ; j<jen ; j++ ) {
					cellProcess( tds[j] );
				}
			}
		
			// Read the ID from the DOM if present
			var rowNode = row.firstChild ? row : row.nTr;
		
			if ( rowNode ) {
				var id = rowNode.getAttribute( 'id' );
		
				if ( id ) {
					_fnSetObjectDataFn( settings.rowId )( d, id );
				}
			}
		
			return {
				data: d,
				cells: tds
			};
		}
		/**
		 * Create a new TR element (and it's TD children) for a row
		 *  @param {object} oSettings dataTables settings object
		 *  @param {int} iRow Row to consider
		 *  @param {node} [nTrIn] TR element to add to the table - optional. If not given,
		 *    DataTables will create a row automatically
		 *  @param {array} [anTds] Array of TD|TH elements for the row - must be given
		 *    if nTr is.
		 *  @memberof DataTable#oApi
		 */
		function _fnCreateTr ( oSettings, iRow, nTrIn, anTds )
		{
			var
				row = oSettings.aoData[iRow],
				rowData = row._aData,
				cells = [],
				nTr, nTd, oCol,
				i, iLen;
		
			if ( row.nTr === null )
			{
				nTr = nTrIn || document.createElement('tr');
		
				row.nTr = nTr;
				row.anCells = cells;
		
				/* Use a private property on the node to allow reserve mapping from the node
				 * to the aoData array for fast look up
				 */
				nTr._DT_RowIndex = iRow;
		
				/* Special parameters can be given by the data source to be used on the row */
				_fnRowAttributes( oSettings, row );
		
				/* Process each column */
				for ( i=0, iLen=oSettings.aoColumns.length ; i<iLen ; i++ )
				{
					oCol = oSettings.aoColumns[i];
		
					nTd = nTrIn ? anTds[i] : document.createElement( oCol.sCellType );
					nTd._DT_CellIndex = {
						row: iRow,
						column: i
					};
					
					cells.push( nTd );
		
					// Need to create the HTML if new, or if a rendering function is defined
					if ( (!nTrIn || oCol.mRender || oCol.mData !== i) &&
						 (!$.isPlainObject(oCol.mData) || oCol.mData._ !== i+'.display')
					) {
						nTd.innerHTML = _fnGetCellData( oSettings, iRow, i, 'display' );
					}
		
					/* Add user defined class */
					if ( oCol.sClass )
					{
						nTd.className += ' '+oCol.sClass;
					}
		
					// Visibility - add or remove as required
					if ( oCol.bVisible && ! nTrIn )
					{
						nTr.appendChild( nTd );
					}
					else if ( ! oCol.bVisible && nTrIn )
					{
						nTd.parentNode.removeChild( nTd );
					}
		
					if ( oCol.fnCreatedCell )
					{
						oCol.fnCreatedCell.call( oSettings.oInstance,
							nTd, _fnGetCellData( oSettings, iRow, i ), rowData, iRow, i
						);
					}
				}
		
				_fnCallbackFire( oSettings, 'aoRowCreatedCallback', null, [nTr, rowData, iRow] );
			}
		
			// Remove once webkit bug 131819 and Chromium bug 365619 have been resolved
			// and deployed
			row.nTr.setAttribute( 'role', 'row' );
		}
		
		
		/**
		 * Add attributes to a row based on the special `DT_*` parameters in a data
		 * source object.
		 *  @param {object} settings DataTables settings object
		 *  @param {object} DataTables row object for the row to be modified
		 *  @memberof DataTable#oApi
		 */
		function _fnRowAttributes( settings, row )
		{
			var tr = row.nTr;
			var data = row._aData;
		
			if ( tr ) {
				var id = settings.rowIdFn( data );
		
				if ( id ) {
					tr.id = id;
				}
		
				if ( data.DT_RowClass ) {
					// Remove any classes added by DT_RowClass before
					var a = data.DT_RowClass.split(' ');
					row.__rowc = row.__rowc ?
						_unique( row.__rowc.concat( a ) ) :
						a;
		
					$(tr)
						.removeClass( row.__rowc.join(' ') )
						.addClass( data.DT_RowClass );
				}
		
				if ( data.DT_RowAttr ) {
					$(tr).attr( data.DT_RowAttr );
				}
		
				if ( data.DT_RowData ) {
					$(tr).data( data.DT_RowData );
				}
			}
		}
		
		
		/**
		 * Create the HTML header for the table
		 *  @param {object} oSettings dataTables settings object
		 *  @memberof DataTable#oApi
		 */
		function _fnBuildHead( oSettings )
		{
			var i, ien, cell, row, column;
			var thead = oSettings.nTHead;
			var tfoot = oSettings.nTFoot;
			var createHeader = $('th, td', thead).length === 0;
			var classes = oSettings.oClasses;
			var columns = oSettings.aoColumns;
		
			if ( createHeader ) {
				row = $('<tr/>').appendTo( thead );
			}
		
			for ( i=0, ien=columns.length ; i<ien ; i++ ) {
				column = columns[i];
				cell = $( column.nTh ).addClass( column.sClass );
		
				if ( createHeader ) {
					cell.appendTo( row );
				}
		
				// 1.11 move into sorting
				if ( oSettings.oFeatures.bSort ) {
					cell.addClass( column.sSortingClass );
		
					if ( column.bSortable !== false ) {
						cell
							.attr( 'tabindex', oSettings.iTabIndex )
							.attr( 'aria-controls', oSettings.sTableId );
		
						_fnSortAttachListener( oSettings, column.nTh, i );
					}
				}
		
				if ( column.sTitle != cell[0].innerHTML ) {
					cell.html( column.sTitle );
				}
		
				_fnRenderer( oSettings, 'header' )(
					oSettings, cell, column, classes
				);
			}
		
			if ( createHeader ) {
				_fnDetectHeader( oSettings.aoHeader, thead );
			}
			
			/* ARIA role for the rows */
		 	$(thead).find('>tr').attr('role', 'row');
		
			/* Deal with the footer - add classes if required */
			$(thead).find('>tr>th, >tr>td').addClass( classes.sHeaderTH );
			$(tfoot).find('>tr>th, >tr>td').addClass( classes.sFooterTH );
		
			// Cache the footer cells. Note that we only take the cells from the first
			// row in the footer. If there is more than one row the user wants to
			// interact with, they need to use the table().foot() method. Note also this
			// allows cells to be used for multiple columns using colspan
			if ( tfoot !== null ) {
				var cells = oSettings.aoFooter[0];
		
				for ( i=0, ien=cells.length ; i<ien ; i++ ) {
					column = columns[i];
					column.nTf = cells[i].cell;
		
					if ( column.sClass ) {
						$(column.nTf).addClass( column.sClass );
					}
				}
			}
		}
		
		
		/**
		 * Draw the header (or footer) element based on the column visibility states. The
		 * methodology here is to use the layout array from _fnDetectHeader, modified for
		 * the instantaneous column visibility, to construct the new layout. The grid is
		 * traversed over cell at a time in a rows x columns grid fashion, although each
		 * cell insert can cover multiple elements in the grid - which is tracks using the
		 * aApplied array. Cell inserts in the grid will only occur where there isn't
		 * already a cell in that position.
		 *  @param {object} oSettings dataTables settings object
		 *  @param array {objects} aoSource Layout array from _fnDetectHeader
		 *  @param {boolean} [bIncludeHidden=false] If true then include the hidden columns in the calc,
		 *  @memberof DataTable#oApi
		 */
		function _fnDrawHead( oSettings, aoSource, bIncludeHidden )
		{
			var i, iLen, j, jLen, k, kLen, n, nLocalTr;
			var aoLocal = [];
			var aApplied = [];
			var iColumns = oSettings.aoColumns.length;
			var iRowspan, iColspan;
		
			if ( ! aoSource )
			{
				return;
			}
		
			if (  bIncludeHidden === undefined )
			{
				bIncludeHidden = false;
			}
		
			/* Make a copy of the master layout array, but without the visible columns in it */
			for ( i=0, iLen=aoSource.length ; i<iLen ; i++ )
			{
				aoLocal[i] = aoSource[i].slice();
				aoLocal[i].nTr = aoSource[i].nTr;
		
				/* Remove any columns which are currently hidden */
				for ( j=iColumns-1 ; j>=0 ; j-- )
				{
					if ( !oSettings.aoColumns[j].bVisible && !bIncludeHidden )
					{
						aoLocal[i].splice( j, 1 );
					}
				}
		
				/* Prep the applied array - it needs an element for each row */
				aApplied.push( [] );
			}
		
			for ( i=0, iLen=aoLocal.length ; i<iLen ; i++ )
			{
				nLocalTr = aoLocal[i].nTr;
		
				/* All cells are going to be replaced, so empty out the row */
				if ( nLocalTr )
				{
					while( (n = nLocalTr.firstChild) )
					{
						nLocalTr.removeChild( n );
					}
				}
		
				for ( j=0, jLen=aoLocal[i].length ; j<jLen ; j++ )
				{
					iRowspan = 1;
					iColspan = 1;
		
					/* Check to see if there is already a cell (row/colspan) covering our target
					 * insert point. If there is, then there is nothing to do.
					 */
					if ( aApplied[i][j] === undefined )
					{
						nLocalTr.appendChild( aoLocal[i][j].cell );
						aApplied[i][j] = 1;
		
						/* Expand the cell to cover as many rows as needed */
						while ( aoLocal[i+iRowspan] !== undefined &&
						        aoLocal[i][j].cell == aoLocal[i+iRowspan][j].cell )
						{
							aApplied[i+iRowspan][j] = 1;
							iRowspan++;
						}
		
						/* Expand the cell to cover as many columns as needed */
						while ( aoLocal[i][j+iColspan] !== undefined &&
						        aoLocal[i][j].cell == aoLocal[i][j+iColspan].cell )
						{
							/* Must update the applied array over the rows for the columns */
							for ( k=0 ; k<iRowspan ; k++ )
							{
								aApplied[i+k][j+iColspan] = 1;
							}
							iColspan++;
						}
		
						/* Do the actual expansion in the DOM */
						$(aoLocal[i][j].cell)
							.attr('rowspan', iRowspan)
							.attr('colspan', iColspan);
					}
				}
			}
		}
		
		
		/**
		 * Insert the required TR nodes into the table for display
		 *  @param {object} oSettings dataTables settings object
		 *  @memberof DataTable#oApi
		 */
		function _fnDraw( oSettings )
		{
			/* Provide a pre-callback function which can be used to cancel the draw is false is returned */
			var aPreDraw = _fnCallbackFire( oSettings, 'aoPreDrawCallback', 'preDraw', [oSettings] );
			if ( $.inArray( false, aPreDraw ) !== -1 )
			{
				_fnProcessingDisplay( oSettings, false );
				return;
			}
		
			var i, iLen, n;
			var anRows = [];
			var iRowCount = 0;
			var asStripeClasses = oSettings.asStripeClasses;
			var iStripes = asStripeClasses.length;
			var iOpenRows = oSettings.aoOpenRows.length;
			var oLang = oSettings.oLanguage;
			var iInitDisplayStart = oSettings.iInitDisplayStart;
			var bServerSide = _fnDataSource( oSettings ) == 'ssp';
			var aiDisplay = oSettings.aiDisplay;
		
			oSettings.bDrawing = true;
		
			/* Check and see if we have an initial draw position from state saving */
			if ( iInitDisplayStart !== undefined && iInitDisplayStart !== -1 )
			{
				oSettings._iDisplayStart = bServerSide ?
					iInitDisplayStart :
					iInitDisplayStart >= oSettings.fnRecordsDisplay() ?
						0 :
						iInitDisplayStart;
		
				oSettings.iInitDisplayStart = -1;
			}
		
			var iDisplayStart = oSettings._iDisplayStart;
			var iDisplayEnd = oSettings.fnDisplayEnd();
		
			/* Server-side processing draw intercept */
			if ( oSettings.bDeferLoading )
			{
				oSettings.bDeferLoading = false;
				oSettings.iDraw++;
				_fnProcessingDisplay( oSettings, false );
			}
			else if ( !bServerSide )
			{
				oSettings.iDraw++;
			}
			else if ( !oSettings.bDestroying && !_fnAjaxUpdate( oSettings ) )
			{
				return;
			}
		
			if ( aiDisplay.length !== 0 )
			{
				var iStart = bServerSide ? 0 : iDisplayStart;
				var iEnd = bServerSide ? oSettings.aoData.length : iDisplayEnd;
		
				for ( var j=iStart ; j<iEnd ; j++ )
				{
					var iDataIndex = aiDisplay[j];
					var aoData = oSettings.aoData[ iDataIndex ];
					if ( aoData.nTr === null )
					{
						_fnCreateTr( oSettings, iDataIndex );
					}
		
					var nRow = aoData.nTr;
		
					/* Remove the old striping classes and then add the new one */
					if ( iStripes !== 0 )
					{
						var sStripe = asStripeClasses[ iRowCount % iStripes ];
						if ( aoData._sRowStripe != sStripe )
						{
							$(nRow).removeClass( aoData._sRowStripe ).addClass( sStripe );
							aoData._sRowStripe = sStripe;
						}
					}
		
					// Row callback functions - might want to manipulate the row
					// iRowCount and j are not currently documented. Are they at all
					// useful?
					_fnCallbackFire( oSettings, 'aoRowCallback', null,
						[nRow, aoData._aData, iRowCount, j] );
		
					anRows.push( nRow );
					iRowCount++;
				}
			}
			else
			{
				/* Table is empty - create a row with an empty message in it */
				var sZero = oLang.sZeroRecords;
				if ( oSettings.iDraw == 1 &&  _fnDataSource( oSettings ) == 'ajax' )
				{
					sZero = oLang.sLoadingRecords;
				}
				else if ( oLang.sEmptyTable && oSettings.fnRecordsTotal() === 0 )
				{
					sZero = oLang.sEmptyTable;
				}
		
				anRows[ 0 ] = $( '<tr/>', { 'class': iStripes ? asStripeClasses[0] : '' } )
					.append( $('<td />', {
						'valign':  'top',
						'colSpan': _fnVisbleColumns( oSettings ),
						'class':   oSettings.oClasses.sRowEmpty
					} ).html( sZero ) )[0];
			}
		
			/* Header and footer callbacks */
			_fnCallbackFire( oSettings, 'aoHeaderCallback', 'header', [ $(oSettings.nTHead).children('tr')[0],
				_fnGetDataMaster( oSettings ), iDisplayStart, iDisplayEnd, aiDisplay ] );
		
			_fnCallbackFire( oSettings, 'aoFooterCallback', 'footer', [ $(oSettings.nTFoot).children('tr')[0],
				_fnGetDataMaster( oSettings ), iDisplayStart, iDisplayEnd, aiDisplay ] );
		
			var body = $(oSettings.nTBody);
		
			body.children().detach();
			body.append( $(anRows) );
		
			/* Call all required callback functions for the end of a draw */
			_fnCallbackFire( oSettings, 'aoDrawCallback', 'draw', [oSettings] );
		
			/* Draw is complete, sorting and filtering must be as well */
			oSettings.bSorted = false;
			oSettings.bFiltered = false;
			oSettings.bDrawing = false;
		}
		
		
		/**
		 * Redraw the table - taking account of the various features which are enabled
		 *  @param {object} oSettings dataTables settings object
		 *  @param {boolean} [holdPosition] Keep the current paging position. By default
		 *    the paging is reset to the first page
		 *  @memberof DataTable#oApi
		 */
		function _fnReDraw( settings, holdPosition )
		{
			var
				features = settings.oFeatures,
				sort     = features.bSort,
				filter   = features.bFilter;
		
			if ( sort ) {
				_fnSort( settings );
			}
		
			if ( filter ) {
				_fnFilterComplete( settings, settings.oPreviousSearch );
			}
			else {
				// No filtering, so we want to just use the display master
				settings.aiDisplay = settings.aiDisplayMaster.slice();
			}
		
			if ( holdPosition !== true ) {
				settings._iDisplayStart = 0;
			}
		
			// Let any modules know about the draw hold position state (used by
			// scrolling internally)
			settings._drawHold = holdPosition;
		
			_fnDraw( settings );
		
			settings._drawHold = false;
		}
		
		
		/**
		 * Add the options to the page HTML for the table
		 *  @param {object} oSettings dataTables settings object
		 *  @memberof DataTable#oApi
		 */
		function _fnAddOptionsHtml ( oSettings )
		{
			var classes = oSettings.oClasses;
			var table = $(oSettings.nTable);
			var holding = $('<div/>').insertBefore( table ); // Holding element for speed
			var features = oSettings.oFeatures;
		
			// All DataTables are wrapped in a div
			var insert = $('<div/>', {
				id:      oSettings.sTableId+'_wrapper',
				'class': classes.sWrapper + (oSettings.nTFoot ? '' : ' '+classes.sNoFooter)
			} );
		
			oSettings.nHolding = holding[0];
			oSettings.nTableWrapper = insert[0];
			oSettings.nTableReinsertBefore = oSettings.nTable.nextSibling;
		
			/* Loop over the user set positioning and place the elements as needed */
			var aDom = oSettings.sDom.split('');
			var featureNode, cOption, nNewNode, cNext, sAttr, j;
			for ( var i=0 ; i<aDom.length ; i++ )
			{
				featureNode = null;
				cOption = aDom[i];
		
				if ( cOption == '<' )
				{
					/* New container div */
					nNewNode = $('<div/>')[0];
		
					/* Check to see if we should append an id and/or a class name to the container */
					cNext = aDom[i+1];
					if ( cNext == "'" || cNext == '"' )
					{
						sAttr = "";
						j = 2;
						while ( aDom[i+j] != cNext )
						{
							sAttr += aDom[i+j];
							j++;
						}
		
						/* Replace jQuery UI constants @todo depreciated */
						if ( sAttr == "H" )
						{
							sAttr = classes.sJUIHeader;
						}
						else if ( sAttr == "F" )
						{
							sAttr = classes.sJUIFooter;
						}
		
						/* The attribute can be in the format of "#id.class", "#id" or "class" This logic
						 * breaks the string into parts and applies them as needed
						 */
						if ( sAttr.indexOf('.') != -1 )
						{
							var aSplit = sAttr.split('.');
							nNewNode.id = aSplit[0].substr(1, aSplit[0].length-1);
							nNewNode.className = aSplit[1];
						}
						else if ( sAttr.charAt(0) == "#" )
						{
							nNewNode.id = sAttr.substr(1, sAttr.length-1);
						}
						else
						{
							nNewNode.className = sAttr;
						}
		
						i += j; /* Move along the position array */
					}
		
					insert.append( nNewNode );
					insert = $(nNewNode);
				}
				else if ( cOption == '>' )
				{
					/* End container div */
					insert = insert.parent();
				}
				// @todo Move options into their own plugins?
				else if ( cOption == 'l' && features.bPaginate && features.bLengthChange )
				{
					/* Length */
					featureNode = _fnFeatureHtmlLength( oSettings );
				}
				else if ( cOption == 'f' && features.bFilter )
				{
					/* Filter */
					featureNode = _fnFeatureHtmlFilter( oSettings );
				}
				else if ( cOption == 'r' && features.bProcessing )
				{
					/* pRocessing */
					featureNode = _fnFeatureHtmlProcessing( oSettings );
				}
				else if ( cOption == 't' )
				{
					/* Table */
					featureNode = _fnFeatureHtmlTable( oSettings );
				}
				else if ( cOption ==  'i' && features.bInfo )
				{
					/* Info */
					featureNode = _fnFeatureHtmlInfo( oSettings );
				}
				else if ( cOption == 'p' && features.bPaginate )
				{
					/* Pagination */
					featureNode = _fnFeatureHtmlPaginate( oSettings );
				}
				else if ( DataTable.ext.feature.length !== 0 )
				{
					/* Plug-in features */
					var aoFeatures = DataTable.ext.feature;
					for ( var k=0, kLen=aoFeatures.length ; k<kLen ; k++ )
					{
						if ( cOption == aoFeatures[k].cFeature )
						{
							featureNode = aoFeatures[k].fnInit( oSettings );
							break;
						}
					}
				}
		
				/* Add to the 2D features array */
				if ( featureNode )
				{
					var aanFeatures = oSettings.aanFeatures;
		
					if ( ! aanFeatures[cOption] )
					{
						aanFeatures[cOption] = [];
					}
		
					aanFeatures[cOption].push( featureNode );
					insert.append( featureNode );
				}
			}
		
			/* Built our DOM structure - replace the holding div with what we want */
			holding.replaceWith( insert );
			oSettings.nHolding = null;
		}
		
		
		/**
		 * Use the DOM source to create up an array of header cells. The idea here is to
		 * create a layout grid (array) of rows x columns, which contains a reference
		 * to the cell that that point in the grid (regardless of col/rowspan), such that
		 * any column / row could be removed and the new grid constructed
		 *  @param array {object} aLayout Array to store the calculated layout in
		 *  @param {node} nThead The header/footer element for the table
		 *  @memberof DataTable#oApi
		 */
		function _fnDetectHeader ( aLayout, nThead )
		{
			var nTrs = $(nThead).children('tr');
			var nTr, nCell;
			var i, k, l, iLen, jLen, iColShifted, iColumn, iColspan, iRowspan;
			var bUnique;
			var fnShiftCol = function ( a, i, j ) {
				var k = a[i];
		                while ( k[j] ) {
					j++;
				}
				return j;
			};
		
			aLayout.splice( 0, aLayout.length );
		
			/* We know how many rows there are in the layout - so prep it */
			for ( i=0, iLen=nTrs.length ; i<iLen ; i++ )
			{
				aLayout.push( [] );
			}
		
			/* Calculate a layout array */
			for ( i=0, iLen=nTrs.length ; i<iLen ; i++ )
			{
				nTr = nTrs[i];
				iColumn = 0;
		
				/* For every cell in the row... */
				nCell = nTr.firstChild;
				while ( nCell ) {
					if ( nCell.nodeName.toUpperCase() == "TD" ||
					     nCell.nodeName.toUpperCase() == "TH" )
					{
						/* Get the col and rowspan attributes from the DOM and sanitise them */
						iColspan = nCell.getAttribute('colspan') * 1;
						iRowspan = nCell.getAttribute('rowspan') * 1;
						iColspan = (!iColspan || iColspan===0 || iColspan===1) ? 1 : iColspan;
						iRowspan = (!iRowspan || iRowspan===0 || iRowspan===1) ? 1 : iRowspan;
		
						/* There might be colspan cells already in this row, so shift our target
						 * accordingly
						 */
						iColShifted = fnShiftCol( aLayout, i, iColumn );
		
						/* Cache calculation for unique columns */
						bUnique = iColspan === 1 ? true : false;
		
						/* If there is col / rowspan, copy the information into the layout grid */
						for ( l=0 ; l<iColspan ; l++ )
						{
							for ( k=0 ; k<iRowspan ; k++ )
							{
								aLayout[i+k][iColShifted+l] = {
									"cell": nCell,
									"unique": bUnique
								};
								aLayout[i+k].nTr = nTr;
							}
						}
					}
					nCell = nCell.nextSibling;
				}
			}
		}
		
		
		/**
		 * Get an array of unique th elements, one for each column
		 *  @param {object} oSettings dataTables settings object
		 *  @param {node} nHeader automatically detect the layout from this node - optional
		 *  @param {array} aLayout thead/tfoot layout from _fnDetectHeader - optional
		 *  @returns array {node} aReturn list of unique th's
		 *  @memberof DataTable#oApi
		 */
		function _fnGetUniqueThs ( oSettings, nHeader, aLayout )
		{
			var aReturn = [];
			if ( !aLayout )
			{
				aLayout = oSettings.aoHeader;
				if ( nHeader )
				{
					aLayout = [];
					_fnDetectHeader( aLayout, nHeader );
				}
			}
		
			for ( var i=0, iLen=aLayout.length ; i<iLen ; i++ )
			{
				for ( var j=0, jLen=aLayout[i].length ; j<jLen ; j++ )
				{
					if ( aLayout[i][j].unique &&
						 (!aReturn[j] || !oSettings.bSortCellsTop) )
					{
						aReturn[j] = aLayout[i][j].cell;
					}
				}
			}
		
			return aReturn;
		}
		
		/**
		 * Create an Ajax call based on the table's settings, taking into account that
		 * parameters can have multiple forms, and backwards compatibility.
		 *
		 * @param {object} oSettings dataTables settings object
		 * @param {array} data Data to send to the server, required by
		 *     DataTables - may be augmented by developer callbacks
		 * @param {function} fn Callback function to run when data is obtained
		 */
		function _fnBuildAjax( oSettings, data, fn )
		{
			// Compatibility with 1.9-, allow fnServerData and event to manipulate
			_fnCallbackFire( oSettings, 'aoServerParams', 'serverParams', [data] );
		
			// Convert to object based for 1.10+ if using the old array scheme which can
			// come from server-side processing or serverParams
			if ( data && $.isArray(data) ) {
				var tmp = {};
				var rbracket = /(.*?)\[\]$/;
		
				$.each( data, function (key, val) {
					var match = val.name.match(rbracket);
		
					if ( match ) {
						// Support for arrays
						var name = match[0];
		
						if ( ! tmp[ name ] ) {
							tmp[ name ] = [];
						}
						tmp[ name ].push( val.value );
					}
					else {
						tmp[val.name] = val.value;
					}
				} );
				data = tmp;
			}
		
			var ajaxData;
			var ajax = oSettings.ajax;
			var instance = oSettings.oInstance;
			var callback = function ( json ) {
				_fnCallbackFire( oSettings, null, 'xhr', [oSettings, json, oSettings.jqXHR] );
				fn( json );
			};
		
			if ( $.isPlainObject( ajax ) && ajax.data )
			{
				ajaxData = ajax.data;
		
				var newData = $.isFunction( ajaxData ) ?
					ajaxData( data, oSettings ) :  // fn can manipulate data or return
					ajaxData;                      // an object object or array to merge
		
				// If the function returned something, use that alone
				data = $.isFunction( ajaxData ) && newData ?
					newData :
					$.extend( true, data, newData );
		
				// Remove the data property as we've resolved it already and don't want
				// jQuery to do it again (it is restored at the end of the function)
				delete ajax.data;
			}
		
			var baseAjax = {
				"data": data,
				"success": function (json) {
					var error = json.error || json.sError;
					if ( error ) {
						_fnLog( oSettings, 0, error );
					}
		
					oSettings.json = json;
					callback( json );
				},
				"dataType": "json",
				"cache": false,
				"type": oSettings.sServerMethod,
				"error": function (xhr, error, thrown) {
					var ret = _fnCallbackFire( oSettings, null, 'xhr', [oSettings, null, oSettings.jqXHR] );
		
					if ( $.inArray( true, ret ) === -1 ) {
						if ( error == "parsererror" ) {
							_fnLog( oSettings, 0, 'Invalid JSON response', 1 );
						}
						else if ( xhr.readyState === 4 ) {
							_fnLog( oSettings, 0, 'Ajax error', 7 );
						}
					}
		
					_fnProcessingDisplay( oSettings, false );
				}
			};
		
			// Store the data submitted for the API
			oSettings.oAjaxData = data;
		
			// Allow plug-ins and external processes to modify the data
			_fnCallbackFire( oSettings, null, 'preXhr', [oSettings, data] );
		
			if ( oSettings.fnServerData )
			{
				// DataTables 1.9- compatibility
				oSettings.fnServerData.call( instance,
					oSettings.sAjaxSource,
					$.map( data, function (val, key) { // Need to convert back to 1.9 trad format
						return { name: key, value: val };
					} ),
					callback,
					oSettings
				);
			}
			else if ( oSettings.sAjaxSource || typeof ajax === 'string' )
			{
				// DataTables 1.9- compatibility
				oSettings.jqXHR = $.ajax( $.extend( baseAjax, {
					url: ajax || oSettings.sAjaxSource
				} ) );
			}
			else if ( $.isFunction( ajax ) )
			{
				// Is a function - let the caller define what needs to be done
				oSettings.jqXHR = ajax.call( instance, data, callback, oSettings );
			}
			else
			{
				// Object to extend the base settings
				oSettings.jqXHR = $.ajax( $.extend( baseAjax, ajax ) );
		
				// Restore for next time around
				ajax.data = ajaxData;
			}
		}
		
		
		/**
		 * Update the table using an Ajax call
		 *  @param {object} settings dataTables settings object
		 *  @returns {boolean} Block the table drawing or not
		 *  @memberof DataTable#oApi
		 */
		function _fnAjaxUpdate( settings )
		{
			if ( settings.bAjaxDataGet ) {
				settings.iDraw++;
				_fnProcessingDisplay( settings, true );
		
				_fnBuildAjax(
					settings,
					_fnAjaxParameters( settings ),
					function(json) {
						_fnAjaxUpdateDraw( settings, json );
					}
				);
		
				return false;
			}
			return true;
		}
		
		
		/**
		 * Build up the parameters in an object needed for a server-side processing
		 * request. Note that this is basically done twice, is different ways - a modern
		 * method which is used by default in DataTables 1.10 which uses objects and
		 * arrays, or the 1.9- method with is name / value pairs. 1.9 method is used if
		 * the sAjaxSource option is used in the initialisation, or the legacyAjax
		 * option is set.
		 *  @param {object} oSettings dataTables settings object
		 *  @returns {bool} block the table drawing or not
		 *  @memberof DataTable#oApi
		 */
		function _fnAjaxParameters( settings )
		{
			var
				columns = settings.aoColumns,
				columnCount = columns.length,
				features = settings.oFeatures,
				preSearch = settings.oPreviousSearch,
				preColSearch = settings.aoPreSearchCols,
				i, data = [], dataProp, column, columnSearch,
				sort = _fnSortFlatten( settings ),
				displayStart = settings._iDisplayStart,
				displayLength = features.bPaginate !== false ?
					settings._iDisplayLength :
					-1;
		
			var param = function ( name, value ) {
				data.push( { 'name': name, 'value': value } );
			};
		
			// DataTables 1.9- compatible method
			param( 'sEcho',          settings.iDraw );
			param( 'iColumns',       columnCount );
			param( 'sColumns',       _pluck( columns, 'sName' ).join(',') );
			param( 'iDisplayStart',  displayStart );
			param( 'iDisplayLength', displayLength );
		
			// DataTables 1.10+ method
			var d = {
				draw:    settings.iDraw,
				columns: [],
				order:   [],
				start:   displayStart,
				length:  displayLength,
				search:  {
					value: preSearch.sSearch,
					regex: preSearch.bRegex
				}
			};
		
			for ( i=0 ; i<columnCount ; i++ ) {
				column = columns[i];
				columnSearch = preColSearch[i];
				dataProp = typeof column.mData=="function" ? 'function' : column.mData ;
		
				d.columns.push( {
					data:       dataProp,
					name:       column.sName,
					searchable: column.bSearchable,
					orderable:  column.bSortable,
					search:     {
						value: columnSearch.sSearch,
						regex: columnSearch.bRegex
					}
				} );
		
				param( "mDataProp_"+i, dataProp );
		
				if ( features.bFilter ) {
					param( 'sSearch_'+i,     columnSearch.sSearch );
					param( 'bRegex_'+i,      columnSearch.bRegex );
					param( 'bSearchable_'+i, column.bSearchable );
				}
		
				if ( features.bSort ) {
					param( 'bSortable_'+i, column.bSortable );
				}
			}
		
			if ( features.bFilter ) {
				param( 'sSearch', preSearch.sSearch );
				param( 'bRegex', preSearch.bRegex );
			}
		
			if ( features.bSort ) {
				$.each( sort, function ( i, val ) {
					d.order.push( { column: val.col, dir: val.dir } );
		
					param( 'iSortCol_'+i, val.col );
					param( 'sSortDir_'+i, val.dir );
				} );
		
				param( 'iSortingCols', sort.length );
			}
		
			// If the legacy.ajax parameter is null, then we automatically decide which
			// form to use, based on sAjaxSource
			var legacy = DataTable.ext.legacy.ajax;
			if ( legacy === null ) {
				return settings.sAjaxSource ? data : d;
			}
		
			// Otherwise, if legacy has been specified then we use that to decide on the
			// form
			return legacy ? data : d;
		}
		
		
		/**
		 * Data the data from the server (nuking the old) and redraw the table
		 *  @param {object} oSettings dataTables settings object
		 *  @param {object} json json data return from the server.
		 *  @param {string} json.sEcho Tracking flag for DataTables to match requests
		 *  @param {int} json.iTotalRecords Number of records in the data set, not accounting for filtering
		 *  @param {int} json.iTotalDisplayRecords Number of records in the data set, accounting for filtering
		 *  @param {array} json.aaData The data to display on this page
		 *  @param {string} [json.sColumns] Column ordering (sName, comma separated)
		 *  @memberof DataTable#oApi
		 */
		function _fnAjaxUpdateDraw ( settings, json )
		{
			// v1.10 uses camelCase variables, while 1.9 uses Hungarian notation.
			// Support both
			var compat = function ( old, modern ) {
				return json[old] !== undefined ? json[old] : json[modern];
			};
		
			var data = _fnAjaxDataSrc( settings, json );
			var draw            = compat( 'sEcho',                'draw' );
			var recordsTotal    = compat( 'iTotalRecords',        'recordsTotal' );
			var recordsFiltered = compat( 'iTotalDisplayRecords', 'recordsFiltered' );
		
			if ( draw ) {
				// Protect against out of sequence returns
				if ( draw*1 < settings.iDraw ) {
					return;
				}
				settings.iDraw = draw * 1;
			}
		
			_fnClearTable( settings );
			settings._iRecordsTotal   = parseInt(recordsTotal, 10);
			settings._iRecordsDisplay = parseInt(recordsFiltered, 10);
		
			for ( var i=0, ien=data.length ; i<ien ; i++ ) {
				_fnAddData( settings, data[i] );
			}
			settings.aiDisplay = settings.aiDisplayMaster.slice();
		
			settings.bAjaxDataGet = false;
			_fnDraw( settings );
		
			if ( ! settings._bInitComplete ) {
				_fnInitComplete( settings, json );
			}
		
			settings.bAjaxDataGet = true;
			_fnProcessingDisplay( settings, false );
		}
		
		
		/**
		 * Get the data from the JSON data source to use for drawing a table. Using
		 * `_fnGetObjectDataFn` allows the data to be sourced from a property of the
		 * source object, or from a processing function.
		 *  @param {object} oSettings dataTables settings object
		 *  @param  {object} json Data source object / array from the server
		 *  @return {array} Array of data to use
		 */
		function _fnAjaxDataSrc ( oSettings, json )
		{
			var dataSrc = $.isPlainObject( oSettings.ajax ) && oSettings.ajax.dataSrc !== undefined ?
				oSettings.ajax.dataSrc :
				oSettings.sAjaxDataProp; // Compatibility with 1.9-.
		
			// Compatibility with 1.9-. In order to read from aaData, check if the
			// default has been changed, if not, check for aaData
			if ( dataSrc === 'data' ) {
				return json.aaData || json[dataSrc];
			}
		
			return dataSrc !== "" ?
				_fnGetObjectDataFn( dataSrc )( json ) :
				json;
		}
		
		/**
		 * Generate the node required for filtering text
		 *  @returns {node} Filter control element
		 *  @param {object} oSettings dataTables settings object
		 *  @memberof DataTable#oApi
		 */
		function _fnFeatureHtmlFilter ( settings )
		{
			var classes = settings.oClasses;
			var tableId = settings.sTableId;
			var language = settings.oLanguage;
			var previousSearch = settings.oPreviousSearch;
			var features = settings.aanFeatures;
			var input = '<input type="search" class="'+classes.sFilterInput+'"/>';
		
			var str = language.sSearch;
			str = str.match(/_INPUT_/) ?
				str.replace('_INPUT_', input) :
				str+input;
		
			var filter = $('<div/>', {
					'id': ! features.f ? tableId+'_filter' : null,
					'class': classes.sFilter
				} )
				.append( $('<label/>' ).append( str ) );
		
			var searchFn = function() {
				/* Update all other filter input elements for the new display */
				var n = features.f;
				var val = !this.value ? "" : this.value; // mental IE8 fix :-(
		
				/* Now do the filter */
				if ( val != previousSearch.sSearch ) {
					_fnFilterComplete( settings, {
						"sSearch": val,
						"bRegex": previousSearch.bRegex,
						"bSmart": previousSearch.bSmart ,
						"bCaseInsensitive": previousSearch.bCaseInsensitive
					} );
		
					// Need to redraw, without resorting
					settings._iDisplayStart = 0;
					_fnDraw( settings );
				}
			};
		
			var searchDelay = settings.searchDelay !== null ?
				settings.searchDelay :
				_fnDataSource( settings ) === 'ssp' ?
					400 :
					0;
		
			var jqFilter = $('input', filter)
				.val( previousSearch.sSearch )
				.attr( 'placeholder', language.sSearchPlaceholder )
				.bind(
					'keyup.DT search.DT input.DT paste.DT cut.DT',
					searchDelay ?
						_fnThrottle( searchFn, searchDelay ) :
						searchFn
				)
				.bind( 'keypress.DT', function(e) {
					/* Prevent form submission */
					if ( e.keyCode == 13 ) {
						return false;
					}
				} )
				.attr('aria-controls', tableId);
		
			// Update the input elements whenever the table is filtered
			$(settings.nTable).on( 'search.dt.DT', function ( ev, s ) {
				if ( settings === s ) {
					// IE9 throws an 'unknown error' if document.activeElement is used
					// inside an iframe or frame...
					try {
						if ( jqFilter[0] !== document.activeElement ) {
							jqFilter.val( previousSearch.sSearch );
						}
					}
					catch ( e ) {}
				}
			} );
		
			return filter[0];
		}
		
		
		/**
		 * Filter the table using both the global filter and column based filtering
		 *  @param {object} oSettings dataTables settings object
		 *  @param {object} oSearch search information
		 *  @param {int} [iForce] force a research of the master array (1) or not (undefined or 0)
		 *  @memberof DataTable#oApi
		 */
		function _fnFilterComplete ( oSettings, oInput, iForce )
		{
			var oPrevSearch = oSettings.oPreviousSearch;
			var aoPrevSearch = oSettings.aoPreSearchCols;
			var fnSaveFilter = function ( oFilter ) {
				/* Save the filtering values */
				oPrevSearch.sSearch = oFilter.sSearch;
				oPrevSearch.bRegex = oFilter.bRegex;
				oPrevSearch.bSmart = oFilter.bSmart;
				oPrevSearch.bCaseInsensitive = oFilter.bCaseInsensitive;
			};
			var fnRegex = function ( o ) {
				// Backwards compatibility with the bEscapeRegex option
				return o.bEscapeRegex !== undefined ? !o.bEscapeRegex : o.bRegex;
			};
		
			// Resolve any column types that are unknown due to addition or invalidation
			// @todo As per sort - can this be moved into an event handler?
			_fnColumnTypes( oSettings );
		
			/* In server-side processing all filtering is done by the server, so no point hanging around here */
			if ( _fnDataSource( oSettings ) != 'ssp' )
			{
				/* Global filter */
				_fnFilter( oSettings, oInput.sSearch, iForce, fnRegex(oInput), oInput.bSmart, oInput.bCaseInsensitive );
				fnSaveFilter( oInput );
		
				/* Now do the individual column filter */
				for ( var i=0 ; i<aoPrevSearch.length ; i++ )
				{
					_fnFilterColumn( oSettings, aoPrevSearch[i].sSearch, i, fnRegex(aoPrevSearch[i]),
						aoPrevSearch[i].bSmart, aoPrevSearch[i].bCaseInsensitive );
				}
		
				/* Custom filtering */
				_fnFilterCustom( oSettings );
			}
			else
			{
				fnSaveFilter( oInput );
			}
		
			/* Tell the draw function we have been filtering */
			oSettings.bFiltered = true;
			_fnCallbackFire( oSettings, null, 'search', [oSettings] );
		}
		
		
		/**
		 * Apply custom filtering functions
		 *  @param {object} oSettings dataTables settings object
		 *  @memberof DataTable#oApi
		 */
		function _fnFilterCustom( settings )
		{
			var filters = DataTable.ext.search;
			var displayRows = settings.aiDisplay;
			var row, rowIdx;
		
			for ( var i=0, ien=filters.length ; i<ien ; i++ ) {
				var rows = [];
		
				// Loop over each row and see if it should be included
				for ( var j=0, jen=displayRows.length ; j<jen ; j++ ) {
					rowIdx = displayRows[ j ];
					row = settings.aoData[ rowIdx ];
		
					if ( filters[i]( settings, row._aFilterData, rowIdx, row._aData, j ) ) {
						rows.push( rowIdx );
					}
				}
		
				// So the array reference doesn't break set the results into the
				// existing array
				displayRows.length = 0;
				$.merge( displayRows, rows );
			}
		}
		
		
		/**
		 * Filter the table on a per-column basis
		 *  @param {object} oSettings dataTables settings object
		 *  @param {string} sInput string to filter on
		 *  @param {int} iColumn column to filter
		 *  @param {bool} bRegex treat search string as a regular expression or not
		 *  @param {bool} bSmart use smart filtering or not
		 *  @param {bool} bCaseInsensitive Do case insenstive matching or not
		 *  @memberof DataTable#oApi
		 */
		function _fnFilterColumn ( settings, searchStr, colIdx, regex, smart, caseInsensitive )
		{
			if ( searchStr === '' ) {
				return;
			}
		
			var data;
			var display = settings.aiDisplay;
			var rpSearch = _fnFilterCreateSearch( searchStr, regex, smart, caseInsensitive );
		
			for ( var i=display.length-1 ; i>=0 ; i-- ) {
				data = settings.aoData[ display[i] ]._aFilterData[ colIdx ];
		
				if ( ! rpSearch.test( data ) ) {
					display.splice( i, 1 );
				}
			}
		}
		
		
		/**
		 * Filter the data table based on user input and draw the table
		 *  @param {object} settings dataTables settings object
		 *  @param {string} input string to filter on
		 *  @param {int} force optional - force a research of the master array (1) or not (undefined or 0)
		 *  @param {bool} regex treat as a regular expression or not
		 *  @param {bool} smart perform smart filtering or not
		 *  @param {bool} caseInsensitive Do case insenstive matching or not
		 *  @memberof DataTable#oApi
		 */
		function _fnFilter( settings, input, force, regex, smart, caseInsensitive )
		{
			var rpSearch = _fnFilterCreateSearch( input, regex, smart, caseInsensitive );
			var prevSearch = settings.oPreviousSearch.sSearch;
			var displayMaster = settings.aiDisplayMaster;
			var display, invalidated, i;
		
			// Need to take account of custom filtering functions - always filter
			if ( DataTable.ext.search.length !== 0 ) {
				force = true;
			}
		
			// Check if any of the rows were invalidated
			invalidated = _fnFilterData( settings );
		
			// If the input is blank - we just want the full data set
			if ( input.length <= 0 ) {
				settings.aiDisplay = displayMaster.slice();
			}
			else {
				// New search - start from the master array
				if ( invalidated ||
					 force ||
					 prevSearch.length > input.length ||
					 input.indexOf(prevSearch) !== 0 ||
					 settings.bSorted // On resort, the display master needs to be
					                  // re-filtered since indexes will have changed
				) {
					settings.aiDisplay = displayMaster.slice();
				}
		
				// Search the display array
				display = settings.aiDisplay;
		
				for ( i=display.length-1 ; i>=0 ; i-- ) {
					if ( ! rpSearch.test( settings.aoData[ display[i] ]._sFilterRow ) ) {
						display.splice( i, 1 );
					}
				}
			}
		}
		
		
		/**
		 * Build a regular expression object suitable for searching a table
		 *  @param {string} sSearch string to search for
		 *  @param {bool} bRegex treat as a regular expression or not
		 *  @param {bool} bSmart perform smart filtering or not
		 *  @param {bool} bCaseInsensitive Do case insensitive matching or not
		 *  @returns {RegExp} constructed object
		 *  @memberof DataTable#oApi
		 */
		function _fnFilterCreateSearch( search, regex, smart, caseInsensitive )
		{
			search = regex ?
				search :
				_fnEscapeRegex( search );
			
			if ( smart ) {
				/* For smart filtering we want to allow the search to work regardless of
				 * word order. We also want double quoted text to be preserved, so word
				 * order is important - a la google. So this is what we want to
				 * generate:
				 * 
				 * ^(?=.*?\bone\b)(?=.*?\btwo three\b)(?=.*?\bfour\b).*$
				 */
				var a = $.map( search.match( /"[^"]+"|[^ ]+/g ) || [''], function ( word ) {
					if ( word.charAt(0) === '"' ) {
						var m = word.match( /^"(.*)"$/ );
						word = m ? m[1] : word;
					}
		
					return word.replace('"', '');
				} );
		
				search = '^(?=.*?'+a.join( ')(?=.*?' )+').*$';
			}
		
			return new RegExp( search, caseInsensitive ? 'i' : '' );
		}
		
		
		/**
		 * Escape a string such that it can be used in a regular expression
		 *  @param {string} sVal string to escape
		 *  @returns {string} escaped string
		 *  @memberof DataTable#oApi
		 */
		var _fnEscapeRegex = DataTable.util.escapeRegex;
		
		var __filter_div = $('<div>')[0];
		var __filter_div_textContent = __filter_div.textContent !== undefined;
		
		// Update the filtering data for each row if needed (by invalidation or first run)
		function _fnFilterData ( settings )
		{
			var columns = settings.aoColumns;
			var column;
			var i, j, ien, jen, filterData, cellData, row;
			var fomatters = DataTable.ext.type.search;
			var wasInvalidated = false;
		
			for ( i=0, ien=settings.aoData.length ; i<ien ; i++ ) {
				row = settings.aoData[i];
		
				if ( ! row._aFilterData ) {
					filterData = [];
		
					for ( j=0, jen=columns.length ; j<jen ; j++ ) {
						column = columns[j];
		
						if ( column.bSearchable ) {
							cellData = _fnGetCellData( settings, i, j, 'filter' );
		
							if ( fomatters[ column.sType ] ) {
								cellData = fomatters[ column.sType ]( cellData );
							}
		
							// Search in DataTables 1.10 is string based. In 1.11 this
							// should be altered to also allow strict type checking.
							if ( cellData === null ) {
								cellData = '';
							}
		
							if ( typeof cellData !== 'string' && cellData.toString ) {
								cellData = cellData.toString();
							}
						}
						else {
							cellData = '';
						}
		
						// If it looks like there is an HTML entity in the string,
						// attempt to decode it so sorting works as expected. Note that
						// we could use a single line of jQuery to do this, but the DOM
						// method used here is much faster http://jsperf.com/html-decode
						if ( cellData.indexOf && cellData.indexOf('&') !== -1 ) {
							__filter_div.innerHTML = cellData;
							cellData = __filter_div_textContent ?
								__filter_div.textContent :
								__filter_div.innerText;
						}
		
						if ( cellData.replace ) {
							cellData = cellData.replace(/[\r\n]/g, '');
						}
		
						filterData.push( cellData );
					}
		
					row._aFilterData = filterData;
					row._sFilterRow = filterData.join('  ');
					wasInvalidated = true;
				}
			}
		
			return wasInvalidated;
		}
		
		
		/**
		 * Convert from the internal Hungarian notation to camelCase for external
		 * interaction
		 *  @param {object} obj Object to convert
		 *  @returns {object} Inverted object
		 *  @memberof DataTable#oApi
		 */
		function _fnSearchToCamel ( obj )
		{
			return {
				search:          obj.sSearch,
				smart:           obj.bSmart,
				regex:           obj.bRegex,
				caseInsensitive: obj.bCaseInsensitive
			};
		}
		
		
		
		/**
		 * Convert from camelCase notation to the internal Hungarian. We could use the
		 * Hungarian convert function here, but this is cleaner
		 *  @param {object} obj Object to convert
		 *  @returns {object} Inverted object
		 *  @memberof DataTable#oApi
		 */
		function _fnSearchToHung ( obj )
		{
			return {
				sSearch:          obj.search,
				bSmart:           obj.smart,
				bRegex:           obj.regex,
				bCaseInsensitive: obj.caseInsensitive
			};
		}
		
		/**
		 * Generate the node required for the info display
		 *  @param {object} oSettings dataTables settings object
		 *  @returns {node} Information element
		 *  @memberof DataTable#oApi
		 */
		function _fnFeatureHtmlInfo ( settings )
		{
			var
				tid = settings.sTableId,
				nodes = settings.aanFeatures.i,
				n = $('<div/>', {
					'class': settings.oClasses.sInfo,
					'id': ! nodes ? tid+'_info' : null
				} );
		
			if ( ! nodes ) {
				// Update display on each draw
				settings.aoDrawCallback.push( {
					"fn": _fnUpdateInfo,
					"sName": "information"
				} );
		
				n
					.attr( 'role', 'status' )
					.attr( 'aria-live', 'polite' );
		
				// Table is described by our info div
				$(settings.nTable).attr( 'aria-describedby', tid+'_info' );
			}
		
			return n[0];
		}
		
		
		/**
		 * Update the information elements in the display
		 *  @param {object} settings dataTables settings object
		 *  @memberof DataTable#oApi
		 */
		function _fnUpdateInfo ( settings )
		{
			/* Show information about the table */
			var nodes = settings.aanFeatures.i;
			if ( nodes.length === 0 ) {
				return;
			}
		
			var
				lang  = settings.oLanguage,
				start = settings._iDisplayStart+1,
				end   = settings.fnDisplayEnd(),
				max   = settings.fnRecordsTotal(),
				total = settings.fnRecordsDisplay(),
				out   = total ?
					lang.sInfo :
					lang.sInfoEmpty;
		
			if ( total !== max ) {
				/* Record set after filtering */
				out += ' ' + lang.sInfoFiltered;
			}
		
			// Convert the macros
			out += lang.sInfoPostFix;
			out = _fnInfoMacros( settings, out );
		
			var callback = lang.fnInfoCallback;
			if ( callback !== null ) {
				out = callback.call( settings.oInstance,
					settings, start, end, max, total, out
				);
			}
		
			$(nodes).html( out );
		}
		
		
		function _fnInfoMacros ( settings, str )
		{
			// When infinite scrolling, we are always starting at 1. _iDisplayStart is used only
			// internally
			var
				formatter  = settings.fnFormatNumber,
				start      = settings._iDisplayStart+1,
				len        = settings._iDisplayLength,
				vis        = settings.fnRecordsDisplay(),
				all        = len === -1;
		
			return str.
				replace(/_START_/g, formatter.call( settings, start ) ).
				replace(/_END_/g,   formatter.call( settings, settings.fnDisplayEnd() ) ).
				replace(/_MAX_/g,   formatter.call( settings, settings.fnRecordsTotal() ) ).
				replace(/_TOTAL_/g, formatter.call( settings, vis ) ).
				replace(/_PAGE_/g,  formatter.call( settings, all ? 1 : Math.ceil( start / len ) ) ).
				replace(/_PAGES_/g, formatter.call( settings, all ? 1 : Math.ceil( vis / len ) ) );
		}
		
		
		
		/**
		 * Draw the table for the first time, adding all required features
		 *  @param {object} settings dataTables settings object
		 *  @memberof DataTable#oApi
		 */
		function _fnInitialise ( settings )
		{
			var i, iLen, iAjaxStart=settings.iInitDisplayStart;
			var columns = settings.aoColumns, column;
			var features = settings.oFeatures;
			var deferLoading = settings.bDeferLoading; // value modified by the draw
		
			/* Ensure that the table data is fully initialised */
			if ( ! settings.bInitialised ) {
				setTimeout( function(){ _fnInitialise( settings ); }, 200 );
				return;
			}
		
			/* Show the display HTML options */
			_fnAddOptionsHtml( settings );
		
			/* Build and draw the header / footer for the table */
			_fnBuildHead( settings );
			_fnDrawHead( settings, settings.aoHeader );
			_fnDrawHead( settings, settings.aoFooter );
		
			/* Okay to show that something is going on now */
			_fnProcessingDisplay( settings, true );
		
			/* Calculate sizes for columns */
			if ( features.bAutoWidth ) {
				_fnCalculateColumnWidths( settings );
			}
		
			for ( i=0, iLen=columns.length ; i<iLen ; i++ ) {
				column = columns[i];
		
				if ( column.sWidth ) {
					column.nTh.style.width = _fnStringToCss( column.sWidth );
				}
			}
		
			_fnCallbackFire( settings, null, 'preInit', [settings] );
		
			// If there is default sorting required - let's do it. The sort function
			// will do the drawing for us. Otherwise we draw the table regardless of the
			// Ajax source - this allows the table to look initialised for Ajax sourcing
			// data (show 'loading' message possibly)
			_fnReDraw( settings );
		
			// Server-side processing init complete is done by _fnAjaxUpdateDraw
			var dataSrc = _fnDataSource( settings );
			if ( dataSrc != 'ssp' || deferLoading ) {
				// if there is an ajax source load the data
				if ( dataSrc == 'ajax' ) {
					_fnBuildAjax( settings, [], function(json) {
						var aData = _fnAjaxDataSrc( settings, json );
		
						// Got the data - add it to the table
						for ( i=0 ; i<aData.length ; i++ ) {
							_fnAddData( settings, aData[i] );
						}
		
						// Reset the init display for cookie saving. We've already done
						// a filter, and therefore cleared it before. So we need to make
						// it appear 'fresh'
						settings.iInitDisplayStart = iAjaxStart;
		
						_fnReDraw( settings );
		
						_fnProcessingDisplay( settings, false );
						_fnInitComplete( settings, json );
					}, settings );
				}
				else {
					_fnProcessingDisplay( settings, false );
					_fnInitComplete( settings );
				}
			}
		}
		
		
		/**
		 * Draw the table for the first time, adding all required features
		 *  @param {object} oSettings dataTables settings object
		 *  @param {object} [json] JSON from the server that completed the table, if using Ajax source
		 *    with client-side processing (optional)
		 *  @memberof DataTable#oApi
		 */
		function _fnInitComplete ( settings, json )
		{
			settings._bInitComplete = true;
		
			// When data was added after the initialisation (data or Ajax) we need to
			// calculate the column sizing
			if ( json || settings.oInit.aaData ) {
				_fnAdjustColumnSizing( settings );
			}
		
			_fnCallbackFire( settings, null, 'plugin-init', [settings, json] );
			_fnCallbackFire( settings, 'aoInitComplete', 'init', [settings, json] );
		}
		
		
		function _fnLengthChange ( settings, val )
		{
			var len = parseInt( val, 10 );
			settings._iDisplayLength = len;
		
			_fnLengthOverflow( settings );
		
			// Fire length change event
			_fnCallbackFire( settings, null, 'length', [settings, len] );
		}
		
		
		/**
		 * Generate the node required for user display length changing
		 *  @param {object} settings dataTables settings object
		 *  @returns {node} Display length feature node
		 *  @memberof DataTable#oApi
		 */
		function _fnFeatureHtmlLength ( settings )
		{
			var
				classes  = settings.oClasses,
				tableId  = settings.sTableId,
				menu     = settings.aLengthMenu,
				d2       = $.isArray( menu[0] ),
				lengths  = d2 ? menu[0] : menu,
				language = d2 ? menu[1] : menu;
		
			var select = $('<select/>', {
				'name':          tableId+'_length',
				'aria-controls': tableId,
				'class':         classes.sLengthSelect
			} );
		
			for ( var i=0, ien=lengths.length ; i<ien ; i++ ) {
				select[0][ i ] = new Option( language[i], lengths[i] );
			}
		
			var div = $('<div><label/></div>').addClass( classes.sLength );
			if ( ! settings.aanFeatures.l ) {
				div[0].id = tableId+'_length';
			}
		
			div.children().append(
				settings.oLanguage.sLengthMenu.replace( '_MENU_', select[0].outerHTML )
			);
		
			// Can't use `select` variable as user might provide their own and the
			// reference is broken by the use of outerHTML
			$('select', div)
				.val( settings._iDisplayLength )
				.bind( 'change.DT', function(e) {
					_fnLengthChange( settings, $(this).val() );
					_fnDraw( settings );
				} );
		
			// Update node value whenever anything changes the table's length
			$(settings.nTable).bind( 'length.dt.DT', function (e, s, len) {
				if ( settings === s ) {
					$('select', div).val( len );
				}
			} );
		
			return div[0];
		}
		
		
		
		/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
		 * Note that most of the paging logic is done in
		 * DataTable.ext.pager
		 */
		
		/**
		 * Generate the node required for default pagination
		 *  @param {object} oSettings dataTables settings object
		 *  @returns {node} Pagination feature node
		 *  @memberof DataTable#oApi
		 */
		function _fnFeatureHtmlPaginate ( settings )
		{
			var
				type   = settings.sPaginationType,
				plugin = DataTable.ext.pager[ type ],
				modern = typeof plugin === 'function',
				redraw = function( settings ) {
					_fnDraw( settings );
				},
				node = $('<div/>').addClass( settings.oClasses.sPaging + type )[0],
				features = settings.aanFeatures;
		
			if ( ! modern ) {
				plugin.fnInit( settings, node, redraw );
			}
		
			/* Add a draw callback for the pagination on first instance, to update the paging display */
			if ( ! features.p )
			{
				node.id = settings.sTableId+'_paginate';
		
				settings.aoDrawCallback.push( {
					"fn": function( settings ) {
						if ( modern ) {
							var
								start      = settings._iDisplayStart,
								len        = settings._iDisplayLength,
								visRecords = settings.fnRecordsDisplay(),
								all        = len === -1,
								page = all ? 0 : Math.ceil( start / len ),
								pages = all ? 1 : Math.ceil( visRecords / len ),
								buttons = plugin(page, pages),
								i, ien;
		
							for ( i=0, ien=features.p.length ; i<ien ; i++ ) {
								_fnRenderer( settings, 'pageButton' )(
									settings, features.p[i], i, buttons, page, pages
								);
							}
						}
						else {
							plugin.fnUpdate( settings, redraw );
						}
					},
					"sName": "pagination"
				} );
			}
		
			return node;
		}
		
		
		/**
		 * Alter the display settings to change the page
		 *  @param {object} settings DataTables settings object
		 *  @param {string|int} action Paging action to take: "first", "previous",
		 *    "next" or "last" or page number to jump to (integer)
		 *  @param [bool] redraw Automatically draw the update or not
		 *  @returns {bool} true page has changed, false - no change
		 *  @memberof DataTable#oApi
		 */
		function _fnPageChange ( settings, action, redraw )
		{
			var
				start     = settings._iDisplayStart,
				len       = settings._iDisplayLength,
				records   = settings.fnRecordsDisplay();
		
			if ( records === 0 || len === -1 )
			{
				start = 0;
			}
			else if ( typeof action === "number" )
			{
				start = action * len;
		
				if ( start > records )
				{
					start = 0;
				}
			}
			else if ( action == "first" )
			{
				start = 0;
			}
			else if ( action == "previous" )
			{
				start = len >= 0 ?
					start - len :
					0;
		
				if ( start < 0 )
				{
				  start = 0;
				}
			}
			else if ( action == "next" )
			{
				if ( start + len < records )
				{
					start += len;
				}
			}
			else if ( action == "last" )
			{
				start = Math.floor( (records-1) / len) * len;
			}
			else
			{
				_fnLog( settings, 0, "Unknown paging action: "+action, 5 );
			}
		
			var changed = settings._iDisplayStart !== start;
			settings._iDisplayStart = start;
		
			if ( changed ) {
				_fnCallbackFire( settings, null, 'page', [settings] );
		
				if ( redraw ) {
					_fnDraw( settings );
				}
			}
		
			return changed;
		}
		
		
		
		/**
		 * Generate the node required for the processing node
		 *  @param {object} settings dataTables settings object
		 *  @returns {node} Processing element
		 *  @memberof DataTable#oApi
		 */
		function _fnFeatureHtmlProcessing ( settings )
		{
			return $('<div/>', {
					'id': ! settings.aanFeatures.r ? settings.sTableId+'_processing' : null,
					'class': settings.oClasses.sProcessing
				} )
				.html( settings.oLanguage.sProcessing )
				.insertBefore( settings.nTable )[0];
		}
		
		
		/**
		 * Display or hide the processing indicator
		 *  @param {object} settings dataTables settings object
		 *  @param {bool} show Show the processing indicator (true) or not (false)
		 *  @memberof DataTable#oApi
		 */
		function _fnProcessingDisplay ( settings, show )
		{
			if ( settings.oFeatures.bProcessing ) {
				$(settings.aanFeatures.r).css( 'display', show ? 'block' : 'none' );
			}
		
			_fnCallbackFire( settings, null, 'processing', [settings, show] );
		}
		
		/**
		 * Add any control elements for the table - specifically scrolling
		 *  @param {object} settings dataTables settings object
		 *  @returns {node} Node to add to the DOM
		 *  @memberof DataTable#oApi
		 */
		function _fnFeatureHtmlTable ( settings )
		{
			var table = $(settings.nTable);
		
			// Add the ARIA grid role to the table
			table.attr( 'role', 'grid' );
		
			// Scrolling from here on in
			var scroll = settings.oScroll;
		
			if ( scroll.sX === '' && scroll.sY === '' ) {
				return settings.nTable;
			}
		
			var scrollX = scroll.sX;
			var scrollY = scroll.sY;
			var classes = settings.oClasses;
			var caption = table.children('caption');
			var captionSide = caption.length ? caption[0]._captionSide : null;
			var headerClone = $( table[0].cloneNode(false) );
			var footerClone = $( table[0].cloneNode(false) );
			var footer = table.children('tfoot');
			var _div = '<div/>';
			var size = function ( s ) {
				return !s ? null : _fnStringToCss( s );
			};
		
			if ( ! footer.length ) {
				footer = null;
			}
		
			/*
			 * The HTML structure that we want to generate in this function is:
			 *  div - scroller
			 *    div - scroll head
			 *      div - scroll head inner
			 *        table - scroll head table
			 *          thead - thead
			 *    div - scroll body
			 *      table - table (master table)
			 *        thead - thead clone for sizing
			 *        tbody - tbody
			 *    div - scroll foot
			 *      div - scroll foot inner
			 *        table - scroll foot table
			 *          tfoot - tfoot
			 */
			var scroller = $( _div, { 'class': classes.sScrollWrapper } )
				.append(
					$(_div, { 'class': classes.sScrollHead } )
						.css( {
							overflow: 'hidden',
							position: 'relative',
							border: 0,
							width: scrollX ? size(scrollX) : '100%'
						} )
						.append(
							$(_div, { 'class': classes.sScrollHeadInner } )
								.css( {
									'box-sizing': 'content-box',
									width: scroll.sXInner || '100%'
								} )
								.append(
									headerClone
										.removeAttr('id')
										.css( 'margin-left', 0 )
										.append( captionSide === 'top' ? caption : null )
										.append(
											table.children('thead')
										)
								)
						)
				)
				.append(
					$(_div, { 'class': classes.sScrollBody } )
						.css( {
							position: 'relative',
							overflow: 'auto',
							width: size( scrollX )
						} )
						.append( table )
				);
		
			if ( footer ) {
				scroller.append(
					$(_div, { 'class': classes.sScrollFoot } )
						.css( {
							overflow: 'hidden',
							border: 0,
							width: scrollX ? size(scrollX) : '100%'
						} )
						.append(
							$(_div, { 'class': classes.sScrollFootInner } )
								.append(
									footerClone
										.removeAttr('id')
										.css( 'margin-left', 0 )
										.append( captionSide === 'bottom' ? caption : null )
										.append(
											table.children('tfoot')
										)
								)
						)
				);
			}
		
			var children = scroller.children();
			var scrollHead = children[0];
			var scrollBody = children[1];
			var scrollFoot = footer ? children[2] : null;
		
			// When the body is scrolled, then we also want to scroll the headers
			if ( scrollX ) {
				$(scrollBody).on( 'scroll.DT', function (e) {
					var scrollLeft = this.scrollLeft;
		
					scrollHead.scrollLeft = scrollLeft;
		
					if ( footer ) {
						scrollFoot.scrollLeft = scrollLeft;
					}
				} );
			}
		
			$(scrollBody).css(
				scrollY && scroll.bCollapse ? 'max-height' : 'height', 
				scrollY
			);
		
			settings.nScrollHead = scrollHead;
			settings.nScrollBody = scrollBody;
			settings.nScrollFoot = scrollFoot;
		
			// On redraw - align columns
			settings.aoDrawCallback.push( {
				"fn": _fnScrollDraw,
				"sName": "scrolling"
			} );
		
			return scroller[0];
		}
		
		
		
		/**
		 * Update the header, footer and body tables for resizing - i.e. column
		 * alignment.
		 *
		 * Welcome to the most horrible function DataTables. The process that this
		 * function follows is basically:
		 *   1. Re-create the table inside the scrolling div
		 *   2. Take live measurements from the DOM
		 *   3. Apply the measurements to align the columns
		 *   4. Clean up
		 *
		 *  @param {object} settings dataTables settings object
		 *  @memberof DataTable#oApi
		 */
		function _fnScrollDraw ( settings )
		{
			// Given that this is such a monster function, a lot of variables are use
			// to try and keep the minimised size as small as possible
			var
				scroll         = settings.oScroll,
				scrollX        = scroll.sX,
				scrollXInner   = scroll.sXInner,
				scrollY        = scroll.sY,
				barWidth       = scroll.iBarWidth,
				divHeader      = $(settings.nScrollHead),
				divHeaderStyle = divHeader[0].style,
				divHeaderInner = divHeader.children('div'),
				divHeaderInnerStyle = divHeaderInner[0].style,
				divHeaderTable = divHeaderInner.children('table'),
				divBodyEl      = settings.nScrollBody,
				divBody        = $(divBodyEl),
				divBodyStyle   = divBodyEl.style,
				divFooter      = $(settings.nScrollFoot),
				divFooterInner = divFooter.children('div'),
				divFooterTable = divFooterInner.children('table'),
				header         = $(settings.nTHead),
				table          = $(settings.nTable),
				tableEl        = table[0],
				tableStyle     = tableEl.style,
				footer         = settings.nTFoot ? $(settings.nTFoot) : null,
				browser        = settings.oBrowser,
				ie67           = browser.bScrollOversize,
				dtHeaderCells  = _pluck( settings.aoColumns, 'nTh' ),
				headerTrgEls, footerTrgEls,
				headerSrcEls, footerSrcEls,
				headerCopy, footerCopy,
				headerWidths=[], footerWidths=[],
				headerContent=[], footerContent=[],
				idx, correction, sanityWidth,
				zeroOut = function(nSizer) {
					var style = nSizer.style;
					style.paddingTop = "0";
					style.paddingBottom = "0";
					style.borderTopWidth = "0";
					style.borderBottomWidth = "0";
					style.height = 0;
				};
		
			// If the scrollbar visibility has changed from the last draw, we need to
			// adjust the column sizes as the table width will have changed to account
			// for the scrollbar
			var scrollBarVis = divBodyEl.scrollHeight > divBodyEl.clientHeight;
			
			if ( settings.scrollBarVis !== scrollBarVis && settings.scrollBarVis !== undefined ) {
				settings.scrollBarVis = scrollBarVis;
				_fnAdjustColumnSizing( settings );
				return; // adjust column sizing will call this function again
			}
			else {
				settings.scrollBarVis = scrollBarVis;
			}
		
			/*
			 * 1. Re-create the table inside the scrolling div
			 */
		
			// Remove the old minimised thead and tfoot elements in the inner table
			table.children('thead, tfoot').remove();
		
			if ( footer ) {
				footerCopy = footer.clone().prependTo( table );
				footerTrgEls = footer.find('tr'); // the original tfoot is in its own table and must be sized
				footerSrcEls = footerCopy.find('tr');
			}
		
			// Clone the current header and footer elements and then place it into the inner table
			headerCopy = header.clone().prependTo( table );
			headerTrgEls = header.find('tr'); // original header is in its own table
			headerSrcEls = headerCopy.find('tr');
			headerCopy.find('th, td').removeAttr('tabindex');
		
		
			/*
			 * 2. Take live measurements from the DOM - do not alter the DOM itself!
			 */
		
			// Remove old sizing and apply the calculated column widths
			// Get the unique column headers in the newly created (cloned) header. We want to apply the
			// calculated sizes to this header
			if ( ! scrollX )
			{
				divBodyStyle.width = '100%';
				divHeader[0].style.width = '100%';
			}
		
			$.each( _fnGetUniqueThs( settings, headerCopy ), function ( i, el ) {
				idx = _fnVisibleToColumnIndex( settings, i );
				el.style.width = settings.aoColumns[idx].sWidth;
			} );
		
			if ( footer ) {
				_fnApplyToChildren( function(n) {
					n.style.width = "";
				}, footerSrcEls );
			}
		
			// Size the table as a whole
			sanityWidth = table.outerWidth();
			if ( scrollX === "" ) {
				// No x scrolling
				tableStyle.width = "100%";
		
				// IE7 will make the width of the table when 100% include the scrollbar
				// - which is shouldn't. When there is a scrollbar we need to take this
				// into account.
				if ( ie67 && (table.find('tbody').height() > divBodyEl.offsetHeight ||
					divBody.css('overflow-y') == "scroll")
				) {
					tableStyle.width = _fnStringToCss( table.outerWidth() - barWidth);
				}
		
				// Recalculate the sanity width
				sanityWidth = table.outerWidth();
			}
			else if ( scrollXInner !== "" ) {
				// legacy x scroll inner has been given - use it
				tableStyle.width = _fnStringToCss(scrollXInner);
		
				// Recalculate the sanity width
				sanityWidth = table.outerWidth();
			}
		
			// Hidden header should have zero height, so remove padding and borders. Then
			// set the width based on the real headers
		
			// Apply all styles in one pass
			_fnApplyToChildren( zeroOut, headerSrcEls );
		
			// Read all widths in next pass
			_fnApplyToChildren( function(nSizer) {
				headerContent.push( nSizer.innerHTML );
				headerWidths.push( _fnStringToCss( $(nSizer).css('width') ) );
			}, headerSrcEls );
		
			// Apply all widths in final pass
			_fnApplyToChildren( function(nToSize, i) {
				// Only apply widths to the DataTables detected header cells - this
				// prevents complex headers from having contradictory sizes applied
				if ( $.inArray( nToSize, dtHeaderCells ) !== -1 ) {
					nToSize.style.width = headerWidths[i];
				}
			}, headerTrgEls );
		
			$(headerSrcEls).height(0);
		
			/* Same again with the footer if we have one */
			if ( footer )
			{
				_fnApplyToChildren( zeroOut, footerSrcEls );
		
				_fnApplyToChildren( function(nSizer) {
					footerContent.push( nSizer.innerHTML );
					footerWidths.push( _fnStringToCss( $(nSizer).css('width') ) );
				}, footerSrcEls );
		
				_fnApplyToChildren( function(nToSize, i) {
					nToSize.style.width = footerWidths[i];
				}, footerTrgEls );
		
				$(footerSrcEls).height(0);
			}
		
		
			/*
			 * 3. Apply the measurements
			 */
		
			// "Hide" the header and footer that we used for the sizing. We need to keep
			// the content of the cell so that the width applied to the header and body
			// both match, but we want to hide it completely. We want to also fix their
			// width to what they currently are
			_fnApplyToChildren( function(nSizer, i) {
				nSizer.innerHTML = '<div class="dataTables_sizing" style="height:0;overflow:hidden;">'+headerContent[i]+'</div>';
				nSizer.style.width = headerWidths[i];
			}, headerSrcEls );
		
			if ( footer )
			{
				_fnApplyToChildren( function(nSizer, i) {
					nSizer.innerHTML = '<div class="dataTables_sizing" style="height:0;overflow:hidden;">'+footerContent[i]+'</div>';
					nSizer.style.width = footerWidths[i];
				}, footerSrcEls );
			}
		
			// Sanity check that the table is of a sensible width. If not then we are going to get
			// misalignment - try to prevent this by not allowing the table to shrink below its min width
			if ( table.outerWidth() < sanityWidth )
			{
				// The min width depends upon if we have a vertical scrollbar visible or not */
				correction = ((divBodyEl.scrollHeight > divBodyEl.offsetHeight ||
					divBody.css('overflow-y') == "scroll")) ?
						sanityWidth+barWidth :
						sanityWidth;
		
				// IE6/7 are a law unto themselves...
				if ( ie67 && (divBodyEl.scrollHeight >
					divBodyEl.offsetHeight || divBody.css('overflow-y') == "scroll")
				) {
					tableStyle.width = _fnStringToCss( correction-barWidth );
				}
		
				// And give the user a warning that we've stopped the table getting too small
				if ( scrollX === "" || scrollXInner !== "" ) {
					_fnLog( settings, 1, 'Possible column misalignment', 6 );
				}
			}
			else
			{
				correction = '100%';
			}
		
			// Apply to the container elements
			divBodyStyle.width = _fnStringToCss( correction );
			divHeaderStyle.width = _fnStringToCss( correction );
		
			if ( footer ) {
				settings.nScrollFoot.style.width = _fnStringToCss( correction );
			}
		
		
			/*
			 * 4. Clean up
			 */
			if ( ! scrollY ) {
				/* IE7< puts a vertical scrollbar in place (when it shouldn't be) due to subtracting
				 * the scrollbar height from the visible display, rather than adding it on. We need to
				 * set the height in order to sort this. Don't want to do it in any other browsers.
				 */
				if ( ie67 ) {
					divBodyStyle.height = _fnStringToCss( tableEl.offsetHeight+barWidth );
				}
			}
		
			/* Finally set the width's of the header and footer tables */
			var iOuterWidth = table.outerWidth();
			divHeaderTable[0].style.width = _fnStringToCss( iOuterWidth );
			divHeaderInnerStyle.width = _fnStringToCss( iOuterWidth );
		
			// Figure out if there are scrollbar present - if so then we need a the header and footer to
			// provide a bit more space to allow "overflow" scrolling (i.e. past the scrollbar)
			var bScrolling = table.height() > divBodyEl.clientHeight || divBody.css('overflow-y') == "scroll";
			var padding = 'padding' + (browser.bScrollbarLeft ? 'Left' : 'Right' );
			divHeaderInnerStyle[ padding ] = bScrolling ? barWidth+"px" : "0px";
		
			if ( footer ) {
				divFooterTable[0].style.width = _fnStringToCss( iOuterWidth );
				divFooterInner[0].style.width = _fnStringToCss( iOuterWidth );
				divFooterInner[0].style[padding] = bScrolling ? barWidth+"px" : "0px";
			}
		
			// Correct DOM ordering for colgroup - comes before the thead
			table.children('colgroup').insertBefore( table.children('thead') );
		
			/* Adjust the position of the header in case we loose the y-scrollbar */
			divBody.scroll();
		
			// If sorting or filtering has occurred, jump the scrolling back to the top
			// only if we aren't holding the position
			if ( (settings.bSorted || settings.bFiltered) && ! settings._drawHold ) {
				divBodyEl.scrollTop = 0;
			}
		}
		
		
		
		/**
		 * Apply a given function to the display child nodes of an element array (typically
		 * TD children of TR rows
		 *  @param {function} fn Method to apply to the objects
		 *  @param array {nodes} an1 List of elements to look through for display children
		 *  @param array {nodes} an2 Another list (identical structure to the first) - optional
		 *  @memberof DataTable#oApi
		 */
		function _fnApplyToChildren( fn, an1, an2 )
		{
			var index=0, i=0, iLen=an1.length;
			var nNode1, nNode2;
		
			while ( i < iLen ) {
				nNode1 = an1[i].firstChild;
				nNode2 = an2 ? an2[i].firstChild : null;
		
				while ( nNode1 ) {
					if ( nNode1.nodeType === 1 ) {
						if ( an2 ) {
							fn( nNode1, nNode2, index );
						}
						else {
							fn( nNode1, index );
						}
		
						index++;
					}
		
					nNode1 = nNode1.nextSibling;
					nNode2 = an2 ? nNode2.nextSibling : null;
				}
		
				i++;
			}
		}
		
		
		
		var __re_html_remove = /<.*?>/g;
		
		
		/**
		 * Calculate the width of columns for the table
		 *  @param {object} oSettings dataTables settings object
		 *  @memberof DataTable#oApi
		 */
		function _fnCalculateColumnWidths ( oSettings )
		{
			var
				table = oSettings.nTable,
				columns = oSettings.aoColumns,
				scroll = oSettings.oScroll,
				scrollY = scroll.sY,
				scrollX = scroll.sX,
				scrollXInner = scroll.sXInner,
				columnCount = columns.length,
				visibleColumns = _fnGetColumns( oSettings, 'bVisible' ),
				headerCells = $('th', oSettings.nTHead),
				tableWidthAttr = table.getAttribute('width'), // from DOM element
				tableContainer = table.parentNode,
				userInputs = false,
				i, column, columnIdx, width, outerWidth,
				browser = oSettings.oBrowser,
				ie67 = browser.bScrollOversize;
		
			var styleWidth = table.style.width;
			if ( styleWidth && styleWidth.indexOf('%') !== -1 ) {
				tableWidthAttr = styleWidth;
			}
		
			/* Convert any user input sizes into pixel sizes */
			for ( i=0 ; i<visibleColumns.length ; i++ ) {
				column = columns[ visibleColumns[i] ];
		
				if ( column.sWidth !== null ) {
					column.sWidth = _fnConvertToWidth( column.sWidthOrig, tableContainer );
		
					userInputs = true;
				}
			}
		
			/* If the number of columns in the DOM equals the number that we have to
			 * process in DataTables, then we can use the offsets that are created by
			 * the web- browser. No custom sizes can be set in order for this to happen,
			 * nor scrolling used
			 */
			if ( ie67 || ! userInputs && ! scrollX && ! scrollY &&
			     columnCount == _fnVisbleColumns( oSettings ) &&
			     columnCount == headerCells.length
			) {
				for ( i=0 ; i<columnCount ; i++ ) {
					var colIdx = _fnVisibleToColumnIndex( oSettings, i );
		
					if ( colIdx !== null ) {
						columns[ colIdx ].sWidth = _fnStringToCss( headerCells.eq(i).width() );
					}
				}
			}
			else
			{
				// Otherwise construct a single row, worst case, table with the widest
				// node in the data, assign any user defined widths, then insert it into
				// the DOM and allow the browser to do all the hard work of calculating
				// table widths
				var tmpTable = $(table).clone() // don't use cloneNode - IE8 will remove events on the main table
					.css( 'visibility', 'hidden' )
					.removeAttr( 'id' );
		
				// Clean up the table body
				tmpTable.find('tbody tr').remove();
				var tr = $('<tr/>').appendTo( tmpTable.find('tbody') );
		
				// Clone the table header and footer - we can't use the header / footer
				// from the cloned table, since if scrolling is active, the table's
				// real header and footer are contained in different table tags
				tmpTable.find('thead, tfoot').remove();
				tmpTable
					.append( $(oSettings.nTHead).clone() )
					.append( $(oSettings.nTFoot).clone() );
		
				// Remove any assigned widths from the footer (from scrolling)
				tmpTable.find('tfoot th, tfoot td').css('width', '');
		
				// Apply custom sizing to the cloned header
				headerCells = _fnGetUniqueThs( oSettings, tmpTable.find('thead')[0] );
		
				for ( i=0 ; i<visibleColumns.length ; i++ ) {
					column = columns[ visibleColumns[i] ];
		
					headerCells[i].style.width = column.sWidthOrig !== null && column.sWidthOrig !== '' ?
						_fnStringToCss( column.sWidthOrig ) :
						'';
		
					// For scrollX we need to force the column width otherwise the
					// browser will collapse it. If this width is smaller than the
					// width the column requires, then it will have no effect
					if ( column.sWidthOrig && scrollX ) {
						$( headerCells[i] ).append( $('<div/>').css( {
							width: column.sWidthOrig,
							margin: 0,
							padding: 0,
							border: 0,
							height: 1
						} ) );
					}
				}
		
				// Find the widest cell for each column and put it into the table
				if ( oSettings.aoData.length ) {
					for ( i=0 ; i<visibleColumns.length ; i++ ) {
						columnIdx = visibleColumns[i];
						column = columns[ columnIdx ];
		
						$( _fnGetWidestNode( oSettings, columnIdx ) )
							.clone( false )
							.append( column.sContentPadding )
							.appendTo( tr );
					}
				}
		
				// Tidy the temporary table - remove name attributes so there aren't
				// duplicated in the dom (radio elements for example)
				$('[name]', tmpTable).removeAttr('name');
		
				// Table has been built, attach to the document so we can work with it.
				// A holding element is used, positioned at the top of the container
				// with minimal height, so it has no effect on if the container scrolls
				// or not. Otherwise it might trigger scrolling when it actually isn't
				// needed
				var holder = $('<div/>').css( scrollX || scrollY ?
						{
							position: 'absolute',
							top: 0,
							left: 0,
							height: 1,
							right: 0,
							overflow: 'hidden'
						} :
						{}
					)
					.append( tmpTable )
					.appendTo( tableContainer );
		
				// When scrolling (X or Y) we want to set the width of the table as 
				// appropriate. However, when not scrolling leave the table width as it
				// is. This results in slightly different, but I think correct behaviour
				if ( scrollX && scrollXInner ) {
					tmpTable.width( scrollXInner );
				}
				else if ( scrollX ) {
					tmpTable.css( 'width', 'auto' );
					tmpTable.removeAttr('width');
		
					// If there is no width attribute or style, then allow the table to
					// collapse
					if ( tmpTable.width() < tableContainer.clientWidth && tableWidthAttr ) {
						tmpTable.width( tableContainer.clientWidth );
					}
				}
				else if ( scrollY ) {
					tmpTable.width( tableContainer.clientWidth );
				}
				else if ( tableWidthAttr ) {
					tmpTable.width( tableWidthAttr );
				}
		
				// Get the width of each column in the constructed table - we need to
				// know the inner width (so it can be assigned to the other table's
				// cells) and the outer width so we can calculate the full width of the
				// table. This is safe since DataTables requires a unique cell for each
				// column, but if ever a header can span multiple columns, this will
				// need to be modified.
				var total = 0;
				for ( i=0 ; i<visibleColumns.length ; i++ ) {
					var cell = $(headerCells[i]);
					var border = cell.outerWidth() - cell.width();
		
					// Use getBounding... where possible (not IE8-) because it can give
					// sub-pixel accuracy, which we then want to round up!
					var bounding = browser.bBounding ?
						Math.ceil( headerCells[i].getBoundingClientRect().width ) :
						cell.outerWidth();
		
					// Total is tracked to remove any sub-pixel errors as the outerWidth
					// of the table might not equal the total given here (IE!).
					total += bounding;
		
					// Width for each column to use
					columns[ visibleColumns[i] ].sWidth = _fnStringToCss( bounding - border );
				}
		
				table.style.width = _fnStringToCss( total );
		
				// Finished with the table - ditch it
				holder.remove();
			}
		
			// If there is a width attr, we want to attach an event listener which
			// allows the table sizing to automatically adjust when the window is
			// resized. Use the width attr rather than CSS, since we can't know if the
			// CSS is a relative value or absolute - DOM read is always px.
			if ( tableWidthAttr ) {
				table.style.width = _fnStringToCss( tableWidthAttr );
			}
		
			if ( (tableWidthAttr || scrollX) && ! oSettings._reszEvt ) {
				var bindResize = function () {
					$(window).bind('resize.DT-'+oSettings.sInstance, _fnThrottle( function () {
						_fnAdjustColumnSizing( oSettings );
					} ) );
				};
		
				// IE6/7 will crash if we bind a resize event handler on page load.
				// To be removed in 1.11 which drops IE6/7 support
				if ( ie67 ) {
					setTimeout( bindResize, 1000 );
				}
				else {
					bindResize();
				}
		
				oSettings._reszEvt = true;
			}
		}
		
		
		/**
		 * Throttle the calls to a function. Arguments and context are maintained for
		 * the throttled function
		 *  @param {function} fn Function to be called
		 *  @param {int} [freq=200] call frequency in mS
		 *  @returns {function} wrapped function
		 *  @memberof DataTable#oApi
		 */
		var _fnThrottle = DataTable.util.throttle;
		
		
		/**
		 * Convert a CSS unit width to pixels (e.g. 2em)
		 *  @param {string} width width to be converted
		 *  @param {node} parent parent to get the with for (required for relative widths) - optional
		 *  @returns {int} width in pixels
		 *  @memberof DataTable#oApi
		 */
		function _fnConvertToWidth ( width, parent )
		{
			if ( ! width ) {
				return 0;
			}
		
			var n = $('<div/>')
				.css( 'width', _fnStringToCss( width ) )
				.appendTo( parent || document.body );
		
			var val = n[0].offsetWidth;
			n.remove();
		
			return val;
		}
		
		
		/**
		 * Get the widest node
		 *  @param {object} settings dataTables settings object
		 *  @param {int} colIdx column of interest
		 *  @returns {node} widest table node
		 *  @memberof DataTable#oApi
		 */
		function _fnGetWidestNode( settings, colIdx )
		{
			var idx = _fnGetMaxLenString( settings, colIdx );
			if ( idx < 0 ) {
				return null;
			}
		
			var data = settings.aoData[ idx ];
			return ! data.nTr ? // Might not have been created when deferred rendering
				$('<td/>').html( _fnGetCellData( settings, idx, colIdx, 'display' ) )[0] :
				data.anCells[ colIdx ];
		}
		
		
		/**
		 * Get the maximum strlen for each data column
		 *  @param {object} settings dataTables settings object
		 *  @param {int} colIdx column of interest
		 *  @returns {string} max string length for each column
		 *  @memberof DataTable#oApi
		 */
		function _fnGetMaxLenString( settings, colIdx )
		{
			var s, max=-1, maxIdx = -1;
		
			for ( var i=0, ien=settings.aoData.length ; i<ien ; i++ ) {
				s = _fnGetCellData( settings, i, colIdx, 'display' )+'';
				s = s.replace( __re_html_remove, '' );
				s = s.replace( /&nbsp;/g, ' ' );
		
				if ( s.length > max ) {
					max = s.length;
					maxIdx = i;
				}
			}
		
			return maxIdx;
		}
		
		
		/**
		 * Append a CSS unit (only if required) to a string
		 *  @param {string} value to css-ify
		 *  @returns {string} value with css unit
		 *  @memberof DataTable#oApi
		 */
		function _fnStringToCss( s )
		{
			if ( s === null ) {
				return '0px';
			}
		
			if ( typeof s == 'number' ) {
				return s < 0 ?
					'0px' :
					s+'px';
			}
		
			// Check it has a unit character already
			return s.match(/\d$/) ?
				s+'px' :
				s;
		}
		
		
		
		function _fnSortFlatten ( settings )
		{
			var
				i, iLen, k, kLen,
				aSort = [],
				aiOrig = [],
				aoColumns = settings.aoColumns,
				aDataSort, iCol, sType, srcCol,
				fixed = settings.aaSortingFixed,
				fixedObj = $.isPlainObject( fixed ),
				nestedSort = [],
				add = function ( a ) {
					if ( a.length && ! $.isArray( a[0] ) ) {
						// 1D array
						nestedSort.push( a );
					}
					else {
						// 2D array
						$.merge( nestedSort, a );
					}
				};
		
			// Build the sort array, with pre-fix and post-fix options if they have been
			// specified
			if ( $.isArray( fixed ) ) {
				add( fixed );
			}
		
			if ( fixedObj && fixed.pre ) {
				add( fixed.pre );
			}
		
			add( settings.aaSorting );
		
			if (fixedObj && fixed.post ) {
				add( fixed.post );
			}
		
			for ( i=0 ; i<nestedSort.length ; i++ )
			{
				srcCol = nestedSort[i][0];
				aDataSort = aoColumns[ srcCol ].aDataSort;
		
				for ( k=0, kLen=aDataSort.length ; k<kLen ; k++ )
				{
					iCol = aDataSort[k];
					sType = aoColumns[ iCol ].sType || 'string';
		
					if ( nestedSort[i]._idx === undefined ) {
						nestedSort[i]._idx = $.inArray( nestedSort[i][1], aoColumns[iCol].asSorting );
					}
		
					aSort.push( {
						src:       srcCol,
						col:       iCol,
						dir:       nestedSort[i][1],
						index:     nestedSort[i]._idx,
						type:      sType,
						formatter: DataTable.ext.type.order[ sType+"-pre" ]
					} );
				}
			}
		
			return aSort;
		}
		
		/**
		 * Change the order of the table
		 *  @param {object} oSettings dataTables settings object
		 *  @memberof DataTable#oApi
		 *  @todo This really needs split up!
		 */
		function _fnSort ( oSettings )
		{
			var
				i, ien, iLen, j, jLen, k, kLen,
				sDataType, nTh,
				aiOrig = [],
				oExtSort = DataTable.ext.type.order,
				aoData = oSettings.aoData,
				aoColumns = oSettings.aoColumns,
				aDataSort, data, iCol, sType, oSort,
				formatters = 0,
				sortCol,
				displayMaster = oSettings.aiDisplayMaster,
				aSort;
		
			// Resolve any column types that are unknown due to addition or invalidation
			// @todo Can this be moved into a 'data-ready' handler which is called when
			//   data is going to be used in the table?
			_fnColumnTypes( oSettings );
		
			aSort = _fnSortFlatten( oSettings );
		
			for ( i=0, ien=aSort.length ; i<ien ; i++ ) {
				sortCol = aSort[i];
		
				// Track if we can use the fast sort algorithm
				if ( sortCol.formatter ) {
					formatters++;
				}
		
				// Load the data needed for the sort, for each cell
				_fnSortData( oSettings, sortCol.col );
			}
		
			/* No sorting required if server-side or no sorting array */
			if ( _fnDataSource( oSettings ) != 'ssp' && aSort.length !== 0 )
			{
				// Create a value - key array of the current row positions such that we can use their
				// current position during the sort, if values match, in order to perform stable sorting
				for ( i=0, iLen=displayMaster.length ; i<iLen ; i++ ) {
					aiOrig[ displayMaster[i] ] = i;
				}
		
				/* Do the sort - here we want multi-column sorting based on a given data source (column)
				 * and sorting function (from oSort) in a certain direction. It's reasonably complex to
				 * follow on it's own, but this is what we want (example two column sorting):
				 *  fnLocalSorting = function(a,b){
				 *    var iTest;
				 *    iTest = oSort['string-asc']('data11', 'data12');
				 *      if (iTest !== 0)
				 *        return iTest;
				 *    iTest = oSort['numeric-desc']('data21', 'data22');
				 *    if (iTest !== 0)
				 *      return iTest;
				 *    return oSort['numeric-asc']( aiOrig[a], aiOrig[b] );
				 *  }
				 * Basically we have a test for each sorting column, if the data in that column is equal,
				 * test the next column. If all columns match, then we use a numeric sort on the row
				 * positions in the original data array to provide a stable sort.
				 *
				 * Note - I know it seems excessive to have two sorting methods, but the first is around
				 * 15% faster, so the second is only maintained for backwards compatibility with sorting
				 * methods which do not have a pre-sort formatting function.
				 */
				if ( formatters === aSort.length ) {
					// All sort types have formatting functions
					displayMaster.sort( function ( a, b ) {
						var
							x, y, k, test, sort,
							len=aSort.length,
							dataA = aoData[a]._aSortData,
							dataB = aoData[b]._aSortData;
		
						for ( k=0 ; k<len ; k++ ) {
							sort = aSort[k];
		
							x = dataA[ sort.col ];
							y = dataB[ sort.col ];
		
							test = x<y ? -1 : x>y ? 1 : 0;
							if ( test !== 0 ) {
								return sort.dir === 'asc' ? test : -test;
							}
						}
		
						x = aiOrig[a];
						y = aiOrig[b];
						return x<y ? -1 : x>y ? 1 : 0;
					} );
				}
				else {
					// Depreciated - remove in 1.11 (providing a plug-in option)
					// Not all sort types have formatting methods, so we have to call their sorting
					// methods.
					displayMaster.sort( function ( a, b ) {
						var
							x, y, k, l, test, sort, fn,
							len=aSort.length,
							dataA = aoData[a]._aSortData,
							dataB = aoData[b]._aSortData;
		
						for ( k=0 ; k<len ; k++ ) {
							sort = aSort[k];
		
							x = dataA[ sort.col ];
							y = dataB[ sort.col ];
		
							fn = oExtSort[ sort.type+"-"+sort.dir ] || oExtSort[ "string-"+sort.dir ];
							test = fn( x, y );
							if ( test !== 0 ) {
								return test;
							}
						}
		
						x = aiOrig[a];
						y = aiOrig[b];
						return x<y ? -1 : x>y ? 1 : 0;
					} );
				}
			}
		
			/* Tell the draw function that we have sorted the data */
			oSettings.bSorted = true;
		}
		
		
		function _fnSortAria ( settings )
		{
			var label;
			var nextSort;
			var columns = settings.aoColumns;
			var aSort = _fnSortFlatten( settings );
			var oAria = settings.oLanguage.oAria;
		
			// ARIA attributes - need to loop all columns, to update all (removing old
			// attributes as needed)
			for ( var i=0, iLen=columns.length ; i<iLen ; i++ )
			{
				var col = columns[i];
				var asSorting = col.asSorting;
				var sTitle = col.sTitle.replace( /<.*?>/g, "" );
				var th = col.nTh;
		
				// IE7 is throwing an error when setting these properties with jQuery's
				// attr() and removeAttr() methods...
				th.removeAttribute('aria-sort');
		
				/* In ARIA only the first sorting column can be marked as sorting - no multi-sort option */
				if ( col.bSortable ) {
					if ( aSort.length > 0 && aSort[0].col == i ) {
						th.setAttribute('aria-sort', aSort[0].dir=="asc" ? "ascending" : "descending" );
						nextSort = asSorting[ aSort[0].index+1 ] || asSorting[0];
					}
					else {
						nextSort = asSorting[0];
					}
		
					label = sTitle + ( nextSort === "asc" ?
						oAria.sSortAscending :
						oAria.sSortDescending
					);
				}
				else {
					label = sTitle;
				}
		
				th.setAttribute('aria-label', label);
			}
		}
		
		
		/**
		 * Function to run on user sort request
		 *  @param {object} settings dataTables settings object
		 *  @param {node} attachTo node to attach the handler to
		 *  @param {int} colIdx column sorting index
		 *  @param {boolean} [append=false] Append the requested sort to the existing
		 *    sort if true (i.e. multi-column sort)
		 *  @param {function} [callback] callback function
		 *  @memberof DataTable#oApi
		 */
		function _fnSortListener ( settings, colIdx, append, callback )
		{
			var col = settings.aoColumns[ colIdx ];
			var sorting = settings.aaSorting;
			var asSorting = col.asSorting;
			var nextSortIdx;
			var next = function ( a, overflow ) {
				var idx = a._idx;
				if ( idx === undefined ) {
					idx = $.inArray( a[1], asSorting );
				}
		
				return idx+1 < asSorting.length ?
					idx+1 :
					overflow ?
						null :
						0;
			};
		
			// Convert to 2D array if needed
			if ( typeof sorting[0] === 'number' ) {
				sorting = settings.aaSorting = [ sorting ];
			}
		
			// If appending the sort then we are multi-column sorting
			if ( append && settings.oFeatures.bSortMulti ) {
				// Are we already doing some kind of sort on this column?
				var sortIdx = $.inArray( colIdx, _pluck(sorting, '0') );
		
				if ( sortIdx !== -1 ) {
					// Yes, modify the sort
					nextSortIdx = next( sorting[sortIdx], true );
		
					if ( nextSortIdx === null && sorting.length === 1 ) {
						nextSortIdx = 0; // can't remove sorting completely
					}
		
					if ( nextSortIdx === null ) {
						sorting.splice( sortIdx, 1 );
					}
					else {
						sorting[sortIdx][1] = asSorting[ nextSortIdx ];
						sorting[sortIdx]._idx = nextSortIdx;
					}
				}
				else {
					// No sort on this column yet
					sorting.push( [ colIdx, asSorting[0], 0 ] );
					sorting[sorting.length-1]._idx = 0;
				}
			}
			else if ( sorting.length && sorting[0][0] == colIdx ) {
				// Single column - already sorting on this column, modify the sort
				nextSortIdx = next( sorting[0] );
		
				sorting.length = 1;
				sorting[0][1] = asSorting[ nextSortIdx ];
				sorting[0]._idx = nextSortIdx;
			}
			else {
				// Single column - sort only on this column
				sorting.length = 0;
				sorting.push( [ colIdx, asSorting[0] ] );
				sorting[0]._idx = 0;
			}
		
			// Run the sort by calling a full redraw
			_fnReDraw( settings );
		
			// callback used for async user interaction
			if ( typeof callback == 'function' ) {
				callback( settings );
			}
		}
		
		
		/**
		 * Attach a sort handler (click) to a node
		 *  @param {object} settings dataTables settings object
		 *  @param {node} attachTo node to attach the handler to
		 *  @param {int} colIdx column sorting index
		 *  @param {function} [callback] callback function
		 *  @memberof DataTable#oApi
		 */
		function _fnSortAttachListener ( settings, attachTo, colIdx, callback )
		{
			var col = settings.aoColumns[ colIdx ];
		
			_fnBindAction( attachTo, {}, function (e) {
				/* If the column is not sortable - don't to anything */
				if ( col.bSortable === false ) {
					return;
				}
		
				// If processing is enabled use a timeout to allow the processing
				// display to be shown - otherwise to it synchronously
				if ( settings.oFeatures.bProcessing ) {
					_fnProcessingDisplay( settings, true );
		
					setTimeout( function() {
						_fnSortListener( settings, colIdx, e.shiftKey, callback );
		
						// In server-side processing, the draw callback will remove the
						// processing display
						if ( _fnDataSource( settings ) !== 'ssp' ) {
							_fnProcessingDisplay( settings, false );
						}
					}, 0 );
				}
				else {
					_fnSortListener( settings, colIdx, e.shiftKey, callback );
				}
			} );
		}
		
		
		/**
		 * Set the sorting classes on table's body, Note: it is safe to call this function
		 * when bSort and bSortClasses are false
		 *  @param {object} oSettings dataTables settings object
		 *  @memberof DataTable#oApi
		 */
		function _fnSortingClasses( settings )
		{
			var oldSort = settings.aLastSort;
			var sortClass = settings.oClasses.sSortColumn;
			var sort = _fnSortFlatten( settings );
			var features = settings.oFeatures;
			var i, ien, colIdx;
		
			if ( features.bSort && features.bSortClasses ) {
				// Remove old sorting classes
				for ( i=0, ien=oldSort.length ; i<ien ; i++ ) {
					colIdx = oldSort[i].src;
		
					// Remove column sorting
					$( _pluck( settings.aoData, 'anCells', colIdx ) )
						.removeClass( sortClass + (i<2 ? i+1 : 3) );
				}
		
				// Add new column sorting
				for ( i=0, ien=sort.length ; i<ien ; i++ ) {
					colIdx = sort[i].src;
		
					$( _pluck( settings.aoData, 'anCells', colIdx ) )
						.addClass( sortClass + (i<2 ? i+1 : 3) );
				}
			}
		
			settings.aLastSort = sort;
		}
		
		
		// Get the data to sort a column, be it from cache, fresh (populating the
		// cache), or from a sort formatter
		function _fnSortData( settings, idx )
		{
			// Custom sorting function - provided by the sort data type
			var column = settings.aoColumns[ idx ];
			var customSort = DataTable.ext.order[ column.sSortDataType ];
			var customData;
		
			if ( customSort ) {
				customData = customSort.call( settings.oInstance, settings, idx,
					_fnColumnIndexToVisible( settings, idx )
				);
			}
		
			// Use / populate cache
			var row, cellData;
			var formatter = DataTable.ext.type.order[ column.sType+"-pre" ];
		
			for ( var i=0, ien=settings.aoData.length ; i<ien ; i++ ) {
				row = settings.aoData[i];
		
				if ( ! row._aSortData ) {
					row._aSortData = [];
				}
		
				if ( ! row._aSortData[idx] || customSort ) {
					cellData = customSort ?
						customData[i] : // If there was a custom sort function, use data from there
						_fnGetCellData( settings, i, idx, 'sort' );
		
					row._aSortData[ idx ] = formatter ?
						formatter( cellData ) :
						cellData;
				}
			}
		}
		
		
		
		/**
		 * Save the state of a table
		 *  @param {object} oSettings dataTables settings object
		 *  @memberof DataTable#oApi
		 */
		function _fnSaveState ( settings )
		{
			if ( !settings.oFeatures.bStateSave || settings.bDestroying )
			{
				return;
			}
		
			/* Store the interesting variables */
			var state = {
				time:    +new Date(),
				start:   settings._iDisplayStart,
				length:  settings._iDisplayLength,
				order:   $.extend( true, [], settings.aaSorting ),
				search:  _fnSearchToCamel( settings.oPreviousSearch ),
				columns: $.map( settings.aoColumns, function ( col, i ) {
					return {
						visible: col.bVisible,
						search: _fnSearchToCamel( settings.aoPreSearchCols[i] )
					};
				} )
			};
		
			_fnCallbackFire( settings, "aoStateSaveParams", 'stateSaveParams', [settings, state] );
		
			settings.oSavedState = state;
			settings.fnStateSaveCallback.call( settings.oInstance, settings, state );
		}
		
		
		/**
		 * Attempt to load a saved table state
		 *  @param {object} oSettings dataTables settings object
		 *  @param {object} oInit DataTables init object so we can override settings
		 *  @memberof DataTable#oApi
		 */
		function _fnLoadState ( settings, oInit )
		{
			var i, ien;
			var columns = settings.aoColumns;
		
			if ( ! settings.oFeatures.bStateSave ) {
				return;
			}
		
			var state = settings.fnStateLoadCallback.call( settings.oInstance, settings );
			if ( ! state || ! state.time ) {
				return;
			}
		
			/* Allow custom and plug-in manipulation functions to alter the saved data set and
			 * cancelling of loading by returning false
			 */
			var abStateLoad = _fnCallbackFire( settings, 'aoStateLoadParams', 'stateLoadParams', [settings, state] );
			if ( $.inArray( false, abStateLoad ) !== -1 ) {
				return;
			}
		
			/* Reject old data */
			var duration = settings.iStateDuration;
			if ( duration > 0 && state.time < +new Date() - (duration*1000) ) {
				return;
			}
		
			// Number of columns have changed - all bets are off, no restore of settings
			if ( columns.length !== state.columns.length ) {
				return;
			}
		
			// Store the saved state so it might be accessed at any time
			settings.oLoadedState = $.extend( true, {}, state );
		
			// Restore key features - todo - for 1.11 this needs to be done by
			// subscribed events
			if ( state.start !== undefined ) {
				settings._iDisplayStart    = state.start;
				settings.iInitDisplayStart = state.start;
			}
			if ( state.length !== undefined ) {
				settings._iDisplayLength   = state.length;
			}
		
			// Order
			if ( state.order !== undefined ) {
				settings.aaSorting = [];
				$.each( state.order, function ( i, col ) {
					settings.aaSorting.push( col[0] >= columns.length ?
						[ 0, col[1] ] :
						col
					);
				} );
			}
		
			// Search
			if ( state.search !== undefined ) {
				$.extend( settings.oPreviousSearch, _fnSearchToHung( state.search ) );
			}
		
			// Columns
			for ( i=0, ien=state.columns.length ; i<ien ; i++ ) {
				var col = state.columns[i];
		
				// Visibility
				if ( col.visible !== undefined ) {
					columns[i].bVisible = col.visible;
				}
		
				// Search
				if ( col.search !== undefined ) {
					$.extend( settings.aoPreSearchCols[i], _fnSearchToHung( col.search ) );
				}
			}
		
			_fnCallbackFire( settings, 'aoStateLoaded', 'stateLoaded', [settings, state] );
		}
		
		
		/**
		 * Return the settings object for a particular table
		 *  @param {node} table table we are using as a dataTable
		 *  @returns {object} Settings object - or null if not found
		 *  @memberof DataTable#oApi
		 */
		function _fnSettingsFromNode ( table )
		{
			var settings = DataTable.settings;
			var idx = $.inArray( table, _pluck( settings, 'nTable' ) );
		
			return idx !== -1 ?
				settings[ idx ] :
				null;
		}
		
		
		/**
		 * Log an error message
		 *  @param {object} settings dataTables settings object
		 *  @param {int} level log error messages, or display them to the user
		 *  @param {string} msg error message
		 *  @param {int} tn Technical note id to get more information about the error.
		 *  @memberof DataTable#oApi
		 */
		function _fnLog( settings, level, msg, tn )
		{
			msg = 'DataTables warning: '+
				(settings ? 'table id='+settings.sTableId+' - ' : '')+msg;
		
			if ( tn ) {
				msg += '. For more information about this error, please see '+
				'http://datatables.net/tn/'+tn;
			}
		
			if ( ! level  ) {
				// Backwards compatibility pre 1.10
				var ext = DataTable.ext;
				var type = ext.sErrMode || ext.errMode;
		
				if ( settings ) {
					_fnCallbackFire( settings, null, 'error', [ settings, tn, msg ] );
				}
		
				if ( type == 'alert' ) {
					alert( msg );
				}
				else if ( type == 'throw' ) {
					throw new Error(msg);
				}
				else if ( typeof type == 'function' ) {
					type( settings, tn, msg );
				}
			}
			else if ( window.console && console.log ) {
				console.log( msg );
			}
		}
		
		
		/**
		 * See if a property is defined on one object, if so assign it to the other object
		 *  @param {object} ret target object
		 *  @param {object} src source object
		 *  @param {string} name property
		 *  @param {string} [mappedName] name to map too - optional, name used if not given
		 *  @memberof DataTable#oApi
		 */
		function _fnMap( ret, src, name, mappedName )
		{
			if ( $.isArray( name ) ) {
				$.each( name, function (i, val) {
					if ( $.isArray( val ) ) {
						_fnMap( ret, src, val[0], val[1] );
					}
					else {
						_fnMap( ret, src, val );
					}
				} );
		
				return;
			}
		
			if ( mappedName === undefined ) {
				mappedName = name;
			}
		
			if ( src[name] !== undefined ) {
				ret[mappedName] = src[name];
			}
		}
		
		
		/**
		 * Extend objects - very similar to jQuery.extend, but deep copy objects, and
		 * shallow copy arrays. The reason we need to do this, is that we don't want to
		 * deep copy array init values (such as aaSorting) since the dev wouldn't be
		 * able to override them, but we do want to deep copy arrays.
		 *  @param {object} out Object to extend
		 *  @param {object} extender Object from which the properties will be applied to
		 *      out
		 *  @param {boolean} breakRefs If true, then arrays will be sliced to take an
		 *      independent copy with the exception of the `data` or `aaData` parameters
		 *      if they are present. This is so you can pass in a collection to
		 *      DataTables and have that used as your data source without breaking the
		 *      references
		 *  @returns {object} out Reference, just for convenience - out === the return.
		 *  @memberof DataTable#oApi
		 *  @todo This doesn't take account of arrays inside the deep copied objects.
		 */
		function _fnExtend( out, extender, breakRefs )
		{
			var val;
		
			for ( var prop in extender ) {
				if ( extender.hasOwnProperty(prop) ) {
					val = extender[prop];
		
					if ( $.isPlainObject( val ) ) {
						if ( ! $.isPlainObject( out[prop] ) ) {
							out[prop] = {};
						}
						$.extend( true, out[prop], val );
					}
					else if ( breakRefs && prop !== 'data' && prop !== 'aaData' && $.isArray(val) ) {
						out[prop] = val.slice();
					}
					else {
						out[prop] = val;
					}
				}
			}
		
			return out;
		}
		
		
		/**
		 * Bind an event handers to allow a click or return key to activate the callback.
		 * This is good for accessibility since a return on the keyboard will have the
		 * same effect as a click, if the element has focus.
		 *  @param {element} n Element to bind the action to
		 *  @param {object} oData Data object to pass to the triggered function
		 *  @param {function} fn Callback function for when the event is triggered
		 *  @memberof DataTable#oApi
		 */
		function _fnBindAction( n, oData, fn )
		{
			$(n)
				.bind( 'click.DT', oData, function (e) {
						n.blur(); // Remove focus outline for mouse users
						fn(e);
					} )
				.bind( 'keypress.DT', oData, function (e){
						if ( e.which === 13 ) {
							e.preventDefault();
							fn(e);
						}
					} )
				.bind( 'selectstart.DT', function () {
						/* Take the brutal approach to cancelling text selection */
						return false;
					} );
		}
		
		
		/**
		 * Register a callback function. Easily allows a callback function to be added to
		 * an array store of callback functions that can then all be called together.
		 *  @param {object} oSettings dataTables settings object
		 *  @param {string} sStore Name of the array storage for the callbacks in oSettings
		 *  @param {function} fn Function to be called back
		 *  @param {string} sName Identifying name for the callback (i.e. a label)
		 *  @memberof DataTable#oApi
		 */
		function _fnCallbackReg( oSettings, sStore, fn, sName )
		{
			if ( fn )
			{
				oSettings[sStore].push( {
					"fn": fn,
					"sName": sName
				} );
			}
		}
		
		
		/**
		 * Fire callback functions and trigger events. Note that the loop over the
		 * callback array store is done backwards! Further note that you do not want to
		 * fire off triggers in time sensitive applications (for example cell creation)
		 * as its slow.
		 *  @param {object} settings dataTables settings object
		 *  @param {string} callbackArr Name of the array storage for the callbacks in
		 *      oSettings
		 *  @param {string} eventName Name of the jQuery custom event to trigger. If
		 *      null no trigger is fired
		 *  @param {array} args Array of arguments to pass to the callback function /
		 *      trigger
		 *  @memberof DataTable#oApi
		 */
		function _fnCallbackFire( settings, callbackArr, eventName, args )
		{
			var ret = [];
		
			if ( callbackArr ) {
				ret = $.map( settings[callbackArr].slice().reverse(), function (val, i) {
					return val.fn.apply( settings.oInstance, args );
				} );
			}
		
			if ( eventName !== null ) {
				var e = $.Event( eventName+'.dt' );
		
				$(settings.nTable).trigger( e, args );
		
				ret.push( e.result );
			}
		
			return ret;
		}
		
		
		function _fnLengthOverflow ( settings )
		{
			var
				start = settings._iDisplayStart,
				end = settings.fnDisplayEnd(),
				len = settings._iDisplayLength;
		
			/* If we have space to show extra rows (backing up from the end point - then do so */
			if ( start >= end )
			{
				start = end - len;
			}
		
			// Keep the start record on the current page
			start -= (start % len);
		
			if ( len === -1 || start < 0 )
			{
				start = 0;
			}
		
			settings._iDisplayStart = start;
		}
		
		
		function _fnRenderer( settings, type )
		{
			var renderer = settings.renderer;
			var host = DataTable.ext.renderer[type];
		
			if ( $.isPlainObject( renderer ) && renderer[type] ) {
				// Specific renderer for this type. If available use it, otherwise use
				// the default.
				return host[renderer[type]] || host._;
			}
			else if ( typeof renderer === 'string' ) {
				// Common renderer - if there is one available for this type use it,
				// otherwise use the default
				return host[renderer] || host._;
			}
		
			// Use the default
			return host._;
		}
		
		
		/**
		 * Detect the data source being used for the table. Used to simplify the code
		 * a little (ajax) and to make it compress a little smaller.
		 *
		 *  @param {object} settings dataTables settings object
		 *  @returns {string} Data source
		 *  @memberof DataTable#oApi
		 */
		function _fnDataSource ( settings )
		{
			if ( settings.oFeatures.bServerSide ) {
				return 'ssp';
			}
			else if ( settings.ajax || settings.sAjaxSource ) {
				return 'ajax';
			}
			return 'dom';
		}
		
	
		
		
		/**
		 * Computed structure of the DataTables API, defined by the options passed to
		 * `DataTable.Api.register()` when building the API.
		 *
		 * The structure is built in order to speed creation and extension of the Api
		 * objects since the extensions are effectively pre-parsed.
		 *
		 * The array is an array of objects with the following structure, where this
		 * base array represents the Api prototype base:
		 *
		 *     [
		 *       {
		 *         name:      'data'                -- string   - Property name
		 *         val:       function () {},       -- function - Api method (or undefined if just an object
		 *         methodExt: [ ... ],              -- array    - Array of Api object definitions to extend the method result
		 *         propExt:   [ ... ]               -- array    - Array of Api object definitions to extend the property
		 *       },
		 *       {
		 *         name:     'row'
		 *         val:       {},
		 *         methodExt: [ ... ],
		 *         propExt:   [
		 *           {
		 *             name:      'data'
		 *             val:       function () {},
		 *             methodExt: [ ... ],
		 *             propExt:   [ ... ]
		 *           },
		 *           ...
		 *         ]
		 *       }
		 *     ]
		 *
		 * @type {Array}
		 * @ignore
		 */
		var __apiStruct = [];
		
		
		/**
		 * `Array.prototype` reference.
		 *
		 * @type object
		 * @ignore
		 */
		var __arrayProto = Array.prototype;
		
		
		/**
		 * Abstraction for `context` parameter of the `Api` constructor to allow it to
		 * take several different forms for ease of use.
		 *
		 * Each of the input parameter types will be converted to a DataTables settings
		 * object where possible.
		 *
		 * @param  {string|node|jQuery|object} mixed DataTable identifier. Can be one
		 *   of:
		 *
		 *   * `string` - jQuery selector. Any DataTables' matching the given selector
		 *     with be found and used.
		 *   * `node` - `TABLE` node which has already been formed into a DataTable.
		 *   * `jQuery` - A jQuery object of `TABLE` nodes.
		 *   * `object` - DataTables settings object
		 *   * `DataTables.Api` - API instance
		 * @return {array|null} Matching DataTables settings objects. `null` or
		 *   `undefined` is returned if no matching DataTable is found.
		 * @ignore
		 */
		var _toSettings = function ( mixed )
		{
			var idx, jq;
			var settings = DataTable.settings;
			var tables = $.map( settings, function (el, i) {
				return el.nTable;
			} );
		
			if ( ! mixed ) {
				return [];
			}
			else if ( mixed.nTable && mixed.oApi ) {
				// DataTables settings object
				return [ mixed ];
			}
			else if ( mixed.nodeName && mixed.nodeName.toLowerCase() === 'table' ) {
				// Table node
				idx = $.inArray( mixed, tables );
				return idx !== -1 ? [ settings[idx] ] : null;
			}
			else if ( mixed && typeof mixed.settings === 'function' ) {
				return mixed.settings().toArray();
			}
			else if ( typeof mixed === 'string' ) {
				// jQuery selector
				jq = $(mixed);
			}
			else if ( mixed instanceof $ ) {
				// jQuery object (also DataTables instance)
				jq = mixed;
			}
		
			if ( jq ) {
				return jq.map( function(i) {
					idx = $.inArray( this, tables );
					return idx !== -1 ? settings[idx] : null;
				} ).toArray();
			}
		};
		
		
		/**
		 * DataTables API class - used to control and interface with  one or more
		 * DataTables enhanced tables.
		 *
		 * The API class is heavily based on jQuery, presenting a chainable interface
		 * that you can use to interact with tables. Each instance of the API class has
		 * a "context" - i.e. the tables that it will operate on. This could be a single
		 * table, all tables on a page or a sub-set thereof.
		 *
		 * Additionally the API is designed to allow you to easily work with the data in
		 * the tables, retrieving and manipulating it as required. This is done by
		 * presenting the API class as an array like interface. The contents of the
		 * array depend upon the actions requested by each method (for example
		 * `rows().nodes()` will return an array of nodes, while `rows().data()` will
		 * return an array of objects or arrays depending upon your table's
		 * configuration). The API object has a number of array like methods (`push`,
		 * `pop`, `reverse` etc) as well as additional helper methods (`each`, `pluck`,
		 * `unique` etc) to assist your working with the data held in a table.
		 *
		 * Most methods (those which return an Api instance) are chainable, which means
		 * the return from a method call also has all of the methods available that the
		 * top level object had. For example, these two calls are equivalent:
		 *
		 *     // Not chained
		 *     api.row.add( {...} );
		 *     api.draw();
		 *
		 *     // Chained
		 *     api.row.add( {...} ).draw();
		 *
		 * @class DataTable.Api
		 * @param {array|object|string|jQuery} context DataTable identifier. This is
		 *   used to define which DataTables enhanced tables this API will operate on.
		 *   Can be one of:
		 *
		 *   * `string` - jQuery selector. Any DataTables' matching the given selector
		 *     with be found and used.
		 *   * `node` - `TABLE` node which has already been formed into a DataTable.
		 *   * `jQuery` - A jQuery object of `TABLE` nodes.
		 *   * `object` - DataTables settings object
		 * @param {array} [data] Data to initialise the Api instance with.
		 *
		 * @example
		 *   // Direct initialisation during DataTables construction
		 *   var api = $('#example').DataTable();
		 *
		 * @example
		 *   // Initialisation using a DataTables jQuery object
		 *   var api = $('#example').dataTable().api();
		 *
		 * @example
		 *   // Initialisation as a constructor
		 *   var api = new $.fn.DataTable.Api( 'table.dataTable' );
		 */
		_Api = function ( context, data )
		{
			if ( ! (this instanceof _Api) ) {
				return new _Api( context, data );
			}
		
			var settings = [];
			var ctxSettings = function ( o ) {
				var a = _toSettings( o );
				if ( a ) {
					settings = settings.concat( a );
				}
			};
		
			if ( $.isArray( context ) ) {
				for ( var i=0, ien=context.length ; i<ien ; i++ ) {
					ctxSettings( context[i] );
				}
			}
			else {
				ctxSettings( context );
			}
		
			// Remove duplicates
			this.context = _unique( settings );
		
			// Initial data
			if ( data ) {
				$.merge( this, data );
			}
		
			// selector
			this.selector = {
				rows: null,
				cols: null,
				opts: null
			};
		
			_Api.extend( this, this, __apiStruct );
		};
		
		DataTable.Api = _Api;
		
		// Don't destroy the existing prototype, just extend it. Required for jQuery 2's
		// isPlainObject.
		$.extend( _Api.prototype, {
			any: function ()
			{
				return this.count() !== 0;
			},
		
		
			concat:  __arrayProto.concat,
		
		
			context: [], // array of table settings objects
		
		
			count: function ()
			{
				return this.flatten().length;
			},
		
		
			each: function ( fn )
			{
				for ( var i=0, ien=this.length ; i<ien; i++ ) {
					fn.call( this, this[i], i, this );
				}
		
				return this;
			},
		
		
			eq: function ( idx )
			{
				var ctx = this.context;
		
				return ctx.length > idx ?
					new _Api( ctx[idx], this[idx] ) :
					null;
			},
		
		
			filter: function ( fn )
			{
				var a = [];
		
				if ( __arrayProto.filter ) {
					a = __arrayProto.filter.call( this, fn, this );
				}
				else {
					// Compatibility for browsers without EMCA-252-5 (JS 1.6)
					for ( var i=0, ien=this.length ; i<ien ; i++ ) {
						if ( fn.call( this, this[i], i, this ) ) {
							a.push( this[i] );
						}
					}
				}
		
				return new _Api( this.context, a );
			},
		
		
			flatten: function ()
			{
				var a = [];
				return new _Api( this.context, a.concat.apply( a, this.toArray() ) );
			},
		
		
			join:    __arrayProto.join,
		
		
			indexOf: __arrayProto.indexOf || function (obj, start)
			{
				for ( var i=(start || 0), ien=this.length ; i<ien ; i++ ) {
					if ( this[i] === obj ) {
						return i;
					}
				}
				return -1;
			},
		
			iterator: function ( flatten, type, fn, alwaysNew ) {
				var
					a = [], ret,
					i, ien, j, jen,
					context = this.context,
					rows, items, item,
					selector = this.selector;
		
				// Argument shifting
				if ( typeof flatten === 'string' ) {
					alwaysNew = fn;
					fn = type;
					type = flatten;
					flatten = false;
				}
		
				for ( i=0, ien=context.length ; i<ien ; i++ ) {
					var apiInst = new _Api( context[i] );
		
					if ( type === 'table' ) {
						ret = fn.call( apiInst, context[i], i );
		
						if ( ret !== undefined ) {
							a.push( ret );
						}
					}
					else if ( type === 'columns' || type === 'rows' ) {
						// this has same length as context - one entry for each table
						ret = fn.call( apiInst, context[i], this[i], i );
		
						if ( ret !== undefined ) {
							a.push( ret );
						}
					}
					else if ( type === 'column' || type === 'column-rows' || type === 'row' || type === 'cell' ) {
						// columns and rows share the same structure.
						// 'this' is an array of column indexes for each context
						items = this[i];
		
						if ( type === 'column-rows' ) {
							rows = _selector_row_indexes( context[i], selector.opts );
						}
		
						for ( j=0, jen=items.length ; j<jen ; j++ ) {
							item = items[j];
		
							if ( type === 'cell' ) {
								ret = fn.call( apiInst, context[i], item.row, item.column, i, j );
							}
							else {
								ret = fn.call( apiInst, context[i], item, i, j, rows );
							}
		
							if ( ret !== undefined ) {
								a.push( ret );
							}
						}
					}
				}
		
				if ( a.length || alwaysNew ) {
					var api = new _Api( context, flatten ? a.concat.apply( [], a ) : a );
					var apiSelector = api.selector;
					apiSelector.rows = selector.rows;
					apiSelector.cols = selector.cols;
					apiSelector.opts = selector.opts;
					return api;
				}
				return this;
			},
		
		
			lastIndexOf: __arrayProto.lastIndexOf || function (obj, start)
			{
				// Bit cheeky...
				return this.indexOf.apply( this.toArray.reverse(), arguments );
			},
		
		
			length:  0,
		
		
			map: function ( fn )
			{
				var a = [];
		
				if ( __arrayProto.map ) {
					a = __arrayProto.map.call( this, fn, this );
				}
				else {
					// Compatibility for browsers without EMCA-252-5 (JS 1.6)
					for ( var i=0, ien=this.length ; i<ien ; i++ ) {
						a.push( fn.call( this, this[i], i ) );
					}
				}
		
				return new _Api( this.context, a );
			},
		
		
			pluck: function ( prop )
			{
				return this.map( function ( el ) {
					return el[ prop ];
				} );
			},
		
			pop:     __arrayProto.pop,
		
		
			push:    __arrayProto.push,
		
		
			// Does not return an API instance
			reduce: __arrayProto.reduce || function ( fn, init )
			{
				return _fnReduce( this, fn, init, 0, this.length, 1 );
			},
		
		
			reduceRight: __arrayProto.reduceRight || function ( fn, init )
			{
				return _fnReduce( this, fn, init, this.length-1, -1, -1 );
			},
		
		
			reverse: __arrayProto.reverse,
		
		
			// Object with rows, columns and opts
			selector: null,
		
		
			shift:   __arrayProto.shift,
		
		
			sort:    __arrayProto.sort, // ? name - order?
		
		
			splice:  __arrayProto.splice,
		
		
			toArray: function ()
			{
				return __arrayProto.slice.call( this );
			},
		
		
			to$: function ()
			{
				return $( this );
			},
		
		
			toJQuery: function ()
			{
				return $( this );
			},
		
		
			unique: function ()
			{
				return new _Api( this.context, _unique(this) );
			},
		
		
			unshift: __arrayProto.unshift
		} );
		
		
		_Api.extend = function ( scope, obj, ext )
		{
			// Only extend API instances and static properties of the API
			if ( ! ext.length || ! obj || ( ! (obj instanceof _Api) && ! obj.__dt_wrapper ) ) {
				return;
			}
		
			var
				i, ien,
				j, jen,
				struct, inner,
				methodScoping = function ( scope, fn, struc ) {
					return function () {
						var ret = fn.apply( scope, arguments );
		
						// Method extension
						_Api.extend( ret, ret, struc.methodExt );
						return ret;
					};
				};
		
			for ( i=0, ien=ext.length ; i<ien ; i++ ) {
				struct = ext[i];
		
				// Value
				obj[ struct.name ] = typeof struct.val === 'function' ?
					methodScoping( scope, struct.val, struct ) :
					$.isPlainObject( struct.val ) ?
						{} :
						struct.val;
		
				obj[ struct.name ].__dt_wrapper = true;
		
				// Property extension
				_Api.extend( scope, obj[ struct.name ], struct.propExt );
			}
		};
		
		
		// @todo - Is there need for an augment function?
		// _Api.augment = function ( inst, name )
		// {
		// 	// Find src object in the structure from the name
		// 	var parts = name.split('.');
		
		// 	_Api.extend( inst, obj );
		// };
		
		
		//     [
		//       {
		//         name:      'data'                -- string   - Property name
		//         val:       function () {},       -- function - Api method (or undefined if just an object
		//         methodExt: [ ... ],              -- array    - Array of Api object definitions to extend the method result
		//         propExt:   [ ... ]               -- array    - Array of Api object definitions to extend the property
		//       },
		//       {
		//         name:     'row'
		//         val:       {},
		//         methodExt: [ ... ],
		//         propExt:   [
		//           {
		//             name:      'data'
		//             val:       function () {},
		//             methodExt: [ ... ],
		//             propExt:   [ ... ]
		//           },
		//           ...
		//         ]
		//       }
		//     ]
		
		_Api.register = _api_register = function ( name, val )
		{
			if ( $.isArray( name ) ) {
				for ( var j=0, jen=name.length ; j<jen ; j++ ) {
					_Api.register( name[j], val );
				}
				return;
			}
		
			var
				i, ien,
				heir = name.split('.'),
				struct = __apiStruct,
				key, method;
		
			var find = function ( src, name ) {
				for ( var i=0, ien=src.length ; i<ien ; i++ ) {
					if ( src[i].name === name ) {
						return src[i];
					}
				}
				return null;
			};
		
			for ( i=0, ien=heir.length ; i<ien ; i++ ) {
				method = heir[i].indexOf('()') !== -1;
				key = method ?
					heir[i].replace('()', '') :
					heir[i];
		
				var src = find( struct, key );
				if ( ! src ) {
					src = {
						name:      key,
						val:       {},
						methodExt: [],
						propExt:   []
					};
					struct.push( src );
				}
		
				if ( i === ien-1 ) {
					src.val = val;
				}
				else {
					struct = method ?
						src.methodExt :
						src.propExt;
				}
			}
		};
		
		
		_Api.registerPlural = _api_registerPlural = function ( pluralName, singularName, val ) {
			_Api.register( pluralName, val );
		
			_Api.register( singularName, function () {
				var ret = val.apply( this, arguments );
		
				if ( ret === this ) {
					// Returned item is the API instance that was passed in, return it
					return this;
				}
				else if ( ret instanceof _Api ) {
					// New API instance returned, want the value from the first item
					// in the returned array for the singular result.
					return ret.length ?
						$.isArray( ret[0] ) ?
							new _Api( ret.context, ret[0] ) : // Array results are 'enhanced'
							ret[0] :
						undefined;
				}
		
				// Non-API return - just fire it back
				return ret;
			} );
		};
		
		
		/**
		 * Selector for HTML tables. Apply the given selector to the give array of
		 * DataTables settings objects.
		 *
		 * @param {string|integer} [selector] jQuery selector string or integer
		 * @param  {array} Array of DataTables settings objects to be filtered
		 * @return {array}
		 * @ignore
		 */
		var __table_selector = function ( selector, a )
		{
			// Integer is used to pick out a table by index
			if ( typeof selector === 'number' ) {
				return [ a[ selector ] ];
			}
		
			// Perform a jQuery selector on the table nodes
			var nodes = $.map( a, function (el, i) {
				return el.nTable;
			} );
		
			return $(nodes)
				.filter( selector )
				.map( function (i) {
					// Need to translate back from the table node to the settings
					var idx = $.inArray( this, nodes );
					return a[ idx ];
				} )
				.toArray();
		};
		
		
		
		/**
		 * Context selector for the API's context (i.e. the tables the API instance
		 * refers to.
		 *
		 * @name    DataTable.Api#tables
		 * @param {string|integer} [selector] Selector to pick which tables the iterator
		 *   should operate on. If not given, all tables in the current context are
		 *   used. This can be given as a jQuery selector (for example `':gt(0)'`) to
		 *   select multiple tables or as an integer to select a single table.
		 * @returns {DataTable.Api} Returns a new API instance if a selector is given.
		 */
		_api_register( 'tables()', function ( selector ) {
			// A new instance is created if there was a selector specified
			return selector ?
				new _Api( __table_selector( selector, this.context ) ) :
				this;
		} );
		
		
		_api_register( 'table()', function ( selector ) {
			var tables = this.tables( selector );
			var ctx = tables.context;
		
			// Truncate to the first matched table
			return ctx.length ?
				new _Api( ctx[0] ) :
				tables;
		} );
		
		
		_api_registerPlural( 'tables().nodes()', 'table().node()' , function () {
			return this.iterator( 'table', function ( ctx ) {
				return ctx.nTable;
			}, 1 );
		} );
		
		
		_api_registerPlural( 'tables().body()', 'table().body()' , function () {
			return this.iterator( 'table', function ( ctx ) {
				return ctx.nTBody;
			}, 1 );
		} );
		
		
		_api_registerPlural( 'tables().header()', 'table().header()' , function () {
			return this.iterator( 'table', function ( ctx ) {
				return ctx.nTHead;
			}, 1 );
		} );
		
		
		_api_registerPlural( 'tables().footer()', 'table().footer()' , function () {
			return this.iterator( 'table', function ( ctx ) {
				return ctx.nTFoot;
			}, 1 );
		} );
		
		
		_api_registerPlural( 'tables().containers()', 'table().container()' , function () {
			return this.iterator( 'table', function ( ctx ) {
				return ctx.nTableWrapper;
			}, 1 );
		} );
		
		
		
		/**
		 * Redraw the tables in the current context.
		 */
		_api_register( 'draw()', function ( paging ) {
			return this.iterator( 'table', function ( settings ) {
				if ( paging === 'page' ) {
					_fnDraw( settings );
				}
				else {
					if ( typeof paging === 'string' ) {
						paging = paging === 'full-hold' ?
							false :
							true;
					}
		
					_fnReDraw( settings, paging===false );
				}
			} );
		} );
		
		
		
		/**
		 * Get the current page index.
		 *
		 * @return {integer} Current page index (zero based)
		 *//**
		 * Set the current page.
		 *
		 * Note that if you attempt to show a page which does not exist, DataTables will
		 * not throw an error, but rather reset the paging.
		 *
		 * @param {integer|string} action The paging action to take. This can be one of:
		 *  * `integer` - The page index to jump to
		 *  * `string` - An action to take:
		 *    * `first` - Jump to first page.
		 *    * `next` - Jump to the next page
		 *    * `previous` - Jump to previous page
		 *    * `last` - Jump to the last page.
		 * @returns {DataTables.Api} this
		 */
		_api_register( 'page()', function ( action ) {
			if ( action === undefined ) {
				return this.page.info().page; // not an expensive call
			}
		
			// else, have an action to take on all tables
			return this.iterator( 'table', function ( settings ) {
				_fnPageChange( settings, action );
			} );
		} );
		
		
		/**
		 * Paging information for the first table in the current context.
		 *
		 * If you require paging information for another table, use the `table()` method
		 * with a suitable selector.
		 *
		 * @return {object} Object with the following properties set:
		 *  * `page` - Current page index (zero based - i.e. the first page is `0`)
		 *  * `pages` - Total number of pages
		 *  * `start` - Display index for the first record shown on the current page
		 *  * `end` - Display index for the last record shown on the current page
		 *  * `length` - Display length (number of records). Note that generally `start
		 *    + length = end`, but this is not always true, for example if there are
		 *    only 2 records to show on the final page, with a length of 10.
		 *  * `recordsTotal` - Full data set length
		 *  * `recordsDisplay` - Data set length once the current filtering criterion
		 *    are applied.
		 */
		_api_register( 'page.info()', function ( action ) {
			if ( this.context.length === 0 ) {
				return undefined;
			}
		
			var
				settings   = this.context[0],
				start      = settings._iDisplayStart,
				len        = settings.oFeatures.bPaginate ? settings._iDisplayLength : -1,
				visRecords = settings.fnRecordsDisplay(),
				all        = len === -1;
		
			return {
				"page":           all ? 0 : Math.floor( start / len ),
				"pages":          all ? 1 : Math.ceil( visRecords / len ),
				"start":          start,
				"end":            settings.fnDisplayEnd(),
				"length":         len,
				"recordsTotal":   settings.fnRecordsTotal(),
				"recordsDisplay": visRecords,
				"serverSide":     _fnDataSource( settings ) === 'ssp'
			};
		} );
		
		
		/**
		 * Get the current page length.
		 *
		 * @return {integer} Current page length. Note `-1` indicates that all records
		 *   are to be shown.
		 *//**
		 * Set the current page length.
		 *
		 * @param {integer} Page length to set. Use `-1` to show all records.
		 * @returns {DataTables.Api} this
		 */
		_api_register( 'page.len()', function ( len ) {
			// Note that we can't call this function 'length()' because `length`
			// is a Javascript property of functions which defines how many arguments
			// the function expects.
			if ( len === undefined ) {
				return this.context.length !== 0 ?
					this.context[0]._iDisplayLength :
					undefined;
			}
		
			// else, set the page length
			return this.iterator( 'table', function ( settings ) {
				_fnLengthChange( settings, len );
			} );
		} );
		
		
		
		var __reload = function ( settings, holdPosition, callback ) {
			// Use the draw event to trigger a callback
			if ( callback ) {
				var api = new _Api( settings );
		
				api.one( 'draw', function () {
					callback( api.ajax.json() );
				} );
			}
		
			if ( _fnDataSource( settings ) == 'ssp' ) {
				_fnReDraw( settings, holdPosition );
			}
			else {
				_fnProcessingDisplay( settings, true );
		
				// Cancel an existing request
				var xhr = settings.jqXHR;
				if ( xhr && xhr.readyState !== 4 ) {
					xhr.abort();
				}
		
				// Trigger xhr
				_fnBuildAjax( settings, [], function( json ) {
					_fnClearTable( settings );
		
					var data = _fnAjaxDataSrc( settings, json );
					for ( var i=0, ien=data.length ; i<ien ; i++ ) {
						_fnAddData( settings, data[i] );
					}
		
					_fnReDraw( settings, holdPosition );
					_fnProcessingDisplay( settings, false );
				} );
			}
		};
		
		
		/**
		 * Get the JSON response from the last Ajax request that DataTables made to the
		 * server. Note that this returns the JSON from the first table in the current
		 * context.
		 *
		 * @return {object} JSON received from the server.
		 */
		_api_register( 'ajax.json()', function () {
			var ctx = this.context;
		
			if ( ctx.length > 0 ) {
				return ctx[0].json;
			}
		
			// else return undefined;
		} );
		
		
		/**
		 * Get the data submitted in the last Ajax request
		 */
		_api_register( 'ajax.params()', function () {
			var ctx = this.context;
		
			if ( ctx.length > 0 ) {
				return ctx[0].oAjaxData;
			}
		
			// else return undefined;
		} );
		
		
		/**
		 * Reload tables from the Ajax data source. Note that this function will
		 * automatically re-draw the table when the remote data has been loaded.
		 *
		 * @param {boolean} [reset=true] Reset (default) or hold the current paging
		 *   position. A full re-sort and re-filter is performed when this method is
		 *   called, which is why the pagination reset is the default action.
		 * @returns {DataTables.Api} this
		 */
		_api_register( 'ajax.reload()', function ( callback, resetPaging ) {
			return this.iterator( 'table', function (settings) {
				__reload( settings, resetPaging===false, callback );
			} );
		} );
		
		
		/**
		 * Get the current Ajax URL. Note that this returns the URL from the first
		 * table in the current context.
		 *
		 * @return {string} Current Ajax source URL
		 *//**
		 * Set the Ajax URL. Note that this will set the URL for all tables in the
		 * current context.
		 *
		 * @param {string} url URL to set.
		 * @returns {DataTables.Api} this
		 */
		_api_register( 'ajax.url()', function ( url ) {
			var ctx = this.context;
		
			if ( url === undefined ) {
				// get
				if ( ctx.length === 0 ) {
					return undefined;
				}
				ctx = ctx[0];
		
				return ctx.ajax ?
					$.isPlainObject( ctx.ajax ) ?
						ctx.ajax.url :
						ctx.ajax :
					ctx.sAjaxSource;
			}
		
			// set
			return this.iterator( 'table', function ( settings ) {
				if ( $.isPlainObject( settings.ajax ) ) {
					settings.ajax.url = url;
				}
				else {
					settings.ajax = url;
				}
				// No need to consider sAjaxSource here since DataTables gives priority
				// to `ajax` over `sAjaxSource`. So setting `ajax` here, renders any
				// value of `sAjaxSource` redundant.
			} );
		} );
		
		
		/**
		 * Load data from the newly set Ajax URL. Note that this method is only
		 * available when `ajax.url()` is used to set a URL. Additionally, this method
		 * has the same effect as calling `ajax.reload()` but is provided for
		 * convenience when setting a new URL. Like `ajax.reload()` it will
		 * automatically redraw the table once the remote data has been loaded.
		 *
		 * @returns {DataTables.Api} this
		 */
		_api_register( 'ajax.url().load()', function ( callback, resetPaging ) {
			// Same as a reload, but makes sense to present it for easy access after a
			// url change
			return this.iterator( 'table', function ( ctx ) {
				__reload( ctx, resetPaging===false, callback );
			} );
		} );
		
		
		
		
		var _selector_run = function ( type, selector, selectFn, settings, opts )
		{
			var
				out = [], res,
				a, i, ien, j, jen,
				selectorType = typeof selector;
		
			// Can't just check for isArray here, as an API or jQuery instance might be
			// given with their array like look
			if ( ! selector || selectorType === 'string' || selectorType === 'function' || selector.length === undefined ) {
				selector = [ selector ];
			}
		
			for ( i=0, ien=selector.length ; i<ien ; i++ ) {
				a = selector[i] && selector[i].split ?
					selector[i].split(',') :
					[ selector[i] ];
		
				for ( j=0, jen=a.length ; j<jen ; j++ ) {
					res = selectFn( typeof a[j] === 'string' ? $.trim(a[j]) : a[j] );
		
					if ( res && res.length ) {
						out = out.concat( res );
					}
				}
			}
		
			// selector extensions
			var ext = _ext.selector[ type ];
			if ( ext.length ) {
				for ( i=0, ien=ext.length ; i<ien ; i++ ) {
					out = ext[i]( settings, opts, out );
				}
			}
		
			return _unique( out );
		};
		
		
		var _selector_opts = function ( opts )
		{
			if ( ! opts ) {
				opts = {};
			}
		
			// Backwards compatibility for 1.9- which used the terminology filter rather
			// than search
			if ( opts.filter && opts.search === undefined ) {
				opts.search = opts.filter;
			}
		
			return $.extend( {
				search: 'none',
				order: 'current',
				page: 'all'
			}, opts );
		};
		
		
		var _selector_first = function ( inst )
		{
			// Reduce the API instance to the first item found
			for ( var i=0, ien=inst.length ; i<ien ; i++ ) {
				if ( inst[i].length > 0 ) {
					// Assign the first element to the first item in the instance
					// and truncate the instance and context
					inst[0] = inst[i];
					inst[0].length = 1;
					inst.length = 1;
					inst.context = [ inst.context[i] ];
		
					return inst;
				}
			}
		
			// Not found - return an empty instance
			inst.length = 0;
			return inst;
		};
		
		
		var _selector_row_indexes = function ( settings, opts )
		{
			var
				i, ien, tmp, a=[],
				displayFiltered = settings.aiDisplay,
				displayMaster = settings.aiDisplayMaster;
		
			var
				search = opts.search,  // none, applied, removed
				order  = opts.order,   // applied, current, index (original - compatibility with 1.9)
				page   = opts.page;    // all, current
		
			if ( _fnDataSource( settings ) == 'ssp' ) {
				// In server-side processing mode, most options are irrelevant since
				// rows not shown don't exist and the index order is the applied order
				// Removed is a special case - for consistency just return an empty
				// array
				return search === 'removed' ?
					[] :
					_range( 0, displayMaster.length );
			}
			else if ( page == 'current' ) {
				// Current page implies that order=current and fitler=applied, since it is
				// fairly senseless otherwise, regardless of what order and search actually
				// are
				for ( i=settings._iDisplayStart, ien=settings.fnDisplayEnd() ; i<ien ; i++ ) {
					a.push( displayFiltered[i] );
				}
			}
			else if ( order == 'current' || order == 'applied' ) {
				a = search == 'none' ?
					displayMaster.slice() :                      // no search
					search == 'applied' ?
						displayFiltered.slice() :                // applied search
						$.map( displayMaster, function (el, i) { // removed search
							return $.inArray( el, displayFiltered ) === -1 ? el : null;
						} );
			}
			else if ( order == 'index' || order == 'original' ) {
				for ( i=0, ien=settings.aoData.length ; i<ien ; i++ ) {
					if ( search == 'none' ) {
						a.push( i );
					}
					else { // applied | removed
						tmp = $.inArray( i, displayFiltered );
		
						if ((tmp === -1 && search == 'removed') ||
							(tmp >= 0   && search == 'applied') )
						{
							a.push( i );
						}
					}
				}
			}
		
			return a;
		};
		
		
		/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
		 * Rows
		 *
		 * {}          - no selector - use all available rows
		 * {integer}   - row aoData index
		 * {node}      - TR node
		 * {string}    - jQuery selector to apply to the TR elements
		 * {array}     - jQuery array of nodes, or simply an array of TR nodes
		 *
		 */
		
		
		var __row_selector = function ( settings, selector, opts )
		{
			var run = function ( sel ) {
				var selInt = _intVal( sel );
				var i, ien;
		
				// Short cut - selector is a number and no options provided (default is
				// all records, so no need to check if the index is in there, since it
				// must be - dev error if the index doesn't exist).
				if ( selInt !== null && ! opts ) {
					return [ selInt ];
				}
		
				var rows = _selector_row_indexes( settings, opts );
		
				if ( selInt !== null && $.inArray( selInt, rows ) !== -1 ) {
					// Selector - integer
					return [ selInt ];
				}
				else if ( ! sel ) {
					// Selector - none
					return rows;
				}
		
				// Selector - function
				if ( typeof sel === 'function' ) {
					return $.map( rows, function (idx) {
						var row = settings.aoData[ idx ];
						return sel( idx, row._aData, row.nTr ) ? idx : null;
					} );
				}
		
				// Get nodes in the order from the `rows` array with null values removed
				var nodes = _removeEmpty(
					_pluck_order( settings.aoData, rows, 'nTr' )
				);
		
				// Selector - node
				if ( sel.nodeName ) {
					if ( sel._DT_RowIndex !== undefined ) {
						return [ sel._DT_RowIndex ]; // Property added by DT for fast lookup
					}
					else if ( sel._DT_CellIndex ) {
						return [ sel._DT_CellIndex.row ];
					}
					else {
						var host = $(sel).closest('*[data-dt-row]');
						return host.length ?
							[ host.data('dt-row') ] :
							[];
					}
				}
		
				// ID selector. Want to always be able to select rows by id, regardless
				// of if the tr element has been created or not, so can't rely upon
				// jQuery here - hence a custom implementation. This does not match
				// Sizzle's fast selector or HTML4 - in HTML5 the ID can be anything,
				// but to select it using a CSS selector engine (like Sizzle or
				// querySelect) it would need to need to be escaped for some characters.
				// DataTables simplifies this for row selectors since you can select
				// only a row. A # indicates an id any anything that follows is the id -
				// unescaped.
				if ( typeof sel === 'string' && sel.charAt(0) === '#' ) {
					// get row index from id
					var rowObj = settings.aIds[ sel.replace( /^#/, '' ) ];
					if ( rowObj !== undefined ) {
						return [ rowObj.idx ];
					}
		
					// need to fall through to jQuery in case there is DOM id that
					// matches
				}
		
				// Selector - jQuery selector string, array of nodes or jQuery object/
				// As jQuery's .filter() allows jQuery objects to be passed in filter,
				// it also allows arrays, so this will cope with all three options
				return $(nodes)
					.filter( sel )
					.map( function () {
						return this._DT_RowIndex;
					} )
					.toArray();
			};
		
			return _selector_run( 'row', selector, run, settings, opts );
		};
		
		
		_api_register( 'rows()', function ( selector, opts ) {
			// argument shifting
			if ( selector === undefined ) {
				selector = '';
			}
			else if ( $.isPlainObject( selector ) ) {
				opts = selector;
				selector = '';
			}
		
			opts = _selector_opts( opts );
		
			var inst = this.iterator( 'table', function ( settings ) {
				return __row_selector( settings, selector, opts );
			}, 1 );
		
			// Want argument shifting here and in __row_selector?
			inst.selector.rows = selector;
			inst.selector.opts = opts;
		
			return inst;
		} );
		
		_api_register( 'rows().nodes()', function () {
			return this.iterator( 'row', function ( settings, row ) {
				return settings.aoData[ row ].nTr || undefined;
			}, 1 );
		} );
		
		_api_register( 'rows().data()', function () {
			return this.iterator( true, 'rows', function ( settings, rows ) {
				return _pluck_order( settings.aoData, rows, '_aData' );
			}, 1 );
		} );
		
		_api_registerPlural( 'rows().cache()', 'row().cache()', function ( type ) {
			return this.iterator( 'row', function ( settings, row ) {
				var r = settings.aoData[ row ];
				return type === 'search' ? r._aFilterData : r._aSortData;
			}, 1 );
		} );
		
		_api_registerPlural( 'rows().invalidate()', 'row().invalidate()', function ( src ) {
			return this.iterator( 'row', function ( settings, row ) {
				_fnInvalidate( settings, row, src );
			} );
		} );
		
		_api_registerPlural( 'rows().indexes()', 'row().index()', function () {
			return this.iterator( 'row', function ( settings, row ) {
				return row;
			}, 1 );
		} );
		
		_api_registerPlural( 'rows().ids()', 'row().id()', function ( hash ) {
			var a = [];
			var context = this.context;
		
			// `iterator` will drop undefined values, but in this case we want them
			for ( var i=0, ien=context.length ; i<ien ; i++ ) {
				for ( var j=0, jen=this[i].length ; j<jen ; j++ ) {
					var id = context[i].rowIdFn( context[i].aoData[ this[i][j] ]._aData );
					a.push( (hash === true ? '#' : '' )+ id );
				}
			}
		
			return new _Api( context, a );
		} );
		
		_api_registerPlural( 'rows().remove()', 'row().remove()', function () {
			var that = this;
		
			this.iterator( 'row', function ( settings, row, thatIdx ) {
				var data = settings.aoData;
				var rowData = data[ row ];
				var i, ien, j, jen;
				var loopRow, loopCells;
		
				data.splice( row, 1 );
		
				// Update the cached indexes
				for ( i=0, ien=data.length ; i<ien ; i++ ) {
					loopRow = data[i];
					loopCells = loopRow.anCells;
		
					// Rows
					if ( loopRow.nTr !== null ) {
						loopRow.nTr._DT_RowIndex = i;
					}
		
					// Cells
					if ( loopCells !== null ) {
						for ( j=0, jen=loopCells.length ; j<jen ; j++ ) {
							loopCells[j]._DT_CellIndex.row = i;
						}
					}
				}
		
				// Delete from the display arrays
				_fnDeleteIndex( settings.aiDisplayMaster, row );
				_fnDeleteIndex( settings.aiDisplay, row );
				_fnDeleteIndex( that[ thatIdx ], row, false ); // maintain local indexes
		
				// Check for an 'overflow' they case for displaying the table
				_fnLengthOverflow( settings );
		
				// Remove the row's ID reference if there is one
				var id = settings.rowIdFn( rowData._aData );
				if ( id !== undefined ) {
					delete settings.aIds[ id ];
				}
			} );
		
			this.iterator( 'table', function ( settings ) {
				for ( var i=0, ien=settings.aoData.length ; i<ien ; i++ ) {
					settings.aoData[i].idx = i;
				}
			} );
		
			return this;
		} );
		
		
		_api_register( 'rows.add()', function ( rows ) {
			var newRows = this.iterator( 'table', function ( settings ) {
					var row, i, ien;
					var out = [];
		
					for ( i=0, ien=rows.length ; i<ien ; i++ ) {
						row = rows[i];
		
						if ( row.nodeName && row.nodeName.toUpperCase() === 'TR' ) {
							out.push( _fnAddTr( settings, row )[0] );
						}
						else {
							out.push( _fnAddData( settings, row ) );
						}
					}
		
					return out;
				}, 1 );
		
			// Return an Api.rows() extended instance, so rows().nodes() etc can be used
			var modRows = this.rows( -1 );
			modRows.pop();
			$.merge( modRows, newRows );
		
			return modRows;
		} );
		
		
		
		
		
		/**
		 *
		 */
		_api_register( 'row()', function ( selector, opts ) {
			return _selector_first( this.rows( selector, opts ) );
		} );
		
		
		_api_register( 'row().data()', function ( data ) {
			var ctx = this.context;
		
			if ( data === undefined ) {
				// Get
				return ctx.length && this.length ?
					ctx[0].aoData[ this[0] ]._aData :
					undefined;
			}
		
			// Set
			ctx[0].aoData[ this[0] ]._aData = data;
		
			// Automatically invalidate
			_fnInvalidate( ctx[0], this[0], 'data' );
		
			return this;
		} );
		
		
		_api_register( 'row().node()', function () {
			var ctx = this.context;
		
			return ctx.length && this.length ?
				ctx[0].aoData[ this[0] ].nTr || null :
				null;
		} );
		
		
		_api_register( 'row.add()', function ( row ) {
			// Allow a jQuery object to be passed in - only a single row is added from
			// it though - the first element in the set
			if ( row instanceof $ && row.length ) {
				row = row[0];
			}
		
			var rows = this.iterator( 'table', function ( settings ) {
				if ( row.nodeName && row.nodeName.toUpperCase() === 'TR' ) {
					return _fnAddTr( settings, row )[0];
				}
				return _fnAddData( settings, row );
			} );
		
			// Return an Api.rows() extended instance, with the newly added row selected
			return this.row( rows[0] );
		} );
		
		
		
		var __details_add = function ( ctx, row, data, klass )
		{
			// Convert to array of TR elements
			var rows = [];
			var addRow = function ( r, k ) {
				// Recursion to allow for arrays of jQuery objects
				if ( $.isArray( r ) || r instanceof $ ) {
					for ( var i=0, ien=r.length ; i<ien ; i++ ) {
						addRow( r[i], k );
					}
					return;
				}
		
				// If we get a TR element, then just add it directly - up to the dev
				// to add the correct number of columns etc
				if ( r.nodeName && r.nodeName.toLowerCase() === 'tr' ) {
					rows.push( r );
				}
				else {
					// Otherwise create a row with a wrapper
					var created = $('<tr><td/></tr>').addClass( k );
					$('td', created)
						.addClass( k )
						.html( r )
						[0].colSpan = _fnVisbleColumns( ctx );
		
					rows.push( created[0] );
				}
			};
		
			addRow( data, klass );
		
			if ( row._details ) {
				row._details.remove();
			}
		
			row._details = $(rows);
		
			// If the children were already shown, that state should be retained
			if ( row._detailsShow ) {
				row._details.insertAfter( row.nTr );
			}
		};
		
		
		var __details_remove = function ( api, idx )
		{
			var ctx = api.context;
		
			if ( ctx.length ) {
				var row = ctx[0].aoData[ idx !== undefined ? idx : api[0] ];
		
				if ( row && row._details ) {
					row._details.remove();
		
					row._detailsShow = undefined;
					row._details = undefined;
				}
			}
		};
		
		
		var __details_display = function ( api, show ) {
			var ctx = api.context;
		
			if ( ctx.length && api.length ) {
				var row = ctx[0].aoData[ api[0] ];
		
				if ( row._details ) {
					row._detailsShow = show;
		
					if ( show ) {
						row._details.insertAfter( row.nTr );
					}
					else {
						row._details.detach();
					}
		
					__details_events( ctx[0] );
				}
			}
		};
		
		
		var __details_events = function ( settings )
		{
			var api = new _Api( settings );
			var namespace = '.dt.DT_details';
			var drawEvent = 'draw'+namespace;
			var colvisEvent = 'column-visibility'+namespace;
			var destroyEvent = 'destroy'+namespace;
			var data = settings.aoData;
		
			api.off( drawEvent +' '+ colvisEvent +' '+ destroyEvent );
		
			if ( _pluck( data, '_details' ).length > 0 ) {
				// On each draw, insert the required elements into the document
				api.on( drawEvent, function ( e, ctx ) {
					if ( settings !== ctx ) {
						return;
					}
		
					api.rows( {page:'current'} ).eq(0).each( function (idx) {
						// Internal data grab
						var row = data[ idx ];
		
						if ( row._detailsShow ) {
							row._details.insertAfter( row.nTr );
						}
					} );
				} );
		
				// Column visibility change - update the colspan
				api.on( colvisEvent, function ( e, ctx, idx, vis ) {
					if ( settings !== ctx ) {
						return;
					}
		
					// Update the colspan for the details rows (note, only if it already has
					// a colspan)
					var row, visible = _fnVisbleColumns( ctx );
		
					for ( var i=0, ien=data.length ; i<ien ; i++ ) {
						row = data[i];
		
						if ( row._details ) {
							row._details.children('td[colspan]').attr('colspan', visible );
						}
					}
				} );
		
				// Table destroyed - nuke any child rows
				api.on( destroyEvent, function ( e, ctx ) {
					if ( settings !== ctx ) {
						return;
					}
		
					for ( var i=0, ien=data.length ; i<ien ; i++ ) {
						if ( data[i]._details ) {
							__details_remove( api, i );
						}
					}
				} );
			}
		};
		
		// Strings for the method names to help minification
		var _emp = '';
		var _child_obj = _emp+'row().child';
		var _child_mth = _child_obj+'()';
		
		// data can be:
		//  tr
		//  string
		//  jQuery or array of any of the above
		_api_register( _child_mth, function ( data, klass ) {
			var ctx = this.context;
		
			if ( data === undefined ) {
				// get
				return ctx.length && this.length ?
					ctx[0].aoData[ this[0] ]._details :
					undefined;
			}
			else if ( data === true ) {
				// show
				this.child.show();
			}
			else if ( data === false ) {
				// remove
				__details_remove( this );
			}
			else if ( ctx.length && this.length ) {
				// set
				__details_add( ctx[0], ctx[0].aoData[ this[0] ], data, klass );
			}
		
			return this;
		} );
		
		
		_api_register( [
			_child_obj+'.show()',
			_child_mth+'.show()' // only when `child()` was called with parameters (without
		], function ( show ) {   // it returns an object and this method is not executed)
			__details_display( this, true );
			return this;
		} );
		
		
		_api_register( [
			_child_obj+'.hide()',
			_child_mth+'.hide()' // only when `child()` was called with parameters (without
		], function () {         // it returns an object and this method is not executed)
			__details_display( this, false );
			return this;
		} );
		
		
		_api_register( [
			_child_obj+'.remove()',
			_child_mth+'.remove()' // only when `child()` was called with parameters (without
		], function () {           // it returns an object and this method is not executed)
			__details_remove( this );
			return this;
		} );
		
		
		_api_register( _child_obj+'.isShown()', function () {
			var ctx = this.context;
		
			if ( ctx.length && this.length ) {
				// _detailsShown as false or undefined will fall through to return false
				return ctx[0].aoData[ this[0] ]._detailsShow || false;
			}
			return false;
		} );
		
		
		
		/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
		 * Columns
		 *
		 * {integer}           - column index (>=0 count from left, <0 count from right)
		 * "{integer}:visIdx"  - visible column index (i.e. translate to column index)  (>=0 count from left, <0 count from right)
		 * "{integer}:visible" - alias for {integer}:visIdx  (>=0 count from left, <0 count from right)
		 * "{string}:name"     - column name
		 * "{string}"          - jQuery selector on column header nodes
		 *
		 */
		
		// can be an array of these items, comma separated list, or an array of comma
		// separated lists
		
		var __re_column_selector = /^(.+):(name|visIdx|visible)$/;
		
		
		// r1 and r2 are redundant - but it means that the parameters match for the
		// iterator callback in columns().data()
		var __columnData = function ( settings, column, r1, r2, rows ) {
			var a = [];
			for ( var row=0, ien=rows.length ; row<ien ; row++ ) {
				a.push( _fnGetCellData( settings, rows[row], column ) );
			}
			return a;
		};
		
		
		var __column_selector = function ( settings, selector, opts )
		{
			var
				columns = settings.aoColumns,
				names = _pluck( columns, 'sName' ),
				nodes = _pluck( columns, 'nTh' );
		
			var run = function ( s ) {
				var selInt = _intVal( s );
		
				// Selector - all
				if ( s === '' ) {
					return _range( columns.length );
				}
		
				// Selector - index
				if ( selInt !== null ) {
					return [ selInt >= 0 ?
						selInt : // Count from left
						columns.length + selInt // Count from right (+ because its a negative value)
					];
				}
		
				// Selector = function
				if ( typeof s === 'function' ) {
					var rows = _selector_row_indexes( settings, opts );
		
					return $.map( columns, function (col, idx) {
						return s(
								idx,
								__columnData( settings, idx, 0, 0, rows ),
								nodes[ idx ]
							) ? idx : null;
					} );
				}
		
				// jQuery or string selector
				var match = typeof s === 'string' ?
					s.match( __re_column_selector ) :
					'';
		
				if ( match ) {
					switch( match[2] ) {
						case 'visIdx':
						case 'visible':
							var idx = parseInt( match[1], 10 );
							// Visible index given, convert to column index
							if ( idx < 0 ) {
								// Counting from the right
								var visColumns = $.map( columns, function (col,i) {
									return col.bVisible ? i : null;
								} );
								return [ visColumns[ visColumns.length + idx ] ];
							}
							// Counting from the left
							return [ _fnVisibleToColumnIndex( settings, idx ) ];
		
						case 'name':
							// match by name. `names` is column index complete and in order
							return $.map( names, function (name, i) {
								return name === match[1] ? i : null;
							} );
		
						default:
							return [];
					}
				}
		
				// Cell in the table body
				if ( s.nodeName && s._DT_CellIndex ) {
					return [ s._DT_CellIndex.column ];
				}
		
				// jQuery selector on the TH elements for the columns
				var jqResult = $( nodes )
					.filter( s )
					.map( function () {
						return $.inArray( this, nodes ); // `nodes` is column index complete and in order
					} )
					.toArray();
		
				if ( jqResult.length || ! s.nodeName ) {
					return jqResult;
				}
		
				// Otherwise a node which might have a `dt-column` data attribute, or be
				// a child or such an element
				var host = $(s).closest('*[data-dt-column]');
				return host.length ?
					[ host.data('dt-column') ] :
					[];
			};
		
			return _selector_run( 'column', selector, run, settings, opts );
		};
		
		
		var __setColumnVis = function ( settings, column, vis ) {
			var
				cols = settings.aoColumns,
				col  = cols[ column ],
				data = settings.aoData,
				row, cells, i, ien, tr;
		
			// Get
			if ( vis === undefined ) {
				return col.bVisible;
			}
		
			// Set
			// No change
			if ( col.bVisible === vis ) {
				return;
			}
		
			if ( vis ) {
				// Insert column
				// Need to decide if we should use appendChild or insertBefore
				var insertBefore = $.inArray( true, _pluck(cols, 'bVisible'), column+1 );
		
				for ( i=0, ien=data.length ; i<ien ; i++ ) {
					tr = data[i].nTr;
					cells = data[i].anCells;
		
					if ( tr ) {
						// insertBefore can act like appendChild if 2nd arg is null
						tr.insertBefore( cells[ column ], cells[ insertBefore ] || null );
					}
				}
			}
			else {
				// Remove column
				$( _pluck( settings.aoData, 'anCells', column ) ).detach();
			}
		
			// Common actions
			col.bVisible = vis;
			_fnDrawHead( settings, settings.aoHeader );
			_fnDrawHead( settings, settings.aoFooter );
		
			_fnSaveState( settings );
		};
		
		
		_api_register( 'columns()', function ( selector, opts ) {
			// argument shifting
			if ( selector === undefined ) {
				selector = '';
			}
			else if ( $.isPlainObject( selector ) ) {
				opts = selector;
				selector = '';
			}
		
			opts = _selector_opts( opts );
		
			var inst = this.iterator( 'table', function ( settings ) {
				return __column_selector( settings, selector, opts );
			}, 1 );
		
			// Want argument shifting here and in _row_selector?
			inst.selector.cols = selector;
			inst.selector.opts = opts;
		
			return inst;
		} );
		
		_api_registerPlural( 'columns().header()', 'column().header()', function ( selector, opts ) {
			return this.iterator( 'column', function ( settings, column ) {
				return settings.aoColumns[column].nTh;
			}, 1 );
		} );
		
		_api_registerPlural( 'columns().footer()', 'column().footer()', function ( selector, opts ) {
			return this.iterator( 'column', function ( settings, column ) {
				return settings.aoColumns[column].nTf;
			}, 1 );
		} );
		
		_api_registerPlural( 'columns().data()', 'column().data()', function () {
			return this.iterator( 'column-rows', __columnData, 1 );
		} );
		
		_api_registerPlural( 'columns().dataSrc()', 'column().dataSrc()', function () {
			return this.iterator( 'column', function ( settings, column ) {
				return settings.aoColumns[column].mData;
			}, 1 );
		} );
		
		_api_registerPlural( 'columns().cache()', 'column().cache()', function ( type ) {
			return this.iterator( 'column-rows', function ( settings, column, i, j, rows ) {
				return _pluck_order( settings.aoData, rows,
					type === 'search' ? '_aFilterData' : '_aSortData', column
				);
			}, 1 );
		} );
		
		_api_registerPlural( 'columns().nodes()', 'column().nodes()', function () {
			return this.iterator( 'column-rows', function ( settings, column, i, j, rows ) {
				return _pluck_order( settings.aoData, rows, 'anCells', column ) ;
			}, 1 );
		} );
		
		_api_registerPlural( 'columns().visible()', 'column().visible()', function ( vis, calc ) {
			var ret = this.iterator( 'column', function ( settings, column ) {
				if ( vis === undefined ) {
					return settings.aoColumns[ column ].bVisible;
				} // else
				__setColumnVis( settings, column, vis );
			} );
		
			// Group the column visibility changes
			if ( vis !== undefined ) {
				// Second loop once the first is done for events
				this.iterator( 'column', function ( settings, column ) {
					_fnCallbackFire( settings, null, 'column-visibility', [settings, column, vis, calc] );
				} );
		
				if ( calc === undefined || calc ) {
					this.columns.adjust();
				}
			}
		
			return ret;
		} );
		
		_api_registerPlural( 'columns().indexes()', 'column().index()', function ( type ) {
			return this.iterator( 'column', function ( settings, column ) {
				return type === 'visible' ?
					_fnColumnIndexToVisible( settings, column ) :
					column;
			}, 1 );
		} );
		
		_api_register( 'columns.adjust()', function () {
			return this.iterator( 'table', function ( settings ) {
				_fnAdjustColumnSizing( settings );
			}, 1 );
		} );
		
		_api_register( 'column.index()', function ( type, idx ) {
			if ( this.context.length !== 0 ) {
				var ctx = this.context[0];
		
				if ( type === 'fromVisible' || type === 'toData' ) {
					return _fnVisibleToColumnIndex( ctx, idx );
				}
				else if ( type === 'fromData' || type === 'toVisible' ) {
					return _fnColumnIndexToVisible( ctx, idx );
				}
			}
		} );
		
		_api_register( 'column()', function ( selector, opts ) {
			return _selector_first( this.columns( selector, opts ) );
		} );
		
		
		
		var __cell_selector = function ( settings, selector, opts )
		{
			var data = settings.aoData;
			var rows = _selector_row_indexes( settings, opts );
			var cells = _removeEmpty( _pluck_order( data, rows, 'anCells' ) );
			var allCells = $( [].concat.apply([], cells) );
			var row;
			var columns = settings.aoColumns.length;
			var a, i, ien, j, o, host;
		
			var run = function ( s ) {
				var fnSelector = typeof s === 'function';
		
				if ( s === null || s === undefined || fnSelector ) {
					// All cells and function selectors
					a = [];
		
					for ( i=0, ien=rows.length ; i<ien ; i++ ) {
						row = rows[i];
		
						for ( j=0 ; j<columns ; j++ ) {
							o = {
								row: row,
								column: j
							};
		
							if ( fnSelector ) {
								// Selector - function
								host = data[ row ];
		
								if ( s( o, _fnGetCellData(settings, row, j), host.anCells ? host.anCells[j] : null ) ) {
									a.push( o );
								}
							}
							else {
								// Selector - all
								a.push( o );
							}
						}
					}
		
					return a;
				}
				
				// Selector - index
				if ( $.isPlainObject( s ) ) {
					return [s];
				}
		
				// Selector - jQuery filtered cells
				var jqResult = allCells
					.filter( s )
					.map( function (i, el) {
						return { // use a new object, in case someone changes the values
							row:    el._DT_CellIndex.row,
							column: el._DT_CellIndex.column
		 				};
					} )
					.toArray();
		
				if ( jqResult.length || ! s.nodeName ) {
					return jqResult;
				}
		
				// Otherwise the selector is a node, and there is one last option - the
				// element might be a child of an element which has dt-row and dt-column
				// data attributes
				host = $(s).closest('*[data-dt-row]');
				return host.length ?
					[ {
						row: host.data('dt-row'),
						column: host.data('dt-column')
					} ] :
					[];
			};
		
			return _selector_run( 'cell', selector, run, settings, opts );
		};
		
		
		
		
		_api_register( 'cells()', function ( rowSelector, columnSelector, opts ) {
			// Argument shifting
			if ( $.isPlainObject( rowSelector ) ) {
				// Indexes
				if ( rowSelector.row === undefined ) {
					// Selector options in first parameter
					opts = rowSelector;
					rowSelector = null;
				}
				else {
					// Cell index objects in first parameter
					opts = columnSelector;
					columnSelector = null;
				}
			}
			if ( $.isPlainObject( columnSelector ) ) {
				opts = columnSelector;
				columnSelector = null;
			}
		
			// Cell selector
			if ( columnSelector === null || columnSelector === undefined ) {
				return this.iterator( 'table', function ( settings ) {
					return __cell_selector( settings, rowSelector, _selector_opts( opts ) );
				} );
			}
		
			// Row + column selector
			var columns = this.columns( columnSelector, opts );
			var rows = this.rows( rowSelector, opts );
			var a, i, ien, j, jen;
		
			var cells = this.iterator( 'table', function ( settings, idx ) {
				a = [];
		
				for ( i=0, ien=rows[idx].length ; i<ien ; i++ ) {
					for ( j=0, jen=columns[idx].length ; j<jen ; j++ ) {
						a.push( {
							row:    rows[idx][i],
							column: columns[idx][j]
						} );
					}
				}
		
				return a;
			}, 1 );
		
			$.extend( cells.selector, {
				cols: columnSelector,
				rows: rowSelector,
				opts: opts
			} );
		
			return cells;
		} );
		
		
		_api_registerPlural( 'cells().nodes()', 'cell().node()', function () {
			return this.iterator( 'cell', function ( settings, row, column ) {
				var data = settings.aoData[ row ];
		
				return data && data.anCells ?
					data.anCells[ column ] :
					undefined;
			}, 1 );
		} );
		
		
		_api_register( 'cells().data()', function () {
			return this.iterator( 'cell', function ( settings, row, column ) {
				return _fnGetCellData( settings, row, column );
			}, 1 );
		} );
		
		
		_api_registerPlural( 'cells().cache()', 'cell().cache()', function ( type ) {
			type = type === 'search' ? '_aFilterData' : '_aSortData';
		
			return this.iterator( 'cell', function ( settings, row, column ) {
				return settings.aoData[ row ][ type ][ column ];
			}, 1 );
		} );
		
		
		_api_registerPlural( 'cells().render()', 'cell().render()', function ( type ) {
			return this.iterator( 'cell', function ( settings, row, column ) {
				return _fnGetCellData( settings, row, column, type );
			}, 1 );
		} );
		
		
		_api_registerPlural( 'cells().indexes()', 'cell().index()', function () {
			return this.iterator( 'cell', function ( settings, row, column ) {
				return {
					row: row,
					column: column,
					columnVisible: _fnColumnIndexToVisible( settings, column )
				};
			}, 1 );
		} );
		
		
		_api_registerPlural( 'cells().invalidate()', 'cell().invalidate()', function ( src ) {
			return this.iterator( 'cell', function ( settings, row, column ) {
				_fnInvalidate( settings, row, src, column );
			} );
		} );
		
		
		
		_api_register( 'cell()', function ( rowSelector, columnSelector, opts ) {
			return _selector_first( this.cells( rowSelector, columnSelector, opts ) );
		} );
		
		
		_api_register( 'cell().data()', function ( data ) {
			var ctx = this.context;
			var cell = this[0];
		
			if ( data === undefined ) {
				// Get
				return ctx.length && cell.length ?
					_fnGetCellData( ctx[0], cell[0].row, cell[0].column ) :
					undefined;
			}
		
			// Set
			_fnSetCellData( ctx[0], cell[0].row, cell[0].column, data );
			_fnInvalidate( ctx[0], cell[0].row, 'data', cell[0].column );
		
			return this;
		} );
		
		
		
		/**
		 * Get current ordering (sorting) that has been applied to the table.
		 *
		 * @returns {array} 2D array containing the sorting information for the first
		 *   table in the current context. Each element in the parent array represents
		 *   a column being sorted upon (i.e. multi-sorting with two columns would have
		 *   2 inner arrays). The inner arrays may have 2 or 3 elements. The first is
		 *   the column index that the sorting condition applies to, the second is the
		 *   direction of the sort (`desc` or `asc`) and, optionally, the third is the
		 *   index of the sorting order from the `column.sorting` initialisation array.
		 *//**
		 * Set the ordering for the table.
		 *
		 * @param {integer} order Column index to sort upon.
		 * @param {string} direction Direction of the sort to be applied (`asc` or `desc`)
		 * @returns {DataTables.Api} this
		 *//**
		 * Set the ordering for the table.
		 *
		 * @param {array} order 1D array of sorting information to be applied.
		 * @param {array} [...] Optional additional sorting conditions
		 * @returns {DataTables.Api} this
		 *//**
		 * Set the ordering for the table.
		 *
		 * @param {array} order 2D array of sorting information to be applied.
		 * @returns {DataTables.Api} this
		 */
		_api_register( 'order()', function ( order, dir ) {
			var ctx = this.context;
		
			if ( order === undefined ) {
				// get
				return ctx.length !== 0 ?
					ctx[0].aaSorting :
					undefined;
			}
		
			// set
			if ( typeof order === 'number' ) {
				// Simple column / direction passed in
				order = [ [ order, dir ] ];
			}
			else if ( order.length && ! $.isArray( order[0] ) ) {
				// Arguments passed in (list of 1D arrays)
				order = Array.prototype.slice.call( arguments );
			}
			// otherwise a 2D array was passed in
		
			return this.iterator( 'table', function ( settings ) {
				settings.aaSorting = order.slice();
			} );
		} );
		
		
		/**
		 * Attach a sort listener to an element for a given column
		 *
		 * @param {node|jQuery|string} node Identifier for the element(s) to attach the
		 *   listener to. This can take the form of a single DOM node, a jQuery
		 *   collection of nodes or a jQuery selector which will identify the node(s).
		 * @param {integer} column the column that a click on this node will sort on
		 * @param {function} [callback] callback function when sort is run
		 * @returns {DataTables.Api} this
		 */
		_api_register( 'order.listener()', function ( node, column, callback ) {
			return this.iterator( 'table', function ( settings ) {
				_fnSortAttachListener( settings, node, column, callback );
			} );
		} );
		
		
		_api_register( 'order.fixed()', function ( set ) {
			if ( ! set ) {
				var ctx = this.context;
				var fixed = ctx.length ?
					ctx[0].aaSortingFixed :
					undefined;
		
				return $.isArray( fixed ) ?
					{ pre: fixed } :
					fixed;
			}
		
			return this.iterator( 'table', function ( settings ) {
				settings.aaSortingFixed = $.extend( true, {}, set );
			} );
		} );
		
		
		// Order by the selected column(s)
		_api_register( [
			'columns().order()',
			'column().order()'
		], function ( dir ) {
			var that = this;
		
			return this.iterator( 'table', function ( settings, i ) {
				var sort = [];
		
				$.each( that[i], function (j, col) {
					sort.push( [ col, dir ] );
				} );
		
				settings.aaSorting = sort;
			} );
		} );
		
		
		
		_api_register( 'search()', function ( input, regex, smart, caseInsen ) {
			var ctx = this.context;
		
			if ( input === undefined ) {
				// get
				return ctx.length !== 0 ?
					ctx[0].oPreviousSearch.sSearch :
					undefined;
			}
		
			// set
			return this.iterator( 'table', function ( settings ) {
				if ( ! settings.oFeatures.bFilter ) {
					return;
				}
		
				_fnFilterComplete( settings, $.extend( {}, settings.oPreviousSearch, {
					"sSearch": input+"",
					"bRegex":  regex === null ? false : regex,
					"bSmart":  smart === null ? true  : smart,
					"bCaseInsensitive": caseInsen === null ? true : caseInsen
				} ), 1 );
			} );
		} );
		
		
		_api_registerPlural(
			'columns().search()',
			'column().search()',
			function ( input, regex, smart, caseInsen ) {
				return this.iterator( 'column', function ( settings, column ) {
					var preSearch = settings.aoPreSearchCols;
		
					if ( input === undefined ) {
						// get
						return preSearch[ column ].sSearch;
					}
		
					// set
					if ( ! settings.oFeatures.bFilter ) {
						return;
					}
		
					$.extend( preSearch[ column ], {
						"sSearch": input+"",
						"bRegex":  regex === null ? false : regex,
						"bSmart":  smart === null ? true  : smart,
						"bCaseInsensitive": caseInsen === null ? true : caseInsen
					} );
		
					_fnFilterComplete( settings, settings.oPreviousSearch, 1 );
				} );
			}
		);
		
		/*
		 * State API methods
		 */
		
		_api_register( 'state()', function () {
			return this.context.length ?
				this.context[0].oSavedState :
				null;
		} );
		
		
		_api_register( 'state.clear()', function () {
			return this.iterator( 'table', function ( settings ) {
				// Save an empty object
				settings.fnStateSaveCallback.call( settings.oInstance, settings, {} );
			} );
		} );
		
		
		_api_register( 'state.loaded()', function () {
			return this.context.length ?
				this.context[0].oLoadedState :
				null;
		} );
		
		
		_api_register( 'state.save()', function () {
			return this.iterator( 'table', function ( settings ) {
				_fnSaveState( settings );
			} );
		} );
		
		
		
		/**
		 * Provide a common method for plug-ins to check the version of DataTables being
		 * used, in order to ensure compatibility.
		 *
		 *  @param {string} version Version string to check for, in the format "X.Y.Z".
		 *    Note that the formats "X" and "X.Y" are also acceptable.
		 *  @returns {boolean} true if this version of DataTables is greater or equal to
		 *    the required version, or false if this version of DataTales is not
		 *    suitable
		 *  @static
		 *  @dtopt API-Static
		 *
		 *  @example
		 *    alert( $.fn.dataTable.versionCheck( '1.9.0' ) );
		 */
		DataTable.versionCheck = DataTable.fnVersionCheck = function( version )
		{
			var aThis = DataTable.version.split('.');
			var aThat = version.split('.');
			var iThis, iThat;
		
			for ( var i=0, iLen=aThat.length ; i<iLen ; i++ ) {
				iThis = parseInt( aThis[i], 10 ) || 0;
				iThat = parseInt( aThat[i], 10 ) || 0;
		
				// Parts are the same, keep comparing
				if (iThis === iThat) {
					continue;
				}
		
				// Parts are different, return immediately
				return iThis > iThat;
			}
		
			return true;
		};
		
		
		/**
		 * Check if a `<table>` node is a DataTable table already or not.
		 *
		 *  @param {node|jquery|string} table Table node, jQuery object or jQuery
		 *      selector for the table to test. Note that if more than more than one
		 *      table is passed on, only the first will be checked
		 *  @returns {boolean} true the table given is a DataTable, or false otherwise
		 *  @static
		 *  @dtopt API-Static
		 *
		 *  @example
		 *    if ( ! $.fn.DataTable.isDataTable( '#example' ) ) {
		 *      $('#example').dataTable();
		 *    }
		 */
		DataTable.isDataTable = DataTable.fnIsDataTable = function ( table )
		{
			var t = $(table).get(0);
			var is = false;
		
			$.each( DataTable.settings, function (i, o) {
				var head = o.nScrollHead ? $('table', o.nScrollHead)[0] : null;
				var foot = o.nScrollFoot ? $('table', o.nScrollFoot)[0] : null;
		
				if ( o.nTable === t || head === t || foot === t ) {
					is = true;
				}
			} );
		
			return is;
		};
		
		
		/**
		 * Get all DataTable tables that have been initialised - optionally you can
		 * select to get only currently visible tables.
		 *
		 *  @param {boolean} [visible=false] Flag to indicate if you want all (default)
		 *    or visible tables only.
		 *  @returns {array} Array of `table` nodes (not DataTable instances) which are
		 *    DataTables
		 *  @static
		 *  @dtopt API-Static
		 *
		 *  @example
		 *    $.each( $.fn.dataTable.tables(true), function () {
		 *      $(table).DataTable().columns.adjust();
		 *    } );
		 */
		DataTable.tables = DataTable.fnTables = function ( visible )
		{
			var api = false;
		
			if ( $.isPlainObject( visible ) ) {
				api = visible.api;
				visible = visible.visible;
			}
		
			var a = $.map( DataTable.settings, function (o) {
				if ( !visible || (visible && $(o.nTable).is(':visible')) ) {
					return o.nTable;
				}
			} );
		
			return api ?
				new _Api( a ) :
				a;
		};
		
		
		/**
		 * Convert from camel case parameters to Hungarian notation. This is made public
		 * for the extensions to provide the same ability as DataTables core to accept
		 * either the 1.9 style Hungarian notation, or the 1.10+ style camelCase
		 * parameters.
		 *
		 *  @param {object} src The model object which holds all parameters that can be
		 *    mapped.
		 *  @param {object} user The object to convert from camel case to Hungarian.
		 *  @param {boolean} force When set to `true`, properties which already have a
		 *    Hungarian value in the `user` object will be overwritten. Otherwise they
		 *    won't be.
		 */
		DataTable.camelToHungarian = _fnCamelToHungarian;
		
		
		
		/**
		 *
		 */
		_api_register( '$()', function ( selector, opts ) {
			var
				rows   = this.rows( opts ).nodes(), // Get all rows
				jqRows = $(rows);
		
			return $( [].concat(
				jqRows.filter( selector ).toArray(),
				jqRows.find( selector ).toArray()
			) );
		} );
		
		
		// jQuery functions to operate on the tables
		$.each( [ 'on', 'one', 'off' ], function (i, key) {
			_api_register( key+'()', function ( /* event, handler */ ) {
				var args = Array.prototype.slice.call(arguments);
		
				// Add the `dt` namespace automatically if it isn't already present
				if ( ! args[0].match(/\.dt\b/) ) {
					args[0] += '.dt';
				}
		
				var inst = $( this.tables().nodes() );
				inst[key].apply( inst, args );
				return this;
			} );
		} );
		
		
		_api_register( 'clear()', function () {
			return this.iterator( 'table', function ( settings ) {
				_fnClearTable( settings );
			} );
		} );
		
		
		_api_register( 'settings()', function () {
			return new _Api( this.context, this.context );
		} );
		
		
		_api_register( 'init()', function () {
			var ctx = this.context;
			return ctx.length ? ctx[0].oInit : null;
		} );
		
		
		_api_register( 'data()', function () {
			return this.iterator( 'table', function ( settings ) {
				return _pluck( settings.aoData, '_aData' );
			} ).flatten();
		} );
		
		
		_api_register( 'destroy()', function ( remove ) {
			remove = remove || false;
		
			return this.iterator( 'table', function ( settings ) {
				var orig      = settings.nTableWrapper.parentNode;
				var classes   = settings.oClasses;
				var table     = settings.nTable;
				var tbody     = settings.nTBody;
				var thead     = settings.nTHead;
				var tfoot     = settings.nTFoot;
				var jqTable   = $(table);
				var jqTbody   = $(tbody);
				var jqWrapper = $(settings.nTableWrapper);
				var rows      = $.map( settings.aoData, function (r) { return r.nTr; } );
				var i, ien;
		
				// Flag to note that the table is currently being destroyed - no action
				// should be taken
				settings.bDestroying = true;
		
				// Fire off the destroy callbacks for plug-ins etc
				_fnCallbackFire( settings, "aoDestroyCallback", "destroy", [settings] );
		
				// If not being removed from the document, make all columns visible
				if ( ! remove ) {
					new _Api( settings ).columns().visible( true );
				}
		
				// Blitz all `DT` namespaced events (these are internal events, the
				// lowercase, `dt` events are user subscribed and they are responsible
				// for removing them
				jqWrapper.unbind('.DT').find(':not(tbody *)').unbind('.DT');
				$(window).unbind('.DT-'+settings.sInstance);
		
				// When scrolling we had to break the table up - restore it
				if ( table != thead.parentNode ) {
					jqTable.children('thead').detach();
					jqTable.append( thead );
				}
		
				if ( tfoot && table != tfoot.parentNode ) {
					jqTable.children('tfoot').detach();
					jqTable.append( tfoot );
				}
		
				settings.aaSorting = [];
				settings.aaSortingFixed = [];
				_fnSortingClasses( settings );
		
				$( rows ).removeClass( settings.asStripeClasses.join(' ') );
		
				$('th, td', thead).removeClass( classes.sSortable+' '+
					classes.sSortableAsc+' '+classes.sSortableDesc+' '+classes.sSortableNone
				);
		
				if ( settings.bJUI ) {
					$('th span.'+classes.sSortIcon+ ', td span.'+classes.sSortIcon, thead).detach();
					$('th, td', thead).each( function () {
						var wrapper = $('div.'+classes.sSortJUIWrapper, this);
						$(this).append( wrapper.contents() );
						wrapper.detach();
					} );
				}
		
				// Add the TR elements back into the table in their original order
				jqTbody.children().detach();
				jqTbody.append( rows );
		
				// Remove the DataTables generated nodes, events and classes
				var removedMethod = remove ? 'remove' : 'detach';
				jqTable[ removedMethod ]();
				jqWrapper[ removedMethod ]();
		
				// If we need to reattach the table to the document
				if ( ! remove && orig ) {
					// insertBefore acts like appendChild if !arg[1]
					orig.insertBefore( table, settings.nTableReinsertBefore );
		
					// Restore the width of the original table - was read from the style property,
					// so we can restore directly to that
					jqTable
						.css( 'width', settings.sDestroyWidth )
						.removeClass( classes.sTable );
		
					// If the were originally stripe classes - then we add them back here.
					// Note this is not fool proof (for example if not all rows had stripe
					// classes - but it's a good effort without getting carried away
					ien = settings.asDestroyStripes.length;
		
					if ( ien ) {
						jqTbody.children().each( function (i) {
							$(this).addClass( settings.asDestroyStripes[i % ien] );
						} );
					}
				}
		
				/* Remove the settings object from the settings array */
				var idx = $.inArray( settings, DataTable.settings );
				if ( idx !== -1 ) {
					DataTable.settings.splice( idx, 1 );
				}
			} );
		} );
		
		
		// Add the `every()` method for rows, columns and cells in a compact form
		$.each( [ 'column', 'row', 'cell' ], function ( i, type ) {
			_api_register( type+'s().every()', function ( fn ) {
				var opts = this.selector.opts;
				var api = this;
		
				return this.iterator( type, function ( settings, arg1, arg2, arg3, arg4 ) {
					// Rows and columns:
					//  arg1 - index
					//  arg2 - table counter
					//  arg3 - loop counter
					//  arg4 - undefined
					// Cells:
					//  arg1 - row index
					//  arg2 - column index
					//  arg3 - table counter
					//  arg4 - loop counter
					fn.call(
						api[ type ](
							arg1,
							type==='cell' ? arg2 : opts,
							type==='cell' ? opts : undefined
						),
						arg1, arg2, arg3, arg4
					);
				} );
			} );
		} );
		
		
		// i18n method for extensions to be able to use the language object from the
		// DataTable
		_api_register( 'i18n()', function ( token, def, plural ) {
			var ctx = this.context[0];
			var resolved = _fnGetObjectDataFn( token )( ctx.oLanguage );
		
			if ( resolved === undefined ) {
				resolved = def;
			}
		
			if ( plural !== undefined && $.isPlainObject( resolved ) ) {
				resolved = resolved[ plural ] !== undefined ?
					resolved[ plural ] :
					resolved._;
			}
		
			return resolved.replace( '%d', plural ); // nb: plural might be undefined,
		} );
	
		/**
		 * Version string for plug-ins to check compatibility. Allowed format is
		 * `a.b.c-d` where: a:int, b:int, c:int, d:string(dev|beta|alpha). `d` is used
		 * only for non-release builds. See http://semver.org/ for more information.
		 *  @member
		 *  @type string
		 *  @default Version number
		 */
		DataTable.version = "1.10.12";
	
		/**
		 * Private data store, containing all of the settings objects that are
		 * created for the tables on a given page.
		 *
		 * Note that the `DataTable.settings` object is aliased to
		 * `jQuery.fn.dataTableExt` through which it may be accessed and
		 * manipulated, or `jQuery.fn.dataTable.settings`.
		 *  @member
		 *  @type array
		 *  @default []
		 *  @private
		 */
		DataTable.settings = [];
	
		/**
		 * Object models container, for the various models that DataTables has
		 * available to it. These models define the objects that are used to hold
		 * the active state and configuration of the table.
		 *  @namespace
		 */
		DataTable.models = {};
		
		
		
		/**
		 * Template object for the way in which DataTables holds information about
		 * search information for the global filter and individual column filters.
		 *  @namespace
		 */
		DataTable.models.oSearch = {
			/**
			 * Flag to indicate if the filtering should be case insensitive or not
			 *  @type boolean
			 *  @default true
			 */
			"bCaseInsensitive": true,
		
			/**
			 * Applied search term
			 *  @type string
			 *  @default <i>Empty string</i>
			 */
			"sSearch": "",
		
			/**
			 * Flag to indicate if the search term should be interpreted as a
			 * regular expression (true) or not (false) and therefore and special
			 * regex characters escaped.
			 *  @type boolean
			 *  @default false
			 */
			"bRegex": false,
		
			/**
			 * Flag to indicate if DataTables is to use its smart filtering or not.
			 *  @type boolean
			 *  @default true
			 */
			"bSmart": true
		};
		
		
		
		
		/**
		 * Template object for the way in which DataTables holds information about
		 * each individual row. This is the object format used for the settings
		 * aoData array.
		 *  @namespace
		 */
		DataTable.models.oRow = {
			/**
			 * TR element for the row
			 *  @type node
			 *  @default null
			 */
			"nTr": null,
		
			/**
			 * Array of TD elements for each row. This is null until the row has been
			 * created.
			 *  @type array nodes
			 *  @default []
			 */
			"anCells": null,
		
			/**
			 * Data object from the original data source for the row. This is either
			 * an array if using the traditional form of DataTables, or an object if
			 * using mData options. The exact type will depend on the passed in
			 * data from the data source, or will be an array if using DOM a data
			 * source.
			 *  @type array|object
			 *  @default []
			 */
			"_aData": [],
		
			/**
			 * Sorting data cache - this array is ostensibly the same length as the
			 * number of columns (although each index is generated only as it is
			 * needed), and holds the data that is used for sorting each column in the
			 * row. We do this cache generation at the start of the sort in order that
			 * the formatting of the sort data need be done only once for each cell
			 * per sort. This array should not be read from or written to by anything
			 * other than the master sorting methods.
			 *  @type array
			 *  @default null
			 *  @private
			 */
			"_aSortData": null,
		
			/**
			 * Per cell filtering data cache. As per the sort data cache, used to
			 * increase the performance of the filtering in DataTables
			 *  @type array
			 *  @default null
			 *  @private
			 */
			"_aFilterData": null,
		
			/**
			 * Filtering data cache. This is the same as the cell filtering cache, but
			 * in this case a string rather than an array. This is easily computed with
			 * a join on `_aFilterData`, but is provided as a cache so the join isn't
			 * needed on every search (memory traded for performance)
			 *  @type array
			 *  @default null
			 *  @private
			 */
			"_sFilterRow": null,
		
			/**
			 * Cache of the class name that DataTables has applied to the row, so we
			 * can quickly look at this variable rather than needing to do a DOM check
			 * on className for the nTr property.
			 *  @type string
			 *  @default <i>Empty string</i>
			 *  @private
			 */
			"_sRowStripe": "",
		
			/**
			 * Denote if the original data source was from the DOM, or the data source
			 * object. This is used for invalidating data, so DataTables can
			 * automatically read data from the original source, unless uninstructed
			 * otherwise.
			 *  @type string
			 *  @default null
			 *  @private
			 */
			"src": null,
		
			/**
			 * Index in the aoData array. This saves an indexOf lookup when we have the
			 * object, but want to know the index
			 *  @type integer
			 *  @default -1
			 *  @private
			 */
			"idx": -1
		};
		
		
		/**
		 * Template object for the column information object in DataTables. This object
		 * is held in the settings aoColumns array and contains all the information that
		 * DataTables needs about each individual column.
		 *
		 * Note that this object is related to {@link DataTable.defaults.column}
		 * but this one is the internal data store for DataTables's cache of columns.
		 * It should NOT be manipulated outside of DataTables. Any configuration should
		 * be done through the initialisation options.
		 *  @namespace
		 */
		DataTable.models.oColumn = {
			/**
			 * Column index. This could be worked out on-the-fly with $.inArray, but it
			 * is faster to just hold it as a variable
			 *  @type integer
			 *  @default null
			 */
			"idx": null,
		
			/**
			 * A list of the columns that sorting should occur on when this column
			 * is sorted. That this property is an array allows multi-column sorting
			 * to be defined for a column (for example first name / last name columns
			 * would benefit from this). The values are integers pointing to the
			 * columns to be sorted on (typically it will be a single integer pointing
			 * at itself, but that doesn't need to be the case).
			 *  @type array
			 */
			"aDataSort": null,
		
			/**
			 * Define the sorting directions that are applied to the column, in sequence
			 * as the column is repeatedly sorted upon - i.e. the first value is used
			 * as the sorting direction when the column if first sorted (clicked on).
			 * Sort it again (click again) and it will move on to the next index.
			 * Repeat until loop.
			 *  @type array
			 */
			"asSorting": null,
		
			/**
			 * Flag to indicate if the column is searchable, and thus should be included
			 * in the filtering or not.
			 *  @type boolean
			 */
			"bSearchable": null,
		
			/**
			 * Flag to indicate if the column is sortable or not.
			 *  @type boolean
			 */
			"bSortable": null,
		
			/**
			 * Flag to indicate if the column is currently visible in the table or not
			 *  @type boolean
			 */
			"bVisible": null,
		
			/**
			 * Store for manual type assignment using the `column.type` option. This
			 * is held in store so we can manipulate the column's `sType` property.
			 *  @type string
			 *  @default null
			 *  @private
			 */
			"_sManualType": null,
		
			/**
			 * Flag to indicate if HTML5 data attributes should be used as the data
			 * source for filtering or sorting. True is either are.
			 *  @type boolean
			 *  @default false
			 *  @private
			 */
			"_bAttrSrc": false,
		
			/**
			 * Developer definable function that is called whenever a cell is created (Ajax source,
			 * etc) or processed for input (DOM source). This can be used as a compliment to mRender
			 * allowing you to modify the DOM element (add background colour for example) when the
			 * element is available.
			 *  @type function
			 *  @param {element} nTd The TD node that has been created
			 *  @param {*} sData The Data for the cell
			 *  @param {array|object} oData The data for the whole row
			 *  @param {int} iRow The row index for the aoData data store
			 *  @default null
			 */
			"fnCreatedCell": null,
		
			/**
			 * Function to get data from a cell in a column. You should <b>never</b>
			 * access data directly through _aData internally in DataTables - always use
			 * the method attached to this property. It allows mData to function as
			 * required. This function is automatically assigned by the column
			 * initialisation method
			 *  @type function
			 *  @param {array|object} oData The data array/object for the array
			 *    (i.e. aoData[]._aData)
			 *  @param {string} sSpecific The specific data type you want to get -
			 *    'display', 'type' 'filter' 'sort'
			 *  @returns {*} The data for the cell from the given row's data
			 *  @default null
			 */
			"fnGetData": null,
		
			/**
			 * Function to set data for a cell in the column. You should <b>never</b>
			 * set the data directly to _aData internally in DataTables - always use
			 * this method. It allows mData to function as required. This function
			 * is automatically assigned by the column initialisation method
			 *  @type function
			 *  @param {array|object} oData The data array/object for the array
			 *    (i.e. aoData[]._aData)
			 *  @param {*} sValue Value to set
			 *  @default null
			 */
			"fnSetData": null,
		
			/**
			 * Property to read the value for the cells in the column from the data
			 * source array / object. If null, then the default content is used, if a
			 * function is given then the return from the function is used.
			 *  @type function|int|string|null
			 *  @default null
			 */
			"mData": null,
		
			/**
			 * Partner property to mData which is used (only when defined) to get
			 * the data - i.e. it is basically the same as mData, but without the
			 * 'set' option, and also the data fed to it is the result from mData.
			 * This is the rendering method to match the data method of mData.
			 *  @type function|int|string|null
			 *  @default null
			 */
			"mRender": null,
		
			/**
			 * Unique header TH/TD element for this column - this is what the sorting
			 * listener is attached to (if sorting is enabled.)
			 *  @type node
			 *  @default null
			 */
			"nTh": null,
		
			/**
			 * Unique footer TH/TD element for this column (if there is one). Not used
			 * in DataTables as such, but can be used for plug-ins to reference the
			 * footer for each column.
			 *  @type node
			 *  @default null
			 */
			"nTf": null,
		
			/**
			 * The class to apply to all TD elements in the table's TBODY for the column
			 *  @type string
			 *  @default null
			 */
			"sClass": null,
		
			/**
			 * When DataTables calculates the column widths to assign to each column,
			 * it finds the longest string in each column and then constructs a
			 * temporary table and reads the widths from that. The problem with this
			 * is that "mmm" is much wider then "iiii", but the latter is a longer
			 * string - thus the calculation can go wrong (doing it properly and putting
			 * it into an DOM object and measuring that is horribly(!) slow). Thus as
			 * a "work around" we provide this option. It will append its value to the
			 * text that is found to be the longest string for the column - i.e. padding.
			 *  @type string
			 */
			"sContentPadding": null,
		
			/**
			 * Allows a default value to be given for a column's data, and will be used
			 * whenever a null data source is encountered (this can be because mData
			 * is set to null, or because the data source itself is null).
			 *  @type string
			 *  @default null
			 */
			"sDefaultContent": null,
		
			/**
			 * Name for the column, allowing reference to the column by name as well as
			 * by index (needs a lookup to work by name).
			 *  @type string
			 */
			"sName": null,
		
			/**
			 * Custom sorting data type - defines which of the available plug-ins in
			 * afnSortData the custom sorting will use - if any is defined.
			 *  @type string
			 *  @default std
			 */
			"sSortDataType": 'std',
		
			/**
			 * Class to be applied to the header element when sorting on this column
			 *  @type string
			 *  @default null
			 */
			"sSortingClass": null,
		
			/**
			 * Class to be applied to the header element when sorting on this column -
			 * when jQuery UI theming is used.
			 *  @type string
			 *  @default null
			 */
			"sSortingClassJUI": null,
		
			/**
			 * Title of the column - what is seen in the TH element (nTh).
			 *  @type string
			 */
			"sTitle": null,
		
			/**
			 * Column sorting and filtering type
			 *  @type string
			 *  @default null
			 */
			"sType": null,
		
			/**
			 * Width of the column
			 *  @type string
			 *  @default null
			 */
			"sWidth": null,
		
			/**
			 * Width of the column when it was first "encountered"
			 *  @type string
			 *  @default null
			 */
			"sWidthOrig": null
		};
		
		
		/*
		 * Developer note: The properties of the object below are given in Hungarian
		 * notation, that was used as the interface for DataTables prior to v1.10, however
		 * from v1.10 onwards the primary interface is camel case. In order to avoid
		 * breaking backwards compatibility utterly with this change, the Hungarian
		 * version is still, internally the primary interface, but is is not documented
		 * - hence the @name tags in each doc comment. This allows a Javascript function
		 * to create a map from Hungarian notation to camel case (going the other direction
		 * would require each property to be listed, which would at around 3K to the size
		 * of DataTables, while this method is about a 0.5K hit.
		 *
		 * Ultimately this does pave the way for Hungarian notation to be dropped
		 * completely, but that is a massive amount of work and will break current
		 * installs (therefore is on-hold until v2).
		 */
		
		/**
		 * Initialisation options that can be given to DataTables at initialisation
		 * time.
		 *  @namespace
		 */
		DataTable.defaults = {
			/**
			 * An array of data to use for the table, passed in at initialisation which
			 * will be used in preference to any data which is already in the DOM. This is
			 * particularly useful for constructing tables purely in Javascript, for
			 * example with a custom Ajax call.
			 *  @type array
			 *  @default null
			 *
			 *  @dtopt Option
			 *  @name DataTable.defaults.data
			 *
			 *  @example
			 *    // Using a 2D array data source
			 *    $(document).ready( function () {
			 *      $('#example').dataTable( {
			 *        "data": [
			 *          ['Trident', 'Internet Explorer 4.0', 'Win 95+', 4, 'X'],
			 *          ['Trident', 'Internet Explorer 5.0', 'Win 95+', 5, 'C'],
			 *        ],
			 *        "columns": [
			 *          { "title": "Engine" },
			 *          { "title": "Browser" },
			 *          { "title": "Platform" },
			 *          { "title": "Version" },
			 *          { "title": "Grade" }
			 *        ]
			 *      } );
			 *    } );
			 *
			 *  @example
			 *    // Using an array of objects as a data source (`data`)
			 *    $(document).ready( function () {
			 *      $('#example').dataTable( {
			 *        "data": [
			 *          {
			 *            "engine":   "Trident",
			 *            "browser":  "Internet Explorer 4.0",
			 *            "platform": "Win 95+",
			 *            "version":  4,
			 *            "grade":    "X"
			 *          },
			 *          {
			 *            "engine":   "Trident",
			 *            "browser":  "Internet Explorer 5.0",
			 *            "platform": "Win 95+",
			 *            "version":  5,
			 *            "grade":    "C"
			 *          }
			 *        ],
			 *        "columns": [
			 *          { "title": "Engine",   "data": "engine" },
			 *          { "title": "Browser",  "data": "browser" },
			 *          { "title": "Platform", "data": "platform" },
			 *          { "title": "Version",  "data": "version" },
			 *          { "title": "Grade",    "data": "grade" }
			 *        ]
			 *      } );
			 *    } );
			 */
			"aaData": null,
		
		
			/**
			 * If ordering is enabled, then DataTables will perform a first pass sort on
			 * initialisation. You can define which column(s) the sort is performed
			 * upon, and the sorting direction, with this variable. The `sorting` array
			 * should contain an array for each column to be sorted initially containing
			 * the column's index and a direction string ('asc' or 'desc').
			 *  @type array
			 *  @default [[0,'asc']]
			 *
			 *  @dtopt Option
			 *  @name DataTable.defaults.order
			 *
			 *  @example
			 *    // Sort by 3rd column first, and then 4th column
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "order": [[2,'asc'], [3,'desc']]
			 *      } );
			 *    } );
			 *
			 *    // No initial sorting
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "order": []
			 *      } );
			 *    } );
			 */
			"aaSorting": [[0,'asc']],
		
		
			/**
			 * This parameter is basically identical to the `sorting` parameter, but
			 * cannot be overridden by user interaction with the table. What this means
			 * is that you could have a column (visible or hidden) which the sorting
			 * will always be forced on first - any sorting after that (from the user)
			 * will then be performed as required. This can be useful for grouping rows
			 * together.
			 *  @type array
			 *  @default null
			 *
			 *  @dtopt Option
			 *  @name DataTable.defaults.orderFixed
			 *
			 *  @example
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "orderFixed": [[0,'asc']]
			 *      } );
			 *    } )
			 */
			"aaSortingFixed": [],
		
		
			/**
			 * DataTables can be instructed to load data to display in the table from a
			 * Ajax source. This option defines how that Ajax call is made and where to.
			 *
			 * The `ajax` property has three different modes of operation, depending on
			 * how it is defined. These are:
			 *
			 * * `string` - Set the URL from where the data should be loaded from.
			 * * `object` - Define properties for `jQuery.ajax`.
			 * * `function` - Custom data get function
			 *
			 * `string`
			 * --------
			 *
			 * As a string, the `ajax` property simply defines the URL from which
			 * DataTables will load data.
			 *
			 * `object`
			 * --------
			 *
			 * As an object, the parameters in the object are passed to
			 * [jQuery.ajax](http://api.jquery.com/jQuery.ajax/) allowing fine control
			 * of the Ajax request. DataTables has a number of default parameters which
			 * you can override using this option. Please refer to the jQuery
			 * documentation for a full description of the options available, although
			 * the following parameters provide additional options in DataTables or
			 * require special consideration:
			 *
			 * * `data` - As with jQuery, `data` can be provided as an object, but it
			 *   can also be used as a function to manipulate the data DataTables sends
			 *   to the server. The function takes a single parameter, an object of
			 *   parameters with the values that DataTables has readied for sending. An
			 *   object may be returned which will be merged into the DataTables
			 *   defaults, or you can add the items to the object that was passed in and
			 *   not return anything from the function. This supersedes `fnServerParams`
			 *   from DataTables 1.9-.
			 *
			 * * `dataSrc` - By default DataTables will look for the property `data` (or
			 *   `aaData` for compatibility with DataTables 1.9-) when obtaining data
			 *   from an Ajax source or for server-side processing - this parameter
			 *   allows that property to be changed. You can use Javascript dotted
			 *   object notation to get a data source for multiple levels of nesting, or
			 *   it my be used as a function. As a function it takes a single parameter,
			 *   the JSON returned from the server, which can be manipulated as
			 *   required, with the returned value being that used by DataTables as the
			 *   data source for the table. This supersedes `sAjaxDataProp` from
			 *   DataTables 1.9-.
			 *
			 * * `success` - Should not be overridden it is used internally in
			 *   DataTables. To manipulate / transform the data returned by the server
			 *   use `ajax.dataSrc`, or use `ajax` as a function (see below).
			 *
			 * `function`
			 * ----------
			 *
			 * As a function, making the Ajax call is left up to yourself allowing
			 * complete control of the Ajax request. Indeed, if desired, a method other
			 * than Ajax could be used to obtain the required data, such as Web storage
			 * or an AIR database.
			 *
			 * The function is given four parameters and no return is required. The
			 * parameters are:
			 *
			 * 1. _object_ - Data to send to the server
			 * 2. _function_ - Callback function that must be executed when the required
			 *    data has been obtained. That data should be passed into the callback
			 *    as the only parameter
			 * 3. _object_ - DataTables settings object for the table
			 *
			 * Note that this supersedes `fnServerData` from DataTables 1.9-.
			 *
			 *  @type string|object|function
			 *  @default null
			 *
			 *  @dtopt Option
			 *  @name DataTable.defaults.ajax
			 *  @since 1.10.0
			 *
			 * @example
			 *   // Get JSON data from a file via Ajax.
			 *   // Note DataTables expects data in the form `{ data: [ ...data... ] }` by default).
			 *   $('#example').dataTable( {
			 *     "ajax": "data.json"
			 *   } );
			 *
			 * @example
			 *   // Get JSON data from a file via Ajax, using `dataSrc` to change
			 *   // `data` to `tableData` (i.e. `{ tableData: [ ...data... ] }`)
			 *   $('#example').dataTable( {
			 *     "ajax": {
			 *       "url": "data.json",
			 *       "dataSrc": "tableData"
			 *     }
			 *   } );
			 *
			 * @example
			 *   // Get JSON data from a file via Ajax, using `dataSrc` to read data
			 *   // from a plain array rather than an array in an object
			 *   $('#example').dataTable( {
			 *     "ajax": {
			 *       "url": "data.json",
			 *       "dataSrc": ""
			 *     }
			 *   } );
			 *
			 * @example
			 *   // Manipulate the data returned from the server - add a link to data
			 *   // (note this can, should, be done using `render` for the column - this
			 *   // is just a simple example of how the data can be manipulated).
			 *   $('#example').dataTable( {
			 *     "ajax": {
			 *       "url": "data.json",
			 *       "dataSrc": function ( json ) {
			 *         for ( var i=0, ien=json.length ; i<ien ; i++ ) {
			 *           json[i][0] = '<a href="/message/'+json[i][0]+'>View message</a>';
			 *         }
			 *         return json;
			 *       }
			 *     }
			 *   } );
			 *
			 * @example
			 *   // Add data to the request
			 *   $('#example').dataTable( {
			 *     "ajax": {
			 *       "url": "data.json",
			 *       "data": function ( d ) {
			 *         return {
			 *           "extra_search": $('#extra').val()
			 *         };
			 *       }
			 *     }
			 *   } );
			 *
			 * @example
			 *   // Send request as POST
			 *   $('#example').dataTable( {
			 *     "ajax": {
			 *       "url": "data.json",
			 *       "type": "POST"
			 *     }
			 *   } );
			 *
			 * @example
			 *   // Get the data from localStorage (could interface with a form for
			 *   // adding, editing and removing rows).
			 *   $('#example').dataTable( {
			 *     "ajax": function (data, callback, settings) {
			 *       callback(
			 *         JSON.parse( localStorage.getItem('dataTablesData') )
			 *       );
			 *     }
			 *   } );
			 */
			"ajax": null,
		
		
			/**
			 * This parameter allows you to readily specify the entries in the length drop
			 * down menu that DataTables shows when pagination is enabled. It can be
			 * either a 1D array of options which will be used for both the displayed
			 * option and the value, or a 2D array which will use the array in the first
			 * position as the value, and the array in the second position as the
			 * displayed options (useful for language strings such as 'All').
			 *
			 * Note that the `pageLength` property will be automatically set to the
			 * first value given in this array, unless `pageLength` is also provided.
			 *  @type array
			 *  @default [ 10, 25, 50, 100 ]
			 *
			 *  @dtopt Option
			 *  @name DataTable.defaults.lengthMenu
			 *
			 *  @example
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "lengthMenu": [[10, 25, 50, -1], [10, 25, 50, "All"]]
			 *      } );
			 *    } );
			 */
			"aLengthMenu": [ 10, 25, 50, 100 ],
		
		
			/**
			 * The `columns` option in the initialisation parameter allows you to define
			 * details about the way individual columns behave. For a full list of
			 * column options that can be set, please see
			 * {@link DataTable.defaults.column}. Note that if you use `columns` to
			 * define your columns, you must have an entry in the array for every single
			 * column that you have in your table (these can be null if you don't which
			 * to specify any options).
			 *  @member
			 *
			 *  @name DataTable.defaults.column
			 */
			"aoColumns": null,
		
			/**
			 * Very similar to `columns`, `columnDefs` allows you to target a specific
			 * column, multiple columns, or all columns, using the `targets` property of
			 * each object in the array. This allows great flexibility when creating
			 * tables, as the `columnDefs` arrays can be of any length, targeting the
			 * columns you specifically want. `columnDefs` may use any of the column
			 * options available: {@link DataTable.defaults.column}, but it _must_
			 * have `targets` defined in each object in the array. Values in the `targets`
			 * array may be:
			 *   <ul>
			 *     <li>a string - class name will be matched on the TH for the column</li>
			 *     <li>0 or a positive integer - column index counting from the left</li>
			 *     <li>a negative integer - column index counting from the right</li>
			 *     <li>the string "_all" - all columns (i.e. assign a default)</li>
			 *   </ul>
			 *  @member
			 *
			 *  @name DataTable.defaults.columnDefs
			 */
			"aoColumnDefs": null,
		
		
			/**
			 * Basically the same as `search`, this parameter defines the individual column
			 * filtering state at initialisation time. The array must be of the same size
			 * as the number of columns, and each element be an object with the parameters
			 * `search` and `escapeRegex` (the latter is optional). 'null' is also
			 * accepted and the default will be used.
			 *  @type array
			 *  @default []
			 *
			 *  @dtopt Option
			 *  @name DataTable.defaults.searchCols
			 *
			 *  @example
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "searchCols": [
			 *          null,
			 *          { "search": "My filter" },
			 *          null,
			 *          { "search": "^[0-9]", "escapeRegex": false }
			 *        ]
			 *      } );
			 *    } )
			 */
			"aoSearchCols": [],
		
		
			/**
			 * An array of CSS classes that should be applied to displayed rows. This
			 * array may be of any length, and DataTables will apply each class
			 * sequentially, looping when required.
			 *  @type array
			 *  @default null <i>Will take the values determined by the `oClasses.stripe*`
			 *    options</i>
			 *
			 *  @dtopt Option
			 *  @name DataTable.defaults.stripeClasses
			 *
			 *  @example
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "stripeClasses": [ 'strip1', 'strip2', 'strip3' ]
			 *      } );
			 *    } )
			 */
			"asStripeClasses": null,
		
		
			/**
			 * Enable or disable automatic column width calculation. This can be disabled
			 * as an optimisation (it takes some time to calculate the widths) if the
			 * tables widths are passed in using `columns`.
			 *  @type boolean
			 *  @default true
			 *
			 *  @dtopt Features
			 *  @name DataTable.defaults.autoWidth
			 *
			 *  @example
			 *    $(document).ready( function () {
			 *      $('#example').dataTable( {
			 *        "autoWidth": false
			 *      } );
			 *    } );
			 */
			"bAutoWidth": true,
		
		
			/**
			 * Deferred rendering can provide DataTables with a huge speed boost when you
			 * are using an Ajax or JS data source for the table. This option, when set to
			 * true, will cause DataTables to defer the creation of the table elements for
			 * each row until they are needed for a draw - saving a significant amount of
			 * time.
			 *  @type boolean
			 *  @default false
			 *
			 *  @dtopt Features
			 *  @name DataTable.defaults.deferRender
			 *
			 *  @example
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "ajax": "sources/arrays.txt",
			 *        "deferRender": true
			 *      } );
			 *    } );
			 */
			"bDeferRender": false,
		
		
			/**
			 * Replace a DataTable which matches the given selector and replace it with
			 * one which has the properties of the new initialisation object passed. If no
			 * table matches the selector, then the new DataTable will be constructed as
			 * per normal.
			 *  @type boolean
			 *  @default false
			 *
			 *  @dtopt Options
			 *  @name DataTable.defaults.destroy
			 *
			 *  @example
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "srollY": "200px",
			 *        "paginate": false
			 *      } );
			 *
			 *      // Some time later....
			 *      $('#example').dataTable( {
			 *        "filter": false,
			 *        "destroy": true
			 *      } );
			 *    } );
			 */
			"bDestroy": false,
		
		
			/**
			 * Enable or disable filtering of data. Filtering in DataTables is "smart" in
			 * that it allows the end user to input multiple words (space separated) and
			 * will match a row containing those words, even if not in the order that was
			 * specified (this allow matching across multiple columns). Note that if you
			 * wish to use filtering in DataTables this must remain 'true' - to remove the
			 * default filtering input box and retain filtering abilities, please use
			 * {@link DataTable.defaults.dom}.
			 *  @type boolean
			 *  @default true
			 *
			 *  @dtopt Features
			 *  @name DataTable.defaults.searching
			 *
			 *  @example
			 *    $(document).ready( function () {
			 *      $('#example').dataTable( {
			 *        "searching": false
			 *      } );
			 *    } );
			 */
			"bFilter": true,
		
		
			/**
			 * Enable or disable the table information display. This shows information
			 * about the data that is currently visible on the page, including information
			 * about filtered data if that action is being performed.
			 *  @type boolean
			 *  @default true
			 *
			 *  @dtopt Features
			 *  @name DataTable.defaults.info
			 *
			 *  @example
			 *    $(document).ready( function () {
			 *      $('#example').dataTable( {
			 *        "info": false
			 *      } );
			 *    } );
			 */
			"bInfo": true,
		
		
			/**
			 * Enable jQuery UI ThemeRoller support (required as ThemeRoller requires some
			 * slightly different and additional mark-up from what DataTables has
			 * traditionally used).
			 *  @type boolean
			 *  @default false
			 *
			 *  @dtopt Features
			 *  @name DataTable.defaults.jQueryUI
			 *
			 *  @example
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "jQueryUI": true
			 *      } );
			 *    } );
			 */
			"bJQueryUI": false,
		
		
			/**
			 * Allows the end user to select the size of a formatted page from a select
			 * menu (sizes are 10, 25, 50 and 100). Requires pagination (`paginate`).
			 *  @type boolean
			 *  @default true
			 *
			 *  @dtopt Features
			 *  @name DataTable.defaults.lengthChange
			 *
			 *  @example
			 *    $(document).ready( function () {
			 *      $('#example').dataTable( {
			 *        "lengthChange": false
			 *      } );
			 *    } );
			 */
			"bLengthChange": true,
		
		
			/**
			 * Enable or disable pagination.
			 *  @type boolean
			 *  @default true
			 *
			 *  @dtopt Features
			 *  @name DataTable.defaults.paging
			 *
			 *  @example
			 *    $(document).ready( function () {
			 *      $('#example').dataTable( {
			 *        "paging": false
			 *      } );
			 *    } );
			 */
			"bPaginate": true,
		
		
			/**
			 * Enable or disable the display of a 'processing' indicator when the table is
			 * being processed (e.g. a sort). This is particularly useful for tables with
			 * large amounts of data where it can take a noticeable amount of time to sort
			 * the entries.
			 *  @type boolean
			 *  @default false
			 *
			 *  @dtopt Features
			 *  @name DataTable.defaults.processing
			 *
			 *  @example
			 *    $(document).ready( function () {
			 *      $('#example').dataTable( {
			 *        "processing": true
			 *      } );
			 *    } );
			 */
			"bProcessing": false,
		
		
			/**
			 * Retrieve the DataTables object for the given selector. Note that if the
			 * table has already been initialised, this parameter will cause DataTables
			 * to simply return the object that has already been set up - it will not take
			 * account of any changes you might have made to the initialisation object
			 * passed to DataTables (setting this parameter to true is an acknowledgement
			 * that you understand this). `destroy` can be used to reinitialise a table if
			 * you need.
			 *  @type boolean
			 *  @default false
			 *
			 *  @dtopt Options
			 *  @name DataTable.defaults.retrieve
			 *
			 *  @example
			 *    $(document).ready( function() {
			 *      initTable();
			 *      tableActions();
			 *    } );
			 *
			 *    function initTable ()
			 *    {
			 *      return $('#example').dataTable( {
			 *        "scrollY": "200px",
			 *        "paginate": false,
			 *        "retrieve": true
			 *      } );
			 *    }
			 *
			 *    function tableActions ()
			 *    {
			 *      var table = initTable();
			 *      // perform API operations with oTable
			 *    }
			 */
			"bRetrieve": false,
		
		
			/**
			 * When vertical (y) scrolling is enabled, DataTables will force the height of
			 * the table's viewport to the given height at all times (useful for layout).
			 * However, this can look odd when filtering data down to a small data set,
			 * and the footer is left "floating" further down. This parameter (when
			 * enabled) will cause DataTables to collapse the table's viewport down when
			 * the result set will fit within the given Y height.
			 *  @type boolean
			 *  @default false
			 *
			 *  @dtopt Options
			 *  @name DataTable.defaults.scrollCollapse
			 *
			 *  @example
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "scrollY": "200",
			 *        "scrollCollapse": true
			 *      } );
			 *    } );
			 */
			"bScrollCollapse": false,
		
		
			/**
			 * Configure DataTables to use server-side processing. Note that the
			 * `ajax` parameter must also be given in order to give DataTables a
			 * source to obtain the required data for each draw.
			 *  @type boolean
			 *  @default false
			 *
			 *  @dtopt Features
			 *  @dtopt Server-side
			 *  @name DataTable.defaults.serverSide
			 *
			 *  @example
			 *    $(document).ready( function () {
			 *      $('#example').dataTable( {
			 *        "serverSide": true,
			 *        "ajax": "xhr.php"
			 *      } );
			 *    } );
			 */
			"bServerSide": false,
		
		
			/**
			 * Enable or disable sorting of columns. Sorting of individual columns can be
			 * disabled by the `sortable` option for each column.
			 *  @type boolean
			 *  @default true
			 *
			 *  @dtopt Features
			 *  @name DataTable.defaults.ordering
			 *
			 *  @example
			 *    $(document).ready( function () {
			 *      $('#example').dataTable( {
			 *        "ordering": false
			 *      } );
			 *    } );
			 */
			"bSort": true,
		
		
			/**
			 * Enable or display DataTables' ability to sort multiple columns at the
			 * same time (activated by shift-click by the user).
			 *  @type boolean
			 *  @default true
			 *
			 *  @dtopt Options
			 *  @name DataTable.defaults.orderMulti
			 *
			 *  @example
			 *    // Disable multiple column sorting ability
			 *    $(document).ready( function () {
			 *      $('#example').dataTable( {
			 *        "orderMulti": false
			 *      } );
			 *    } );
			 */
			"bSortMulti": true,
		
		
			/**
			 * Allows control over whether DataTables should use the top (true) unique
			 * cell that is found for a single column, or the bottom (false - default).
			 * This is useful when using complex headers.
			 *  @type boolean
			 *  @default false
			 *
			 *  @dtopt Options
			 *  @name DataTable.defaults.orderCellsTop
			 *
			 *  @example
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "orderCellsTop": true
			 *      } );
			 *    } );
			 */
			"bSortCellsTop": false,
		
		
			/**
			 * Enable or disable the addition of the classes `sorting\_1`, `sorting\_2` and
			 * `sorting\_3` to the columns which are currently being sorted on. This is
			 * presented as a feature switch as it can increase processing time (while
			 * classes are removed and added) so for large data sets you might want to
			 * turn this off.
			 *  @type boolean
			 *  @default true
			 *
			 *  @dtopt Features
			 *  @name DataTable.defaults.orderClasses
			 *
			 *  @example
			 *    $(document).ready( function () {
			 *      $('#example').dataTable( {
			 *        "orderClasses": false
			 *      } );
			 *    } );
			 */
			"bSortClasses": true,
		
		
			/**
			 * Enable or disable state saving. When enabled HTML5 `localStorage` will be
			 * used to save table display information such as pagination information,
			 * display length, filtering and sorting. As such when the end user reloads
			 * the page the display display will match what thy had previously set up.
			 *
			 * Due to the use of `localStorage` the default state saving is not supported
			 * in IE6 or 7. If state saving is required in those browsers, use
			 * `stateSaveCallback` to provide a storage solution such as cookies.
			 *  @type boolean
			 *  @default false
			 *
			 *  @dtopt Features
			 *  @name DataTable.defaults.stateSave
			 *
			 *  @example
			 *    $(document).ready( function () {
			 *      $('#example').dataTable( {
			 *        "stateSave": true
			 *      } );
			 *    } );
			 */
			"bStateSave": false,
		
		
			/**
			 * This function is called when a TR element is created (and all TD child
			 * elements have been inserted), or registered if using a DOM source, allowing
			 * manipulation of the TR element (adding classes etc).
			 *  @type function
			 *  @param {node} row "TR" element for the current row
			 *  @param {array} data Raw data array for this row
			 *  @param {int} dataIndex The index of this row in the internal aoData array
			 *
			 *  @dtopt Callbacks
			 *  @name DataTable.defaults.createdRow
			 *
			 *  @example
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "createdRow": function( row, data, dataIndex ) {
			 *          // Bold the grade for all 'A' grade browsers
			 *          if ( data[4] == "A" )
			 *          {
			 *            $('td:eq(4)', row).html( '<b>A</b>' );
			 *          }
			 *        }
			 *      } );
			 *    } );
			 */
			"fnCreatedRow": null,
		
		
			/**
			 * This function is called on every 'draw' event, and allows you to
			 * dynamically modify any aspect you want about the created DOM.
			 *  @type function
			 *  @param {object} settings DataTables settings object
			 *
			 *  @dtopt Callbacks
			 *  @name DataTable.defaults.drawCallback
			 *
			 *  @example
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "drawCallback": function( settings ) {
			 *          alert( 'DataTables has redrawn the table' );
			 *        }
			 *      } );
			 *    } );
			 */
			"fnDrawCallback": null,
		
		
			/**
			 * Identical to fnHeaderCallback() but for the table footer this function
			 * allows you to modify the table footer on every 'draw' event.
			 *  @type function
			 *  @param {node} foot "TR" element for the footer
			 *  @param {array} data Full table data (as derived from the original HTML)
			 *  @param {int} start Index for the current display starting point in the
			 *    display array
			 *  @param {int} end Index for the current display ending point in the
			 *    display array
			 *  @param {array int} display Index array to translate the visual position
			 *    to the full data array
			 *
			 *  @dtopt Callbacks
			 *  @name DataTable.defaults.footerCallback
			 *
			 *  @example
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "footerCallback": function( tfoot, data, start, end, display ) {
			 *          tfoot.getElementsByTagName('th')[0].innerHTML = "Starting index is "+start;
			 *        }
			 *      } );
			 *    } )
			 */
			"fnFooterCallback": null,
		
		
			/**
			 * When rendering large numbers in the information element for the table
			 * (i.e. "Showing 1 to 10 of 57 entries") DataTables will render large numbers
			 * to have a comma separator for the 'thousands' units (e.g. 1 million is
			 * rendered as "1,000,000") to help readability for the end user. This
			 * function will override the default method DataTables uses.
			 *  @type function
			 *  @member
			 *  @param {int} toFormat number to be formatted
			 *  @returns {string} formatted string for DataTables to show the number
			 *
			 *  @dtopt Callbacks
			 *  @name DataTable.defaults.formatNumber
			 *
			 *  @example
			 *    // Format a number using a single quote for the separator (note that
			 *    // this can also be done with the language.thousands option)
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "formatNumber": function ( toFormat ) {
			 *          return toFormat.toString().replace(
			 *            /\B(?=(\d{3})+(?!\d))/g, "'"
			 *          );
			 *        };
			 *      } );
			 *    } );
			 */
			"fnFormatNumber": function ( toFormat ) {
				return toFormat.toString().replace(
					/\B(?=(\d{3})+(?!\d))/g,
					this.oLanguage.sThousands
				);
			},
		
		
			/**
			 * This function is called on every 'draw' event, and allows you to
			 * dynamically modify the header row. This can be used to calculate and
			 * display useful information about the table.
			 *  @type function
			 *  @param {node} head "TR" element for the header
			 *  @param {array} data Full table data (as derived from the original HTML)
			 *  @param {int} start Index for the current display starting point in the
			 *    display array
			 *  @param {int} end Index for the current display ending point in the
			 *    display array
			 *  @param {array int} display Index array to translate the visual position
			 *    to the full data array
			 *
			 *  @dtopt Callbacks
			 *  @name DataTable.defaults.headerCallback
			 *
			 *  @example
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "fheaderCallback": function( head, data, start, end, display ) {
			 *          head.getElementsByTagName('th')[0].innerHTML = "Displaying "+(end-start)+" records";
			 *        }
			 *      } );
			 *    } )
			 */
			"fnHeaderCallback": null,
		
		
			/**
			 * The information element can be used to convey information about the current
			 * state of the table. Although the internationalisation options presented by
			 * DataTables are quite capable of dealing with most customisations, there may
			 * be times where you wish to customise the string further. This callback
			 * allows you to do exactly that.
			 *  @type function
			 *  @param {object} oSettings DataTables settings object
			 *  @param {int} start Starting position in data for the draw
			 *  @param {int} end End position in data for the draw
			 *  @param {int} max Total number of rows in the table (regardless of
			 *    filtering)
			 *  @param {int} total Total number of rows in the data set, after filtering
			 *  @param {string} pre The string that DataTables has formatted using it's
			 *    own rules
			 *  @returns {string} The string to be displayed in the information element.
			 *
			 *  @dtopt Callbacks
			 *  @name DataTable.defaults.infoCallback
			 *
			 *  @example
			 *    $('#example').dataTable( {
			 *      "infoCallback": function( settings, start, end, max, total, pre ) {
			 *        return start +" to "+ end;
			 *      }
			 *    } );
			 */
			"fnInfoCallback": null,
		
		
			/**
			 * Called when the table has been initialised. Normally DataTables will
			 * initialise sequentially and there will be no need for this function,
			 * however, this does not hold true when using external language information
			 * since that is obtained using an async XHR call.
			 *  @type function
			 *  @param {object} settings DataTables settings object
			 *  @param {object} json The JSON object request from the server - only
			 *    present if client-side Ajax sourced data is used
			 *
			 *  @dtopt Callbacks
			 *  @name DataTable.defaults.initComplete
			 *
			 *  @example
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "initComplete": function(settings, json) {
			 *          alert( 'DataTables has finished its initialisation.' );
			 *        }
			 *      } );
			 *    } )
			 */
			"fnInitComplete": null,
		
		
			/**
			 * Called at the very start of each table draw and can be used to cancel the
			 * draw by returning false, any other return (including undefined) results in
			 * the full draw occurring).
			 *  @type function
			 *  @param {object} settings DataTables settings object
			 *  @returns {boolean} False will cancel the draw, anything else (including no
			 *    return) will allow it to complete.
			 *
			 *  @dtopt Callbacks
			 *  @name DataTable.defaults.preDrawCallback
			 *
			 *  @example
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "preDrawCallback": function( settings ) {
			 *          if ( $('#test').val() == 1 ) {
			 *            return false;
			 *          }
			 *        }
			 *      } );
			 *    } );
			 */
			"fnPreDrawCallback": null,
		
		
			/**
			 * This function allows you to 'post process' each row after it have been
			 * generated for each table draw, but before it is rendered on screen. This
			 * function might be used for setting the row class name etc.
			 *  @type function
			 *  @param {node} row "TR" element for the current row
			 *  @param {array} data Raw data array for this row
			 *  @param {int} displayIndex The display index for the current table draw
			 *  @param {int} displayIndexFull The index of the data in the full list of
			 *    rows (after filtering)
			 *
			 *  @dtopt Callbacks
			 *  @name DataTable.defaults.rowCallback
			 *
			 *  @example
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "rowCallback": function( row, data, displayIndex, displayIndexFull ) {
			 *          // Bold the grade for all 'A' grade browsers
			 *          if ( data[4] == "A" ) {
			 *            $('td:eq(4)', row).html( '<b>A</b>' );
			 *          }
			 *        }
			 *      } );
			 *    } );
			 */
			"fnRowCallback": null,
		
		
			/**
			 * __Deprecated__ The functionality provided by this parameter has now been
			 * superseded by that provided through `ajax`, which should be used instead.
			 *
			 * This parameter allows you to override the default function which obtains
			 * the data from the server so something more suitable for your application.
			 * For example you could use POST data, or pull information from a Gears or
			 * AIR database.
			 *  @type function
			 *  @member
			 *  @param {string} source HTTP source to obtain the data from (`ajax`)
			 *  @param {array} data A key/value pair object containing the data to send
			 *    to the server
			 *  @param {function} callback to be called on completion of the data get
			 *    process that will draw the data on the page.
			 *  @param {object} settings DataTables settings object
			 *
			 *  @dtopt Callbacks
			 *  @dtopt Server-side
			 *  @name DataTable.defaults.serverData
			 *
			 *  @deprecated 1.10. Please use `ajax` for this functionality now.
			 */
			"fnServerData": null,
		
		
			/**
			 * __Deprecated__ The functionality provided by this parameter has now been
			 * superseded by that provided through `ajax`, which should be used instead.
			 *
			 *  It is often useful to send extra data to the server when making an Ajax
			 * request - for example custom filtering information, and this callback
			 * function makes it trivial to send extra information to the server. The
			 * passed in parameter is the data set that has been constructed by
			 * DataTables, and you can add to this or modify it as you require.
			 *  @type function
			 *  @param {array} data Data array (array of objects which are name/value
			 *    pairs) that has been constructed by DataTables and will be sent to the
			 *    server. In the case of Ajax sourced data with server-side processing
			 *    this will be an empty array, for server-side processing there will be a
			 *    significant number of parameters!
			 *  @returns {undefined} Ensure that you modify the data array passed in,
			 *    as this is passed by reference.
			 *
			 *  @dtopt Callbacks
			 *  @dtopt Server-side
			 *  @name DataTable.defaults.serverParams
			 *
			 *  @deprecated 1.10. Please use `ajax` for this functionality now.
			 */
			"fnServerParams": null,
		
		
			/**
			 * Load the table state. With this function you can define from where, and how, the
			 * state of a table is loaded. By default DataTables will load from `localStorage`
			 * but you might wish to use a server-side database or cookies.
			 *  @type function
			 *  @member
			 *  @param {object} settings DataTables settings object
			 *  @return {object} The DataTables state object to be loaded
			 *
			 *  @dtopt Callbacks
			 *  @name DataTable.defaults.stateLoadCallback
			 *
			 *  @example
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "stateSave": true,
			 *        "stateLoadCallback": function (settings) {
			 *          var o;
			 *
			 *          // Send an Ajax request to the server to get the data. Note that
			 *          // this is a synchronous request.
			 *          $.ajax( {
			 *            "url": "/state_load",
			 *            "async": false,
			 *            "dataType": "json",
			 *            "success": function (json) {
			 *              o = json;
			 *            }
			 *          } );
			 *
			 *          return o;
			 *        }
			 *      } );
			 *    } );
			 */
			"fnStateLoadCallback": function ( settings ) {
				try {
					return JSON.parse(
						(settings.iStateDuration === -1 ? sessionStorage : localStorage).getItem(
							'DataTables_'+settings.sInstance+'_'+location.pathname
						)
					);
				} catch (e) {}
			},
		
		
			/**
			 * Callback which allows modification of the saved state prior to loading that state.
			 * This callback is called when the table is loading state from the stored data, but
			 * prior to the settings object being modified by the saved state. Note that for
			 * plug-in authors, you should use the `stateLoadParams` event to load parameters for
			 * a plug-in.
			 *  @type function
			 *  @param {object} settings DataTables settings object
			 *  @param {object} data The state object that is to be loaded
			 *
			 *  @dtopt Callbacks
			 *  @name DataTable.defaults.stateLoadParams
			 *
			 *  @example
			 *    // Remove a saved filter, so filtering is never loaded
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "stateSave": true,
			 *        "stateLoadParams": function (settings, data) {
			 *          data.oSearch.sSearch = "";
			 *        }
			 *      } );
			 *    } );
			 *
			 *  @example
			 *    // Disallow state loading by returning false
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "stateSave": true,
			 *        "stateLoadParams": function (settings, data) {
			 *          return false;
			 *        }
			 *      } );
			 *    } );
			 */
			"fnStateLoadParams": null,
		
		
			/**
			 * Callback that is called when the state has been loaded from the state saving method
			 * and the DataTables settings object has been modified as a result of the loaded state.
			 *  @type function
			 *  @param {object} settings DataTables settings object
			 *  @param {object} data The state object that was loaded
			 *
			 *  @dtopt Callbacks
			 *  @name DataTable.defaults.stateLoaded
			 *
			 *  @example
			 *    // Show an alert with the filtering value that was saved
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "stateSave": true,
			 *        "stateLoaded": function (settings, data) {
			 *          alert( 'Saved filter was: '+data.oSearch.sSearch );
			 *        }
			 *      } );
			 *    } );
			 */
			"fnStateLoaded": null,
		
		
			/**
			 * Save the table state. This function allows you to define where and how the state
			 * information for the table is stored By default DataTables will use `localStorage`
			 * but you might wish to use a server-side database or cookies.
			 *  @type function
			 *  @member
			 *  @param {object} settings DataTables settings object
			 *  @param {object} data The state object to be saved
			 *
			 *  @dtopt Callbacks
			 *  @name DataTable.defaults.stateSaveCallback
			 *
			 *  @example
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "stateSave": true,
			 *        "stateSaveCallback": function (settings, data) {
			 *          // Send an Ajax request to the server with the state object
			 *          $.ajax( {
			 *            "url": "/state_save",
			 *            "data": data,
			 *            "dataType": "json",
			 *            "method": "POST"
			 *            "success": function () {}
			 *          } );
			 *        }
			 *      } );
			 *    } );
			 */
			"fnStateSaveCallback": function ( settings, data ) {
				try {
					(settings.iStateDuration === -1 ? sessionStorage : localStorage).setItem(
						'DataTables_'+settings.sInstance+'_'+location.pathname,
						JSON.stringify( data )
					);
				} catch (e) {}
			},
		
		
			/**
			 * Callback which allows modification of the state to be saved. Called when the table
			 * has changed state a new state save is required. This method allows modification of
			 * the state saving object prior to actually doing the save, including addition or
			 * other state properties or modification. Note that for plug-in authors, you should
			 * use the `stateSaveParams` event to save parameters for a plug-in.
			 *  @type function
			 *  @param {object} settings DataTables settings object
			 *  @param {object} data The state object to be saved
			 *
			 *  @dtopt Callbacks
			 *  @name DataTable.defaults.stateSaveParams
			 *
			 *  @example
			 *    // Remove a saved filter, so filtering is never saved
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "stateSave": true,
			 *        "stateSaveParams": function (settings, data) {
			 *          data.oSearch.sSearch = "";
			 *        }
			 *      } );
			 *    } );
			 */
			"fnStateSaveParams": null,
		
		
			/**
			 * Duration for which the saved state information is considered valid. After this period
			 * has elapsed the state will be returned to the default.
			 * Value is given in seconds.
			 *  @type int
			 *  @default 7200 <i>(2 hours)</i>
			 *
			 *  @dtopt Options
			 *  @name DataTable.defaults.stateDuration
			 *
			 *  @example
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "stateDuration": 60*60*24; // 1 day
			 *      } );
			 *    } )
			 */
			"iStateDuration": 7200,
		
		
			/**
			 * When enabled DataTables will not make a request to the server for the first
			 * page draw - rather it will use the data already on the page (no sorting etc
			 * will be applied to it), thus saving on an XHR at load time. `deferLoading`
			 * is used to indicate that deferred loading is required, but it is also used
			 * to tell DataTables how many records there are in the full table (allowing
			 * the information element and pagination to be displayed correctly). In the case
			 * where a filtering is applied to the table on initial load, this can be
			 * indicated by giving the parameter as an array, where the first element is
			 * the number of records available after filtering and the second element is the
			 * number of records without filtering (allowing the table information element
			 * to be shown correctly).
			 *  @type int | array
			 *  @default null
			 *
			 *  @dtopt Options
			 *  @name DataTable.defaults.deferLoading
			 *
			 *  @example
			 *    // 57 records available in the table, no filtering applied
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "serverSide": true,
			 *        "ajax": "scripts/server_processing.php",
			 *        "deferLoading": 57
			 *      } );
			 *    } );
			 *
			 *  @example
			 *    // 57 records after filtering, 100 without filtering (an initial filter applied)
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "serverSide": true,
			 *        "ajax": "scripts/server_processing.php",
			 *        "deferLoading": [ 57, 100 ],
			 *        "search": {
			 *          "search": "my_filter"
			 *        }
			 *      } );
			 *    } );
			 */
			"iDeferLoading": null,
		
		
			/**
			 * Number of rows to display on a single page when using pagination. If
			 * feature enabled (`lengthChange`) then the end user will be able to override
			 * this to a custom setting using a pop-up menu.
			 *  @type int
			 *  @default 10
			 *
			 *  @dtopt Options
			 *  @name DataTable.defaults.pageLength
			 *
			 *  @example
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "pageLength": 50
			 *      } );
			 *    } )
			 */
			"iDisplayLength": 10,
		
		
			/**
			 * Define the starting point for data display when using DataTables with
			 * pagination. Note that this parameter is the number of records, rather than
			 * the page number, so if you have 10 records per page and want to start on
			 * the third page, it should be "20".
			 *  @type int
			 *  @default 0
			 *
			 *  @dtopt Options
			 *  @name DataTable.defaults.displayStart
			 *
			 *  @example
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "displayStart": 20
			 *      } );
			 *    } )
			 */
			"iDisplayStart": 0,
		
		
			/**
			 * By default DataTables allows keyboard navigation of the table (sorting, paging,
			 * and filtering) by adding a `tabindex` attribute to the required elements. This
			 * allows you to tab through the controls and press the enter key to activate them.
			 * The tabindex is default 0, meaning that the tab follows the flow of the document.
			 * You can overrule this using this parameter if you wish. Use a value of -1 to
			 * disable built-in keyboard navigation.
			 *  @type int
			 *  @default 0
			 *
			 *  @dtopt Options
			 *  @name DataTable.defaults.tabIndex
			 *
			 *  @example
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "tabIndex": 1
			 *      } );
			 *    } );
			 */
			"iTabIndex": 0,
		
		
			/**
			 * Classes that DataTables assigns to the various components and features
			 * that it adds to the HTML table. This allows classes to be configured
			 * during initialisation in addition to through the static
			 * {@link DataTable.ext.oStdClasses} object).
			 *  @namespace
			 *  @name DataTable.defaults.classes
			 */
			"oClasses": {},
		
		
			/**
			 * All strings that DataTables uses in the user interface that it creates
			 * are defined in this object, allowing you to modified them individually or
			 * completely replace them all as required.
			 *  @namespace
			 *  @name DataTable.defaults.language
			 */
			"oLanguage": {
				/**
				 * Strings that are used for WAI-ARIA labels and controls only (these are not
				 * actually visible on the page, but will be read by screenreaders, and thus
				 * must be internationalised as well).
				 *  @namespace
				 *  @name DataTable.defaults.language.aria
				 */
				"oAria": {
					/**
					 * ARIA label that is added to the table headers when the column may be
					 * sorted ascending by activing the column (click or return when focused).
					 * Note that the column header is prefixed to this string.
					 *  @type string
					 *  @default : activate to sort column ascending
					 *
					 *  @dtopt Language
					 *  @name DataTable.defaults.language.aria.sortAscending
					 *
					 *  @example
					 *    $(document).ready( function() {
					 *      $('#example').dataTable( {
					 *        "language": {
					 *          "aria": {
					 *            "sortAscending": " - click/return to sort ascending"
					 *          }
					 *        }
					 *      } );
					 *    } );
					 */
					"sSortAscending": ": activate to sort column ascending",
		
					/**
					 * ARIA label that is added to the table headers when the column may be
					 * sorted descending by activing the column (click or return when focused).
					 * Note that the column header is prefixed to this string.
					 *  @type string
					 *  @default : activate to sort column ascending
					 *
					 *  @dtopt Language
					 *  @name DataTable.defaults.language.aria.sortDescending
					 *
					 *  @example
					 *    $(document).ready( function() {
					 *      $('#example').dataTable( {
					 *        "language": {
					 *          "aria": {
					 *            "sortDescending": " - click/return to sort descending"
					 *          }
					 *        }
					 *      } );
					 *    } );
					 */
					"sSortDescending": ": activate to sort column descending"
				},
		
				/**
				 * Pagination string used by DataTables for the built-in pagination
				 * control types.
				 *  @namespace
				 *  @name DataTable.defaults.language.paginate
				 */
				"oPaginate": {
					/**
					 * Text to use when using the 'full_numbers' type of pagination for the
					 * button to take the user to the first page.
					 *  @type string
					 *  @default First
					 *
					 *  @dtopt Language
					 *  @name DataTable.defaults.language.paginate.first
					 *
					 *  @example
					 *    $(document).ready( function() {
					 *      $('#example').dataTable( {
					 *        "language": {
					 *          "paginate": {
					 *            "first": "First page"
					 *          }
					 *        }
					 *      } );
					 *    } );
					 */
					"sFirst": "First",
		
		
					/**
					 * Text to use when using the 'full_numbers' type of pagination for the
					 * button to take the user to the last page.
					 *  @type string
					 *  @default Last
					 *
					 *  @dtopt Language
					 *  @name DataTable.defaults.language.paginate.last
					 *
					 *  @example
					 *    $(document).ready( function() {
					 *      $('#example').dataTable( {
					 *        "language": {
					 *          "paginate": {
					 *            "last": "Last page"
					 *          }
					 *        }
					 *      } );
					 *    } );
					 */
					"sLast": "Last",
		
		
					/**
					 * Text to use for the 'next' pagination button (to take the user to the
					 * next page).
					 *  @type string
					 *  @default Next
					 *
					 *  @dtopt Language
					 *  @name DataTable.defaults.language.paginate.next
					 *
					 *  @example
					 *    $(document).ready( function() {
					 *      $('#example').dataTable( {
					 *        "language": {
					 *          "paginate": {
					 *            "next": "Next page"
					 *          }
					 *        }
					 *      } );
					 *    } );
					 */
					"sNext": "Next",
		
		
					/**
					 * Text to use for the 'previous' pagination button (to take the user to
					 * the previous page).
					 *  @type string
					 *  @default Previous
					 *
					 *  @dtopt Language
					 *  @name DataTable.defaults.language.paginate.previous
					 *
					 *  @example
					 *    $(document).ready( function() {
					 *      $('#example').dataTable( {
					 *        "language": {
					 *          "paginate": {
					 *            "previous": "Previous page"
					 *          }
					 *        }
					 *      } );
					 *    } );
					 */
					"sPrevious": "Previous"
				},
		
				/**
				 * This string is shown in preference to `zeroRecords` when the table is
				 * empty of data (regardless of filtering). Note that this is an optional
				 * parameter - if it is not given, the value of `zeroRecords` will be used
				 * instead (either the default or given value).
				 *  @type string
				 *  @default No data available in table
				 *
				 *  @dtopt Language
				 *  @name DataTable.defaults.language.emptyTable
				 *
				 *  @example
				 *    $(document).ready( function() {
				 *      $('#example').dataTable( {
				 *        "language": {
				 *          "emptyTable": "No data available in table"
				 *        }
				 *      } );
				 *    } );
				 */
				"sEmptyTable": "No data available in table",
		
		
				/**
				 * This string gives information to the end user about the information
				 * that is current on display on the page. The following tokens can be
				 * used in the string and will be dynamically replaced as the table
				 * display updates. This tokens can be placed anywhere in the string, or
				 * removed as needed by the language requires:
				 *
				 * * `\_START\_` - Display index of the first record on the current page
				 * * `\_END\_` - Display index of the last record on the current page
				 * * `\_TOTAL\_` - Number of records in the table after filtering
				 * * `\_MAX\_` - Number of records in the table without filtering
				 * * `\_PAGE\_` - Current page number
				 * * `\_PAGES\_` - Total number of pages of data in the table
				 *
				 *  @type string
				 *  @default Showing _START_ to _END_ of _TOTAL_ entries
				 *
				 *  @dtopt Language
				 *  @name DataTable.defaults.language.info
				 *
				 *  @example
				 *    $(document).ready( function() {
				 *      $('#example').dataTable( {
				 *        "language": {
				 *          "info": "Showing page _PAGE_ of _PAGES_"
				 *        }
				 *      } );
				 *    } );
				 */
				"sInfo": "Showing _START_ to _END_ of _TOTAL_ entries",
		
		
				/**
				 * Display information string for when the table is empty. Typically the
				 * format of this string should match `info`.
				 *  @type string
				 *  @default Showing 0 to 0 of 0 entries
				 *
				 *  @dtopt Language
				 *  @name DataTable.defaults.language.infoEmpty
				 *
				 *  @example
				 *    $(document).ready( function() {
				 *      $('#example').dataTable( {
				 *        "language": {
				 *          "infoEmpty": "No entries to show"
				 *        }
				 *      } );
				 *    } );
				 */
				"sInfoEmpty": "Showing 0 to 0 of 0 entries",
		
		
				/**
				 * When a user filters the information in a table, this string is appended
				 * to the information (`info`) to give an idea of how strong the filtering
				 * is. The variable _MAX_ is dynamically updated.
				 *  @type string
				 *  @default (filtered from _MAX_ total entries)
				 *
				 *  @dtopt Language
				 *  @name DataTable.defaults.language.infoFiltered
				 *
				 *  @example
				 *    $(document).ready( function() {
				 *      $('#example').dataTable( {
				 *        "language": {
				 *          "infoFiltered": " - filtering from _MAX_ records"
				 *        }
				 *      } );
				 *    } );
				 */
				"sInfoFiltered": "(filtered from _MAX_ total entries)",
		
		
				/**
				 * If can be useful to append extra information to the info string at times,
				 * and this variable does exactly that. This information will be appended to
				 * the `info` (`infoEmpty` and `infoFiltered` in whatever combination they are
				 * being used) at all times.
				 *  @type string
				 *  @default <i>Empty string</i>
				 *
				 *  @dtopt Language
				 *  @name DataTable.defaults.language.infoPostFix
				 *
				 *  @example
				 *    $(document).ready( function() {
				 *      $('#example').dataTable( {
				 *        "language": {
				 *          "infoPostFix": "All records shown are derived from real information."
				 *        }
				 *      } );
				 *    } );
				 */
				"sInfoPostFix": "",
		
		
				/**
				 * This decimal place operator is a little different from the other
				 * language options since DataTables doesn't output floating point
				 * numbers, so it won't ever use this for display of a number. Rather,
				 * what this parameter does is modify the sort methods of the table so
				 * that numbers which are in a format which has a character other than
				 * a period (`.`) as a decimal place will be sorted numerically.
				 *
				 * Note that numbers with different decimal places cannot be shown in
				 * the same table and still be sortable, the table must be consistent.
				 * However, multiple different tables on the page can use different
				 * decimal place characters.
				 *  @type string
				 *  @default 
				 *
				 *  @dtopt Language
				 *  @name DataTable.defaults.language.decimal
				 *
				 *  @example
				 *    $(document).ready( function() {
				 *      $('#example').dataTable( {
				 *        "language": {
				 *          "decimal": ","
				 *          "thousands": "."
				 *        }
				 *      } );
				 *    } );
				 */
				"sDecimal": "",
		
		
				/**
				 * DataTables has a build in number formatter (`formatNumber`) which is
				 * used to format large numbers that are used in the table information.
				 * By default a comma is used, but this can be trivially changed to any
				 * character you wish with this parameter.
				 *  @type string
				 *  @default ,
				 *
				 *  @dtopt Language
				 *  @name DataTable.defaults.language.thousands
				 *
				 *  @example
				 *    $(document).ready( function() {
				 *      $('#example').dataTable( {
				 *        "language": {
				 *          "thousands": "'"
				 *        }
				 *      } );
				 *    } );
				 */
				"sThousands": ",",
		
		
				/**
				 * Detail the action that will be taken when the drop down menu for the
				 * pagination length option is changed. The '_MENU_' variable is replaced
				 * with a default select list of 10, 25, 50 and 100, and can be replaced
				 * with a custom select box if required.
				 *  @type string
				 *  @default Show _MENU_ entries
				 *
				 *  @dtopt Language
				 *  @name DataTable.defaults.language.lengthMenu
				 *
				 *  @example
				 *    // Language change only
				 *    $(document).ready( function() {
				 *      $('#example').dataTable( {
				 *        "language": {
				 *          "lengthMenu": "Display _MENU_ records"
				 *        }
				 *      } );
				 *    } );
				 *
				 *  @example
				 *    // Language and options change
				 *    $(document).ready( function() {
				 *      $('#example').dataTable( {
				 *        "language": {
				 *          "lengthMenu": 'Display <select>'+
				 *            '<option value="10">10</option>'+
				 *            '<option value="20">20</option>'+
				 *            '<option value="30">30</option>'+
				 *            '<option value="40">40</option>'+
				 *            '<option value="50">50</option>'+
				 *            '<option value="-1">All</option>'+
				 *            '</select> records'
				 *        }
				 *      } );
				 *    } );
				 */
				"sLengthMenu": "Show _MENU_ entries",
		
		
				/**
				 * When using Ajax sourced data and during the first draw when DataTables is
				 * gathering the data, this message is shown in an empty row in the table to
				 * indicate to the end user the the data is being loaded. Note that this
				 * parameter is not used when loading data by server-side processing, just
				 * Ajax sourced data with client-side processing.
				 *  @type string
				 *  @default Loading...
				 *
				 *  @dtopt Language
				 *  @name DataTable.defaults.language.loadingRecords
				 *
				 *  @example
				 *    $(document).ready( function() {
				 *      $('#example').dataTable( {
				 *        "language": {
				 *          "loadingRecords": "Please wait - loading..."
				 *        }
				 *      } );
				 *    } );
				 */
				"sLoadingRecords": "Loading...",
		
		
				/**
				 * Text which is displayed when the table is processing a user action
				 * (usually a sort command or similar).
				 *  @type string
				 *  @default Processing...
				 *
				 *  @dtopt Language
				 *  @name DataTable.defaults.language.processing
				 *
				 *  @example
				 *    $(document).ready( function() {
				 *      $('#example').dataTable( {
				 *        "language": {
				 *          "processing": "DataTables is currently busy"
				 *        }
				 *      } );
				 *    } );
				 */
				"sProcessing": "Processing...",
		
		
				/**
				 * Details the actions that will be taken when the user types into the
				 * filtering input text box. The variable "_INPUT_", if used in the string,
				 * is replaced with the HTML text box for the filtering input allowing
				 * control over where it appears in the string. If "_INPUT_" is not given
				 * then the input box is appended to the string automatically.
				 *  @type string
				 *  @default Search:
				 *
				 *  @dtopt Language
				 *  @name DataTable.defaults.language.search
				 *
				 *  @example
				 *    // Input text box will be appended at the end automatically
				 *    $(document).ready( function() {
				 *      $('#example').dataTable( {
				 *        "language": {
				 *          "search": "Filter records:"
				 *        }
				 *      } );
				 *    } );
				 *
				 *  @example
				 *    // Specify where the filter should appear
				 *    $(document).ready( function() {
				 *      $('#example').dataTable( {
				 *        "language": {
				 *          "search": "Apply filter _INPUT_ to table"
				 *        }
				 *      } );
				 *    } );
				 */
				"sSearch": "Search:",
		
		
				/**
				 * Assign a `placeholder` attribute to the search `input` element
				 *  @type string
				 *  @default 
				 *
				 *  @dtopt Language
				 *  @name DataTable.defaults.language.searchPlaceholder
				 */
				"sSearchPlaceholder": "",
		
		
				/**
				 * All of the language information can be stored in a file on the
				 * server-side, which DataTables will look up if this parameter is passed.
				 * It must store the URL of the language file, which is in a JSON format,
				 * and the object has the same properties as the oLanguage object in the
				 * initialiser object (i.e. the above parameters). Please refer to one of
				 * the example language files to see how this works in action.
				 *  @type string
				 *  @default <i>Empty string - i.e. disabled</i>
				 *
				 *  @dtopt Language
				 *  @name DataTable.defaults.language.url
				 *
				 *  @example
				 *    $(document).ready( function() {
				 *      $('#example').dataTable( {
				 *        "language": {
				 *          "url": "http://www.sprymedia.co.uk/dataTables/lang.txt"
				 *        }
				 *      } );
				 *    } );
				 */
				"sUrl": "",
		
		
				/**
				 * Text shown inside the table records when the is no information to be
				 * displayed after filtering. `emptyTable` is shown when there is simply no
				 * information in the table at all (regardless of filtering).
				 *  @type string
				 *  @default No matching records found
				 *
				 *  @dtopt Language
				 *  @name DataTable.defaults.language.zeroRecords
				 *
				 *  @example
				 *    $(document).ready( function() {
				 *      $('#example').dataTable( {
				 *        "language": {
				 *          "zeroRecords": "No records to display"
				 *        }
				 *      } );
				 *    } );
				 */
				"sZeroRecords": "No matching records found"
			},
		
		
			/**
			 * This parameter allows you to have define the global filtering state at
			 * initialisation time. As an object the `search` parameter must be
			 * defined, but all other parameters are optional. When `regex` is true,
			 * the search string will be treated as a regular expression, when false
			 * (default) it will be treated as a straight string. When `smart`
			 * DataTables will use it's smart filtering methods (to word match at
			 * any point in the data), when false this will not be done.
			 *  @namespace
			 *  @extends DataTable.models.oSearch
			 *
			 *  @dtopt Options
			 *  @name DataTable.defaults.search
			 *
			 *  @example
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "search": {"search": "Initial search"}
			 *      } );
			 *    } )
			 */
			"oSearch": $.extend( {}, DataTable.models.oSearch ),
		
		
			/**
			 * __Deprecated__ The functionality provided by this parameter has now been
			 * superseded by that provided through `ajax`, which should be used instead.
			 *
			 * By default DataTables will look for the property `data` (or `aaData` for
			 * compatibility with DataTables 1.9-) when obtaining data from an Ajax
			 * source or for server-side processing - this parameter allows that
			 * property to be changed. You can use Javascript dotted object notation to
			 * get a data source for multiple levels of nesting.
			 *  @type string
			 *  @default data
			 *
			 *  @dtopt Options
			 *  @dtopt Server-side
			 *  @name DataTable.defaults.ajaxDataProp
			 *
			 *  @deprecated 1.10. Please use `ajax` for this functionality now.
			 */
			"sAjaxDataProp": "data",
		
		
			/**
			 * __Deprecated__ The functionality provided by this parameter has now been
			 * superseded by that provided through `ajax`, which should be used instead.
			 *
			 * You can instruct DataTables to load data from an external
			 * source using this parameter (use aData if you want to pass data in you
			 * already have). Simply provide a url a JSON object can be obtained from.
			 *  @type string
			 *  @default null
			 *
			 *  @dtopt Options
			 *  @dtopt Server-side
			 *  @name DataTable.defaults.ajaxSource
			 *
			 *  @deprecated 1.10. Please use `ajax` for this functionality now.
			 */
			"sAjaxSource": null,
		
		
			/**
			 * This initialisation variable allows you to specify exactly where in the
			 * DOM you want DataTables to inject the various controls it adds to the page
			 * (for example you might want the pagination controls at the top of the
			 * table). DIV elements (with or without a custom class) can also be added to
			 * aid styling. The follow syntax is used:
			 *   <ul>
			 *     <li>The following options are allowed:
			 *       <ul>
			 *         <li>'l' - Length changing</li>
			 *         <li>'f' - Filtering input</li>
			 *         <li>'t' - The table!</li>
			 *         <li>'i' - Information</li>
			 *         <li>'p' - Pagination</li>
			 *         <li>'r' - pRocessing</li>
			 *       </ul>
			 *     </li>
			 *     <li>The following constants are allowed:
			 *       <ul>
			 *         <li>'H' - jQueryUI theme "header" classes ('fg-toolbar ui-widget-header ui-corner-tl ui-corner-tr ui-helper-clearfix')</li>
			 *         <li>'F' - jQueryUI theme "footer" classes ('fg-toolbar ui-widget-header ui-corner-bl ui-corner-br ui-helper-clearfix')</li>
			 *       </ul>
			 *     </li>
			 *     <li>The following syntax is expected:
			 *       <ul>
			 *         <li>'&lt;' and '&gt;' - div elements</li>
			 *         <li>'&lt;"class" and '&gt;' - div with a class</li>
			 *         <li>'&lt;"#id" and '&gt;' - div with an ID</li>
			 *       </ul>
			 *     </li>
			 *     <li>Examples:
			 *       <ul>
			 *         <li>'&lt;"wrapper"flipt&gt;'</li>
			 *         <li>'&lt;lf&lt;t&gt;ip&gt;'</li>
			 *       </ul>
			 *     </li>
			 *   </ul>
			 *  @type string
			 *  @default lfrtip <i>(when `jQueryUI` is false)</i> <b>or</b>
			 *    <"H"lfr>t<"F"ip> <i>(when `jQueryUI` is true)</i>
			 *
			 *  @dtopt Options
			 *  @name DataTable.defaults.dom
			 *
			 *  @example
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "dom": '&lt;"top"i&gt;rt&lt;"bottom"flp&gt;&lt;"clear"&gt;'
			 *      } );
			 *    } );
			 */
			"sDom": "lfrtip",
		
		
			/**
			 * Search delay option. This will throttle full table searches that use the
			 * DataTables provided search input element (it does not effect calls to
			 * `dt-api search()`, providing a delay before the search is made.
			 *  @type integer
			 *  @default 0
			 *
			 *  @dtopt Options
			 *  @name DataTable.defaults.searchDelay
			 *
			 *  @example
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "searchDelay": 200
			 *      } );
			 *    } )
			 */
			"searchDelay": null,
		
		
			/**
			 * DataTables features four different built-in options for the buttons to
			 * display for pagination control:
			 *
			 * * `simple` - 'Previous' and 'Next' buttons only
			 * * 'simple_numbers` - 'Previous' and 'Next' buttons, plus page numbers
			 * * `full` - 'First', 'Previous', 'Next' and 'Last' buttons
			 * * `full_numbers` - 'First', 'Previous', 'Next' and 'Last' buttons, plus
			 *   page numbers
			 *  
			 * Further methods can be added using {@link DataTable.ext.oPagination}.
			 *  @type string
			 *  @default simple_numbers
			 *
			 *  @dtopt Options
			 *  @name DataTable.defaults.pagingType
			 *
			 *  @example
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "pagingType": "full_numbers"
			 *      } );
			 *    } )
			 */
			"sPaginationType": "simple_numbers",
		
		
			/**
			 * Enable horizontal scrolling. When a table is too wide to fit into a
			 * certain layout, or you have a large number of columns in the table, you
			 * can enable x-scrolling to show the table in a viewport, which can be
			 * scrolled. This property can be `true` which will allow the table to
			 * scroll horizontally when needed, or any CSS unit, or a number (in which
			 * case it will be treated as a pixel measurement). Setting as simply `true`
			 * is recommended.
			 *  @type boolean|string
			 *  @default <i>blank string - i.e. disabled</i>
			 *
			 *  @dtopt Features
			 *  @name DataTable.defaults.scrollX
			 *
			 *  @example
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "scrollX": true,
			 *        "scrollCollapse": true
			 *      } );
			 *    } );
			 */
			"sScrollX": "",
		
		
			/**
			 * This property can be used to force a DataTable to use more width than it
			 * might otherwise do when x-scrolling is enabled. For example if you have a
			 * table which requires to be well spaced, this parameter is useful for
			 * "over-sizing" the table, and thus forcing scrolling. This property can by
			 * any CSS unit, or a number (in which case it will be treated as a pixel
			 * measurement).
			 *  @type string
			 *  @default <i>blank string - i.e. disabled</i>
			 *
			 *  @dtopt Options
			 *  @name DataTable.defaults.scrollXInner
			 *
			 *  @example
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "scrollX": "100%",
			 *        "scrollXInner": "110%"
			 *      } );
			 *    } );
			 */
			"sScrollXInner": "",
		
		
			/**
			 * Enable vertical scrolling. Vertical scrolling will constrain the DataTable
			 * to the given height, and enable scrolling for any data which overflows the
			 * current viewport. This can be used as an alternative to paging to display
			 * a lot of data in a small area (although paging and scrolling can both be
			 * enabled at the same time). This property can be any CSS unit, or a number
			 * (in which case it will be treated as a pixel measurement).
			 *  @type string
			 *  @default <i>blank string - i.e. disabled</i>
			 *
			 *  @dtopt Features
			 *  @name DataTable.defaults.scrollY
			 *
			 *  @example
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "scrollY": "200px",
			 *        "paginate": false
			 *      } );
			 *    } );
			 */
			"sScrollY": "",
		
		
			/**
			 * __Deprecated__ The functionality provided by this parameter has now been
			 * superseded by that provided through `ajax`, which should be used instead.
			 *
			 * Set the HTTP method that is used to make the Ajax call for server-side
			 * processing or Ajax sourced data.
			 *  @type string
			 *  @default GET
			 *
			 *  @dtopt Options
			 *  @dtopt Server-side
			 *  @name DataTable.defaults.serverMethod
			 *
			 *  @deprecated 1.10. Please use `ajax` for this functionality now.
			 */
			"sServerMethod": "GET",
		
		
			/**
			 * DataTables makes use of renderers when displaying HTML elements for
			 * a table. These renderers can be added or modified by plug-ins to
			 * generate suitable mark-up for a site. For example the Bootstrap
			 * integration plug-in for DataTables uses a paging button renderer to
			 * display pagination buttons in the mark-up required by Bootstrap.
			 *
			 * For further information about the renderers available see
			 * DataTable.ext.renderer
			 *  @type string|object
			 *  @default null
			 *
			 *  @name DataTable.defaults.renderer
			 *
			 */
			"renderer": null,
		
		
			/**
			 * Set the data property name that DataTables should use to get a row's id
			 * to set as the `id` property in the node.
			 *  @type string
			 *  @default DT_RowId
			 *
			 *  @name DataTable.defaults.rowId
			 */
			"rowId": "DT_RowId"
		};
		
		_fnHungarianMap( DataTable.defaults );
		
		
		
		/*
		 * Developer note - See note in model.defaults.js about the use of Hungarian
		 * notation and camel case.
		 */
		
		/**
		 * Column options that can be given to DataTables at initialisation time.
		 *  @namespace
		 */
		DataTable.defaults.column = {
			/**
			 * Define which column(s) an order will occur on for this column. This
			 * allows a column's ordering to take multiple columns into account when
			 * doing a sort or use the data from a different column. For example first
			 * name / last name columns make sense to do a multi-column sort over the
			 * two columns.
			 *  @type array|int
			 *  @default null <i>Takes the value of the column index automatically</i>
			 *
			 *  @name DataTable.defaults.column.orderData
			 *  @dtopt Columns
			 *
			 *  @example
			 *    // Using `columnDefs`
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "columnDefs": [
			 *          { "orderData": [ 0, 1 ], "targets": [ 0 ] },
			 *          { "orderData": [ 1, 0 ], "targets": [ 1 ] },
			 *          { "orderData": 2, "targets": [ 2 ] }
			 *        ]
			 *      } );
			 *    } );
			 *
			 *  @example
			 *    // Using `columns`
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "columns": [
			 *          { "orderData": [ 0, 1 ] },
			 *          { "orderData": [ 1, 0 ] },
			 *          { "orderData": 2 },
			 *          null,
			 *          null
			 *        ]
			 *      } );
			 *    } );
			 */
			"aDataSort": null,
			"iDataSort": -1,
		
		
			/**
			 * You can control the default ordering direction, and even alter the
			 * behaviour of the sort handler (i.e. only allow ascending ordering etc)
			 * using this parameter.
			 *  @type array
			 *  @default [ 'asc', 'desc' ]
			 *
			 *  @name DataTable.defaults.column.orderSequence
			 *  @dtopt Columns
			 *
			 *  @example
			 *    // Using `columnDefs`
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "columnDefs": [
			 *          { "orderSequence": [ "asc" ], "targets": [ 1 ] },
			 *          { "orderSequence": [ "desc", "asc", "asc" ], "targets": [ 2 ] },
			 *          { "orderSequence": [ "desc" ], "targets": [ 3 ] }
			 *        ]
			 *      } );
			 *    } );
			 *
			 *  @example
			 *    // Using `columns`
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "columns": [
			 *          null,
			 *          { "orderSequence": [ "asc" ] },
			 *          { "orderSequence": [ "desc", "asc", "asc" ] },
			 *          { "orderSequence": [ "desc" ] },
			 *          null
			 *        ]
			 *      } );
			 *    } );
			 */
			"asSorting": [ 'asc', 'desc' ],
		
		
			/**
			 * Enable or disable filtering on the data in this column.
			 *  @type boolean
			 *  @default true
			 *
			 *  @name DataTable.defaults.column.searchable
			 *  @dtopt Columns
			 *
			 *  @example
			 *    // Using `columnDefs`
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "columnDefs": [
			 *          { "searchable": false, "targets": [ 0 ] }
			 *        ] } );
			 *    } );
			 *
			 *  @example
			 *    // Using `columns`
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "columns": [
			 *          { "searchable": false },
			 *          null,
			 *          null,
			 *          null,
			 *          null
			 *        ] } );
			 *    } );
			 */
			"bSearchable": true,
		
		
			/**
			 * Enable or disable ordering on this column.
			 *  @type boolean
			 *  @default true
			 *
			 *  @name DataTable.defaults.column.orderable
			 *  @dtopt Columns
			 *
			 *  @example
			 *    // Using `columnDefs`
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "columnDefs": [
			 *          { "orderable": false, "targets": [ 0 ] }
			 *        ] } );
			 *    } );
			 *
			 *  @example
			 *    // Using `columns`
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "columns": [
			 *          { "orderable": false },
			 *          null,
			 *          null,
			 *          null,
			 *          null
			 *        ] } );
			 *    } );
			 */
			"bSortable": true,
		
		
			/**
			 * Enable or disable the display of this column.
			 *  @type boolean
			 *  @default true
			 *
			 *  @name DataTable.defaults.column.visible
			 *  @dtopt Columns
			 *
			 *  @example
			 *    // Using `columnDefs`
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "columnDefs": [
			 *          { "visible": false, "targets": [ 0 ] }
			 *        ] } );
			 *    } );
			 *
			 *  @example
			 *    // Using `columns`
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "columns": [
			 *          { "visible": false },
			 *          null,
			 *          null,
			 *          null,
			 *          null
			 *        ] } );
			 *    } );
			 */
			"bVisible": true,
		
		
			/**
			 * Developer definable function that is called whenever a cell is created (Ajax source,
			 * etc) or processed for input (DOM source). This can be used as a compliment to mRender
			 * allowing you to modify the DOM element (add background colour for example) when the
			 * element is available.
			 *  @type function
			 *  @param {element} td The TD node that has been created
			 *  @param {*} cellData The Data for the cell
			 *  @param {array|object} rowData The data for the whole row
			 *  @param {int} row The row index for the aoData data store
			 *  @param {int} col The column index for aoColumns
			 *
			 *  @name DataTable.defaults.column.createdCell
			 *  @dtopt Columns
			 *
			 *  @example
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "columnDefs": [ {
			 *          "targets": [3],
			 *          "createdCell": function (td, cellData, rowData, row, col) {
			 *            if ( cellData == "1.7" ) {
			 *              $(td).css('color', 'blue')
			 *            }
			 *          }
			 *        } ]
			 *      });
			 *    } );
			 */
			"fnCreatedCell": null,
		
		
			/**
			 * This parameter has been replaced by `data` in DataTables to ensure naming
			 * consistency. `dataProp` can still be used, as there is backwards
			 * compatibility in DataTables for this option, but it is strongly
			 * recommended that you use `data` in preference to `dataProp`.
			 *  @name DataTable.defaults.column.dataProp
			 */
		
		
			/**
			 * This property can be used to read data from any data source property,
			 * including deeply nested objects / properties. `data` can be given in a
			 * number of different ways which effect its behaviour:
			 *
			 * * `integer` - treated as an array index for the data source. This is the
			 *   default that DataTables uses (incrementally increased for each column).
			 * * `string` - read an object property from the data source. There are
			 *   three 'special' options that can be used in the string to alter how
			 *   DataTables reads the data from the source object:
			 *    * `.` - Dotted Javascript notation. Just as you use a `.` in
			 *      Javascript to read from nested objects, so to can the options
			 *      specified in `data`. For example: `browser.version` or
			 *      `browser.name`. If your object parameter name contains a period, use
			 *      `\\` to escape it - i.e. `first\\.name`.
			 *    * `[]` - Array notation. DataTables can automatically combine data
			 *      from and array source, joining the data with the characters provided
			 *      between the two brackets. For example: `name[, ]` would provide a
			 *      comma-space separated list from the source array. If no characters
			 *      are provided between the brackets, the original array source is
			 *      returned.
			 *    * `()` - Function notation. Adding `()` to the end of a parameter will
			 *      execute a function of the name given. For example: `browser()` for a
			 *      simple function on the data source, `browser.version()` for a
			 *      function in a nested property or even `browser().version` to get an
			 *      object property if the function called returns an object. Note that
			 *      function notation is recommended for use in `render` rather than
			 *      `data` as it is much simpler to use as a renderer.
			 * * `null` - use the original data source for the row rather than plucking
			 *   data directly from it. This action has effects on two other
			 *   initialisation options:
			 *    * `defaultContent` - When null is given as the `data` option and
			 *      `defaultContent` is specified for the column, the value defined by
			 *      `defaultContent` will be used for the cell.
			 *    * `render` - When null is used for the `data` option and the `render`
			 *      option is specified for the column, the whole data source for the
			 *      row is used for the renderer.
			 * * `function` - the function given will be executed whenever DataTables
			 *   needs to set or get the data for a cell in the column. The function
			 *   takes three parameters:
			 *    * Parameters:
			 *      * `{array|object}` The data source for the row
			 *      * `{string}` The type call data requested - this will be 'set' when
			 *        setting data or 'filter', 'display', 'type', 'sort' or undefined
			 *        when gathering data. Note that when `undefined` is given for the
			 *        type DataTables expects to get the raw data for the object back<
			 *      * `{*}` Data to set when the second parameter is 'set'.
			 *    * Return:
			 *      * The return value from the function is not required when 'set' is
			 *        the type of call, but otherwise the return is what will be used
			 *        for the data requested.
			 *
			 * Note that `data` is a getter and setter option. If you just require
			 * formatting of data for output, you will likely want to use `render` which
			 * is simply a getter and thus simpler to use.
			 *
			 * Note that prior to DataTables 1.9.2 `data` was called `mDataProp`. The
			 * name change reflects the flexibility of this property and is consistent
			 * with the naming of mRender. If 'mDataProp' is given, then it will still
			 * be used by DataTables, as it automatically maps the old name to the new
			 * if required.
			 *
			 *  @type string|int|function|null
			 *  @default null <i>Use automatically calculated column index</i>
			 *
			 *  @name DataTable.defaults.column.data
			 *  @dtopt Columns
			 *
			 *  @example
			 *    // Read table data from objects
			 *    // JSON structure for each row:
			 *    //   {
			 *    //      "engine": {value},
			 *    //      "browser": {value},
			 *    //      "platform": {value},
			 *    //      "version": {value},
			 *    //      "grade": {value}
			 *    //   }
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "ajaxSource": "sources/objects.txt",
			 *        "columns": [
			 *          { "data": "engine" },
			 *          { "data": "browser" },
			 *          { "data": "platform" },
			 *          { "data": "version" },
			 *          { "data": "grade" }
			 *        ]
			 *      } );
			 *    } );
			 *
			 *  @example
			 *    // Read information from deeply nested objects
			 *    // JSON structure for each row:
			 *    //   {
			 *    //      "engine": {value},
			 *    //      "browser": {value},
			 *    //      "platform": {
			 *    //         "inner": {value}
			 *    //      },
			 *    //      "details": [
			 *    //         {value}, {value}
			 *    //      ]
			 *    //   }
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "ajaxSource": "sources/deep.txt",
			 *        "columns": [
			 *          { "data": "engine" },
			 *          { "data": "browser" },
			 *          { "data": "platform.inner" },
			 *          { "data": "platform.details.0" },
			 *          { "data": "platform.details.1" }
			 *        ]
			 *      } );
			 *    } );
			 *
			 *  @example
			 *    // Using `data` as a function to provide different information for
			 *    // sorting, filtering and display. In this case, currency (price)
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "columnDefs": [ {
			 *          "targets": [ 0 ],
			 *          "data": function ( source, type, val ) {
			 *            if (type === 'set') {
			 *              source.price = val;
			 *              // Store the computed dislay and filter values for efficiency
			 *              source.price_display = val=="" ? "" : "$"+numberFormat(val);
			 *              source.price_filter  = val=="" ? "" : "$"+numberFormat(val)+" "+val;
			 *              return;
			 *            }
			 *            else if (type === 'display') {
			 *              return source.price_display;
			 *            }
			 *            else if (type === 'filter') {
			 *              return source.price_filter;
			 *            }
			 *            // 'sort', 'type' and undefined all just use the integer
			 *            return source.price;
			 *          }
			 *        } ]
			 *      } );
			 *    } );
			 *
			 *  @example
			 *    // Using default content
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "columnDefs": [ {
			 *          "targets": [ 0 ],
			 *          "data": null,
			 *          "defaultContent": "Click to edit"
			 *        } ]
			 *      } );
			 *    } );
			 *
			 *  @example
			 *    // Using array notation - outputting a list from an array
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "columnDefs": [ {
			 *          "targets": [ 0 ],
			 *          "data": "name[, ]"
			 *        } ]
			 *      } );
			 *    } );
			 *
			 */
			"mData": null,
		
		
			/**
			 * This property is the rendering partner to `data` and it is suggested that
			 * when you want to manipulate data for display (including filtering,
			 * sorting etc) without altering the underlying data for the table, use this
			 * property. `render` can be considered to be the the read only companion to
			 * `data` which is read / write (then as such more complex). Like `data`
			 * this option can be given in a number of different ways to effect its
			 * behaviour:
			 *
			 * * `integer` - treated as an array index for the data source. This is the
			 *   default that DataTables uses (incrementally increased for each column).
			 * * `string` - read an object property from the data source. There are
			 *   three 'special' options that can be used in the string to alter how
			 *   DataTables reads the data from the source object:
			 *    * `.` - Dotted Javascript notation. Just as you use a `.` in
			 *      Javascript to read from nested objects, so to can the options
			 *      specified in `data`. For example: `browser.version` or
			 *      `browser.name`. If your object parameter name contains a period, use
			 *      `\\` to escape it - i.e. `first\\.name`.
			 *    * `[]` - Array notation. DataTables can automatically combine data
			 *      from and array source, joining the data with the characters provided
			 *      between the two brackets. For example: `name[, ]` would provide a
			 *      comma-space separated list from the source array. If no characters
			 *      are provided between the brackets, the original array source is
			 *      returned.
			 *    * `()` - Function notation. Adding `()` to the end of a parameter will
			 *      execute a function of the name given. For example: `browser()` for a
			 *      simple function on the data source, `browser.version()` for a
			 *      function in a nested property or even `browser().version` to get an
			 *      object property if the function called returns an object.
			 * * `object` - use different data for the different data types requested by
			 *   DataTables ('filter', 'display', 'type' or 'sort'). The property names
			 *   of the object is the data type the property refers to and the value can
			 *   defined using an integer, string or function using the same rules as
			 *   `render` normally does. Note that an `_` option _must_ be specified.
			 *   This is the default value to use if you haven't specified a value for
			 *   the data type requested by DataTables.
			 * * `function` - the function given will be executed whenever DataTables
			 *   needs to set or get the data for a cell in the column. The function
			 *   takes three parameters:
			 *    * Parameters:
			 *      * {array|object} The data source for the row (based on `data`)
			 *      * {string} The type call data requested - this will be 'filter',
			 *        'display', 'type' or 'sort'.
			 *      * {array|object} The full data source for the row (not based on
			 *        `data`)
			 *    * Return:
			 *      * The return value from the function is what will be used for the
			 *        data requested.
			 *
			 *  @type string|int|function|object|null
			 *  @default null Use the data source value.
			 *
			 *  @name DataTable.defaults.column.render
			 *  @dtopt Columns
			 *
			 *  @example
			 *    // Create a comma separated list from an array of objects
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "ajaxSource": "sources/deep.txt",
			 *        "columns": [
			 *          { "data": "engine" },
			 *          { "data": "browser" },
			 *          {
			 *            "data": "platform",
			 *            "render": "[, ].name"
			 *          }
			 *        ]
			 *      } );
			 *    } );
			 *
			 *  @example
			 *    // Execute a function to obtain data
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "columnDefs": [ {
			 *          "targets": [ 0 ],
			 *          "data": null, // Use the full data source object for the renderer's source
			 *          "render": "browserName()"
			 *        } ]
			 *      } );
			 *    } );
			 *
			 *  @example
			 *    // As an object, extracting different data for the different types
			 *    // This would be used with a data source such as:
			 *    //   { "phone": 5552368, "phone_filter": "5552368 555-2368", "phone_display": "555-2368" }
			 *    // Here the `phone` integer is used for sorting and type detection, while `phone_filter`
			 *    // (which has both forms) is used for filtering for if a user inputs either format, while
			 *    // the formatted phone number is the one that is shown in the table.
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "columnDefs": [ {
			 *          "targets": [ 0 ],
			 *          "data": null, // Use the full data source object for the renderer's source
			 *          "render": {
			 *            "_": "phone",
			 *            "filter": "phone_filter",
			 *            "display": "phone_display"
			 *          }
			 *        } ]
			 *      } );
			 *    } );
			 *
			 *  @example
			 *    // Use as a function to create a link from the data source
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "columnDefs": [ {
			 *          "targets": [ 0 ],
			 *          "data": "download_link",
			 *          "render": function ( data, type, full ) {
			 *            return '<a href="'+data+'">Download</a>';
			 *          }
			 *        } ]
			 *      } );
			 *    } );
			 */
			"mRender": null,
		
		
			/**
			 * Change the cell type created for the column - either TD cells or TH cells. This
			 * can be useful as TH cells have semantic meaning in the table body, allowing them
			 * to act as a header for a row (you may wish to add scope='row' to the TH elements).
			 *  @type string
			 *  @default td
			 *
			 *  @name DataTable.defaults.column.cellType
			 *  @dtopt Columns
			 *
			 *  @example
			 *    // Make the first column use TH cells
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "columnDefs": [ {
			 *          "targets": [ 0 ],
			 *          "cellType": "th"
			 *        } ]
			 *      } );
			 *    } );
			 */
			"sCellType": "td",
		
		
			/**
			 * Class to give to each cell in this column.
			 *  @type string
			 *  @default <i>Empty string</i>
			 *
			 *  @name DataTable.defaults.column.class
			 *  @dtopt Columns
			 *
			 *  @example
			 *    // Using `columnDefs`
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "columnDefs": [
			 *          { "class": "my_class", "targets": [ 0 ] }
			 *        ]
			 *      } );
			 *    } );
			 *
			 *  @example
			 *    // Using `columns`
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "columns": [
			 *          { "class": "my_class" },
			 *          null,
			 *          null,
			 *          null,
			 *          null
			 *        ]
			 *      } );
			 *    } );
			 */
			"sClass": "",
		
			/**
			 * When DataTables calculates the column widths to assign to each column,
			 * it finds the longest string in each column and then constructs a
			 * temporary table and reads the widths from that. The problem with this
			 * is that "mmm" is much wider then "iiii", but the latter is a longer
			 * string - thus the calculation can go wrong (doing it properly and putting
			 * it into an DOM object and measuring that is horribly(!) slow). Thus as
			 * a "work around" we provide this option. It will append its value to the
			 * text that is found to be the longest string for the column - i.e. padding.
			 * Generally you shouldn't need this!
			 *  @type string
			 *  @default <i>Empty string<i>
			 *
			 *  @name DataTable.defaults.column.contentPadding
			 *  @dtopt Columns
			 *
			 *  @example
			 *    // Using `columns`
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "columns": [
			 *          null,
			 *          null,
			 *          null,
			 *          {
			 *            "contentPadding": "mmm"
			 *          }
			 *        ]
			 *      } );
			 *    } );
			 */
			"sContentPadding": "",
		
		
			/**
			 * Allows a default value to be given for a column's data, and will be used
			 * whenever a null data source is encountered (this can be because `data`
			 * is set to null, or because the data source itself is null).
			 *  @type string
			 *  @default null
			 *
			 *  @name DataTable.defaults.column.defaultContent
			 *  @dtopt Columns
			 *
			 *  @example
			 *    // Using `columnDefs`
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "columnDefs": [
			 *          {
			 *            "data": null,
			 *            "defaultContent": "Edit",
			 *            "targets": [ -1 ]
			 *          }
			 *        ]
			 *      } );
			 *    } );
			 *
			 *  @example
			 *    // Using `columns`
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "columns": [
			 *          null,
			 *          null,
			 *          null,
			 *          {
			 *            "data": null,
			 *            "defaultContent": "Edit"
			 *          }
			 *        ]
			 *      } );
			 *    } );
			 */
			"sDefaultContent": null,
		
		
			/**
			 * This parameter is only used in DataTables' server-side processing. It can
			 * be exceptionally useful to know what columns are being displayed on the
			 * client side, and to map these to database fields. When defined, the names
			 * also allow DataTables to reorder information from the server if it comes
			 * back in an unexpected order (i.e. if you switch your columns around on the
			 * client-side, your server-side code does not also need updating).
			 *  @type string
			 *  @default <i>Empty string</i>
			 *
			 *  @name DataTable.defaults.column.name
			 *  @dtopt Columns
			 *
			 *  @example
			 *    // Using `columnDefs`
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "columnDefs": [
			 *          { "name": "engine", "targets": [ 0 ] },
			 *          { "name": "browser", "targets": [ 1 ] },
			 *          { "name": "platform", "targets": [ 2 ] },
			 *          { "name": "version", "targets": [ 3 ] },
			 *          { "name": "grade", "targets": [ 4 ] }
			 *        ]
			 *      } );
			 *    } );
			 *
			 *  @example
			 *    // Using `columns`
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "columns": [
			 *          { "name": "engine" },
			 *          { "name": "browser" },
			 *          { "name": "platform" },
			 *          { "name": "version" },
			 *          { "name": "grade" }
			 *        ]
			 *      } );
			 *    } );
			 */
			"sName": "",
		
		
			/**
			 * Defines a data source type for the ordering which can be used to read
			 * real-time information from the table (updating the internally cached
			 * version) prior to ordering. This allows ordering to occur on user
			 * editable elements such as form inputs.
			 *  @type string
			 *  @default std
			 *
			 *  @name DataTable.defaults.column.orderDataType
			 *  @dtopt Columns
			 *
			 *  @example
			 *    // Using `columnDefs`
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "columnDefs": [
			 *          { "orderDataType": "dom-text", "targets": [ 2, 3 ] },
			 *          { "type": "numeric", "targets": [ 3 ] },
			 *          { "orderDataType": "dom-select", "targets": [ 4 ] },
			 *          { "orderDataType": "dom-checkbox", "targets": [ 5 ] }
			 *        ]
			 *      } );
			 *    } );
			 *
			 *  @example
			 *    // Using `columns`
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "columns": [
			 *          null,
			 *          null,
			 *          { "orderDataType": "dom-text" },
			 *          { "orderDataType": "dom-text", "type": "numeric" },
			 *          { "orderDataType": "dom-select" },
			 *          { "orderDataType": "dom-checkbox" }
			 *        ]
			 *      } );
			 *    } );
			 */
			"sSortDataType": "std",
		
		
			/**
			 * The title of this column.
			 *  @type string
			 *  @default null <i>Derived from the 'TH' value for this column in the
			 *    original HTML table.</i>
			 *
			 *  @name DataTable.defaults.column.title
			 *  @dtopt Columns
			 *
			 *  @example
			 *    // Using `columnDefs`
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "columnDefs": [
			 *          { "title": "My column title", "targets": [ 0 ] }
			 *        ]
			 *      } );
			 *    } );
			 *
			 *  @example
			 *    // Using `columns`
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "columns": [
			 *          { "title": "My column title" },
			 *          null,
			 *          null,
			 *          null,
			 *          null
			 *        ]
			 *      } );
			 *    } );
			 */
			"sTitle": null,
		
		
			/**
			 * The type allows you to specify how the data for this column will be
			 * ordered. Four types (string, numeric, date and html (which will strip
			 * HTML tags before ordering)) are currently available. Note that only date
			 * formats understood by Javascript's Date() object will be accepted as type
			 * date. For example: "Mar 26, 2008 5:03 PM". May take the values: 'string',
			 * 'numeric', 'date' or 'html' (by default). Further types can be adding
			 * through plug-ins.
			 *  @type string
			 *  @default null <i>Auto-detected from raw data</i>
			 *
			 *  @name DataTable.defaults.column.type
			 *  @dtopt Columns
			 *
			 *  @example
			 *    // Using `columnDefs`
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "columnDefs": [
			 *          { "type": "html", "targets": [ 0 ] }
			 *        ]
			 *      } );
			 *    } );
			 *
			 *  @example
			 *    // Using `columns`
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "columns": [
			 *          { "type": "html" },
			 *          null,
			 *          null,
			 *          null,
			 *          null
			 *        ]
			 *      } );
			 *    } );
			 */
			"sType": null,
		
		
			/**
			 * Defining the width of the column, this parameter may take any CSS value
			 * (3em, 20px etc). DataTables applies 'smart' widths to columns which have not
			 * been given a specific width through this interface ensuring that the table
			 * remains readable.
			 *  @type string
			 *  @default null <i>Automatic</i>
			 *
			 *  @name DataTable.defaults.column.width
			 *  @dtopt Columns
			 *
			 *  @example
			 *    // Using `columnDefs`
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "columnDefs": [
			 *          { "width": "20%", "targets": [ 0 ] }
			 *        ]
			 *      } );
			 *    } );
			 *
			 *  @example
			 *    // Using `columns`
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "columns": [
			 *          { "width": "20%" },
			 *          null,
			 *          null,
			 *          null,
			 *          null
			 *        ]
			 *      } );
			 *    } );
			 */
			"sWidth": null
		};
		
		_fnHungarianMap( DataTable.defaults.column );
		
		
		
		/**
		 * DataTables settings object - this holds all the information needed for a
		 * given table, including configuration, data and current application of the
		 * table options. DataTables does not have a single instance for each DataTable
		 * with the settings attached to that instance, but rather instances of the
		 * DataTable "class" are created on-the-fly as needed (typically by a
		 * $().dataTable() call) and the settings object is then applied to that
		 * instance.
		 *
		 * Note that this object is related to {@link DataTable.defaults} but this
		 * one is the internal data store for DataTables's cache of columns. It should
		 * NOT be manipulated outside of DataTables. Any configuration should be done
		 * through the initialisation options.
		 *  @namespace
		 *  @todo Really should attach the settings object to individual instances so we
		 *    don't need to create new instances on each $().dataTable() call (if the
		 *    table already exists). It would also save passing oSettings around and
		 *    into every single function. However, this is a very significant
		 *    architecture change for DataTables and will almost certainly break
		 *    backwards compatibility with older installations. This is something that
		 *    will be done in 2.0.
		 */
		DataTable.models.oSettings = {
			/**
			 * Primary features of DataTables and their enablement state.
			 *  @namespace
			 */
			"oFeatures": {
		
				/**
				 * Flag to say if DataTables should automatically try to calculate the
				 * optimum table and columns widths (true) or not (false).
				 * Note that this parameter will be set by the initialisation routine. To
				 * set a default use {@link DataTable.defaults}.
				 *  @type boolean
				 */
				"bAutoWidth": null,
		
				/**
				 * Delay the creation of TR and TD elements until they are actually
				 * needed by a driven page draw. This can give a significant speed
				 * increase for Ajax source and Javascript source data, but makes no
				 * difference at all fro DOM and server-side processing tables.
				 * Note that this parameter will be set by the initialisation routine. To
				 * set a default use {@link DataTable.defaults}.
				 *  @type boolean
				 */
				"bDeferRender": null,
		
				/**
				 * Enable filtering on the table or not. Note that if this is disabled
				 * then there is no filtering at all on the table, including fnFilter.
				 * To just remove the filtering input use sDom and remove the 'f' option.
				 * Note that this parameter will be set by the initialisation routine. To
				 * set a default use {@link DataTable.defaults}.
				 *  @type boolean
				 */
				"bFilter": null,
		
				/**
				 * Table information element (the 'Showing x of y records' div) enable
				 * flag.
				 * Note that this parameter will be set by the initialisation routine. To
				 * set a default use {@link DataTable.defaults}.
				 *  @type boolean
				 */
				"bInfo": null,
		
				/**
				 * Present a user control allowing the end user to change the page size
				 * when pagination is enabled.
				 * Note that this parameter will be set by the initialisation routine. To
				 * set a default use {@link DataTable.defaults}.
				 *  @type boolean
				 */
				"bLengthChange": null,
		
				/**
				 * Pagination enabled or not. Note that if this is disabled then length
				 * changing must also be disabled.
				 * Note that this parameter will be set by the initialisation routine. To
				 * set a default use {@link DataTable.defaults}.
				 *  @type boolean
				 */
				"bPaginate": null,
		
				/**
				 * Processing indicator enable flag whenever DataTables is enacting a
				 * user request - typically an Ajax request for server-side processing.
				 * Note that this parameter will be set by the initialisation routine. To
				 * set a default use {@link DataTable.defaults}.
				 *  @type boolean
				 */
				"bProcessing": null,
		
				/**
				 * Server-side processing enabled flag - when enabled DataTables will
				 * get all data from the server for every draw - there is no filtering,
				 * sorting or paging done on the client-side.
				 * Note that this parameter will be set by the initialisation routine. To
				 * set a default use {@link DataTable.defaults}.
				 *  @type boolean
				 */
				"bServerSide": null,
		
				/**
				 * Sorting enablement flag.
				 * Note that this parameter will be set by the initialisation routine. To
				 * set a default use {@link DataTable.defaults}.
				 *  @type boolean
				 */
				"bSort": null,
		
				/**
				 * Multi-column sorting
				 * Note that this parameter will be set by the initialisation routine. To
				 * set a default use {@link DataTable.defaults}.
				 *  @type boolean
				 */
				"bSortMulti": null,
		
				/**
				 * Apply a class to the columns which are being sorted to provide a
				 * visual highlight or not. This can slow things down when enabled since
				 * there is a lot of DOM interaction.
				 * Note that this parameter will be set by the initialisation routine. To
				 * set a default use {@link DataTable.defaults}.
				 *  @type boolean
				 */
				"bSortClasses": null,
		
				/**
				 * State saving enablement flag.
				 * Note that this parameter will be set by the initialisation routine. To
				 * set a default use {@link DataTable.defaults}.
				 *  @type boolean
				 */
				"bStateSave": null
			},
		
		
			/**
			 * Scrolling settings for a table.
			 *  @namespace
			 */
			"oScroll": {
				/**
				 * When the table is shorter in height than sScrollY, collapse the
				 * table container down to the height of the table (when true).
				 * Note that this parameter will be set by the initialisation routine. To
				 * set a default use {@link DataTable.defaults}.
				 *  @type boolean
				 */
				"bCollapse": null,
		
				/**
				 * Width of the scrollbar for the web-browser's platform. Calculated
				 * during table initialisation.
				 *  @type int
				 *  @default 0
				 */
				"iBarWidth": 0,
		
				/**
				 * Viewport width for horizontal scrolling. Horizontal scrolling is
				 * disabled if an empty string.
				 * Note that this parameter will be set by the initialisation routine. To
				 * set a default use {@link DataTable.defaults}.
				 *  @type string
				 */
				"sX": null,
		
				/**
				 * Width to expand the table to when using x-scrolling. Typically you
				 * should not need to use this.
				 * Note that this parameter will be set by the initialisation routine. To
				 * set a default use {@link DataTable.defaults}.
				 *  @type string
				 *  @deprecated
				 */
				"sXInner": null,
		
				/**
				 * Viewport height for vertical scrolling. Vertical scrolling is disabled
				 * if an empty string.
				 * Note that this parameter will be set by the initialisation routine. To
				 * set a default use {@link DataTable.defaults}.
				 *  @type string
				 */
				"sY": null
			},
		
			/**
			 * Language information for the table.
			 *  @namespace
			 *  @extends DataTable.defaults.oLanguage
			 */
			"oLanguage": {
				/**
				 * Information callback function. See
				 * {@link DataTable.defaults.fnInfoCallback}
				 *  @type function
				 *  @default null
				 */
				"fnInfoCallback": null
			},
		
			/**
			 * Browser support parameters
			 *  @namespace
			 */
			"oBrowser": {
				/**
				 * Indicate if the browser incorrectly calculates width:100% inside a
				 * scrolling element (IE6/7)
				 *  @type boolean
				 *  @default false
				 */
				"bScrollOversize": false,
		
				/**
				 * Determine if the vertical scrollbar is on the right or left of the
				 * scrolling container - needed for rtl language layout, although not
				 * all browsers move the scrollbar (Safari).
				 *  @type boolean
				 *  @default false
				 */
				"bScrollbarLeft": false,
		
				/**
				 * Flag for if `getBoundingClientRect` is fully supported or not
				 *  @type boolean
				 *  @default false
				 */
				"bBounding": false,
		
				/**
				 * Browser scrollbar width
				 *  @type integer
				 *  @default 0
				 */
				"barWidth": 0
			},
		
		
			"ajax": null,
		
		
			/**
			 * Array referencing the nodes which are used for the features. The
			 * parameters of this object match what is allowed by sDom - i.e.
			 *   <ul>
			 *     <li>'l' - Length changing</li>
			 *     <li>'f' - Filtering input</li>
			 *     <li>'t' - The table!</li>
			 *     <li>'i' - Information</li>
			 *     <li>'p' - Pagination</li>
			 *     <li>'r' - pRocessing</li>
			 *   </ul>
			 *  @type array
			 *  @default []
			 */
			"aanFeatures": [],
		
			/**
			 * Store data information - see {@link DataTable.models.oRow} for detailed
			 * information.
			 *  @type array
			 *  @default []
			 */
			"aoData": [],
		
			/**
			 * Array of indexes which are in the current display (after filtering etc)
			 *  @type array
			 *  @default []
			 */
			"aiDisplay": [],
		
			/**
			 * Array of indexes for display - no filtering
			 *  @type array
			 *  @default []
			 */
			"aiDisplayMaster": [],
		
			/**
			 * Map of row ids to data indexes
			 *  @type object
			 *  @default {}
			 */
			"aIds": {},
		
			/**
			 * Store information about each column that is in use
			 *  @type array
			 *  @default []
			 */
			"aoColumns": [],
		
			/**
			 * Store information about the table's header
			 *  @type array
			 *  @default []
			 */
			"aoHeader": [],
		
			/**
			 * Store information about the table's footer
			 *  @type array
			 *  @default []
			 */
			"aoFooter": [],
		
			/**
			 * Store the applied global search information in case we want to force a
			 * research or compare the old search to a new one.
			 * Note that this parameter will be set by the initialisation routine. To
			 * set a default use {@link DataTable.defaults}.
			 *  @namespace
			 *  @extends DataTable.models.oSearch
			 */
			"oPreviousSearch": {},
		
			/**
			 * Store the applied search for each column - see
			 * {@link DataTable.models.oSearch} for the format that is used for the
			 * filtering information for each column.
			 *  @type array
			 *  @default []
			 */
			"aoPreSearchCols": [],
		
			/**
			 * Sorting that is applied to the table. Note that the inner arrays are
			 * used in the following manner:
			 * <ul>
			 *   <li>Index 0 - column number</li>
			 *   <li>Index 1 - current sorting direction</li>
			 * </ul>
			 * Note that this parameter will be set by the initialisation routine. To
			 * set a default use {@link DataTable.defaults}.
			 *  @type array
			 *  @todo These inner arrays should really be objects
			 */
			"aaSorting": null,
		
			/**
			 * Sorting that is always applied to the table (i.e. prefixed in front of
			 * aaSorting).
			 * Note that this parameter will be set by the initialisation routine. To
			 * set a default use {@link DataTable.defaults}.
			 *  @type array
			 *  @default []
			 */
			"aaSortingFixed": [],
		
			/**
			 * Classes to use for the striping of a table.
			 * Note that this parameter will be set by the initialisation routine. To
			 * set a default use {@link DataTable.defaults}.
			 *  @type array
			 *  @default []
			 */
			"asStripeClasses": null,
		
			/**
			 * If restoring a table - we should restore its striping classes as well
			 *  @type array
			 *  @default []
			 */
			"asDestroyStripes": [],
		
			/**
			 * If restoring a table - we should restore its width
			 *  @type int
			 *  @default 0
			 */
			"sDestroyWidth": 0,
		
			/**
			 * Callback functions array for every time a row is inserted (i.e. on a draw).
			 *  @type array
			 *  @default []
			 */
			"aoRowCallback": [],
		
			/**
			 * Callback functions for the header on each draw.
			 *  @type array
			 *  @default []
			 */
			"aoHeaderCallback": [],
		
			/**
			 * Callback function for the footer on each draw.
			 *  @type array
			 *  @default []
			 */
			"aoFooterCallback": [],
		
			/**
			 * Array of callback functions for draw callback functions
			 *  @type array
			 *  @default []
			 */
			"aoDrawCallback": [],
		
			/**
			 * Array of callback functions for row created function
			 *  @type array
			 *  @default []
			 */
			"aoRowCreatedCallback": [],
		
			/**
			 * Callback functions for just before the table is redrawn. A return of
			 * false will be used to cancel the draw.
			 *  @type array
			 *  @default []
			 */
			"aoPreDrawCallback": [],
		
			/**
			 * Callback functions for when the table has been initialised.
			 *  @type array
			 *  @default []
			 */
			"aoInitComplete": [],
		
		
			/**
			 * Callbacks for modifying the settings to be stored for state saving, prior to
			 * saving state.
			 *  @type array
			 *  @default []
			 */
			"aoStateSaveParams": [],
		
			/**
			 * Callbacks for modifying the settings that have been stored for state saving
			 * prior to using the stored values to restore the state.
			 *  @type array
			 *  @default []
			 */
			"aoStateLoadParams": [],
		
			/**
			 * Callbacks for operating on the settings object once the saved state has been
			 * loaded
			 *  @type array
			 *  @default []
			 */
			"aoStateLoaded": [],
		
			/**
			 * Cache the table ID for quick access
			 *  @type string
			 *  @default <i>Empty string</i>
			 */
			"sTableId": "",
		
			/**
			 * The TABLE node for the main table
			 *  @type node
			 *  @default null
			 */
			"nTable": null,
		
			/**
			 * Permanent ref to the thead element
			 *  @type node
			 *  @default null
			 */
			"nTHead": null,
		
			/**
			 * Permanent ref to the tfoot element - if it exists
			 *  @type node
			 *  @default null
			 */
			"nTFoot": null,
		
			/**
			 * Permanent ref to the tbody element
			 *  @type node
			 *  @default null
			 */
			"nTBody": null,
		
			/**
			 * Cache the wrapper node (contains all DataTables controlled elements)
			 *  @type node
			 *  @default null
			 */
			"nTableWrapper": null,
		
			/**
			 * Indicate if when using server-side processing the loading of data
			 * should be deferred until the second draw.
			 * Note that this parameter will be set by the initialisation routine. To
			 * set a default use {@link DataTable.defaults}.
			 *  @type boolean
			 *  @default false
			 */
			"bDeferLoading": false,
		
			/**
			 * Indicate if all required information has been read in
			 *  @type boolean
			 *  @default false
			 */
			"bInitialised": false,
		
			/**
			 * Information about open rows. Each object in the array has the parameters
			 * 'nTr' and 'nParent'
			 *  @type array
			 *  @default []
			 */
			"aoOpenRows": [],
		
			/**
			 * Dictate the positioning of DataTables' control elements - see
			 * {@link DataTable.model.oInit.sDom}.
			 * Note that this parameter will be set by the initialisation routine. To
			 * set a default use {@link DataTable.defaults}.
			 *  @type string
			 *  @default null
			 */
			"sDom": null,
		
			/**
			 * Search delay (in mS)
			 *  @type integer
			 *  @default null
			 */
			"searchDelay": null,
		
			/**
			 * Which type of pagination should be used.
			 * Note that this parameter will be set by the initialisation routine. To
			 * set a default use {@link DataTable.defaults}.
			 *  @type string
			 *  @default two_button
			 */
			"sPaginationType": "two_button",
		
			/**
			 * The state duration (for `stateSave`) in seconds.
			 * Note that this parameter will be set by the initialisation routine. To
			 * set a default use {@link DataTable.defaults}.
			 *  @type int
			 *  @default 0
			 */
			"iStateDuration": 0,
		
			/**
			 * Array of callback functions for state saving. Each array element is an
			 * object with the following parameters:
			 *   <ul>
			 *     <li>function:fn - function to call. Takes two parameters, oSettings
			 *       and the JSON string to save that has been thus far created. Returns
			 *       a JSON string to be inserted into a json object
			 *       (i.e. '"param": [ 0, 1, 2]')</li>
			 *     <li>string:sName - name of callback</li>
			 *   </ul>
			 *  @type array
			 *  @default []
			 */
			"aoStateSave": [],
		
			/**
			 * Array of callback functions for state loading. Each array element is an
			 * object with the following parameters:
			 *   <ul>
			 *     <li>function:fn - function to call. Takes two parameters, oSettings
			 *       and the object stored. May return false to cancel state loading</li>
			 *     <li>string:sName - name of callback</li>
			 *   </ul>
			 *  @type array
			 *  @default []
			 */
			"aoStateLoad": [],
		
			/**
			 * State that was saved. Useful for back reference
			 *  @type object
			 *  @default null
			 */
			"oSavedState": null,
		
			/**
			 * State that was loaded. Useful for back reference
			 *  @type object
			 *  @default null
			 */
			"oLoadedState": null,
		
			/**
			 * Source url for AJAX data for the table.
			 * Note that this parameter will be set by the initialisation routine. To
			 * set a default use {@link DataTable.defaults}.
			 *  @type string
			 *  @default null
			 */
			"sAjaxSource": null,
		
			/**
			 * Property from a given object from which to read the table data from. This
			 * can be an empty string (when not server-side processing), in which case
			 * it is  assumed an an array is given directly.
			 * Note that this parameter will be set by the initialisation routine. To
			 * set a default use {@link DataTable.defaults}.
			 *  @type string
			 */
			"sAjaxDataProp": null,
		
			/**
			 * Note if draw should be blocked while getting data
			 *  @type boolean
			 *  @default true
			 */
			"bAjaxDataGet": true,
		
			/**
			 * The last jQuery XHR object that was used for server-side data gathering.
			 * This can be used for working with the XHR information in one of the
			 * callbacks
			 *  @type object
			 *  @default null
			 */
			"jqXHR": null,
		
			/**
			 * JSON returned from the server in the last Ajax request
			 *  @type object
			 *  @default undefined
			 */
			"json": undefined,
		
			/**
			 * Data submitted as part of the last Ajax request
			 *  @type object
			 *  @default undefined
			 */
			"oAjaxData": undefined,
		
			/**
			 * Function to get the server-side data.
			 * Note that this parameter will be set by the initialisation routine. To
			 * set a default use {@link DataTable.defaults}.
			 *  @type function
			 */
			"fnServerData": null,
		
			/**
			 * Functions which are called prior to sending an Ajax request so extra
			 * parameters can easily be sent to the server
			 *  @type array
			 *  @default []
			 */
			"aoServerParams": [],
		
			/**
			 * Send the XHR HTTP method - GET or POST (could be PUT or DELETE if
			 * required).
			 * Note that this parameter will be set by the initialisation routine. To
			 * set a default use {@link DataTable.defaults}.
			 *  @type string
			 */
			"sServerMethod": null,
		
			/**
			 * Format numbers for display.
			 * Note that this parameter will be set by the initialisation routine. To
			 * set a default use {@link DataTable.defaults}.
			 *  @type function
			 */
			"fnFormatNumber": null,
		
			/**
			 * List of options that can be used for the user selectable length menu.
			 * Note that this parameter will be set by the initialisation routine. To
			 * set a default use {@link DataTable.defaults}.
			 *  @type array
			 *  @default []
			 */
			"aLengthMenu": null,
		
			/**
			 * Counter for the draws that the table does. Also used as a tracker for
			 * server-side processing
			 *  @type int
			 *  @default 0
			 */
			"iDraw": 0,
		
			/**
			 * Indicate if a redraw is being done - useful for Ajax
			 *  @type boolean
			 *  @default false
			 */
			"bDrawing": false,
		
			/**
			 * Draw index (iDraw) of the last error when parsing the returned data
			 *  @type int
			 *  @default -1
			 */
			"iDrawError": -1,
		
			/**
			 * Paging display length
			 *  @type int
			 *  @default 10
			 */
			"_iDisplayLength": 10,
		
			/**
			 * Paging start point - aiDisplay index
			 *  @type int
			 *  @default 0
			 */
			"_iDisplayStart": 0,
		
			/**
			 * Server-side processing - number of records in the result set
			 * (i.e. before filtering), Use fnRecordsTotal rather than
			 * this property to get the value of the number of records, regardless of
			 * the server-side processing setting.
			 *  @type int
			 *  @default 0
			 *  @private
			 */
			"_iRecordsTotal": 0,
		
			/**
			 * Server-side processing - number of records in the current display set
			 * (i.e. after filtering). Use fnRecordsDisplay rather than
			 * this property to get the value of the number of records, regardless of
			 * the server-side processing setting.
			 *  @type boolean
			 *  @default 0
			 *  @private
			 */
			"_iRecordsDisplay": 0,
		
			/**
			 * Flag to indicate if jQuery UI marking and classes should be used.
			 * Note that this parameter will be set by the initialisation routine. To
			 * set a default use {@link DataTable.defaults}.
			 *  @type boolean
			 */
			"bJUI": null,
		
			/**
			 * The classes to use for the table
			 *  @type object
			 *  @default {}
			 */
			"oClasses": {},
		
			/**
			 * Flag attached to the settings object so you can check in the draw
			 * callback if filtering has been done in the draw. Deprecated in favour of
			 * events.
			 *  @type boolean
			 *  @default false
			 *  @deprecated
			 */
			"bFiltered": false,
		
			/**
			 * Flag attached to the settings object so you can check in the draw
			 * callback if sorting has been done in the draw. Deprecated in favour of
			 * events.
			 *  @type boolean
			 *  @default false
			 *  @deprecated
			 */
			"bSorted": false,
		
			/**
			 * Indicate that if multiple rows are in the header and there is more than
			 * one unique cell per column, if the top one (true) or bottom one (false)
			 * should be used for sorting / title by DataTables.
			 * Note that this parameter will be set by the initialisation routine. To
			 * set a default use {@link DataTable.defaults}.
			 *  @type boolean
			 */
			"bSortCellsTop": null,
		
			/**
			 * Initialisation object that is used for the table
			 *  @type object
			 *  @default null
			 */
			"oInit": null,
		
			/**
			 * Destroy callback functions - for plug-ins to attach themselves to the
			 * destroy so they can clean up markup and events.
			 *  @type array
			 *  @default []
			 */
			"aoDestroyCallback": [],
		
		
			/**
			 * Get the number of records in the current record set, before filtering
			 *  @type function
			 */
			"fnRecordsTotal": function ()
			{
				return _fnDataSource( this ) == 'ssp' ?
					this._iRecordsTotal * 1 :
					this.aiDisplayMaster.length;
			},
		
			/**
			 * Get the number of records in the current record set, after filtering
			 *  @type function
			 */
			"fnRecordsDisplay": function ()
			{
				return _fnDataSource( this ) == 'ssp' ?
					this._iRecordsDisplay * 1 :
					this.aiDisplay.length;
			},
		
			/**
			 * Get the display end point - aiDisplay index
			 *  @type function
			 */
			"fnDisplayEnd": function ()
			{
				var
					len      = this._iDisplayLength,
					start    = this._iDisplayStart,
					calc     = start + len,
					records  = this.aiDisplay.length,
					features = this.oFeatures,
					paginate = features.bPaginate;
		
				if ( features.bServerSide ) {
					return paginate === false || len === -1 ?
						start + records :
						Math.min( start+len, this._iRecordsDisplay );
				}
				else {
					return ! paginate || calc>records || len===-1 ?
						records :
						calc;
				}
			},
		
			/**
			 * The DataTables object for this table
			 *  @type object
			 *  @default null
			 */
			"oInstance": null,
		
			/**
			 * Unique identifier for each instance of the DataTables object. If there
			 * is an ID on the table node, then it takes that value, otherwise an
			 * incrementing internal counter is used.
			 *  @type string
			 *  @default null
			 */
			"sInstance": null,
		
			/**
			 * tabindex attribute value that is added to DataTables control elements, allowing
			 * keyboard navigation of the table and its controls.
			 */
			"iTabIndex": 0,
		
			/**
			 * DIV container for the footer scrolling table if scrolling
			 */
			"nScrollHead": null,
		
			/**
			 * DIV container for the footer scrolling table if scrolling
			 */
			"nScrollFoot": null,
		
			/**
			 * Last applied sort
			 *  @type array
			 *  @default []
			 */
			"aLastSort": [],
		
			/**
			 * Stored plug-in instances
			 *  @type object
			 *  @default {}
			 */
			"oPlugins": {},
		
			/**
			 * Function used to get a row's id from the row's data
			 *  @type function
			 *  @default null
			 */
			"rowIdFn": null,
		
			/**
			 * Data location where to store a row's id
			 *  @type string
			 *  @default null
			 */
			"rowId": null
		};
	
		/**
		 * Extension object for DataTables that is used to provide all extension
		 * options.
		 *
		 * Note that the `DataTable.ext` object is available through
		 * `jQuery.fn.dataTable.ext` where it may be accessed and manipulated. It is
		 * also aliased to `jQuery.fn.dataTableExt` for historic reasons.
		 *  @namespace
		 *  @extends DataTable.models.ext
		 */
		
		
		/**
		 * DataTables extensions
		 * 
		 * This namespace acts as a collection area for plug-ins that can be used to
		 * extend DataTables capabilities. Indeed many of the build in methods
		 * use this method to provide their own capabilities (sorting methods for
		 * example).
		 *
		 * Note that this namespace is aliased to `jQuery.fn.dataTableExt` for legacy
		 * reasons
		 *
		 *  @namespace
		 */
		DataTable.ext = _ext = {
			/**
			 * Buttons. For use with the Buttons extension for DataTables. This is
			 * defined here so other extensions can define buttons regardless of load
			 * order. It is _not_ used by DataTables core.
			 *
			 *  @type object
			 *  @default {}
			 */
			buttons: {},
		
		
			/**
			 * Element class names
			 *
			 *  @type object
			 *  @default {}
			 */
			classes: {},
		
		
			/**
			 * DataTables build type (expanded by the download builder)
			 *
			 *  @type string
			 */
			builder: "-source-",
		
		
			/**
			 * Error reporting.
			 * 
			 * How should DataTables report an error. Can take the value 'alert',
			 * 'throw', 'none' or a function.
			 *
			 *  @type string|function
			 *  @default alert
			 */
			errMode: "alert",
		
		
			/**
			 * Feature plug-ins.
			 * 
			 * This is an array of objects which describe the feature plug-ins that are
			 * available to DataTables. These feature plug-ins are then available for
			 * use through the `dom` initialisation option.
			 * 
			 * Each feature plug-in is described by an object which must have the
			 * following properties:
			 * 
			 * * `fnInit` - function that is used to initialise the plug-in,
			 * * `cFeature` - a character so the feature can be enabled by the `dom`
			 *   instillation option. This is case sensitive.
			 *
			 * The `fnInit` function has the following input parameters:
			 *
			 * 1. `{object}` DataTables settings object: see
			 *    {@link DataTable.models.oSettings}
			 *
			 * And the following return is expected:
			 * 
			 * * {node|null} The element which contains your feature. Note that the
			 *   return may also be void if your plug-in does not require to inject any
			 *   DOM elements into DataTables control (`dom`) - for example this might
			 *   be useful when developing a plug-in which allows table control via
			 *   keyboard entry
			 *
			 *  @type array
			 *
			 *  @example
			 *    $.fn.dataTable.ext.features.push( {
			 *      "fnInit": function( oSettings ) {
			 *        return new TableTools( { "oDTSettings": oSettings } );
			 *      },
			 *      "cFeature": "T"
			 *    } );
			 */
			feature: [],
		
		
			/**
			 * Row searching.
			 * 
			 * This method of searching is complimentary to the default type based
			 * searching, and a lot more comprehensive as it allows you complete control
			 * over the searching logic. Each element in this array is a function
			 * (parameters described below) that is called for every row in the table,
			 * and your logic decides if it should be included in the searching data set
			 * or not.
			 *
			 * Searching functions have the following input parameters:
			 *
			 * 1. `{object}` DataTables settings object: see
			 *    {@link DataTable.models.oSettings}
			 * 2. `{array|object}` Data for the row to be processed (same as the
			 *    original format that was passed in as the data source, or an array
			 *    from a DOM data source
			 * 3. `{int}` Row index ({@link DataTable.models.oSettings.aoData}), which
			 *    can be useful to retrieve the `TR` element if you need DOM interaction.
			 *
			 * And the following return is expected:
			 *
			 * * {boolean} Include the row in the searched result set (true) or not
			 *   (false)
			 *
			 * Note that as with the main search ability in DataTables, technically this
			 * is "filtering", since it is subtractive. However, for consistency in
			 * naming we call it searching here.
			 *
			 *  @type array
			 *  @default []
			 *
			 *  @example
			 *    // The following example shows custom search being applied to the
			 *    // fourth column (i.e. the data[3] index) based on two input values
			 *    // from the end-user, matching the data in a certain range.
			 *    $.fn.dataTable.ext.search.push(
			 *      function( settings, data, dataIndex ) {
			 *        var min = document.getElementById('min').value * 1;
			 *        var max = document.getElementById('max').value * 1;
			 *        var version = data[3] == "-" ? 0 : data[3]*1;
			 *
			 *        if ( min == "" && max == "" ) {
			 *          return true;
			 *        }
			 *        else if ( min == "" && version < max ) {
			 *          return true;
			 *        }
			 *        else if ( min < version && "" == max ) {
			 *          return true;
			 *        }
			 *        else if ( min < version && version < max ) {
			 *          return true;
			 *        }
			 *        return false;
			 *      }
			 *    );
			 */
			search: [],
		
		
			/**
			 * Selector extensions
			 *
			 * The `selector` option can be used to extend the options available for the
			 * selector modifier options (`selector-modifier` object data type) that
			 * each of the three built in selector types offer (row, column and cell +
			 * their plural counterparts). For example the Select extension uses this
			 * mechanism to provide an option to select only rows, columns and cells
			 * that have been marked as selected by the end user (`{selected: true}`),
			 * which can be used in conjunction with the existing built in selector
			 * options.
			 *
			 * Each property is an array to which functions can be pushed. The functions
			 * take three attributes:
			 *
			 * * Settings object for the host table
			 * * Options object (`selector-modifier` object type)
			 * * Array of selected item indexes
			 *
			 * The return is an array of the resulting item indexes after the custom
			 * selector has been applied.
			 *
			 *  @type object
			 */
			selector: {
				cell: [],
				column: [],
				row: []
			},
		
		
			/**
			 * Internal functions, exposed for used in plug-ins.
			 * 
			 * Please note that you should not need to use the internal methods for
			 * anything other than a plug-in (and even then, try to avoid if possible).
			 * The internal function may change between releases.
			 *
			 *  @type object
			 *  @default {}
			 */
			internal: {},
		
		
			/**
			 * Legacy configuration options. Enable and disable legacy options that
			 * are available in DataTables.
			 *
			 *  @type object
			 */
			legacy: {
				/**
				 * Enable / disable DataTables 1.9 compatible server-side processing
				 * requests
				 *
				 *  @type boolean
				 *  @default null
				 */
				ajax: null
			},
		
		
			/**
			 * Pagination plug-in methods.
			 * 
			 * Each entry in this object is a function and defines which buttons should
			 * be shown by the pagination rendering method that is used for the table:
			 * {@link DataTable.ext.renderer.pageButton}. The renderer addresses how the
			 * buttons are displayed in the document, while the functions here tell it
			 * what buttons to display. This is done by returning an array of button
			 * descriptions (what each button will do).
			 *
			 * Pagination types (the four built in options and any additional plug-in
			 * options defined here) can be used through the `paginationType`
			 * initialisation parameter.
			 *
			 * The functions defined take two parameters:
			 *
			 * 1. `{int} page` The current page index
			 * 2. `{int} pages` The number of pages in the table
			 *
			 * Each function is expected to return an array where each element of the
			 * array can be one of:
			 *
			 * * `first` - Jump to first page when activated
			 * * `last` - Jump to last page when activated
			 * * `previous` - Show previous page when activated
			 * * `next` - Show next page when activated
			 * * `{int}` - Show page of the index given
			 * * `{array}` - A nested array containing the above elements to add a
			 *   containing 'DIV' element (might be useful for styling).
			 *
			 * Note that DataTables v1.9- used this object slightly differently whereby
			 * an object with two functions would be defined for each plug-in. That
			 * ability is still supported by DataTables 1.10+ to provide backwards
			 * compatibility, but this option of use is now decremented and no longer
			 * documented in DataTables 1.10+.
			 *
			 *  @type object
			 *  @default {}
			 *
			 *  @example
			 *    // Show previous, next and current page buttons only
			 *    $.fn.dataTableExt.oPagination.current = function ( page, pages ) {
			 *      return [ 'previous', page, 'next' ];
			 *    };
			 */
			pager: {},
		
		
			renderer: {
				pageButton: {},
				header: {}
			},
		
		
			/**
			 * Ordering plug-ins - custom data source
			 * 
			 * The extension options for ordering of data available here is complimentary
			 * to the default type based ordering that DataTables typically uses. It
			 * allows much greater control over the the data that is being used to
			 * order a column, but is necessarily therefore more complex.
			 * 
			 * This type of ordering is useful if you want to do ordering based on data
			 * live from the DOM (for example the contents of an 'input' element) rather
			 * than just the static string that DataTables knows of.
			 * 
			 * The way these plug-ins work is that you create an array of the values you
			 * wish to be ordering for the column in question and then return that
			 * array. The data in the array much be in the index order of the rows in
			 * the table (not the currently ordering order!). Which order data gathering
			 * function is run here depends on the `dt-init columns.orderDataType`
			 * parameter that is used for the column (if any).
			 *
			 * The functions defined take two parameters:
			 *
			 * 1. `{object}` DataTables settings object: see
			 *    {@link DataTable.models.oSettings}
			 * 2. `{int}` Target column index
			 *
			 * Each function is expected to return an array:
			 *
			 * * `{array}` Data for the column to be ordering upon
			 *
			 *  @type array
			 *
			 *  @example
			 *    // Ordering using `input` node values
			 *    $.fn.dataTable.ext.order['dom-text'] = function  ( settings, col )
			 *    {
			 *      return this.api().column( col, {order:'index'} ).nodes().map( function ( td, i ) {
			 *        return $('input', td).val();
			 *      } );
			 *    }
			 */
			order: {},
		
		
			/**
			 * Type based plug-ins.
			 *
			 * Each column in DataTables has a type assigned to it, either by automatic
			 * detection or by direct assignment using the `type` option for the column.
			 * The type of a column will effect how it is ordering and search (plug-ins
			 * can also make use of the column type if required).
			 *
			 * @namespace
			 */
			type: {
				/**
				 * Type detection functions.
				 *
				 * The functions defined in this object are used to automatically detect
				 * a column's type, making initialisation of DataTables super easy, even
				 * when complex data is in the table.
				 *
				 * The functions defined take two parameters:
				 *
			     *  1. `{*}` Data from the column cell to be analysed
			     *  2. `{settings}` DataTables settings object. This can be used to
			     *     perform context specific type detection - for example detection
			     *     based on language settings such as using a comma for a decimal
			     *     place. Generally speaking the options from the settings will not
			     *     be required
				 *
				 * Each function is expected to return:
				 *
				 * * `{string|null}` Data type detected, or null if unknown (and thus
				 *   pass it on to the other type detection functions.
				 *
				 *  @type array
				 *
				 *  @example
				 *    // Currency type detection plug-in:
				 *    $.fn.dataTable.ext.type.detect.push(
				 *      function ( data, settings ) {
				 *        // Check the numeric part
				 *        if ( ! $.isNumeric( data.substring(1) ) ) {
				 *          return null;
				 *        }
				 *
				 *        // Check prefixed by currency
				 *        if ( data.charAt(0) == '$' || data.charAt(0) == '&pound;' ) {
				 *          return 'currency';
				 *        }
				 *        return null;
				 *      }
				 *    );
				 */
				detect: [],
		
		
				/**
				 * Type based search formatting.
				 *
				 * The type based searching functions can be used to pre-format the
				 * data to be search on. For example, it can be used to strip HTML
				 * tags or to de-format telephone numbers for numeric only searching.
				 *
				 * Note that is a search is not defined for a column of a given type,
				 * no search formatting will be performed.
				 * 
				 * Pre-processing of searching data plug-ins - When you assign the sType
				 * for a column (or have it automatically detected for you by DataTables
				 * or a type detection plug-in), you will typically be using this for
				 * custom sorting, but it can also be used to provide custom searching
				 * by allowing you to pre-processing the data and returning the data in
				 * the format that should be searched upon. This is done by adding
				 * functions this object with a parameter name which matches the sType
				 * for that target column. This is the corollary of <i>afnSortData</i>
				 * for searching data.
				 *
				 * The functions defined take a single parameter:
				 *
			     *  1. `{*}` Data from the column cell to be prepared for searching
				 *
				 * Each function is expected to return:
				 *
				 * * `{string|null}` Formatted string that will be used for the searching.
				 *
				 *  @type object
				 *  @default {}
				 *
				 *  @example
				 *    $.fn.dataTable.ext.type.search['title-numeric'] = function ( d ) {
				 *      return d.replace(/\n/g," ").replace( /<.*?>/g, "" );
				 *    }
				 */
				search: {},
		
		
				/**
				 * Type based ordering.
				 *
				 * The column type tells DataTables what ordering to apply to the table
				 * when a column is sorted upon. The order for each type that is defined,
				 * is defined by the functions available in this object.
				 *
				 * Each ordering option can be described by three properties added to
				 * this object:
				 *
				 * * `{type}-pre` - Pre-formatting function
				 * * `{type}-asc` - Ascending order function
				 * * `{type}-desc` - Descending order function
				 *
				 * All three can be used together, only `{type}-pre` or only
				 * `{type}-asc` and `{type}-desc` together. It is generally recommended
				 * that only `{type}-pre` is used, as this provides the optimal
				 * implementation in terms of speed, although the others are provided
				 * for compatibility with existing Javascript sort functions.
				 *
				 * `{type}-pre`: Functions defined take a single parameter:
				 *
			     *  1. `{*}` Data from the column cell to be prepared for ordering
				 *
				 * And return:
				 *
				 * * `{*}` Data to be sorted upon
				 *
				 * `{type}-asc` and `{type}-desc`: Functions are typical Javascript sort
				 * functions, taking two parameters:
				 *
			     *  1. `{*}` Data to compare to the second parameter
			     *  2. `{*}` Data to compare to the first parameter
				 *
				 * And returning:
				 *
				 * * `{*}` Ordering match: <0 if first parameter should be sorted lower
				 *   than the second parameter, ===0 if the two parameters are equal and
				 *   >0 if the first parameter should be sorted height than the second
				 *   parameter.
				 * 
				 *  @type object
				 *  @default {}
				 *
				 *  @example
				 *    // Numeric ordering of formatted numbers with a pre-formatter
				 *    $.extend( $.fn.dataTable.ext.type.order, {
				 *      "string-pre": function(x) {
				 *        a = (a === "-" || a === "") ? 0 : a.replace( /[^\d\-\.]/g, "" );
				 *        return parseFloat( a );
				 *      }
				 *    } );
				 *
				 *  @example
				 *    // Case-sensitive string ordering, with no pre-formatting method
				 *    $.extend( $.fn.dataTable.ext.order, {
				 *      "string-case-asc": function(x,y) {
				 *        return ((x < y) ? -1 : ((x > y) ? 1 : 0));
				 *      },
				 *      "string-case-desc": function(x,y) {
				 *        return ((x < y) ? 1 : ((x > y) ? -1 : 0));
				 *      }
				 *    } );
				 */
				order: {}
			},
		
			/**
			 * Unique DataTables instance counter
			 *
			 * @type int
			 * @private
			 */
			_unique: 0,
		
		
			//
			// Depreciated
			// The following properties are retained for backwards compatiblity only.
			// The should not be used in new projects and will be removed in a future
			// version
			//
		
			/**
			 * Version check function.
			 *  @type function
			 *  @depreciated Since 1.10
			 */
			fnVersionCheck: DataTable.fnVersionCheck,
		
		
			/**
			 * Index for what 'this' index API functions should use
			 *  @type int
			 *  @deprecated Since v1.10
			 */
			iApiIndex: 0,
		
		
			/**
			 * jQuery UI class container
			 *  @type object
			 *  @deprecated Since v1.10
			 */
			oJUIClasses: {},
		
		
			/**
			 * Software version
			 *  @type string
			 *  @deprecated Since v1.10
			 */
			sVersion: DataTable.version
		};
		
		
		//
		// Backwards compatibility. Alias to pre 1.10 Hungarian notation counter parts
		//
		$.extend( _ext, {
			afnFiltering: _ext.search,
			aTypes:       _ext.type.detect,
			ofnSearch:    _ext.type.search,
			oSort:        _ext.type.order,
			afnSortData:  _ext.order,
			aoFeatures:   _ext.feature,
			oApi:         _ext.internal,
			oStdClasses:  _ext.classes,
			oPagination:  _ext.pager
		} );
		
		
		$.extend( DataTable.ext.classes, {
			"sTable": "dataTable",
			"sNoFooter": "no-footer",
		
			/* Paging buttons */
			"sPageButton": "paginate_button",
			"sPageButtonActive": "current",
			"sPageButtonDisabled": "disabled",
		
			/* Striping classes */
			"sStripeOdd": "odd",
			"sStripeEven": "even",
		
			/* Empty row */
			"sRowEmpty": "dataTables_empty",
		
			/* Features */
			"sWrapper": "dataTables_wrapper",
			"sFilter": "dataTables_filter",
			"sInfo": "dataTables_info",
			"sPaging": "dataTables_paginate paging_", /* Note that the type is postfixed */
			"sLength": "dataTables_length",
			"sProcessing": "dataTables_processing",
		
			/* Sorting */
			"sSortAsc": "sorting_asc",
			"sSortDesc": "sorting_desc",
			"sSortable": "sorting", /* Sortable in both directions */
			"sSortableAsc": "sorting_asc_disabled",
			"sSortableDesc": "sorting_desc_disabled",
			"sSortableNone": "sorting_disabled",
			"sSortColumn": "sorting_", /* Note that an int is postfixed for the sorting order */
		
			/* Filtering */
			"sFilterInput": "",
		
			/* Page length */
			"sLengthSelect": "",
		
			/* Scrolling */
			"sScrollWrapper": "dataTables_scroll",
			"sScrollHead": "dataTables_scrollHead",
			"sScrollHeadInner": "dataTables_scrollHeadInner",
			"sScrollBody": "dataTables_scrollBody",
			"sScrollFoot": "dataTables_scrollFoot",
			"sScrollFootInner": "dataTables_scrollFootInner",
		
			/* Misc */
			"sHeaderTH": "",
			"sFooterTH": "",
		
			// Deprecated
			"sSortJUIAsc": "",
			"sSortJUIDesc": "",
			"sSortJUI": "",
			"sSortJUIAscAllowed": "",
			"sSortJUIDescAllowed": "",
			"sSortJUIWrapper": "",
			"sSortIcon": "",
			"sJUIHeader": "",
			"sJUIFooter": ""
		} );
		
		
		(function() {
		
		// Reused strings for better compression. Closure compiler appears to have a
		// weird edge case where it is trying to expand strings rather than use the
		// variable version. This results in about 200 bytes being added, for very
		// little preference benefit since it this run on script load only.
		var _empty = '';
		_empty = '';
		
		var _stateDefault = _empty + 'ui-state-default';
		var _sortIcon     = _empty + 'css_right ui-icon ui-icon-';
		var _headerFooter = _empty + 'fg-toolbar ui-toolbar ui-widget-header ui-helper-clearfix';
		
		$.extend( DataTable.ext.oJUIClasses, DataTable.ext.classes, {
			/* Full numbers paging buttons */
			"sPageButton":         "fg-button ui-button "+_stateDefault,
			"sPageButtonActive":   "ui-state-disabled",
			"sPageButtonDisabled": "ui-state-disabled",
		
			/* Features */
			"sPaging": "dataTables_paginate fg-buttonset ui-buttonset fg-buttonset-multi "+
				"ui-buttonset-multi paging_", /* Note that the type is postfixed */
		
			/* Sorting */
			"sSortAsc":            _stateDefault+" sorting_asc",
			"sSortDesc":           _stateDefault+" sorting_desc",
			"sSortable":           _stateDefault+" sorting",
			"sSortableAsc":        _stateDefault+" sorting_asc_disabled",
			"sSortableDesc":       _stateDefault+" sorting_desc_disabled",
			"sSortableNone":       _stateDefault+" sorting_disabled",
			"sSortJUIAsc":         _sortIcon+"triangle-1-n",
			"sSortJUIDesc":        _sortIcon+"triangle-1-s",
			"sSortJUI":            _sortIcon+"carat-2-n-s",
			"sSortJUIAscAllowed":  _sortIcon+"carat-1-n",
			"sSortJUIDescAllowed": _sortIcon+"carat-1-s",
			"sSortJUIWrapper":     "DataTables_sort_wrapper",
			"sSortIcon":           "DataTables_sort_icon",
		
			/* Scrolling */
			"sScrollHead": "dataTables_scrollHead "+_stateDefault,
			"sScrollFoot": "dataTables_scrollFoot "+_stateDefault,
		
			/* Misc */
			"sHeaderTH":  _stateDefault,
			"sFooterTH":  _stateDefault,
			"sJUIHeader": _headerFooter+" ui-corner-tl ui-corner-tr",
			"sJUIFooter": _headerFooter+" ui-corner-bl ui-corner-br"
		} );
		
		}());
		
		
		
		var extPagination = DataTable.ext.pager;
		
		function _numbers ( page, pages ) {
			var
				numbers = [],
				buttons = extPagination.numbers_length,
				half = Math.floor( buttons / 2 ),
				i = 1;
		
			if ( pages <= buttons ) {
				numbers = _range( 0, pages );
			}
			else if ( page <= half ) {
				numbers = _range( 0, buttons-2 );
				numbers.push( 'ellipsis' );
				numbers.push( pages-1 );
			}
			else if ( page >= pages - 1 - half ) {
				numbers = _range( pages-(buttons-2), pages );
				numbers.splice( 0, 0, 'ellipsis' ); // no unshift in ie6
				numbers.splice( 0, 0, 0 );
			}
			else {
				numbers = _range( page-half+2, page+half-1 );
				numbers.push( 'ellipsis' );
				numbers.push( pages-1 );
				numbers.splice( 0, 0, 'ellipsis' );
				numbers.splice( 0, 0, 0 );
			}
		
			numbers.DT_el = 'span';
			return numbers;
		}
		
		
		$.extend( extPagination, {
			simple: function ( page, pages ) {
				return [ 'previous', 'next' ];
			},
		
			full: function ( page, pages ) {
				return [  'first', 'previous', 'next', 'last' ];
			},
		
			numbers: function ( page, pages ) {
				return [ _numbers(page, pages) ];
			},
		
			simple_numbers: function ( page, pages ) {
				return [ 'previous', _numbers(page, pages), 'next' ];
			},
		
			full_numbers: function ( page, pages ) {
				return [ 'first', 'previous', _numbers(page, pages), 'next', 'last' ];
			},
		
			// For testing and plug-ins to use
			_numbers: _numbers,
		
			// Number of number buttons (including ellipsis) to show. _Must be odd!_
			numbers_length: 7
		} );
		
		
		$.extend( true, DataTable.ext.renderer, {
			pageButton: {
				_: function ( settings, host, idx, buttons, page, pages ) {
					var classes = settings.oClasses;
					var lang = settings.oLanguage.oPaginate;
					var aria = settings.oLanguage.oAria.paginate || {};
					var btnDisplay, btnClass, counter=0;
		
					var attach = function( container, buttons ) {
						var i, ien, node, button;
						var clickHandler = function ( e ) {
							_fnPageChange( settings, e.data.action, true );
						};
		
						for ( i=0, ien=buttons.length ; i<ien ; i++ ) {
							button = buttons[i];
		
							if ( $.isArray( button ) ) {
								var inner = $( '<'+(button.DT_el || 'div')+'/>' )
									.appendTo( container );
								attach( inner, button );
							}
							else {
								btnDisplay = null;
								btnClass = '';
		
								switch ( button ) {
									case 'ellipsis':
										container.append('<span class="ellipsis">&#x2026;</span>');
										break;
		
									case 'first':
										btnDisplay = lang.sFirst;
										btnClass = button + (page > 0 ?
											'' : ' '+classes.sPageButtonDisabled);
										break;
		
									case 'previous':
										btnDisplay = lang.sPrevious;
										btnClass = button + (page > 0 ?
											'' : ' '+classes.sPageButtonDisabled);
										break;
		
									case 'next':
										btnDisplay = lang.sNext;
										btnClass = button + (page < pages-1 ?
											'' : ' '+classes.sPageButtonDisabled);
										break;
		
									case 'last':
										btnDisplay = lang.sLast;
										btnClass = button + (page < pages-1 ?
											'' : ' '+classes.sPageButtonDisabled);
										break;
		
									default:
										btnDisplay = button + 1;
										btnClass = page === button ?
											classes.sPageButtonActive : '';
										break;
								}
		
								if ( btnDisplay !== null ) {
									node = $('<a>', {
											'class': classes.sPageButton+' '+btnClass,
											'aria-controls': settings.sTableId,
											'aria-label': aria[ button ],
											'data-dt-idx': counter,
											'tabindex': settings.iTabIndex,
											'id': idx === 0 && typeof button === 'string' ?
												settings.sTableId +'_'+ button :
												null
										} )
										.html( btnDisplay )
										.appendTo( container );
		
									_fnBindAction(
										node, {action: button}, clickHandler
									);
		
									counter++;
								}
							}
						}
					};
		
					// IE9 throws an 'unknown error' if document.activeElement is used
					// inside an iframe or frame. Try / catch the error. Not good for
					// accessibility, but neither are frames.
					var activeEl;
		
					try {
						// Because this approach is destroying and recreating the paging
						// elements, focus is lost on the select button which is bad for
						// accessibility. So we want to restore focus once the draw has
						// completed
						activeEl = $(host).find(document.activeElement).data('dt-idx');
					}
					catch (e) {}
		
					attach( $(host).empty(), buttons );
		
					if ( activeEl ) {
						$(host).find( '[data-dt-idx='+activeEl+']' ).focus();
					}
				}
			}
		} );
		
		
		
		// Built in type detection. See model.ext.aTypes for information about
		// what is required from this methods.
		$.extend( DataTable.ext.type.detect, [
			// Plain numbers - first since V8 detects some plain numbers as dates
			// e.g. Date.parse('55') (but not all, e.g. Date.parse('22')...).
			function ( d, settings )
			{
				var decimal = settings.oLanguage.sDecimal;
				return _isNumber( d, decimal ) ? 'num'+decimal : null;
			},
		
			// Dates (only those recognised by the browser's Date.parse)
			function ( d, settings )
			{
				// V8 will remove any unknown characters at the start and end of the
				// expression, leading to false matches such as `$245.12` or `10%` being
				// a valid date. See forum thread 18941 for detail.
				if ( d && !(d instanceof Date) && ( ! _re_date_start.test(d) || ! _re_date_end.test(d) ) ) {
					return null;
				}
				var parsed = Date.parse(d);
				return (parsed !== null && !isNaN(parsed)) || _empty(d) ? 'date' : null;
			},
		
			// Formatted numbers
			function ( d, settings )
			{
				var decimal = settings.oLanguage.sDecimal;
				return _isNumber( d, decimal, true ) ? 'num-fmt'+decimal : null;
			},
		
			// HTML numeric
			function ( d, settings )
			{
				var decimal = settings.oLanguage.sDecimal;
				return _htmlNumeric( d, decimal ) ? 'html-num'+decimal : null;
			},
		
			// HTML numeric, formatted
			function ( d, settings )
			{
				var decimal = settings.oLanguage.sDecimal;
				return _htmlNumeric( d, decimal, true ) ? 'html-num-fmt'+decimal : null;
			},
		
			// HTML (this is strict checking - there must be html)
			function ( d, settings )
			{
				return _empty( d ) || (typeof d === 'string' && d.indexOf('<') !== -1) ?
					'html' : null;
			}
		] );
		
		
		
		// Filter formatting functions. See model.ext.ofnSearch for information about
		// what is required from these methods.
		// 
		// Note that additional search methods are added for the html numbers and
		// html formatted numbers by `_addNumericSort()` when we know what the decimal
		// place is
		
		
		$.extend( DataTable.ext.type.search, {
			html: function ( data ) {
				return _empty(data) ?
					data :
					typeof data === 'string' ?
						data
							.replace( _re_new_lines, " " )
							.replace( _re_html, "" ) :
						'';
			},
		
			string: function ( data ) {
				return _empty(data) ?
					data :
					typeof data === 'string' ?
						data.replace( _re_new_lines, " " ) :
						data;
			}
		} );
		
		
		
		var __numericReplace = function ( d, decimalPlace, re1, re2 ) {
			if ( d !== 0 && (!d || d === '-') ) {
				return -Infinity;
			}
		
			// If a decimal place other than `.` is used, it needs to be given to the
			// function so we can detect it and replace with a `.` which is the only
			// decimal place Javascript recognises - it is not locale aware.
			if ( decimalPlace ) {
				d = _numToDecimal( d, decimalPlace );
			}
		
			if ( d.replace ) {
				if ( re1 ) {
					d = d.replace( re1, '' );
				}
		
				if ( re2 ) {
					d = d.replace( re2, '' );
				}
			}
		
			return d * 1;
		};
		
		
		// Add the numeric 'deformatting' functions for sorting and search. This is done
		// in a function to provide an easy ability for the language options to add
		// additional methods if a non-period decimal place is used.
		function _addNumericSort ( decimalPlace ) {
			$.each(
				{
					// Plain numbers
					"num": function ( d ) {
						return __numericReplace( d, decimalPlace );
					},
		
					// Formatted numbers
					"num-fmt": function ( d ) {
						return __numericReplace( d, decimalPlace, _re_formatted_numeric );
					},
		
					// HTML numeric
					"html-num": function ( d ) {
						return __numericReplace( d, decimalPlace, _re_html );
					},
		
					// HTML numeric, formatted
					"html-num-fmt": function ( d ) {
						return __numericReplace( d, decimalPlace, _re_html, _re_formatted_numeric );
					}
				},
				function ( key, fn ) {
					// Add the ordering method
					_ext.type.order[ key+decimalPlace+'-pre' ] = fn;
		
					// For HTML types add a search formatter that will strip the HTML
					if ( key.match(/^html\-/) ) {
						_ext.type.search[ key+decimalPlace ] = _ext.type.search.html;
					}
				}
			);
		}
		
		
		// Default sort methods
		$.extend( _ext.type.order, {
			// Dates
			"date-pre": function ( d ) {
				return Date.parse( d ) || 0;
			},
		
			// html
			"html-pre": function ( a ) {
				return _empty(a) ?
					'' :
					a.replace ?
						a.replace( /<.*?>/g, "" ).toLowerCase() :
						a+'';
			},
		
			// string
			"string-pre": function ( a ) {
				// This is a little complex, but faster than always calling toString,
				// http://jsperf.com/tostring-v-check
				return _empty(a) ?
					'' :
					typeof a === 'string' ?
						a.toLowerCase() :
						! a.toString ?
							'' :
							a.toString();
			},
		
			// string-asc and -desc are retained only for compatibility with the old
			// sort methods
			"string-asc": function ( x, y ) {
				return ((x < y) ? -1 : ((x > y) ? 1 : 0));
			},
		
			"string-desc": function ( x, y ) {
				return ((x < y) ? 1 : ((x > y) ? -1 : 0));
			}
		} );
		
		
		// Numeric sorting types - order doesn't matter here
		_addNumericSort( '' );
		
		
		$.extend( true, DataTable.ext.renderer, {
			header: {
				_: function ( settings, cell, column, classes ) {
					// No additional mark-up required
					// Attach a sort listener to update on sort - note that using the
					// `DT` namespace will allow the event to be removed automatically
					// on destroy, while the `dt` namespaced event is the one we are
					// listening for
					$(settings.nTable).on( 'order.dt.DT', function ( e, ctx, sorting, columns ) {
						if ( settings !== ctx ) { // need to check this this is the host
							return;               // table, not a nested one
						}
		
						var colIdx = column.idx;
		
						cell
							.removeClass(
								column.sSortingClass +' '+
								classes.sSortAsc +' '+
								classes.sSortDesc
							)
							.addClass( columns[ colIdx ] == 'asc' ?
								classes.sSortAsc : columns[ colIdx ] == 'desc' ?
									classes.sSortDesc :
									column.sSortingClass
							);
					} );
				},
		
				jqueryui: function ( settings, cell, column, classes ) {
					$('<div/>')
						.addClass( classes.sSortJUIWrapper )
						.append( cell.contents() )
						.append( $('<span/>')
							.addClass( classes.sSortIcon+' '+column.sSortingClassJUI )
						)
						.appendTo( cell );
		
					// Attach a sort listener to update on sort
					$(settings.nTable).on( 'order.dt.DT', function ( e, ctx, sorting, columns ) {
						if ( settings !== ctx ) {
							return;
						}
		
						var colIdx = column.idx;
		
						cell
							.removeClass( classes.sSortAsc +" "+classes.sSortDesc )
							.addClass( columns[ colIdx ] == 'asc' ?
								classes.sSortAsc : columns[ colIdx ] == 'desc' ?
									classes.sSortDesc :
									column.sSortingClass
							);
		
						cell
							.find( 'span.'+classes.sSortIcon )
							.removeClass(
								classes.sSortJUIAsc +" "+
								classes.sSortJUIDesc +" "+
								classes.sSortJUI +" "+
								classes.sSortJUIAscAllowed +" "+
								classes.sSortJUIDescAllowed
							)
							.addClass( columns[ colIdx ] == 'asc' ?
								classes.sSortJUIAsc : columns[ colIdx ] == 'desc' ?
									classes.sSortJUIDesc :
									column.sSortingClassJUI
							);
					} );
				}
			}
		} );
		
		/*
		 * Public helper functions. These aren't used internally by DataTables, or
		 * called by any of the options passed into DataTables, but they can be used
		 * externally by developers working with DataTables. They are helper functions
		 * to make working with DataTables a little bit easier.
		 */
		
		var __htmlEscapeEntities = function ( d ) {
			return typeof d === 'string' ?
				d.replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;') :
				d;
		};
		
		/**
		 * Helpers for `columns.render`.
		 *
		 * The options defined here can be used with the `columns.render` initialisation
		 * option to provide a display renderer. The following functions are defined:
		 *
		 * * `number` - Will format numeric data (defined by `columns.data`) for
		 *   display, retaining the original unformatted data for sorting and filtering.
		 *   It takes 5 parameters:
		 *   * `string` - Thousands grouping separator
		 *   * `string` - Decimal point indicator
		 *   * `integer` - Number of decimal points to show
		 *   * `string` (optional) - Prefix.
		 *   * `string` (optional) - Postfix (/suffix).
		 * * `text` - Escape HTML to help prevent XSS attacks. It has no optional
		 *   parameters.
		 *
		 * @example
		 *   // Column definition using the number renderer
		 *   {
		 *     data: "salary",
		 *     render: $.fn.dataTable.render.number( '\'', '.', 0, '$' )
		 *   }
		 *
		 * @namespace
		 */
		DataTable.render = {
			number: function ( thousands, decimal, precision, prefix, postfix ) {
				return {
					display: function ( d ) {
						if ( typeof d !== 'number' && typeof d !== 'string' ) {
							return d;
						}
		
						var negative = d < 0 ? '-' : '';
						var flo = parseFloat( d );
		
						// If NaN then there isn't much formatting that we can do - just
						// return immediately, escaping any HTML (this was supposed to
						// be a number after all)
						if ( isNaN( flo ) ) {
							return __htmlEscapeEntities( d );
						}
		
						d = Math.abs( flo );
		
						var intPart = parseInt( d, 10 );
						var floatPart = precision ?
							decimal+(d - intPart).toFixed( precision ).substring( 2 ):
							'';
		
						return negative + (prefix||'') +
							intPart.toString().replace(
								/\B(?=(\d{3})+(?!\d))/g, thousands
							) +
							floatPart +
							(postfix||'');
					}
				};
			},
		
			text: function () {
				return {
					display: __htmlEscapeEntities
				};
			}
		};
		
		
		/*
		 * This is really a good bit rubbish this method of exposing the internal methods
		 * publicly... - To be fixed in 2.0 using methods on the prototype
		 */
		
		
		/**
		 * Create a wrapper function for exporting an internal functions to an external API.
		 *  @param {string} fn API function name
		 *  @returns {function} wrapped function
		 *  @memberof DataTable#internal
		 */
		function _fnExternApiFunc (fn)
		{
			return function() {
				var args = [_fnSettingsFromNode( this[DataTable.ext.iApiIndex] )].concat(
					Array.prototype.slice.call(arguments)
				);
				return DataTable.ext.internal[fn].apply( this, args );
			};
		}
		
		
		/**
		 * Reference to internal functions for use by plug-in developers. Note that
		 * these methods are references to internal functions and are considered to be
		 * private. If you use these methods, be aware that they are liable to change
		 * between versions.
		 *  @namespace
		 */
		$.extend( DataTable.ext.internal, {
			_fnExternApiFunc: _fnExternApiFunc,
			_fnBuildAjax: _fnBuildAjax,
			_fnAjaxUpdate: _fnAjaxUpdate,
			_fnAjaxParameters: _fnAjaxParameters,
			_fnAjaxUpdateDraw: _fnAjaxUpdateDraw,
			_fnAjaxDataSrc: _fnAjaxDataSrc,
			_fnAddColumn: _fnAddColumn,
			_fnColumnOptions: _fnColumnOptions,
			_fnAdjustColumnSizing: _fnAdjustColumnSizing,
			_fnVisibleToColumnIndex: _fnVisibleToColumnIndex,
			_fnColumnIndexToVisible: _fnColumnIndexToVisible,
			_fnVisbleColumns: _fnVisbleColumns,
			_fnGetColumns: _fnGetColumns,
			_fnColumnTypes: _fnColumnTypes,
			_fnApplyColumnDefs: _fnApplyColumnDefs,
			_fnHungarianMap: _fnHungarianMap,
			_fnCamelToHungarian: _fnCamelToHungarian,
			_fnLanguageCompat: _fnLanguageCompat,
			_fnBrowserDetect: _fnBrowserDetect,
			_fnAddData: _fnAddData,
			_fnAddTr: _fnAddTr,
			_fnNodeToDataIndex: _fnNodeToDataIndex,
			_fnNodeToColumnIndex: _fnNodeToColumnIndex,
			_fnGetCellData: _fnGetCellData,
			_fnSetCellData: _fnSetCellData,
			_fnSplitObjNotation: _fnSplitObjNotation,
			_fnGetObjectDataFn: _fnGetObjectDataFn,
			_fnSetObjectDataFn: _fnSetObjectDataFn,
			_fnGetDataMaster: _fnGetDataMaster,
			_fnClearTable: _fnClearTable,
			_fnDeleteIndex: _fnDeleteIndex,
			_fnInvalidate: _fnInvalidate,
			_fnGetRowElements: _fnGetRowElements,
			_fnCreateTr: _fnCreateTr,
			_fnBuildHead: _fnBuildHead,
			_fnDrawHead: _fnDrawHead,
			_fnDraw: _fnDraw,
			_fnReDraw: _fnReDraw,
			_fnAddOptionsHtml: _fnAddOptionsHtml,
			_fnDetectHeader: _fnDetectHeader,
			_fnGetUniqueThs: _fnGetUniqueThs,
			_fnFeatureHtmlFilter: _fnFeatureHtmlFilter,
			_fnFilterComplete: _fnFilterComplete,
			_fnFilterCustom: _fnFilterCustom,
			_fnFilterColumn: _fnFilterColumn,
			_fnFilter: _fnFilter,
			_fnFilterCreateSearch: _fnFilterCreateSearch,
			_fnEscapeRegex: _fnEscapeRegex,
			_fnFilterData: _fnFilterData,
			_fnFeatureHtmlInfo: _fnFeatureHtmlInfo,
			_fnUpdateInfo: _fnUpdateInfo,
			_fnInfoMacros: _fnInfoMacros,
			_fnInitialise: _fnInitialise,
			_fnInitComplete: _fnInitComplete,
			_fnLengthChange: _fnLengthChange,
			_fnFeatureHtmlLength: _fnFeatureHtmlLength,
			_fnFeatureHtmlPaginate: _fnFeatureHtmlPaginate,
			_fnPageChange: _fnPageChange,
			_fnFeatureHtmlProcessing: _fnFeatureHtmlProcessing,
			_fnProcessingDisplay: _fnProcessingDisplay,
			_fnFeatureHtmlTable: _fnFeatureHtmlTable,
			_fnScrollDraw: _fnScrollDraw,
			_fnApplyToChildren: _fnApplyToChildren,
			_fnCalculateColumnWidths: _fnCalculateColumnWidths,
			_fnThrottle: _fnThrottle,
			_fnConvertToWidth: _fnConvertToWidth,
			_fnGetWidestNode: _fnGetWidestNode,
			_fnGetMaxLenString: _fnGetMaxLenString,
			_fnStringToCss: _fnStringToCss,
			_fnSortFlatten: _fnSortFlatten,
			_fnSort: _fnSort,
			_fnSortAria: _fnSortAria,
			_fnSortListener: _fnSortListener,
			_fnSortAttachListener: _fnSortAttachListener,
			_fnSortingClasses: _fnSortingClasses,
			_fnSortData: _fnSortData,
			_fnSaveState: _fnSaveState,
			_fnLoadState: _fnLoadState,
			_fnSettingsFromNode: _fnSettingsFromNode,
			_fnLog: _fnLog,
			_fnMap: _fnMap,
			_fnBindAction: _fnBindAction,
			_fnCallbackReg: _fnCallbackReg,
			_fnCallbackFire: _fnCallbackFire,
			_fnLengthOverflow: _fnLengthOverflow,
			_fnRenderer: _fnRenderer,
			_fnDataSource: _fnDataSource,
			_fnRowAttributes: _fnRowAttributes,
			_fnCalculateEnd: function () {} // Used by a lot of plug-ins, but redundant
			                                // in 1.10, so this dead-end function is
			                                // added to prevent errors
		} );
		
	
		// jQuery access
		$.fn.dataTable = DataTable;
	
		// Provide access to the host jQuery object (circular reference)
		DataTable.$ = $;
	
		// Legacy aliases
		$.fn.dataTableSettings = DataTable.settings;
		$.fn.dataTableExt = DataTable.ext;
	
		// With a capital `D` we return a DataTables API instance rather than a
		// jQuery object
		$.fn.DataTable = function ( opts ) {
			return $(this).dataTable( opts ).api();
		};
	
		// All properties that are available to $.fn.dataTable should also be
		// available on $.fn.DataTable
		$.each( DataTable, function ( prop, val ) {
			$.fn.DataTable[ prop ] = val;
		} );
	
	
		// Information about events fired by DataTables - for documentation.
		/**
		 * Draw event, fired whenever the table is redrawn on the page, at the same
		 * point as fnDrawCallback. This may be useful for binding events or
		 * performing calculations when the table is altered at all.
		 *  @name DataTable#draw.dt
		 *  @event
		 *  @param {event} e jQuery event object
		 *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
		 */
	
		/**
		 * Search event, fired when the searching applied to the table (using the
		 * built-in global search, or column filters) is altered.
		 *  @name DataTable#search.dt
		 *  @event
		 *  @param {event} e jQuery event object
		 *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
		 */
	
		/**
		 * Page change event, fired when the paging of the table is altered.
		 *  @name DataTable#page.dt
		 *  @event
		 *  @param {event} e jQuery event object
		 *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
		 */
	
		/**
		 * Order event, fired when the ordering applied to the table is altered.
		 *  @name DataTable#order.dt
		 *  @event
		 *  @param {event} e jQuery event object
		 *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
		 */
	
		/**
		 * DataTables initialisation complete event, fired when the table is fully
		 * drawn, including Ajax data loaded, if Ajax data is required.
		 *  @name DataTable#init.dt
		 *  @event
		 *  @param {event} e jQuery event object
		 *  @param {object} oSettings DataTables settings object
		 *  @param {object} json The JSON object request from the server - only
		 *    present if client-side Ajax sourced data is used</li></ol>
		 */
	
		/**
		 * State save event, fired when the table has changed state a new state save
		 * is required. This event allows modification of the state saving object
		 * prior to actually doing the save, including addition or other state
		 * properties (for plug-ins) or modification of a DataTables core property.
		 *  @name DataTable#stateSaveParams.dt
		 *  @event
		 *  @param {event} e jQuery event object
		 *  @param {object} oSettings DataTables settings object
		 *  @param {object} json The state information to be saved
		 */
	
		/**
		 * State load event, fired when the table is loading state from the stored
		 * data, but prior to the settings object being modified by the saved state
		 * - allowing modification of the saved state is required or loading of
		 * state for a plug-in.
		 *  @name DataTable#stateLoadParams.dt
		 *  @event
		 *  @param {event} e jQuery event object
		 *  @param {object} oSettings DataTables settings object
		 *  @param {object} json The saved state information
		 */
	
		/**
		 * State loaded event, fired when state has been loaded from stored data and
		 * the settings object has been modified by the loaded data.
		 *  @name DataTable#stateLoaded.dt
		 *  @event
		 *  @param {event} e jQuery event object
		 *  @param {object} oSettings DataTables settings object
		 *  @param {object} json The saved state information
		 */
	
		/**
		 * Processing event, fired when DataTables is doing some kind of processing
		 * (be it, order, searcg or anything else). It can be used to indicate to
		 * the end user that there is something happening, or that something has
		 * finished.
		 *  @name DataTable#processing.dt
		 *  @event
		 *  @param {event} e jQuery event object
		 *  @param {object} oSettings DataTables settings object
		 *  @param {boolean} bShow Flag for if DataTables is doing processing or not
		 */
	
		/**
		 * Ajax (XHR) event, fired whenever an Ajax request is completed from a
		 * request to made to the server for new data. This event is called before
		 * DataTables processed the returned data, so it can also be used to pre-
		 * process the data returned from the server, if needed.
		 *
		 * Note that this trigger is called in `fnServerData`, if you override
		 * `fnServerData` and which to use this event, you need to trigger it in you
		 * success function.
		 *  @name DataTable#xhr.dt
		 *  @event
		 *  @param {event} e jQuery event object
		 *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
		 *  @param {object} json JSON returned from the server
		 *
		 *  @example
		 *     // Use a custom property returned from the server in another DOM element
		 *     $('#table').dataTable().on('xhr.dt', function (e, settings, json) {
		 *       $('#status').html( json.status );
		 *     } );
		 *
		 *  @example
		 *     // Pre-process the data returned from the server
		 *     $('#table').dataTable().on('xhr.dt', function (e, settings, json) {
		 *       for ( var i=0, ien=json.aaData.length ; i<ien ; i++ ) {
		 *         json.aaData[i].sum = json.aaData[i].one + json.aaData[i].two;
		 *       }
		 *       // Note no return - manipulate the data directly in the JSON object.
		 *     } );
		 */
	
		/**
		 * Destroy event, fired when the DataTable is destroyed by calling fnDestroy
		 * or passing the bDestroy:true parameter in the initialisation object. This
		 * can be used to remove bound events, added DOM nodes, etc.
		 *  @name DataTable#destroy.dt
		 *  @event
		 *  @param {event} e jQuery event object
		 *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
		 */
	
		/**
		 * Page length change event, fired when number of records to show on each
		 * page (the length) is changed.
		 *  @name DataTable#length.dt
		 *  @event
		 *  @param {event} e jQuery event object
		 *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
		 *  @param {integer} len New length
		 */
	
		/**
		 * Column sizing has changed.
		 *  @name DataTable#column-sizing.dt
		 *  @event
		 *  @param {event} e jQuery event object
		 *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
		 */
	
		/**
		 * Column visibility has changed.
		 *  @name DataTable#column-visibility.dt
		 *  @event
		 *  @param {event} e jQuery event object
		 *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
		 *  @param {int} column Column index
		 *  @param {bool} vis `false` if column now hidden, or `true` if visible
		 */
	
		return $.fn.dataTable;
	}));


/***/ },
/* 15 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 16 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	 * HTML5 export buttons for Buttons and DataTables.
	 * 2016 SpryMedia Ltd - datatables.net/license
	 *
	 * FileSaver.js (1.1.20160328) - MIT license
	 * Copyright Â© 2016 Eli Grey - http://eligrey.com
	 */
	
	(function( factory ){
		if ( true ) {
			// AMD
			!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(1), __webpack_require__(4), __webpack_require__(17)], __WEBPACK_AMD_DEFINE_RESULT__ = function ( $ ) {
				return factory( $, window, document );
			}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
		}
		else if ( typeof exports === 'object' ) {
			// CommonJS
			module.exports = function (root, $, jszip, pdfmake) {
				if ( ! root ) {
					root = window;
				}
	
				if ( ! $ || ! $.fn.dataTable ) {
					$ = require('datatables.net')(root, $).$;
				}
	
				if ( ! $.fn.dataTable.Buttons ) {
					require('datatables.net-buttons')(root, $);
				}
	
				return factory( $, root, root.document, jszip, pdfmake );
			};
		}
		else {
			// Browser
			factory( jQuery, window, document );
		}
	}(function( $, window, document, jszip, pdfmake, undefined ) {
	'use strict';
	var DataTable = $.fn.dataTable;
	
	// Allow the constructor to pass in JSZip and PDFMake from external requires.
	// Otherwise, use globally defined variables, if they are available.
	function _jsZip () {
		return jszip || window.JSZip;
	}
	function _pdfMake () {
		return pdfmake || window.pdfMake;
	}
	
	
	/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	 * FileSaver.js dependency
	 */
	
	/*jslint bitwise: true, indent: 4, laxbreak: true, laxcomma: true, smarttabs: true, plusplus: true */
	
	var _saveAs = (function(view) {
		"use strict";
		// IE <10 is explicitly unsupported
		if (typeof navigator !== "undefined" && /MSIE [1-9]\./.test(navigator.userAgent)) {
			return;
		}
		var
			  doc = view.document
			  // only get URL when necessary in case Blob.js hasn't overridden it yet
			, get_URL = function() {
				return view.URL || view.webkitURL || view;
			}
			, save_link = doc.createElementNS("http://www.w3.org/1999/xhtml", "a")
			, can_use_save_link = "download" in save_link
			, click = function(node) {
				var event = new MouseEvent("click");
				node.dispatchEvent(event);
			}
			, is_safari = /Version\/[\d\.]+.*Safari/.test(navigator.userAgent)
			, webkit_req_fs = view.webkitRequestFileSystem
			, req_fs = view.requestFileSystem || webkit_req_fs || view.mozRequestFileSystem
			, throw_outside = function(ex) {
				(view.setImmediate || view.setTimeout)(function() {
					throw ex;
				}, 0);
			}
			, force_saveable_type = "application/octet-stream"
			, fs_min_size = 0
			// the Blob API is fundamentally broken as there is no "downloadfinished" event to subscribe to
			, arbitrary_revoke_timeout = 1000 * 40 // in ms
			, revoke = function(file) {
				var revoker = function() {
					if (typeof file === "string") { // file is an object URL
						get_URL().revokeObjectURL(file);
					} else { // file is a File
						file.remove();
					}
				};
				/* // Take note W3C:
				var
				  uri = typeof file === "string" ? file : file.toURL()
				, revoker = function(evt) {
					// idealy DownloadFinishedEvent.data would be the URL requested
					if (evt.data === uri) {
						if (typeof file === "string") { // file is an object URL
							get_URL().revokeObjectURL(file);
						} else { // file is a File
							file.remove();
						}
					}
				}
				;
				view.addEventListener("downloadfinished", revoker);
				*/
				setTimeout(revoker, arbitrary_revoke_timeout);
			}
			, dispatch = function(filesaver, event_types, event) {
				event_types = [].concat(event_types);
				var i = event_types.length;
				while (i--) {
					var listener = filesaver["on" + event_types[i]];
					if (typeof listener === "function") {
						try {
							listener.call(filesaver, event || filesaver);
						} catch (ex) {
							throw_outside(ex);
						}
					}
				}
			}
			, auto_bom = function(blob) {
				// prepend BOM for UTF-8 XML and text/* types (including HTML)
				if (/^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(blob.type)) {
					return new Blob(["\ufeff", blob], {type: blob.type});
				}
				return blob;
			}
			, FileSaver = function(blob, name, no_auto_bom) {
				if (!no_auto_bom) {
					blob = auto_bom(blob);
				}
				// First try a.download, then web filesystem, then object URLs
				var
					  filesaver = this
					, type = blob.type
					, blob_changed = false
					, object_url
					, target_view
					, dispatch_all = function() {
						dispatch(filesaver, "writestart progress write writeend".split(" "));
					}
					// on any filesys errors revert to saving with object URLs
					, fs_error = function() {
						if (target_view && is_safari && typeof FileReader !== "undefined") {
							// Safari doesn't allow downloading of blob urls
							var reader = new FileReader();
							reader.onloadend = function() {
								var base64Data = reader.result;
								target_view.location.href = "data:attachment/file" + base64Data.slice(base64Data.search(/[,;]/));
								filesaver.readyState = filesaver.DONE;
								dispatch_all();
							};
							reader.readAsDataURL(blob);
							filesaver.readyState = filesaver.INIT;
							return;
						}
						// don't create more object URLs than needed
						if (blob_changed || !object_url) {
							object_url = get_URL().createObjectURL(blob);
						}
						if (target_view) {
							target_view.location.href = object_url;
						} else {
							var new_tab = view.open(object_url, "_blank");
							if (new_tab === undefined && is_safari) {
								//Apple do not allow window.open, see http://bit.ly/1kZffRI
								view.location.href = object_url
							}
						}
						filesaver.readyState = filesaver.DONE;
						dispatch_all();
						revoke(object_url);
					}
					, abortable = function(func) {
						return function() {
							if (filesaver.readyState !== filesaver.DONE) {
								return func.apply(this, arguments);
							}
						};
					}
					, create_if_not_found = {create: true, exclusive: false}
					, slice
				;
				filesaver.readyState = filesaver.INIT;
				if (!name) {
					name = "download";
				}
				if (can_use_save_link) {
					object_url = get_URL().createObjectURL(blob);
					setTimeout(function() {
						save_link.href = object_url;
						save_link.download = name;
						click(save_link);
						dispatch_all();
						revoke(object_url);
						filesaver.readyState = filesaver.DONE;
					});
					return;
				}
				// Object and web filesystem URLs have a problem saving in Google Chrome when
				// viewed in a tab, so I force save with application/octet-stream
				// http://code.google.com/p/chromium/issues/detail?id=91158
				// Update: Google errantly closed 91158, I submitted it again:
				// https://code.google.com/p/chromium/issues/detail?id=389642
				if (view.chrome && type && type !== force_saveable_type) {
					slice = blob.slice || blob.webkitSlice;
					blob = slice.call(blob, 0, blob.size, force_saveable_type);
					blob_changed = true;
				}
				// Since I can't be sure that the guessed media type will trigger a download
				// in WebKit, I append .download to the filename.
				// https://bugs.webkit.org/show_bug.cgi?id=65440
				if (webkit_req_fs && name !== "download") {
					name += ".download";
				}
				if (type === force_saveable_type || webkit_req_fs) {
					target_view = view;
				}
				if (!req_fs) {
					fs_error();
					return;
				}
				fs_min_size += blob.size;
				req_fs(view.TEMPORARY, fs_min_size, abortable(function(fs) {
					fs.root.getDirectory("saved", create_if_not_found, abortable(function(dir) {
						var save = function() {
							dir.getFile(name, create_if_not_found, abortable(function(file) {
								file.createWriter(abortable(function(writer) {
									writer.onwriteend = function(event) {
										target_view.location.href = file.toURL();
										filesaver.readyState = filesaver.DONE;
										dispatch(filesaver, "writeend", event);
										revoke(file);
									};
									writer.onerror = function() {
										var error = writer.error;
										if (error.code !== error.ABORT_ERR) {
											fs_error();
										}
									};
									"writestart progress write abort".split(" ").forEach(function(event) {
										writer["on" + event] = filesaver["on" + event];
									});
									writer.write(blob);
									filesaver.abort = function() {
										writer.abort();
										filesaver.readyState = filesaver.DONE;
									};
									filesaver.readyState = filesaver.WRITING;
								}), fs_error);
							}), fs_error);
						};
						dir.getFile(name, {create: false}, abortable(function(file) {
							// delete file if it already exists
							file.remove();
							save();
						}), abortable(function(ex) {
							if (ex.code === ex.NOT_FOUND_ERR) {
								save();
							} else {
								fs_error();
							}
						}));
					}), fs_error);
				}), fs_error);
			}
			, FS_proto = FileSaver.prototype
			, saveAs = function(blob, name, no_auto_bom) {
				return new FileSaver(blob, name, no_auto_bom);
			}
		;
		// IE 10+ (native saveAs)
		if (typeof navigator !== "undefined" && navigator.msSaveOrOpenBlob) {
			return function(blob, name, no_auto_bom) {
				if (!no_auto_bom) {
					blob = auto_bom(blob);
				}
				return navigator.msSaveOrOpenBlob(blob, name || "download");
			};
		}
	
		FS_proto.abort = function() {
			var filesaver = this;
			filesaver.readyState = filesaver.DONE;
			dispatch(filesaver, "abort");
		};
		FS_proto.readyState = FS_proto.INIT = 0;
		FS_proto.WRITING = 1;
		FS_proto.DONE = 2;
	
		FS_proto.error =
		FS_proto.onwritestart =
		FS_proto.onprogress =
		FS_proto.onwrite =
		FS_proto.onabort =
		FS_proto.onerror =
		FS_proto.onwriteend =
			null;
	
		return saveAs;
	}(
		   typeof self !== "undefined" && self
		|| typeof window !== "undefined" && window
		|| this.content
	));
	
	
	// Expose file saver on the DataTables API. Can't attach to `DataTables.Buttons`
	// since this file can be loaded before Button's core!
	DataTable.fileSave = _saveAs;
	
	
	/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	 * Local (private) functions
	 */
	
	/**
	 * Get the file name for an exported file.
	 *
	 * @param {object}	config Button configuration
	 * @param {boolean} incExtension Include the file name extension
	 */
	var _filename = function ( config, incExtension )
	{
		// Backwards compatibility
		var filename = config.filename === '*' && config.title !== '*' && config.title !== undefined ?
			config.title :
			config.filename;
	
		if ( typeof filename === 'function' ) {
			filename = filename();
		}
	
		if ( filename.indexOf( '*' ) !== -1 ) {
			filename = $.trim( filename.replace( '*', $('title').text() ) );
		}
	
		// Strip characters which the OS will object to
		filename = filename.replace(/[^a-zA-Z0-9_\u00A1-\uFFFF\.,\-_ !\(\)]/g, "");
	
		return incExtension === undefined || incExtension === true ?
			filename+config.extension :
			filename;
	};
	
	/**
	 * Get the sheet name for Excel exports.
	 *
	 * @param {object}	config Button configuration
	 */
	var _sheetname = function ( config )
	{
		var sheetName = 'Sheet1';
	
		if ( config.sheetName ) {
			sheetName = config.sheetName.replace(/[\[\]\*\/\\\?\:]/g, '');
		}
	
	return sheetName;
	};
	
	/**
	 * Get the title for an exported file.
	 *
	 * @param {object} config	Button configuration
	 */
	var _title = function ( config )
	{
		var title = config.title;
	
		if ( typeof title === 'function' ) {
			title = title();
		}
	
		return title.indexOf( '*' ) !== -1 ?
			title.replace( '*', $('title').text() || 'Exported data' ) :
			title;
	};
	
	/**
	 * Get the newline character(s)
	 *
	 * @param {object}	config Button configuration
	 * @return {string}				Newline character
	 */
	var _newLine = function ( config )
	{
		return config.newline ?
			config.newline :
			navigator.userAgent.match(/Windows/) ?
				'\r\n' :
				'\n';
	};
	
	/**
	 * Combine the data from the `buttons.exportData` method into a string that
	 * will be used in the export file.
	 *
	 * @param	{DataTable.Api} dt		 DataTables API instance
	 * @param	{object}				config Button configuration
	 * @return {object}							 The data to export
	 */
	var _exportData = function ( dt, config )
	{
		var newLine = _newLine( config );
		var data = dt.buttons.exportData( config.exportOptions );
		var boundary = config.fieldBoundary;
		var separator = config.fieldSeparator;
		var reBoundary = new RegExp( boundary, 'g' );
		var escapeChar = config.escapeChar !== undefined ?
			config.escapeChar :
			'\\';
		var join = function ( a ) {
			var s = '';
	
			// If there is a field boundary, then we might need to escape it in
			// the source data
			for ( var i=0, ien=a.length ; i<ien ; i++ ) {
				if ( i > 0 ) {
					s += separator;
				}
	
				s += boundary ?
					boundary + ('' + a[i]).replace( reBoundary, escapeChar+boundary ) + boundary :
					a[i];
			}
	
			return s;
		};
	
		var header = config.header ? join( data.header )+newLine : '';
		var footer = config.footer && data.footer ? newLine+join( data.footer ) : '';
		var body = [];
	
		for ( var i=0, ien=data.body.length ; i<ien ; i++ ) {
			body.push( join( data.body[i] ) );
		}
	
		return {
			str: header + body.join( newLine ) + footer,
			rows: body.length
		};
	};
	
	/**
	 * Safari's data: support for creating and downloading files is really poor, so
	 * various options need to be disabled in it. See
	 * https://bugs.webkit.org/show_bug.cgi?id=102914
	 *
	 * @return {Boolean} `true` if Safari
	 */
	var _isSafari = function ()
	{
		return navigator.userAgent.indexOf('Safari') !== -1 &&
			navigator.userAgent.indexOf('Chrome') === -1 &&
			navigator.userAgent.indexOf('Opera') === -1;
	};
	
	/**
	 * Convert from numeric position to letter for column names in Excel
	 * @param  {int} n Column number
	 * @return {string} Column letter(s) name
	 */
	function createCellPos( n ){
		var ordA = 'A'.charCodeAt(0);
		var ordZ = 'Z'.charCodeAt(0);
		var len = ordZ - ordA + 1;
		var s = "";
	
		while( n >= 0 ) {
			s = String.fromCharCode(n % len + ordA) + s;
			n = Math.floor(n / len) - 1;
		}
	
		return s;
	}
	
	try {
		var _serialiser = new XMLSerializer();
		var _ieExcel;
	}
	catch (t) {}
	
	/**
	 * Recursively add XML files from an object's structure to a ZIP file. This
	 * allows the XSLX file to be easily defined with an object's structure matching
	 * the files structure.
	 *
	 * @param {JSZip} zip ZIP package
	 * @param {object} obj Object to add (recursive)
	 */
	function _addToZip( zip, obj ) {
		if ( _ieExcel === undefined ) {
			// Detect if we are dealing with IE's _awful_ serialiser by seeing if it
			// drop attributes
			_ieExcel = _serialiser
				.serializeToString(
					$.parseXML( excelStrings['xl/worksheets/sheet1.xml'] )
				)
				.indexOf( 'xmlns:r' ) === -1;
		}
	
		$.each( obj, function ( name, val ) {
			if ( $.isPlainObject( val ) ) {
				var newDir = zip.folder( name );
				_addToZip( newDir, val );
			}
			else {
				if ( _ieExcel ) {
					// IE's XML serialiser will drop some name space attributes from
					// from the root node, so we need to save them. Do this by
					// replacing the namespace nodes with a regular attribute that
					// we convert back when serialised. Edge does not have this
					// issue
					var worksheet = val.childNodes[0];
					var i, ien;
					var attrs = [];
	
					for ( i=worksheet.attributes.length-1 ; i>=0 ; i-- ) {
						var attrName = worksheet.attributes[i].nodeName;
						var attrValue = worksheet.attributes[i].nodeValue;
	
						if ( attrName.indexOf( ':' ) !== -1 ) {
							attrs.push( { name: attrName, value: attrValue } );
	
							worksheet.removeAttribute( attrName );
						}
					}
	
					for ( i=0, ien=attrs.length ; i<ien ; i++ ) {
						var attr = val.createAttribute( attrs[i].name.replace( ':', '_dt_b_namespace_token_' ) );
						attr.value = attrs[i].value;
						worksheet.setAttributeNode( attr );
					}
				}
	
				var str = _serialiser.serializeToString(val);
	
				// Fix IE's XML
				if ( _ieExcel ) {
					// IE doesn't include the XML declaration
					if ( str.indexOf( '<?xml' ) === -1 ) {
						str = '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>'+str;
					}
	
					// Return namespace attributes to being as such
					str = str.replace( /_dt_b_namespace_token_/g, ':' );
				}
	
				// Both IE and Edge will put empty name space attributes onto the
				// rows and columns making them useless
				str = str
					.replace( /<row xmlns="" /g, '<row ' )
					.replace( /<cols xmlns="">/g, '<cols>' );
	
				zip.file( name, str );
			}
		} );
	}
	
	/**
	 * Create an XML node and add any children, attributes, etc without needing to
	 * be verbose in the DOM.
	 *
	 * @param  {object} doc      XML document
	 * @param  {string} nodeName Node name
	 * @param  {object} opts     Options - can be `attr` (attributes), `children`
	 *   (child nodes) and `text` (text content)
	 * @return {node}            Created node
	 */
	function _createNode( doc, nodeName, opts ) {
		var tempNode = doc.createElement( nodeName );
	
		if ( opts ) {
			if ( opts.attr ) {
				$(tempNode).attr( opts.attr );
			}
	
			if( opts.children ) {
				$.each( opts.children, function ( key, value ) {
					tempNode.appendChild( value );
				});
			}
	
			if( opts.text ) {
				tempNode.appendChild( doc.createTextNode( opts.text ) );
			}
		}
	
		return tempNode;
	}
	
	/**
	 * Get the width for an Excel column based on the contents of that column
	 * @param  {object} data Data for export
	 * @param  {int}    col  Column index
	 * @return {int}         Column width
	 */
	function _excelColWidth( data, col ) {
		var max = data.header[col].length;
		var len;
	
		if ( data.footer && data.footer[col].length > max ) {
			max = data.footer[col].length;
		}
	
		for ( var i=0, ien=data.body.length ; i<ien ; i++ ) {
			len = data.body[i][col].toString().length;
	
			if ( len > max ) {
				max = len;
			}
	
			// Max width rather than having potentially massive column widths
			if ( max > 40 ) {
				break;
			}
		}
	
		// And a min width
		return max > 5 ? max : 5;
	}
	
	// Excel - Pre-defined strings to build a basic XLSX file
	var excelStrings = {
		"_rels/.rels":
			'<?xml version="1.0" encoding="UTF-8" standalone="yes"?>'+
			'<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">'+
				'<Relationship Id="rId1" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument" Target="xl/workbook.xml"/>'+
			'</Relationships>',
	
		"xl/_rels/workbook.xml.rels":
			'<?xml version="1.0" encoding="UTF-8" standalone="yes"?>'+
			'<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">'+
				'<Relationship Id="rId1" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/worksheet" Target="worksheets/sheet1.xml"/>'+
				'<Relationship Id="rId2" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/styles" Target="styles.xml"/>'+
			'</Relationships>',
	
		"[Content_Types].xml":
			'<?xml version="1.0" encoding="UTF-8" standalone="yes"?>'+
			'<Types xmlns="http://schemas.openxmlformats.org/package/2006/content-types">'+
				'<Default Extension="xml" ContentType="application/xml" />'+
				'<Default Extension="rels" ContentType="application/vnd.openxmlformats-package.relationships+xml" />'+
				'<Default Extension="jpeg" ContentType="image/jpeg" />'+
				'<Override PartName="/xl/workbook.xml" ContentType="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml" />'+
				'<Override PartName="/xl/worksheets/sheet1.xml" ContentType="application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml" />'+
				'<Override PartName="/xl/styles.xml" ContentType="application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml" />'+
			'</Types>',
	
		"xl/workbook.xml":
			'<?xml version="1.0" encoding="UTF-8" standalone="yes"?>'+
			'<workbook xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main" xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships">'+
				'<fileVersion appName="xl" lastEdited="5" lowestEdited="5" rupBuild="24816"/>'+
				'<workbookPr showInkAnnotation="0" autoCompressPictures="0"/>'+
				'<bookViews>'+
					'<workbookView xWindow="0" yWindow="0" windowWidth="25600" windowHeight="19020" tabRatio="500"/>'+
				'</bookViews>'+
				'<sheets>'+
					'<sheet name="" sheetId="1" r:id="rId1"/>'+
				'</sheets>'+
			'</workbook>',
	
		"xl/worksheets/sheet1.xml":
			'<?xml version="1.0" encoding="UTF-8" standalone="yes"?>'+
			'<worksheet xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main" xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships" xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" mc:Ignorable="x14ac" xmlns:x14ac="http://schemas.microsoft.com/office/spreadsheetml/2009/9/ac">'+
				'<sheetData/>'+
			'</worksheet>',
	
		"xl/styles.xml":
			'<?xml version="1.0" encoding="UTF-8"?>'+
			'<styleSheet xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main" xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" mc:Ignorable="x14ac" xmlns:x14ac="http://schemas.microsoft.com/office/spreadsheetml/2009/9/ac">'+
				'<fonts count="5" x14ac:knownFonts="1">'+
					'<font>'+
						'<sz val="11" />'+
						'<name val="Calibri" />'+
					'</font>'+
					'<font>'+
						'<sz val="11" />'+
						'<name val="Calibri" />'+
						'<color rgb="FFFFFFFF" />'+
					'</font>'+
					'<font>'+
						'<sz val="11" />'+
						'<name val="Calibri" />'+
						'<b />'+
					'</font>'+
					'<font>'+
						'<sz val="11" />'+
						'<name val="Calibri" />'+
						'<i />'+
					'</font>'+
					'<font>'+
						'<sz val="11" />'+
						'<name val="Calibri" />'+
						'<u />'+
					'</font>'+
				'</fonts>'+
				'<fills count="6">'+
					'<fill>'+
						'<patternFill patternType="none" />'+
					'</fill>'+
					'<fill/>'+ // Excel appears to use this as a dotted background regardless of values
					'<fill>'+
						'<patternFill patternType="solid">'+
							'<fgColor rgb="FFD9D9D9" />'+
							'<bgColor indexed="64" />'+
						'</patternFill>'+
					'</fill>'+
					'<fill>'+
						'<patternFill patternType="solid">'+
							'<fgColor rgb="FFD99795" />'+
							'<bgColor indexed="64" />'+
						'</patternFill>'+
					'</fill>'+
					'<fill>'+
						'<patternFill patternType="solid">'+
							'<fgColor rgb="ffc6efce" />'+
							'<bgColor indexed="64" />'+
						'</patternFill>'+
					'</fill>'+
					'<fill>'+
						'<patternFill patternType="solid">'+
							'<fgColor rgb="ffc6cfef" />'+
							'<bgColor indexed="64" />'+
						'</patternFill>'+
					'</fill>'+
				'</fills>'+
				'<borders count="2">'+
					'<border>'+
						'<left />'+
						'<right />'+
						'<top />'+
						'<bottom />'+
						'<diagonal />'+
					'</border>'+
					'<border diagonalUp="false" diagonalDown="false">'+
						'<left style="thin">'+
							'<color auto="1" />'+
						'</left>'+
						'<right style="thin">'+
							'<color auto="1" />'+
						'</right>'+
						'<top style="thin">'+
							'<color auto="1" />'+
						'</top>'+
						'<bottom style="thin">'+
							'<color auto="1" />'+
						'</bottom>'+
						'<diagonal />'+
					'</border>'+
				'</borders>'+
				'<cellStyleXfs count="1">'+
					'<xf numFmtId="0" fontId="0" fillId="0" borderId="0" />'+
				'</cellStyleXfs>'+
				'<cellXfs count="56">'+
					'<xf numFmtId="0" fontId="0" fillId="0" borderId="0" applyFont="1" applyFill="1" applyBorder="1"/>'+
					'<xf numFmtId="0" fontId="1" fillId="0" borderId="0" applyFont="1" applyFill="1" applyBorder="1"/>'+
					'<xf numFmtId="0" fontId="2" fillId="0" borderId="0" applyFont="1" applyFill="1" applyBorder="1"/>'+
					'<xf numFmtId="0" fontId="3" fillId="0" borderId="0" applyFont="1" applyFill="1" applyBorder="1"/>'+
					'<xf numFmtId="0" fontId="4" fillId="0" borderId="0" applyFont="1" applyFill="1" applyBorder="1"/>'+
					'<xf numFmtId="0" fontId="0" fillId="2" borderId="0" applyFont="1" applyFill="1" applyBorder="1"/>'+
					'<xf numFmtId="0" fontId="1" fillId="2" borderId="0" applyFont="1" applyFill="1" applyBorder="1"/>'+
					'<xf numFmtId="0" fontId="2" fillId="2" borderId="0" applyFont="1" applyFill="1" applyBorder="1"/>'+
					'<xf numFmtId="0" fontId="3" fillId="2" borderId="0" applyFont="1" applyFill="1" applyBorder="1"/>'+
					'<xf numFmtId="0" fontId="4" fillId="2" borderId="0" applyFont="1" applyFill="1" applyBorder="1"/>'+
					'<xf numFmtId="0" fontId="0" fillId="4" borderId="0" applyFont="1" applyFill="1" applyBorder="1"/>'+
					'<xf numFmtId="0" fontId="1" fillId="4" borderId="0" applyFont="1" applyFill="1" applyBorder="1"/>'+
					'<xf numFmtId="0" fontId="2" fillId="4" borderId="0" applyFont="1" applyFill="1" applyBorder="1"/>'+
					'<xf numFmtId="0" fontId="3" fillId="4" borderId="0" applyFont="1" applyFill="1" applyBorder="1"/>'+
					'<xf numFmtId="0" fontId="4" fillId="4" borderId="0" applyFont="1" applyFill="1" applyBorder="1"/>'+
					'<xf numFmtId="0" fontId="0" fillId="4" borderId="0" applyFont="1" applyFill="1" applyBorder="1"/>'+
					'<xf numFmtId="0" fontId="1" fillId="4" borderId="0" applyFont="1" applyFill="1" applyBorder="1"/>'+
					'<xf numFmtId="0" fontId="2" fillId="4" borderId="0" applyFont="1" applyFill="1" applyBorder="1"/>'+
					'<xf numFmtId="0" fontId="3" fillId="4" borderId="0" applyFont="1" applyFill="1" applyBorder="1"/>'+
					'<xf numFmtId="0" fontId="4" fillId="4" borderId="0" applyFont="1" applyFill="1" applyBorder="1"/>'+
					'<xf numFmtId="0" fontId="0" fillId="5" borderId="0" applyFont="1" applyFill="1" applyBorder="1"/>'+
					'<xf numFmtId="0" fontId="1" fillId="5" borderId="0" applyFont="1" applyFill="1" applyBorder="1"/>'+
					'<xf numFmtId="0" fontId="2" fillId="5" borderId="0" applyFont="1" applyFill="1" applyBorder="1"/>'+
					'<xf numFmtId="0" fontId="3" fillId="5" borderId="0" applyFont="1" applyFill="1" applyBorder="1"/>'+
					'<xf numFmtId="0" fontId="4" fillId="5" borderId="0" applyFont="1" applyFill="1" applyBorder="1"/>'+
					'<xf numFmtId="0" fontId="0" fillId="0" borderId="1" applyFont="1" applyFill="1" applyBorder="1"/>'+
					'<xf numFmtId="0" fontId="1" fillId="0" borderId="1" applyFont="1" applyFill="1" applyBorder="1"/>'+
					'<xf numFmtId="0" fontId="2" fillId="0" borderId="1" applyFont="1" applyFill="1" applyBorder="1"/>'+
					'<xf numFmtId="0" fontId="3" fillId="0" borderId="1" applyFont="1" applyFill="1" applyBorder="1"/>'+
					'<xf numFmtId="0" fontId="4" fillId="0" borderId="1" applyFont="1" applyFill="1" applyBorder="1"/>'+
					'<xf numFmtId="0" fontId="0" fillId="2" borderId="1" applyFont="1" applyFill="1" applyBorder="1"/>'+
					'<xf numFmtId="0" fontId="1" fillId="2" borderId="1" applyFont="1" applyFill="1" applyBorder="1"/>'+
					'<xf numFmtId="0" fontId="2" fillId="2" borderId="1" applyFont="1" applyFill="1" applyBorder="1"/>'+
					'<xf numFmtId="0" fontId="3" fillId="2" borderId="1" applyFont="1" applyFill="1" applyBorder="1"/>'+
					'<xf numFmtId="0" fontId="4" fillId="2" borderId="1" applyFont="1" applyFill="1" applyBorder="1"/>'+
					'<xf numFmtId="0" fontId="0" fillId="3" borderId="1" applyFont="1" applyFill="1" applyBorder="1"/>'+
					'<xf numFmtId="0" fontId="1" fillId="3" borderId="1" applyFont="1" applyFill="1" applyBorder="1"/>'+
					'<xf numFmtId="0" fontId="2" fillId="3" borderId="1" applyFont="1" applyFill="1" applyBorder="1"/>'+
					'<xf numFmtId="0" fontId="3" fillId="3" borderId="1" applyFont="1" applyFill="1" applyBorder="1"/>'+
					'<xf numFmtId="0" fontId="4" fillId="3" borderId="1" applyFont="1" applyFill="1" applyBorder="1"/>'+
					'<xf numFmtId="0" fontId="0" fillId="4" borderId="1" applyFont="1" applyFill="1" applyBorder="1"/>'+
					'<xf numFmtId="0" fontId="1" fillId="4" borderId="1" applyFont="1" applyFill="1" applyBorder="1"/>'+
					'<xf numFmtId="0" fontId="2" fillId="4" borderId="1" applyFont="1" applyFill="1" applyBorder="1"/>'+
					'<xf numFmtId="0" fontId="3" fillId="4" borderId="1" applyFont="1" applyFill="1" applyBorder="1"/>'+
					'<xf numFmtId="0" fontId="4" fillId="4" borderId="1" applyFont="1" applyFill="1" applyBorder="1"/>'+
					'<xf numFmtId="0" fontId="0" fillId="5" borderId="1" applyFont="1" applyFill="1" applyBorder="1"/>'+
					'<xf numFmtId="0" fontId="1" fillId="5" borderId="1" applyFont="1" applyFill="1" applyBorder="1"/>'+
					'<xf numFmtId="0" fontId="2" fillId="5" borderId="1" applyFont="1" applyFill="1" applyBorder="1"/>'+
					'<xf numFmtId="0" fontId="3" fillId="5" borderId="1" applyFont="1" applyFill="1" applyBorder="1"/>'+
					'<xf numFmtId="0" fontId="4" fillId="5" borderId="1" applyFont="1" applyFill="1" applyBorder="1"/>'+
					'<xf numFmtId="0" fontId="0" fillId="0" borderId="0" applyFont="1" applyFill="1" applyBorder="1" xfId="0" applyAlignment="1">'+
						'<alignment horizontal="left"/>'+
					'</xf>'+
					'<xf numFmtId="0" fontId="0" fillId="0" borderId="0" applyFont="1" applyFill="1" applyBorder="1" xfId="0" applyAlignment="1">'+
						'<alignment horizontal="center"/>'+
					'</xf>'+
					'<xf numFmtId="0" fontId="0" fillId="0" borderId="0" applyFont="1" applyFill="1" applyBorder="1" xfId="0" applyAlignment="1">'+
						'<alignment horizontal="right"/>'+
					'</xf>'+
					'<xf numFmtId="0" fontId="0" fillId="0" borderId="0" applyFont="1" applyFill="1" applyBorder="1" xfId="0" applyAlignment="1">'+
						'<alignment horizontal="fill"/>'+
					'</xf>'+
					'<xf numFmtId="0" fontId="0" fillId="0" borderId="0" applyFont="1" applyFill="1" applyBorder="1" xfId="0" applyAlignment="1">'+
						'<alignment textRotation="90"/>'+
					'</xf>'+
					'<xf numFmtId="0" fontId="0" fillId="0" borderId="0" applyFont="1" applyFill="1" applyBorder="1" xfId="0" applyAlignment="1">'+
						'<alignment wrapText="1"/>'+
					'</xf>'+
				'</cellXfs>'+
				'<cellStyles count="1">'+
					'<cellStyle name="Normal" xfId="0" builtinId="0" />'+
				'</cellStyles>'+
				'<dxfs count="0" />'+
				'<tableStyles count="0" defaultTableStyle="TableStyleMedium9" defaultPivotStyle="PivotStyleMedium4" />'+
			'</styleSheet>'
	};
	// Note we could use 3 `for` loops for the styles, but when gzipped there is
	// virtually no difference in size, since the above can be easily compressed
	
	
	
	/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	 * Buttons
	 */
	
	//
	// Copy to clipboard
	//
	DataTable.ext.buttons.copyHtml5 = {
		className: 'buttons-copy buttons-html5',
	
		text: function ( dt ) {
			return dt.i18n( 'buttons.copy', 'Copy' );
		},
	
		action: function ( e, dt, button, config ) {
			var exportData = _exportData( dt, config );
			var output = exportData.str;
			var hiddenDiv = $('<div/>')
				.css( {
					height: 1,
					width: 1,
					overflow: 'hidden',
					position: 'fixed',
					top: 0,
					left: 0
				} );
	
			if ( config.customize ) {
				output = config.customize( output, config );
			}
	
			var textarea = $('<textarea readonly/>')
				.val( output )
				.appendTo( hiddenDiv );
	
			// For browsers that support the copy execCommand, try to use it
			if ( document.queryCommandSupported('copy') ) {
				hiddenDiv.appendTo( dt.table().container() );
				textarea[0].focus();
				textarea[0].select();
	
				try {
					var successful = document.execCommand( 'copy' );
					hiddenDiv.remove();
	
					if (successful) {
						dt.buttons.info(
							dt.i18n( 'buttons.copyTitle', 'Copy to clipboard' ),
							dt.i18n( 'buttons.copySuccess', {
								1: 'Copied one row to clipboard',
								_: 'Copied %d rows to clipboard'
							}, exportData.rows ),
							2000
						);
						return;
					}
				}
				catch (t) {}
			}
	
			// Otherwise we show the text box and instruct the user to use it
			var message = $('<span>'+dt.i18n( 'buttons.copyKeys',
					'Press <i>ctrl</i> or <i>\u2318</i> + <i>C</i> to copy the table data<br>to your system clipboard.<br><br>'+
					'To cancel, click this message or press escape.' )+'</span>'
				)
				.append( hiddenDiv );
	
			dt.buttons.info( dt.i18n( 'buttons.copyTitle', 'Copy to clipboard' ), message, 0 );
	
			// Select the text so when the user activates their system clipboard
			// it will copy that text
			textarea[0].focus();
			textarea[0].select();
	
			// Event to hide the message when the user is done
			var container = $(message).closest('.dt-button-info');
			var close = function () {
				container.off( 'click.buttons-copy' );
				$(document).off( '.buttons-copy' );
				dt.buttons.info( false );
			};
	
			container.on( 'click.buttons-copy', close );
			$(document)
				.on( 'keydown.buttons-copy', function (e) {
					if ( e.keyCode === 27 ) { // esc
						close();
					}
				} )
				.on( 'copy.buttons-copy cut.buttons-copy', function () {
					close();
				} );
		},
	
		exportOptions: {},
	
		fieldSeparator: '\t',
	
		fieldBoundary: '',
	
		header: true,
	
		footer: false
	};
	
	//
	// CSV export
	//
	DataTable.ext.buttons.csvHtml5 = {
		bom: false,
	
		className: 'buttons-csv buttons-html5',
	
		available: function () {
			return window.FileReader !== undefined && window.Blob;
		},
	
		text: function ( dt ) {
			return dt.i18n( 'buttons.csv', 'CSV' );
		},
	
		action: function ( e, dt, button, config ) {
			// Set the text
			var output = _exportData( dt, config ).str;
			var charset = config.charset;
	
			if ( config.customize ) {
				output = config.customize( output, config );
			}
	
			if ( charset !== false ) {
				if ( ! charset ) {
					charset = document.characterSet || document.charset;
				}
	
				if ( charset ) {
					charset = ';charset='+charset;
				}
			}
			else {
				charset = '';
			}
	
			if ( config.bom ) {
				output = '\ufeff' + output;
			}
	
			_saveAs(
				new Blob( [output], {type: 'text/csv'+charset} ),
				_filename( config ),
				true
			);
		},
	
		filename: '*',
	
		extension: '.csv',
	
		exportOptions: {},
	
		fieldSeparator: ',',
	
		fieldBoundary: '"',
	
		escapeChar: '"',
	
		charset: null,
	
		header: true,
	
		footer: false
	};
	
	//
	// Excel (xlsx) export
	//
	DataTable.ext.buttons.excelHtml5 = {
		className: 'buttons-excel buttons-html5',
	
		available: function () {
			return window.FileReader !== undefined && _jsZip() !== undefined && ! _isSafari() && _serialiser;
		},
	
		text: function ( dt ) {
			return dt.i18n( 'buttons.excel', 'Excel' );
		},
	
		action: function ( e, dt, button, config ) {
			var rowPos = 0;
			var getXml = function ( type ) {
				var str = excelStrings[ type ];
	
				//str = str.replace( /xmlns:/g, 'xmlns_' ).replace( /mc:/g, 'mc_' );
	
				return $.parseXML( str );
			};
			var rels = getXml('xl/worksheets/sheet1.xml');
			var relsGet = rels.getElementsByTagName( "sheetData" )[0];
	
			var xlsx = {
				_rels: {
					".rels": getXml('_rels/.rels')
				},
				xl: {
					_rels: {
						"workbook.xml.rels": getXml('xl/_rels/workbook.xml.rels')
					},
					"workbook.xml": getXml('xl/workbook.xml'),
					"styles.xml": getXml('xl/styles.xml'),
					"worksheets": {
						"sheet1.xml": rels
					}
	
				},
				"[Content_Types].xml": getXml('[Content_Types].xml')
			};
	
			var data = dt.buttons.exportData( config.exportOptions );
			var currentRow, rowNode;
			var addRow = function ( row ) {
				currentRow = rowPos+1;
				rowNode = _createNode( rels, "row", { attr: {r:currentRow} } );
	
				for ( var i=0, ien=row.length ; i<ien ; i++ ) {
					// Concat both the Cell Columns as a letter and the Row of the cell.
					var cellId = createCellPos(i) + '' + currentRow;
					var cell;
	
					if ( row[i] === null || row[i] === undefined ) {
						row[i] = '';
					}
	
					// Detect numbers - don't match numbers with leading zeros or a negative
					// anywhere but the start
					if ( typeof row[i] === 'number' || (
							row[i].match &&
							$.trim(row[i]).match(/^-?\d+(\.\d+)?$/) &&
							! $.trim(row[i]).match(/^0\d+/) )
					) {
						cell = _createNode( rels, 'c', {
							attr: {
								t: 'n',
								r: cellId
							},
							children: [
								_createNode( rels, 'v', { text: row[i] } )
							]
						} );
					}
					else {
						// Replace non standard characters for text output
						var text = ! row[i].replace ?
							row[i] :
							row[i].replace(/[\x00-\x09\x0B\x0C\x0E-\x1F\x7F-\x9F]/g, '');
	
						cell = _createNode( rels, 'c', {
							attr: {
								t: 'inlineStr',
								r: cellId
							},
							children:{
								row: _createNode( rels, 'is', {
									children: {
										row: _createNode( rels, 't', {
											text: text
										} )
									}
								} )
							}
						} );
					}
	
					rowNode.appendChild( cell );
				}
				relsGet.appendChild(rowNode);
				rowPos++;
			};
	
			$( 'sheets sheet', xlsx.xl['workbook.xml'] ).attr( 'name', _sheetname( config ) );
	
			if ( config.customizeData ) {
				config.customizeData( data );
			}
	
			if ( config.header ) {
				addRow( data.header, rowPos );
				$('row c', rels).attr( 's', '2' ); // bold
			}
	
			for ( var n=0, ie=data.body.length ; n<ie ; n++ ) {
				addRow( data.body[n], rowPos );
			}
	
			if ( config.footer && data.footer ) {
				addRow( data.footer, rowPos);
				$('row:last c', rels).attr( 's', '2' ); // bold
			}
	
			// Set column widths
			var cols = _createNode( rels, 'cols' );
			$('worksheet', rels).prepend( cols );
	
			for ( var i=0, ien=data.header.length ; i<ien ; i++ ) {
				cols.appendChild( _createNode( rels, 'col', {
					attr: {
						min: i+1,
						max: i+1,
						width: _excelColWidth( data, i ),
						customWidth: 1
					}
				} ) );
			}
	
			// Let the developer customise the document if they want to
			if ( config.customize ) {
				config.customize( xlsx );
			}
	
			var jszip = _jsZip();
			var zip = new jszip();
			var zipConfig = {
				type: 'blob',
				mimeType: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
			};
	
			_addToZip( zip, xlsx );
	
			if ( zip.generateAsync ) {
				// JSZip 3+
				zip
					.generateAsync( zipConfig )
					.then( function ( blob ) {
						_saveAs( blob, _filename( config ) );
					} );
			}
			else {
				// JSZip 2.5
				_saveAs(
					zip.generate( zipConfig ),
					_filename( config )
				);
			}
		},
	
		filename: '*',
	
		extension: '.xlsx',
	
		exportOptions: {},
	
		header: true,
	
		footer: false
	};
	
	//
	// PDF export - using pdfMake - http://pdfmake.org
	//
	DataTable.ext.buttons.pdfHtml5 = {
		className: 'buttons-pdf buttons-html5',
	
		available: function () {
			return window.FileReader !== undefined && _pdfMake();
		},
	
		text: function ( dt ) {
			return dt.i18n( 'buttons.pdf', 'PDF' );
		},
	
		action: function ( e, dt, button, config ) {
			var newLine = _newLine( config );
			var data = dt.buttons.exportData( config.exportOptions );
			var rows = [];
	
			if ( config.header ) {
				rows.push( $.map( data.header, function ( d ) {
					return {
						text: typeof d === 'string' ? d : d+'',
						style: 'tableHeader'
					};
				} ) );
			}
	
			for ( var i=0, ien=data.body.length ; i<ien ; i++ ) {
				rows.push( $.map( data.body[i], function ( d ) {
					return {
						text: typeof d === 'string' ? d : d+'',
						style: i % 2 ? 'tableBodyEven' : 'tableBodyOdd'
					};
				} ) );
			}
	
			if ( config.footer && data.footer) {
				rows.push( $.map( data.footer, function ( d ) {
					return {
						text: typeof d === 'string' ? d : d+'',
						style: 'tableFooter'
					};
				} ) );
			}
	
			var doc = {
				pageSize: config.pageSize,
				pageOrientation: config.orientation,
				content: [
					{
						table: {
							headerRows: 1,
							body: rows
						},
						layout: 'noBorders'
					}
				],
				styles: {
					tableHeader: {
						bold: true,
						fontSize: 11,
						color: 'white',
						fillColor: '#2d4154',
						alignment: 'center'
					},
					tableBodyEven: {},
					tableBodyOdd: {
						fillColor: '#f3f3f3'
					},
					tableFooter: {
						bold: true,
						fontSize: 11,
						color: 'white',
						fillColor: '#2d4154'
					},
					title: {
						alignment: 'center',
						fontSize: 15
					},
					message: {}
				},
				defaultStyle: {
					fontSize: 10
				}
			};
	
			if ( config.message ) {
	      doc.content.unshift( {
	        text: typeof config.message == 'function' ? config.message(dt, button, config) : config.message,
	        style: 'message',
	        margin: [ 0, 0, 0, 12 ]
	      } );
			}
	
			if ( config.title ) {
				doc.content.unshift( {
					text: _title( config, false ),
					style: 'title',
					margin: [ 0, 0, 0, 12 ]
				} );
			}
	
			if ( config.customize ) {
				config.customize( doc, config );
			}
	
			var pdf = _pdfMake().createPdf( doc );
	
			if ( config.download === 'open' && ! _isSafari() ) {
				pdf.open();
			}
			else {
				pdf.getBuffer( function (buffer) {
					var blob = new Blob( [buffer], {type:'application/pdf'} );
	
					_saveAs( blob, _filename( config ) );
				} );
			}
		},
	
		title: '*',
	
		filename: '*',
	
		extension: '.pdf',
	
		exportOptions: {},
	
		orientation: 'portrait',
	
		pageSize: 'A4',
	
		header: true,
	
		footer: false,
	
		message: null,
	
		customize: null,
	
		download: 'download'
	};
	
	
	return DataTable.Buttons;
	}));


/***/ },
/* 17 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*! Buttons for DataTables 1.2.2
	 * Â©2016 SpryMedia Ltd - datatables.net/license
	 */
	
	(function( factory ){
		if ( true ) {
			// AMD
			!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(1), __webpack_require__(4)], __WEBPACK_AMD_DEFINE_RESULT__ = function ( $ ) {
				return factory( $, window, document );
			}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
		}
		else if ( typeof exports === 'object' ) {
			// CommonJS
			module.exports = function (root, $) {
				if ( ! root ) {
					root = window;
				}
	
				if ( ! $ || ! $.fn.dataTable ) {
					$ = require('datatables.net')(root, $).$;
				}
	
				return factory( $, root, root.document );
			};
		}
		else {
			// Browser
			factory( jQuery, window, document );
		}
	}(function( $, window, document, undefined ) {
	'use strict';
	var DataTable = $.fn.dataTable;
	
	
	// Used for namespacing events added to the document by each instance, so they
	// can be removed on destroy
	var _instCounter = 0;
	
	// Button namespacing counter for namespacing events on individual buttons
	var _buttonCounter = 0;
	
	var _dtButtons = DataTable.ext.buttons;
	
	/**
	 * [Buttons description]
	 * @param {[type]}
	 * @param {[type]}
	 */
	var Buttons = function( dt, config )
	{
		// Allow a boolean true for defaults
		if ( config === true ) {
			config = {};
		}
	
		// For easy configuration of buttons an array can be given
		if ( $.isArray( config ) ) {
			config = { buttons: config };
		}
	
		this.c = $.extend( true, {}, Buttons.defaults, config );
	
		// Don't want a deep copy for the buttons
		if ( config.buttons ) {
			this.c.buttons = config.buttons;
		}
	
		this.s = {
			dt: new DataTable.Api( dt ),
			buttons: [],
			listenKeys: '',
			namespace: 'dtb'+(_instCounter++)
		};
	
		this.dom = {
			container: $('<'+this.c.dom.container.tag+'/>')
				.addClass( this.c.dom.container.className )
		};
	
		this._constructor();
	};
	
	
	$.extend( Buttons.prototype, {
		/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
		 * Public methods
		 */
	
		/**
		 * Get the action of a button
		 * @param  {int|string} Button index
		 * @return {function}
		 *//**
		 * Set the action of a button
		 * @param  {node} node Button element
		 * @param  {function} action Function to set
		 * @return {Buttons} Self for chaining
		 */
		action: function ( node, action )
		{
			var button = this._nodeToButton( node );
	
			if ( action === undefined ) {
				return button.conf.action;
			}
	
			button.conf.action = action;
	
			return this;
		},
	
		/**
		 * Add an active class to the button to make to look active or get current
		 * active state.
		 * @param  {node} node Button element
		 * @param  {boolean} [flag] Enable / disable flag
		 * @return {Buttons} Self for chaining or boolean for getter
		 */
		active: function ( node, flag ) {
			var button = this._nodeToButton( node );
			var klass = this.c.dom.button.active;
			var jqNode = $(button.node);
	
			if ( flag === undefined ) {
				return jqNode.hasClass( klass );
			}
	
			jqNode.toggleClass( klass, flag === undefined ? true : flag );
	
			return this;
		},
	
		/**
		 * Add a new button
		 * @param {object} config Button configuration object, base string name or function
		 * @param {int|string} [idx] Button index for where to insert the button
		 * @return {Buttons} Self for chaining
		 */
		add: function ( config, idx )
		{
			var buttons = this.s.buttons;
	
			if ( typeof idx === 'string' ) {
				var split = idx.split('-');
				var base = this.s;
	
				for ( var i=0, ien=split.length-1 ; i<ien ; i++ ) {
					base = base.buttons[ split[i]*1 ];
				}
	
				buttons = base.buttons;
				idx = split[ split.length-1 ]*1;
			}
	
			this._expandButton( buttons, config, false, idx );
			this._draw();
	
			return this;
		},
	
		/**
		 * Get the container node for the buttons
		 * @return {jQuery} Buttons node
		 */
		container: function ()
		{
			return this.dom.container;
		},
	
		/**
		 * Disable a button
		 * @param  {node} node Button node
		 * @return {Buttons} Self for chaining
		 */
		disable: function ( node ) {
			var button = this._nodeToButton( node );
	
			$(button.node).addClass( this.c.dom.button.disabled );
	
			return this;
		},
	
		/**
		 * Destroy the instance, cleaning up event handlers and removing DOM
		 * elements
		 * @return {Buttons} Self for chaining
		 */
		destroy: function ()
		{
			// Key event listener
			$('body').off( 'keyup.'+this.s.namespace );
	
			// Individual button destroy (so they can remove their own events if
			// needed). Take a copy as the array is modified by `remove`
			var buttons = this.s.buttons.slice();
			var i, ien;
			
			for ( i=0, ien=buttons.length ; i<ien ; i++ ) {
				this.remove( buttons[i].node );
			}
	
			// Container
			this.dom.container.remove();
	
			// Remove from the settings object collection
			var buttonInsts = this.s.dt.settings()[0];
	
			for ( i=0, ien=buttonInsts.length ; i<ien ; i++ ) {
				if ( buttonInsts.inst === this ) {
					buttonInsts.splice( i, 1 );
					break;
				}
			}
	
			return this;
		},
	
		/**
		 * Enable / disable a button
		 * @param  {node} node Button node
		 * @param  {boolean} [flag=true] Enable / disable flag
		 * @return {Buttons} Self for chaining
		 */
		enable: function ( node, flag )
		{
			if ( flag === false ) {
				return this.disable( node );
			}
	
			var button = this._nodeToButton( node );
			$(button.node).removeClass( this.c.dom.button.disabled );
	
			return this;
		},
	
		/**
		 * Get the instance name for the button set selector
		 * @return {string} Instance name
		 */
		name: function ()
		{
			return this.c.name;
		},
	
		/**
		 * Get a button's node
		 * @param  {node} node Button node
		 * @return {jQuery} Button element
		 */
		node: function ( node )
		{
			var button = this._nodeToButton( node );
			return $(button.node);
		},
	
		/**
		 * Remove a button.
		 * @param  {node} node Button node
		 * @return {Buttons} Self for chaining
		 */
		remove: function ( node )
		{
			var button = this._nodeToButton( node );
			var host = this._nodeToHost( node );
			var dt = this.s.dt;
	
			// Remove any child buttons first
			if ( button.buttons.length ) {
				for ( var i=button.buttons.length-1 ; i>=0 ; i-- ) {
					this.remove( button.buttons[i].node );
				}
			}
	
			// Allow the button to remove event handlers, etc
			if ( button.conf.destroy ) {
				button.conf.destroy.call( dt.button(node), dt, $(node), button.conf );
			}
	
			this._removeKey( button.conf );
	
			$(button.node).remove();
	
			var idx = $.inArray( button, host );
			host.splice( idx, 1 );
	
			return this;
		},
	
		/**
		 * Get the text for a button
		 * @param  {int|string} node Button index
		 * @return {string} Button text
		 *//**
		 * Set the text for a button
		 * @param  {int|string|function} node Button index
		 * @param  {string} label Text
		 * @return {Buttons} Self for chaining
		 */
		text: function ( node, label )
		{
			var button = this._nodeToButton( node );
			var buttonLiner = this.c.dom.collection.buttonLiner;
			var linerTag = button.inCollection && buttonLiner && buttonLiner.tag ?
				buttonLiner.tag :
				this.c.dom.buttonLiner.tag;
			var dt = this.s.dt;
			var jqNode = $(button.node);
			var text = function ( opt ) {
				return typeof opt === 'function' ?
					opt( dt, jqNode, button.conf ) :
					opt;
			};
	
			if ( label === undefined ) {
				return text( button.conf.text );
			}
	
			button.conf.text = label;
	
			if ( linerTag ) {
				jqNode.children( linerTag ).html( text(label) );
			}
			else {
				jqNode.html( text(label) );
			}
	
			return this;
		},
	
	
		/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
		 * Constructor
		 */
	
		/**
		 * Buttons constructor
		 * @private
		 */
		_constructor: function ()
		{
			var that = this;
			var dt = this.s.dt;
			var dtSettings = dt.settings()[0];
			var buttons =  this.c.buttons;
	
			if ( ! dtSettings._buttons ) {
				dtSettings._buttons = [];
			}
	
			dtSettings._buttons.push( {
				inst: this,
				name: this.c.name
			} );
	
			for ( var i=0, ien=buttons.length ; i<ien ; i++ ) {
				this.add( buttons[i] );
			}
	
			dt.on( 'destroy', function () {
				that.destroy();
			} );
	
			// Global key event binding to listen for button keys
			$('body').on( 'keyup.'+this.s.namespace, function ( e ) {
				if ( ! document.activeElement || document.activeElement === document.body ) {
					// SUse a string of characters for fast lookup of if we need to
					// handle this
					var character = String.fromCharCode(e.keyCode).toLowerCase();
	
					if ( that.s.listenKeys.toLowerCase().indexOf( character ) !== -1 ) {
						that._keypress( character, e );
					}
				}
			} );
		},
	
	
		/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
		 * Private methods
		 */
	
		/**
		 * Add a new button to the key press listener
		 * @param {object} conf Resolved button configuration object
		 * @private
		 */
		_addKey: function ( conf )
		{
			if ( conf.key ) {
				this.s.listenKeys += $.isPlainObject( conf.key ) ?
					conf.key.key :
					conf.key;
			}
		},
	
		/**
		 * Insert the buttons into the container. Call without parameters!
		 * @param  {node} [container] Recursive only - Insert point
		 * @param  {array} [buttons] Recursive only - Buttons array
		 * @private
		 */
		_draw: function ( container, buttons )
		{
			if ( ! container ) {
				container = this.dom.container;
				buttons = this.s.buttons;
			}
	
			container.children().detach();
	
			for ( var i=0, ien=buttons.length ; i<ien ; i++ ) {
				container.append( buttons[i].inserter );
	
				if ( buttons[i].buttons && buttons[i].buttons.length ) {
					this._draw( buttons[i].collection, buttons[i].buttons );
				}
			}
		},
	
		/**
		 * Create buttons from an array of buttons
		 * @param  {array} attachTo Buttons array to attach to
		 * @param  {object} button Button definition
		 * @param  {boolean} inCollection true if the button is in a collection
		 * @private
		 */
		_expandButton: function ( attachTo, button, inCollection, attachPoint )
		{
			var dt = this.s.dt;
			var buttonCounter = 0;
			var buttons = ! $.isArray( button ) ?
				[ button ] :
				button;
	
			for ( var i=0, ien=buttons.length ; i<ien ; i++ ) {
				var conf = this._resolveExtends( buttons[i] );
	
				if ( ! conf ) {
					continue;
				}
	
				// If the configuration is an array, then expand the buttons at this
				// point
				if ( $.isArray( conf ) ) {
					this._expandButton( attachTo, conf, inCollection, attachPoint );
					continue;
				}
	
				var built = this._buildButton( conf, inCollection );
				if ( ! built ) {
					continue;
				}
	
				if ( attachPoint !== undefined ) {
					attachTo.splice( attachPoint, 0, built );
					attachPoint++;
				}
				else {
					attachTo.push( built );
				}
	
				if ( built.conf.buttons ) {
					var collectionDom = this.c.dom.collection;
					built.collection = $('<'+collectionDom.tag+'/>')
						.addClass( collectionDom.className );
					built.conf._collection = built.collection;
	
					this._expandButton( built.buttons, built.conf.buttons, true, attachPoint );
				}
	
				// init call is made here, rather than buildButton as it needs to
				// be selectable, and for that it needs to be in the buttons array
				if ( conf.init ) {
					conf.init.call( dt.button( built.node ), dt, $(built.node), conf );
				}
	
				buttonCounter++;
			}
		},
	
		/**
		 * Create an individual button
		 * @param  {object} config            Resolved button configuration
		 * @param  {boolean} inCollection `true` if a collection button
		 * @return {jQuery} Created button node (jQuery)
		 * @private
		 */
		_buildButton: function ( config, inCollection )
		{
			var buttonDom = this.c.dom.button;
			var linerDom = this.c.dom.buttonLiner;
			var collectionDom = this.c.dom.collection;
			var dt = this.s.dt;
			var text = function ( opt ) {
				return typeof opt === 'function' ?
					opt( dt, button, config ) :
					opt;
			};
	
			if ( inCollection && collectionDom.button ) {
				buttonDom = collectionDom.button;
			}
	
			if ( inCollection && collectionDom.buttonLiner ) {
				linerDom = collectionDom.buttonLiner;
			}
	
			// Make sure that the button is available based on whatever requirements
			// it has. For example, Flash buttons require Flash
			if ( config.available && ! config.available( dt, config ) ) {
				return false;
			}
	
			var action = function ( e, dt, button, config ) {
				config.action.call( dt.button( button ), e, dt, button, config );
	
				$(dt.table().node()).triggerHandler( 'buttons-action.dt', [
					dt.button( button ), dt, button, config 
				] );
			};
	
			var button = $('<'+buttonDom.tag+'/>')
				.addClass( buttonDom.className )
				.attr( 'tabindex', this.s.dt.settings()[0].iTabIndex )
				.attr( 'aria-controls', this.s.dt.table().node().id )
				.on( 'click.dtb', function (e) {
					e.preventDefault();
	
					if ( ! button.hasClass( buttonDom.disabled ) && config.action ) {
						action( e, dt, button, config );
					}
	
					button.blur();
				} )
				.on( 'keyup.dtb', function (e) {
					if ( e.keyCode === 13 ) {
						if ( ! button.hasClass( buttonDom.disabled ) && config.action ) {
							action( e, dt, button, config );
						}
					}
				} );
	
			// Make `a` tags act like a link
			if ( buttonDom.tag.toLowerCase() === 'a' ) {
				button.attr( 'href', '#' );
			}
	
			if ( linerDom.tag ) {
				var liner = $('<'+linerDom.tag+'/>')
					.html( text( config.text ) )
					.addClass( linerDom.className );
	
				if ( linerDom.tag.toLowerCase() === 'a' ) {
					liner.attr( 'href', '#' );
				}
	
				button.append( liner );
			}
			else {
				button.html( text( config.text ) );
			}
	
			if ( config.enabled === false ) {
				button.addClass( buttonDom.disabled );
			}
	
			if ( config.className ) {
				button.addClass( config.className );
			}
	
			if ( config.titleAttr ) {
				button.attr( 'title', config.titleAttr );
			}
	
			if ( ! config.namespace ) {
				config.namespace = '.dt-button-'+(_buttonCounter++);
			}
	
			var buttonContainer = this.c.dom.buttonContainer;
			var inserter;
			if ( buttonContainer && buttonContainer.tag ) {
				inserter = $('<'+buttonContainer.tag+'/>')
					.addClass( buttonContainer.className )
					.append( button );
			}
			else {
				inserter = button;
			}
	
			this._addKey( config );
	
			return {
				conf:         config,
				node:         button.get(0),
				inserter:     inserter,
				buttons:      [],
				inCollection: inCollection,
				collection:   null
			};
		},
	
		/**
		 * Get the button object from a node (recursive)
		 * @param  {node} node Button node
		 * @param  {array} [buttons] Button array, uses base if not defined
		 * @return {object} Button object
		 * @private
		 */
		_nodeToButton: function ( node, buttons )
		{
			if ( ! buttons ) {
				buttons = this.s.buttons;
			}
	
			for ( var i=0, ien=buttons.length ; i<ien ; i++ ) {
				if ( buttons[i].node === node ) {
					return buttons[i];
				}
	
				if ( buttons[i].buttons.length ) {
					var ret = this._nodeToButton( node, buttons[i].buttons );
	
					if ( ret ) {
						return ret;
					}
				}
			}
		},
	
		/**
		 * Get container array for a button from a button node (recursive)
		 * @param  {node} node Button node
		 * @param  {array} [buttons] Button array, uses base if not defined
		 * @return {array} Button's host array
		 * @private
		 */
		_nodeToHost: function ( node, buttons )
		{
			if ( ! buttons ) {
				buttons = this.s.buttons;
			}
	
			for ( var i=0, ien=buttons.length ; i<ien ; i++ ) {
				if ( buttons[i].node === node ) {
					return buttons;
				}
	
				if ( buttons[i].buttons.length ) {
					var ret = this._nodeToHost( node, buttons[i].buttons );
	
					if ( ret ) {
						return ret;
					}
				}
			}
		},
	
		/**
		 * Handle a key press - determine if any button's key configured matches
		 * what was typed and trigger the action if so.
		 * @param  {string} character The character pressed
		 * @param  {object} e Key event that triggered this call
		 * @private
		 */
		_keypress: function ( character, e )
		{
			var run = function ( conf, node ) {
				if ( ! conf.key ) {
					return;
				}
	
				if ( conf.key === character ) {
					$(node).click();
				}
				else if ( $.isPlainObject( conf.key ) ) {
					if ( conf.key.key !== character ) {
						return;
					}
	
					if ( conf.key.shiftKey && ! e.shiftKey ) {
						return;
					}
	
					if ( conf.key.altKey && ! e.altKey ) {
						return;
					}
	
					if ( conf.key.ctrlKey && ! e.ctrlKey ) {
						return;
					}
	
					if ( conf.key.metaKey && ! e.metaKey ) {
						return;
					}
	
					// Made it this far - it is good
					$(node).click();
				}
			};
	
			var recurse = function ( a ) {
				for ( var i=0, ien=a.length ; i<ien ; i++ ) {
					run( a[i].conf, a[i].node );
	
					if ( a[i].buttons.length ) {
						recurse( a[i].buttons );
					}
				}
			};
	
			recurse( this.s.buttons );
		},
	
		/**
		 * Remove a key from the key listener for this instance (to be used when a
		 * button is removed)
		 * @param  {object} conf Button configuration
		 * @private
		 */
		_removeKey: function ( conf )
		{
			if ( conf.key ) {
				var character = $.isPlainObject( conf.key ) ?
					conf.key.key :
					conf.key;
	
				// Remove only one character, as multiple buttons could have the
				// same listening key
				var a = this.s.listenKeys.split('');
				var idx = $.inArray( character, a );
				a.splice( idx, 1 );
				this.s.listenKeys = a.join('');
			}
		},
	
		/**
		 * Resolve a button configuration
		 * @param  {string|function|object} conf Button config to resolve
		 * @return {object} Button configuration
		 * @private
		 */
		_resolveExtends: function ( conf )
		{
			var dt = this.s.dt;
			var i, ien;
			var toConfObject = function ( base ) {
				var loop = 0;
	
				// Loop until we have resolved to a button configuration, or an
				// array of button configurations (which will be iterated
				// separately)
				while ( ! $.isPlainObject(base) && ! $.isArray(base) ) {
					if ( base === undefined ) {
						return;
					}
	
					if ( typeof base === 'function' ) {
						base = base( dt, conf );
	
						if ( ! base ) {
							return false;
						}
					}
					else if ( typeof base === 'string' ) {
						if ( ! _dtButtons[ base ] ) {
							throw 'Unknown button type: '+base;
						}
	
						base = _dtButtons[ base ];
					}
	
					loop++;
					if ( loop > 30 ) {
						// Protect against misconfiguration killing the browser
						throw 'Buttons: Too many iterations';
					}
				}
	
				return $.isArray( base ) ?
					base :
					$.extend( {}, base );
			};
	
			conf = toConfObject( conf );
	
			while ( conf && conf.extend ) {
				// Use `toConfObject` in case the button definition being extended
				// is itself a string or a function
				if ( ! _dtButtons[ conf.extend ] ) {
					throw 'Cannot extend unknown button type: '+conf.extend;
				}
	
				var objArray = toConfObject( _dtButtons[ conf.extend ] );
				if ( $.isArray( objArray ) ) {
					return objArray;
				}
				else if ( ! objArray ) {
					// This is a little brutal as it might be possible to have a
					// valid button without the extend, but if there is no extend
					// then the host button would be acting in an undefined state
					return false;
				}
	
				// Stash the current class name
				var originalClassName = objArray.className;
	
				conf = $.extend( {}, objArray, conf );
	
				// The extend will have overwritten the original class name if the
				// `conf` object also assigned a class, but we want to concatenate
				// them so they are list that is combined from all extended buttons
				if ( originalClassName && conf.className !== originalClassName ) {
					conf.className = originalClassName+' '+conf.className;
				}
	
				// Buttons to be added to a collection  -gives the ability to define
				// if buttons should be added to the start or end of a collection
				var postfixButtons = conf.postfixButtons;
				if ( postfixButtons ) {
					if ( ! conf.buttons ) {
						conf.buttons = [];
					}
	
					for ( i=0, ien=postfixButtons.length ; i<ien ; i++ ) {
						conf.buttons.push( postfixButtons[i] );
					}
	
					conf.postfixButtons = null;
				}
	
				var prefixButtons = conf.prefixButtons;
				if ( prefixButtons ) {
					if ( ! conf.buttons ) {
						conf.buttons = [];
					}
	
					for ( i=0, ien=prefixButtons.length ; i<ien ; i++ ) {
						conf.buttons.splice( i, 0, prefixButtons[i] );
					}
	
					conf.prefixButtons = null;
				}
	
				// Although we want the `conf` object to overwrite almost all of
				// the properties of the object being extended, the `extend`
				// property should come from the object being extended
				conf.extend = objArray.extend;
			}
	
			return conf;
		}
	} );
	
	
	
	/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	 * Statics
	 */
	
	/**
	 * Show / hide a background layer behind a collection
	 * @param  {boolean} Flag to indicate if the background should be shown or
	 *   hidden 
	 * @param  {string} Class to assign to the background
	 * @static
	 */
	Buttons.background = function ( show, className, fade ) {
		if ( fade === undefined ) {
			fade = 400;
		}
	
		if ( show ) {
			$('<div/>')
				.addClass( className )
				.css( 'display', 'none' )
				.appendTo( 'body' )
				.fadeIn( fade );
		}
		else {
			$('body > div.'+className)
				.fadeOut( fade, function () {
					$(this)
						.removeClass( className )
						.remove();
				} );
		}
	};
	
	/**
	 * Instance selector - select Buttons instances based on an instance selector
	 * value from the buttons assigned to a DataTable. This is only useful if
	 * multiple instances are attached to a DataTable.
	 * @param  {string|int|array} Instance selector - see `instance-selector`
	 *   documentation on the DataTables site
	 * @param  {array} Button instance array that was attached to the DataTables
	 *   settings object
	 * @return {array} Buttons instances
	 * @static
	 */
	Buttons.instanceSelector = function ( group, buttons )
	{
		if ( ! group ) {
			return $.map( buttons, function ( v ) {
				return v.inst;
			} );
		}
	
		var ret = [];
		var names = $.map( buttons, function ( v ) {
			return v.name;
		} );
	
		// Flatten the group selector into an array of single options
		var process = function ( input ) {
			if ( $.isArray( input ) ) {
				for ( var i=0, ien=input.length ; i<ien ; i++ ) {
					process( input[i] );
				}
				return;
			}
	
			if ( typeof input === 'string' ) {
				if ( input.indexOf( ',' ) !== -1 ) {
					// String selector, list of names
					process( input.split(',') );
				}
				else {
					// String selector individual name
					var idx = $.inArray( $.trim(input), names );
	
					if ( idx !== -1 ) {
						ret.push( buttons[ idx ].inst );
					}
				}
			}
			else if ( typeof input === 'number' ) {
				// Index selector
				ret.push( buttons[ input ].inst );
			}
		};
		
		process( group );
	
		return ret;
	};
	
	/**
	 * Button selector - select one or more buttons from a selector input so some
	 * operation can be performed on them.
	 * @param  {array} Button instances array that the selector should operate on
	 * @param  {string|int|node|jQuery|array} Button selector - see
	 *   `button-selector` documentation on the DataTables site
	 * @return {array} Array of objects containing `inst` and `idx` properties of
	 *   the selected buttons so you know which instance each button belongs to.
	 * @static
	 */
	Buttons.buttonSelector = function ( insts, selector )
	{
		var ret = [];
		var nodeBuilder = function ( a, buttons, baseIdx ) {
			var button;
			var idx;
	
			for ( var i=0, ien=buttons.length ; i<ien ; i++ ) {
				button = buttons[i];
	
				if ( button ) {
					idx = baseIdx !== undefined ?
						baseIdx+i :
						i+'';
	
					a.push( {
						node: button.node,
						name: button.conf.name,
						idx:  idx
					} );
	
					if ( button.buttons ) {
						nodeBuilder( a, button.buttons, idx+'-' );
					}
				}
			}
		};
	
		var run = function ( selector, inst ) {
			var i, ien;
			var buttons = [];
			nodeBuilder( buttons, inst.s.buttons );
	
			var nodes = $.map( buttons, function (v) {
				return v.node;
			} );
	
			if ( $.isArray( selector ) || selector instanceof $ ) {
				for ( i=0, ien=selector.length ; i<ien ; i++ ) {
					run( selector[i], inst );
				}
				return;
			}
	
			if ( selector === null || selector === undefined || selector === '*' ) {
				// Select all
				for ( i=0, ien=buttons.length ; i<ien ; i++ ) {
					ret.push( {
						inst: inst,
						node: buttons[i].node
					} );
				}
			}
			else if ( typeof selector === 'number' ) {
				// Main button index selector
				ret.push( {
					inst: inst,
					node: inst.s.buttons[ selector ].node
				} );
			}
			else if ( typeof selector === 'string' ) {
				if ( selector.indexOf( ',' ) !== -1 ) {
					// Split
					var a = selector.split(',');
	
					for ( i=0, ien=a.length ; i<ien ; i++ ) {
						run( $.trim(a[i]), inst );
					}
				}
				else if ( selector.match( /^\d+(\-\d+)*$/ ) ) {
					// Sub-button index selector
					var indexes = $.map( buttons, function (v) {
						return v.idx;
					} );
	
					ret.push( {
						inst: inst,
						node: buttons[ $.inArray( selector, indexes ) ].node
					} );
				}
				else if ( selector.indexOf( ':name' ) !== -1 ) {
					// Button name selector
					var name = selector.replace( ':name', '' );
	
					for ( i=0, ien=buttons.length ; i<ien ; i++ ) {
						if ( buttons[i].name === name ) {
							ret.push( {
								inst: inst,
								node: buttons[i].node
							} );
						}
					}
				}
				else {
					// jQuery selector on the nodes
					$( nodes ).filter( selector ).each( function () {
						ret.push( {
							inst: inst,
							node: this
						} );
					} );
				}
			}
			else if ( typeof selector === 'object' && selector.nodeName ) {
				// Node selector
				var idx = $.inArray( selector, nodes );
	
				if ( idx !== -1 ) {
					ret.push( {
						inst: inst,
						node: nodes[ idx ]
					} );
				}
			}
		};
	
	
		for ( var i=0, ien=insts.length ; i<ien ; i++ ) {
			var inst = insts[i];
	
			run( selector, inst );
		}
	
		return ret;
	};
	
	
	/**
	 * Buttons defaults. For full documentation, please refer to the docs/option
	 * directory or the DataTables site.
	 * @type {Object}
	 * @static
	 */
	Buttons.defaults = {
		buttons: [ 'copy', 'excel', 'csv', 'pdf', 'print' ],
		name: 'main',
		tabIndex: 0,
		dom: {
			container: {
				tag: 'div',
				className: 'dt-buttons'
			},
			collection: {
				tag: 'div',
				className: 'dt-button-collection'
			},
			button: {
				tag: 'a',
				className: 'dt-button',
				active: 'active',
				disabled: 'disabled'
			},
			buttonLiner: {
				tag: 'span',
				className: ''
			}
		}
	};
	
	/**
	 * Version information
	 * @type {string}
	 * @static
	 */
	Buttons.version = '1.2.2';
	
	
	$.extend( _dtButtons, {
		collection: {
			text: function ( dt ) {
				return dt.i18n( 'buttons.collection', 'Collection' );
			},
			className: 'buttons-collection',
			action: function ( e, dt, button, config ) {
				var host = button;
				var hostOffset = host.offset();
				var tableContainer = $( dt.table().container() );
				var multiLevel = false;
	
				// Remove any old collection
				if ( $('div.dt-button-background').length ) {
					multiLevel = $('div.dt-button-collection').offset();
					$('body').trigger( 'click.dtb-collection' );
				}
	
				config._collection
					.addClass( config.collectionLayout )
					.css( 'display', 'none' )
					.appendTo( 'body' )
					.fadeIn( config.fade );
	
				var position = config._collection.css( 'position' );
	
				if ( multiLevel && position === 'absolute' ) {
					config._collection.css( {
						top: multiLevel.top + 5, // magic numbers for a little offset
						left: multiLevel.left + 5
					} );
				}
				else if ( position === 'absolute' ) {
					config._collection.css( {
						top: hostOffset.top + host.outerHeight(),
						left: hostOffset.left
					} );
	
					var listRight = hostOffset.left + config._collection.outerWidth();
					var tableRight = tableContainer.offset().left + tableContainer.width();
					if ( listRight > tableRight ) {
						config._collection.css( 'left', hostOffset.left - ( listRight - tableRight ) );
					}
				}
				else {
					// Fix position - centre on screen
					var top = config._collection.height() / 2;
					if ( top > $(window).height() / 2 ) {
						top = $(window).height() / 2;
					}
	
					config._collection.css( 'marginTop', top*-1 );
				}
	
				if ( config.background ) {
					Buttons.background( true, config.backgroundClassName, config.fade );
				}
	
				// Need to break the 'thread' for the collection button being
				// activated by a click - it would also trigger this event
				setTimeout( function () {
					// This is bonkers, but if we don't have a click listener on the
					// background element, iOS Safari will ignore the body click
					// listener below. An empty function here is all that is
					// required to make it work...
					$('div.dt-button-background').on( 'click.dtb-collection', function () {} );
	
					$('body').on( 'click.dtb-collection', function (e) {
						// andSelf is deprecated in jQ1.8, but we want 1.7 compat
						var back = $.fn.addBack ? 'addBack' : 'andSelf';
	
						if ( ! $(e.target).parents()[back]().filter( config._collection ).length ) {
							config._collection
								.fadeOut( config.fade, function () {
									config._collection.detach();
								} );
	
							$('div.dt-button-background').off( 'click.dtb-collection' );
							Buttons.background( false, config.backgroundClassName, config.fade );
	
							$('body').off( 'click.dtb-collection' );
							dt.off( 'buttons-action.b-internal' );
						}
					} );
				}, 10 );
	
				if ( config.autoClose ) {
					dt.on( 'buttons-action.b-internal', function () {
						$('div.dt-button-background').click();
					} );
				}
			},
			background: true,
			collectionLayout: '',
			backgroundClassName: 'dt-button-background',
			autoClose: false,
			fade: 400
		},
		copy: function ( dt, conf ) {
			if ( _dtButtons.copyHtml5 ) {
				return 'copyHtml5';
			}
			if ( _dtButtons.copyFlash && _dtButtons.copyFlash.available( dt, conf ) ) {
				return 'copyFlash';
			}
		},
		csv: function ( dt, conf ) {
			// Common option that will use the HTML5 or Flash export buttons
			if ( _dtButtons.csvHtml5 && _dtButtons.csvHtml5.available( dt, conf ) ) {
				return 'csvHtml5';
			}
			if ( _dtButtons.csvFlash && _dtButtons.csvFlash.available( dt, conf ) ) {
				return 'csvFlash';
			}
		},
		excel: function ( dt, conf ) {
			// Common option that will use the HTML5 or Flash export buttons
			if ( _dtButtons.excelHtml5 && _dtButtons.excelHtml5.available( dt, conf ) ) {
				return 'excelHtml5';
			}
			if ( _dtButtons.excelFlash && _dtButtons.excelFlash.available( dt, conf ) ) {
				return 'excelFlash';
			}
		},
		pdf: function ( dt, conf ) {
			// Common option that will use the HTML5 or Flash export buttons
			if ( _dtButtons.pdfHtml5 && _dtButtons.pdfHtml5.available( dt, conf ) ) {
				return 'pdfHtml5';
			}
			if ( _dtButtons.pdfFlash && _dtButtons.pdfFlash.available( dt, conf ) ) {
				return 'pdfFlash';
			}
		},
		pageLength: function ( dt ) {
			var lengthMenu = dt.settings()[0].aLengthMenu;
			var vals = $.isArray( lengthMenu[0] ) ? lengthMenu[0] : lengthMenu;
			var lang = $.isArray( lengthMenu[0] ) ? lengthMenu[1] : lengthMenu;
			var text = function ( dt ) {
				return dt.i18n( 'buttons.pageLength', {
					"-1": 'Show all rows',
					_:    'Show %d rows'
				}, dt.page.len() );
			};
	
			return {
				extend: 'collection',
				text: text,
				className: 'buttons-page-length',
				autoClose: true,
				buttons: $.map( vals, function ( val, i ) {
					return {
						text: lang[i],
						action: function ( e, dt ) {
							dt.page.len( val ).draw();
						},
						init: function ( dt, node, conf ) {
							var that = this;
							var fn = function () {
								that.active( dt.page.len() === val );
							};
	
							dt.on( 'length.dt'+conf.namespace, fn );
							fn();
						},
						destroy: function ( dt, node, conf ) {
							dt.off( 'length.dt'+conf.namespace );
						}
					};
				} ),
				init: function ( dt, node, conf ) {
					var that = this;
					dt.on( 'length.dt'+conf.namespace, function () {
						that.text( text( dt ) );
					} );
				},
				destroy: function ( dt, node, conf ) {
					dt.off( 'length.dt'+conf.namespace );
				}
			};
		}
	} );
	
	
	/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	 * DataTables API
	 *
	 * For complete documentation, please refer to the docs/api directory or the
	 * DataTables site
	 */
	
	// Buttons group and individual button selector
	DataTable.Api.register( 'buttons()', function ( group, selector ) {
		// Argument shifting
		if ( selector === undefined ) {
			selector = group;
			group = undefined;
		}
	
		this.selector.buttonGroup = group;
	
		var res = this.iterator( true, 'table', function ( ctx ) {
			if ( ctx._buttons ) {
				return Buttons.buttonSelector(
					Buttons.instanceSelector( group, ctx._buttons ),
					selector
				);
			}
		}, true );
	
		res._groupSelector = group;
		return res;
	} );
	
	// Individual button selector
	DataTable.Api.register( 'button()', function ( group, selector ) {
		// just run buttons() and truncate
		var buttons = this.buttons( group, selector );
	
		if ( buttons.length > 1 ) {
			buttons.splice( 1, buttons.length );
		}
	
		return buttons;
	} );
	
	// Active buttons
	DataTable.Api.registerPlural( 'buttons().active()', 'button().active()', function ( flag ) {
		if ( flag === undefined ) {
			return this.map( function ( set ) {
				return set.inst.active( set.node );
			} );
		}
	
		return this.each( function ( set ) {
			set.inst.active( set.node, flag );
		} );
	} );
	
	// Get / set button action
	DataTable.Api.registerPlural( 'buttons().action()', 'button().action()', function ( action ) {
		if ( action === undefined ) {
			return this.map( function ( set ) {
				return set.inst.action( set.node );
			} );
		}
	
		return this.each( function ( set ) {
			set.inst.action( set.node, action );
		} );
	} );
	
	// Enable / disable buttons
	DataTable.Api.register( ['buttons().enable()', 'button().enable()'], function ( flag ) {
		return this.each( function ( set ) {
			set.inst.enable( set.node, flag );
		} );
	} );
	
	// Disable buttons
	DataTable.Api.register( ['buttons().disable()', 'button().disable()'], function () {
		return this.each( function ( set ) {
			set.inst.disable( set.node );
		} );
	} );
	
	// Get button nodes
	DataTable.Api.registerPlural( 'buttons().nodes()', 'button().node()', function () {
		var jq = $();
	
		// jQuery will automatically reduce duplicates to a single entry
		$( this.each( function ( set ) {
			jq = jq.add( set.inst.node( set.node ) );
		} ) );
	
		return jq;
	} );
	
	// Get / set button text (i.e. the button labels)
	DataTable.Api.registerPlural( 'buttons().text()', 'button().text()', function ( label ) {
		if ( label === undefined ) {
			return this.map( function ( set ) {
				return set.inst.text( set.node );
			} );
		}
	
		return this.each( function ( set ) {
			set.inst.text( set.node, label );
		} );
	} );
	
	// Trigger a button's action
	DataTable.Api.registerPlural( 'buttons().trigger()', 'button().trigger()', function () {
		return this.each( function ( set ) {
			set.inst.node( set.node ).trigger( 'click' );
		} );
	} );
	
	// Get the container elements
	DataTable.Api.registerPlural( 'buttons().containers()', 'buttons().container()', function () {
		var jq = $();
		var groupSelector = this._groupSelector;
	
		// We need to use the group selector directly, since if there are no buttons
		// the result set will be empty
		this.iterator( true, 'table', function ( ctx ) {
			if ( ctx._buttons ) {
				var insts = Buttons.instanceSelector( groupSelector, ctx._buttons );
	
				for ( var i=0, ien=insts.length ; i<ien ; i++ ) {
					jq = jq.add( insts[i].container() );
				}
			}
		} );
	
		return jq;
	} );
	
	// Add a new button
	DataTable.Api.register( 'button().add()', function ( idx, conf ) {
		var ctx = this.context;
	
		// Don't use `this` as it could be empty - select the instances directly
		if ( ctx.length ) {
			var inst = Buttons.instanceSelector( this._groupSelector, ctx[0]._buttons );
	
			if ( inst.length ) {
				inst[0].add( conf, idx );
			}
		}
	
		return this.button( this._groupSelector, idx );
	} );
	
	// Destroy the button sets selected
	DataTable.Api.register( 'buttons().destroy()', function () {
		this.pluck( 'inst' ).unique().each( function ( inst ) {
			inst.destroy();
		} );
	
		return this;
	} );
	
	// Remove a button
	DataTable.Api.registerPlural( 'buttons().remove()', 'buttons().remove()', function () {
		this.each( function ( set ) {
			set.inst.remove( set.node );
		} );
	
		return this;
	} );
	
	// Information box that can be used by buttons
	var _infoTimer;
	DataTable.Api.register( 'buttons.info()', function ( title, message, time ) {
		var that = this;
	
		if ( title === false ) {
			$('#datatables_buttons_info').fadeOut( function () {
				$(this).remove();
			} );
			clearTimeout( _infoTimer );
			_infoTimer = null;
	
			return this;
		}
	
		if ( _infoTimer ) {
			clearTimeout( _infoTimer );
		}
	
		if ( $('#datatables_buttons_info').length ) {
			$('#datatables_buttons_info').remove();
		}
	
		title = title ? '<h2>'+title+'</h2>' : '';
	
		$('<div id="datatables_buttons_info" class="dt-button-info"/>')
			.html( title )
			.append( $('<div/>')[ typeof message === 'string' ? 'html' : 'append' ]( message ) )
			.css( 'display', 'none' )
			.appendTo( 'body' )
			.fadeIn();
	
		if ( time !== undefined && time !== 0 ) {
			_infoTimer = setTimeout( function () {
				that.buttons.info( false );
			}, time );
		}
	
		return this;
	} );
	
	// Get data from the table for export - this is common to a number of plug-in
	// buttons so it is included in the Buttons core library
	DataTable.Api.register( 'buttons.exportData()', function ( options ) {
		if ( this.context.length ) {
			return _exportData( new DataTable.Api( this.context[0] ), options );
		}
	} );
	
	
	var _exportTextarea = $('<textarea/>')[0];
	var _exportData = function ( dt, inOpts )
	{
		var config = $.extend( true, {}, {
			rows:           null,
			columns:        '',
			modifier:       {
				search: 'applied',
				order:  'applied'
			},
			orthogonal:     'display',
			stripHtml:      true,
			stripNewlines:  true,
			decodeEntities: true,
			trim:           true,
			format:         {
				header: function ( d ) {
					return strip( d );
				},
				footer: function ( d ) {
					return strip( d );
				},
				body: function ( d ) {
					return strip( d );
				}
			}
		}, inOpts );
	
		var strip = function ( str ) {
			if ( typeof str !== 'string' ) {
				return str;
			}
	
			if ( config.stripHtml ) {
				str = str.replace( /<[^>]*>/g, '' );
			}
	
			if ( config.trim ) {
				str = str.replace( /^\s+|\s+$/g, '' );
			}
	
			if ( config.stripNewlines ) {
				str = str.replace( /\n/g, ' ' );
			}
	
			if ( config.decodeEntities ) {
				_exportTextarea.innerHTML = str;
				str = _exportTextarea.value;
			}
	
			return str;
		};
	
	
		var header = dt.columns( config.columns ).indexes().map( function (idx) {
			var el = dt.column( idx ).header();
			return config.format.header( el.innerHTML, idx, el );
		} ).toArray();
	
		var footer = dt.table().footer() ?
			dt.columns( config.columns ).indexes().map( function (idx) {
				var el = dt.column( idx ).footer();
				return config.format.footer( el ? el.innerHTML : '', idx, el );
			} ).toArray() :
			null;
	
		var rowIndexes = dt.rows( config.rows, config.modifier ).indexes().toArray();
		var cells = dt
			.cells( rowIndexes, config.columns )
			.render( config.orthogonal )
			.toArray();
		var cellNodes = dt
			.cells( rowIndexes, config.columns )
			.nodes()
			.toArray();
	
		var columns = header.length;
		var rows = columns > 0 ? cells.length / columns : 0;
		var body = new Array( rows );
		var cellCounter = 0;
	
		for ( var i=0, ien=rows ; i<ien ; i++ ) {
			var row = new Array( columns );
	
			for ( var j=0 ; j<columns ; j++ ) {
				row[j] = config.format.body( cells[ cellCounter ], i, j, cellNodes[ cellCounter ] );
				cellCounter++;
			}
	
			body[i] = row;
		}
	
		return {
			header: header,
			footer: footer,
			body:   body
		};
	};
	
	
	/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	 * DataTables interface
	 */
	
	// Attach to DataTables objects for global access
	$.fn.dataTable.Buttons = Buttons;
	$.fn.DataTable.Buttons = Buttons;
	
	
	
	// DataTables creation - check if the buttons have been defined for this table,
	// they will have been if the `B` option was used in `dom`, otherwise we should
	// create the buttons instance here so they can be inserted into the document
	// using the API. Listen for `init` for compatibility with pre 1.10.10, but to
	// be removed in future.
	$(document).on( 'init.dt plugin-init.dt', function (e, settings) {
		if ( e.namespace !== 'dt' ) {
			return;
		}
	
		var opts = settings.oInit.buttons || DataTable.defaults.buttons;
	
		if ( opts && ! settings._buttons ) {
			new Buttons( settings, opts ).container();
		}
	} );
	
	// DataTables `dom` feature option
	DataTable.ext.feature.push( {
		fnInit: function( settings ) {
			var api = new DataTable.Api( settings );
			var opts = api.init().buttons || DataTable.defaults.buttons;
	
			return new Buttons( api, opts ).container();
		},
		cFeature: "B"
	} );
	
	
	return Buttons;
	}));


/***/ },
/* 18 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	 * Print button for Buttons and DataTables.
	 * 2016 SpryMedia Ltd - datatables.net/license
	 */
	
	(function( factory ){
		if ( true ) {
			// AMD
			!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(1), __webpack_require__(4), __webpack_require__(17)], __WEBPACK_AMD_DEFINE_RESULT__ = function ( $ ) {
				return factory( $, window, document );
			}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
		}
		else if ( typeof exports === 'object' ) {
			// CommonJS
			module.exports = function (root, $) {
				if ( ! root ) {
					root = window;
				}
	
				if ( ! $ || ! $.fn.dataTable ) {
					$ = require('datatables.net')(root, $).$;
				}
	
				if ( ! $.fn.dataTable.Buttons ) {
					require('datatables.net-buttons')(root, $);
				}
	
				return factory( $, root, root.document );
			};
		}
		else {
			// Browser
			factory( jQuery, window, document );
		}
	}(function( $, window, document, undefined ) {
	'use strict';
	var DataTable = $.fn.dataTable;
	
	
	var _link = document.createElement( 'a' );
	
	/**
	 * Convert a `link` tag's URL from a relative to an absolute address so it will
	 * work correctly in the popup window which has no base URL.
	 *
	 * @param  {node}     el Element to convert
	 */
	var _relToAbs = function( el ) {
		var url;
		var clone = $(el).clone()[0];
		var linkHost;
	
		if ( clone.nodeName.toLowerCase() === 'link' ) {
			_link.href = clone.href;
			linkHost = _link.host;
	
			// IE doesn't have a trailing slash on the host
			// Chrome has it on the pathname
			if ( linkHost.indexOf('/') === -1 && _link.pathname.indexOf('/') !== 0) {
				linkHost += '/';
			}
	
			clone.href = _link.protocol+"//"+linkHost+_link.pathname+_link.search;
		}
	
		return clone.outerHTML;
	};
	
	
	DataTable.ext.buttons.print = {
		className: 'buttons-print',
	
		text: function ( dt ) {
			return dt.i18n( 'buttons.print', 'Print' );
		},
	
		action: function ( e, dt, button, config ) {
			var data = dt.buttons.exportData( config.exportOptions );
			var addRow = function ( d, tag ) {
				var str = '<tr>';
	
				for ( var i=0, ien=d.length ; i<ien ; i++ ) {
					str += '<'+tag+'>'+d[i]+'</'+tag+'>';
				}
	
				return str + '</tr>';
			};
	
			// Construct a table for printing
			var html = '<table class="'+dt.table().node().className+'">';
	
			if ( config.header ) {
				html += '<thead>'+ addRow( data.header, 'th' ) +'</thead>';
			}
	
			html += '<tbody>';
			for ( var i=0, ien=data.body.length ; i<ien ; i++ ) {
				html += addRow( data.body[i], 'td' );
			}
			html += '</tbody>';
	
			if ( config.footer && data.footer ) {
				html += '<tfoot>'+ addRow( data.footer, 'th' ) +'</tfoot>';
			}
	
			// Open a new window for the printable table
			var win = window.open( '', '' );
			var title = config.title;
	
			if ( typeof title === 'function' ) {
				title = title();
			}
	
			if ( title.indexOf( '*' ) !== -1 ) {
				title= title.replace( '*', $('title').text() );
			}
	
			win.document.close();
	
			// Inject the title and also a copy of the style and link tags from this
			// document so the table can retain its base styling. Note that we have
			// to use string manipulation as IE won't allow elements to be created
			// in the host document and then appended to the new window.
			var head = '<title>'+title+'</title>';
			$('style, link').each( function () {
				head += _relToAbs( this );
			} );
	
			try {
				win.document.head.innerHTML = head; // Work around for Edge
			}
			catch (e) {
				$(win.document.head).html( head ); // Old IE
			}
	
			// Inject the table and other surrounding information
			win.document.body.innerHTML =
				'<h1>'+title+'</h1>'+
				'<div>'+
					(typeof config.message === 'function' ?
						config.message( dt, button, config ) :
						config.message
					)+
				'</div>'+
				html;
	
			if ( config.customize ) {
				config.customize( win );
			}
	
			setTimeout( function () {
				if ( config.autoPrint ) {
					win.print(); // blocking - so close will not
					win.close(); // execute until this is done
				}
			}, 250 );
		},
	
		title: '*',
	
		message: '',
	
		exportOptions: {},
	
		header: true,
	
		footer: false,
	
		autoPrint: true,
	
		customize: null
	};
	
	
	return DataTable.Buttons;
	}));


/***/ },
/* 19 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	 * Column visibility buttons for Buttons and DataTables.
	 * 2016 SpryMedia Ltd - datatables.net/license
	 */
	
	(function( factory ){
		if ( true ) {
			// AMD
			!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(1), __webpack_require__(4), __webpack_require__(17)], __WEBPACK_AMD_DEFINE_RESULT__ = function ( $ ) {
				return factory( $, window, document );
			}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
		}
		else if ( typeof exports === 'object' ) {
			// CommonJS
			module.exports = function (root, $) {
				if ( ! root ) {
					root = window;
				}
	
				if ( ! $ || ! $.fn.dataTable ) {
					$ = require('datatables.net')(root, $).$;
				}
	
				if ( ! $.fn.dataTable.Buttons ) {
					require('datatables.net-buttons')(root, $);
				}
	
				return factory( $, root, root.document );
			};
		}
		else {
			// Browser
			factory( jQuery, window, document );
		}
	}(function( $, window, document, undefined ) {
	'use strict';
	var DataTable = $.fn.dataTable;
	
	
	$.extend( DataTable.ext.buttons, {
		// A collection of column visibility buttons
		colvis: function ( dt, conf ) {
			return {
				extend: 'collection',
				text: function ( dt ) {
					return dt.i18n( 'buttons.colvis', 'Column visibility' );
				},
				className: 'buttons-colvis',
				buttons: [ {
					extend: 'columnsToggle',
					columns: conf.columns
				} ]
			};
		},
	
		// Selected columns with individual buttons - toggle column visibility
		columnsToggle: function ( dt, conf ) {
			var columns = dt.columns( conf.columns ).indexes().map( function ( idx ) {
				return {
					extend: 'columnToggle',
					columns: idx
				};
			} ).toArray();
	
			return columns;
		},
	
		// Single button to toggle column visibility
		columnToggle: function ( dt, conf ) {
			return {
				extend: 'columnVisibility',
				columns: conf.columns
			};
		},
	
		// Selected columns with individual buttons - set column visibility
		columnsVisibility: function ( dt, conf ) {
			var columns = dt.columns( conf.columns ).indexes().map( function ( idx ) {
				return {
					extend: 'columnVisibility',
					columns: idx,
					visibility: conf.visibility
				};
			} ).toArray();
	
			return columns;
		},
	
		// Single button to set column visibility
		columnVisibility: {
			columns: undefined, // column selector
			text: function ( dt, button, conf ) {
				return conf._columnText( dt, conf.columns );
			},
			className: 'buttons-columnVisibility',
			action: function ( e, dt, button, conf ) {
				var col = dt.columns( conf.columns );
				var curr = col.visible();
	
				col.visible( conf.visibility !== undefined ?
					conf.visibility :
					! (curr.length ? curr[0] : false )
				);
			},
			init: function ( dt, button, conf ) {
				var that = this;
	
				dt
					.on( 'column-visibility.dt'+conf.namespace, function (e, settings) {
						if ( ! settings.bDestroying ) {
							that.active( dt.column( conf.columns ).visible() );
						}
					} )
					.on( 'column-reorder.dt'+conf.namespace, function (e, settings, details) {
						// Don't rename buttons based on column name if the button
						// controls more than one column!
						if ( dt.columns( conf.columns ).count() !== 1 ) {
							return;
						}
	
						if ( typeof conf.columns === 'number' ) {
							conf.columns = details.mapping[ conf.columns ];
						}
	
						var col = dt.column( conf.columns );
	
						that.text( conf._columnText( dt, conf.columns ) );
						that.active( col.visible() );
					} );
	
				this.active( dt.column( conf.columns ).visible() );
			},
			destroy: function ( dt, button, conf ) {
				dt
					.off( 'column-visibility.dt'+conf.namespace )
					.off( 'column-reorder.dt'+conf.namespace );
			},
	
			_columnText: function ( dt, col ) {
				// Use DataTables' internal data structure until this is presented
				// is a public API. The other option is to use
				// `$( column(col).node() ).text()` but the node might not have been
				// populated when Buttons is constructed.
				var idx = dt.column( col ).index();
				return dt.settings()[0].aoColumns[ idx ].sTitle
					.replace(/\n/g," ")        // remove new lines
					.replace( /<.*?>/g, "" )   // strip HTML
					.replace(/^\s+|\s+$/g,""); // trim
			}
		},
	
	
		colvisRestore: {
			className: 'buttons-colvisRestore',
	
			text: function ( dt ) {
				return dt.i18n( 'buttons.colvisRestore', 'Restore visibility' );
			},
	
			init: function ( dt, button, conf ) {
				conf._visOriginal = dt.columns().indexes().map( function ( idx ) {
					return dt.column( idx ).visible();
				} ).toArray();
			},
	
			action: function ( e, dt, button, conf ) {
				dt.columns().every( function ( i ) {
					// Take into account that ColReorder might have disrupted our
					// indexes
					var idx = dt.colReorder && dt.colReorder.transpose ?
						dt.colReorder.transpose( i, 'toOriginal' ) :
						i;
	
					this.visible( conf._visOriginal[ idx ] );
				} );
			}
		},
	
	
		colvisGroup: {
			className: 'buttons-colvisGroup',
	
			action: function ( e, dt, button, conf ) {
				dt.columns( conf.show ).visible( true, false );
				dt.columns( conf.hide ).visible( false, false );
	
				dt.columns.adjust();
			},
	
			show: [],
	
			hide: []
		}
	} );
	
	
	return DataTable.Buttons;
	}));


/***/ },
/* 20 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	 * Flash export buttons for Buttons and DataTables.
	 * 2015 SpryMedia Ltd - datatables.net/license
	 *
	 * ZeroClipbaord - MIT license
	 * Copyright (c) 2012 Joseph Huckaby
	 */
	
	(function( factory ){
		if ( true ) {
			// AMD
			!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(1), __webpack_require__(4), __webpack_require__(17)], __WEBPACK_AMD_DEFINE_RESULT__ = function ( $ ) {
				return factory( $, window, document );
			}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
		}
		else if ( typeof exports === 'object' ) {
			// CommonJS
			module.exports = function (root, $) {
				if ( ! root ) {
					root = window;
				}
	
				if ( ! $ || ! $.fn.dataTable ) {
					$ = require('datatables.net')(root, $).$;
				}
	
				if ( ! $.fn.dataTable.Buttons ) {
					require('datatables.net-buttons')(root, $);
				}
	
				return factory( $, root, root.document );
			};
		}
		else {
			// Browser
			factory( jQuery, window, document );
		}
	}(function( $, window, document, undefined ) {
	'use strict';
	var DataTable = $.fn.dataTable;
	
	
	/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	 * ZeroClipboard dependency
	 */
	
	/*
	 * ZeroClipboard 1.0.4 with modifications
	 * Author: Joseph Huckaby
	 * License: MIT
	 *
	 * Copyright (c) 2012 Joseph Huckaby
	 */
	var ZeroClipboard_TableTools = {
		version: "1.0.4-TableTools2",
		clients: {}, // registered upload clients on page, indexed by id
		moviePath: '', // URL to movie
		nextId: 1, // ID of next movie
	
		$: function(thingy) {
			// simple DOM lookup utility function
			if (typeof(thingy) == 'string') {
				thingy = document.getElementById(thingy);
			}
			if (!thingy.addClass) {
				// extend element with a few useful methods
				thingy.hide = function() { this.style.display = 'none'; };
				thingy.show = function() { this.style.display = ''; };
				thingy.addClass = function(name) { this.removeClass(name); this.className += ' ' + name; };
				thingy.removeClass = function(name) {
					this.className = this.className.replace( new RegExp("\\s*" + name + "\\s*"), " ").replace(/^\s+/, '').replace(/\s+$/, '');
				};
				thingy.hasClass = function(name) {
					return !!this.className.match( new RegExp("\\s*" + name + "\\s*") );
				};
			}
			return thingy;
		},
	
		setMoviePath: function(path) {
			// set path to ZeroClipboard.swf
			this.moviePath = path;
		},
	
		dispatch: function(id, eventName, args) {
			// receive event from flash movie, send to client
			var client = this.clients[id];
			if (client) {
				client.receiveEvent(eventName, args);
			}
		},
	
		log: function ( str ) {
			console.log( 'Flash: '+str );
		},
	
		register: function(id, client) {
			// register new client to receive events
			this.clients[id] = client;
		},
	
		getDOMObjectPosition: function(obj) {
			// get absolute coordinates for dom element
			var info = {
				left: 0,
				top: 0,
				width: obj.width ? obj.width : obj.offsetWidth,
				height: obj.height ? obj.height : obj.offsetHeight
			};
	
			if ( obj.style.width !== "" ) {
				info.width = obj.style.width.replace("px","");
			}
	
			if ( obj.style.height !== "" ) {
				info.height = obj.style.height.replace("px","");
			}
	
			while (obj) {
				info.left += obj.offsetLeft;
				info.top += obj.offsetTop;
				obj = obj.offsetParent;
			}
	
			return info;
		},
	
		Client: function(elem) {
			// constructor for new simple upload client
			this.handlers = {};
	
			// unique ID
			this.id = ZeroClipboard_TableTools.nextId++;
			this.movieId = 'ZeroClipboard_TableToolsMovie_' + this.id;
	
			// register client with singleton to receive flash events
			ZeroClipboard_TableTools.register(this.id, this);
	
			// create movie
			if (elem) {
				this.glue(elem);
			}
		}
	};
	
	ZeroClipboard_TableTools.Client.prototype = {
	
		id: 0, // unique ID for us
		ready: false, // whether movie is ready to receive events or not
		movie: null, // reference to movie object
		clipText: '', // text to copy to clipboard
		fileName: '', // default file save name
		action: 'copy', // action to perform
		handCursorEnabled: true, // whether to show hand cursor, or default pointer cursor
		cssEffects: true, // enable CSS mouse effects on dom container
		handlers: null, // user event handlers
		sized: false,
		sheetName: '', // default sheet name for excel export
	
		glue: function(elem, title) {
			// glue to DOM element
			// elem can be ID or actual DOM element object
			this.domElement = ZeroClipboard_TableTools.$(elem);
	
			// float just above object, or zIndex 99 if dom element isn't set
			var zIndex = 99;
			if (this.domElement.style.zIndex) {
				zIndex = parseInt(this.domElement.style.zIndex, 10) + 1;
			}
	
			// find X/Y position of domElement
			var box = ZeroClipboard_TableTools.getDOMObjectPosition(this.domElement);
	
			// create floating DIV above element
			this.div = document.createElement('div');
			var style = this.div.style;
			style.position = 'absolute';
			style.left = '0px';
			style.top = '0px';
			style.width = (box.width) + 'px';
			style.height = box.height + 'px';
			style.zIndex = zIndex;
	
			if ( typeof title != "undefined" && title !== "" ) {
				this.div.title = title;
			}
			if ( box.width !== 0 && box.height !== 0 ) {
				this.sized = true;
			}
	
			// style.backgroundColor = '#f00'; // debug
			if ( this.domElement ) {
				this.domElement.appendChild(this.div);
				this.div.innerHTML = this.getHTML( box.width, box.height ).replace(/&/g, '&amp;');
			}
		},
	
		positionElement: function() {
			var box = ZeroClipboard_TableTools.getDOMObjectPosition(this.domElement);
			var style = this.div.style;
	
			style.position = 'absolute';
			//style.left = (this.domElement.offsetLeft)+'px';
			//style.top = this.domElement.offsetTop+'px';
			style.width = box.width + 'px';
			style.height = box.height + 'px';
	
			if ( box.width !== 0 && box.height !== 0 ) {
				this.sized = true;
			} else {
				return;
			}
	
			var flash = this.div.childNodes[0];
			flash.width = box.width;
			flash.height = box.height;
		},
	
		getHTML: function(width, height) {
			// return HTML for movie
			var html = '';
			var flashvars = 'id=' + this.id +
				'&width=' + width +
				'&height=' + height;
	
			if (navigator.userAgent.match(/MSIE/)) {
				// IE gets an OBJECT tag
				var protocol = location.href.match(/^https/i) ? 'https://' : 'http://';
				html += '<object classid="clsid:D27CDB6E-AE6D-11cf-96B8-444553540000" codebase="'+protocol+'download.macromedia.com/pub/shockwave/cabs/flash/swflash.cab#version=10,0,0,0" width="'+width+'" height="'+height+'" id="'+this.movieId+'" align="middle"><param name="allowScriptAccess" value="always" /><param name="allowFullScreen" value="false" /><param name="movie" value="'+ZeroClipboard_TableTools.moviePath+'" /><param name="loop" value="false" /><param name="menu" value="false" /><param name="quality" value="best" /><param name="bgcolor" value="#ffffff" /><param name="flashvars" value="'+flashvars+'"/><param name="wmode" value="transparent"/></object>';
			}
			else {
				// all other browsers get an EMBED tag
				html += '<embed id="'+this.movieId+'" src="'+ZeroClipboard_TableTools.moviePath+'" loop="false" menu="false" quality="best" bgcolor="#ffffff" width="'+width+'" height="'+height+'" name="'+this.movieId+'" align="middle" allowScriptAccess="always" allowFullScreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="'+flashvars+'" wmode="transparent" />';
			}
			return html;
		},
	
		hide: function() {
			// temporarily hide floater offscreen
			if (this.div) {
				this.div.style.left = '-2000px';
			}
		},
	
		show: function() {
			// show ourselves after a call to hide()
			this.reposition();
		},
	
		destroy: function() {
			// destroy control and floater
			var that = this;
	
			if (this.domElement && this.div) {
				$(this.div).remove();
	
				this.domElement = null;
				this.div = null;
	
				$.each( ZeroClipboard_TableTools.clients, function ( id, client ) {
					if ( client === that ) {
						delete ZeroClipboard_TableTools.clients[ id ];
					}
				} );
			}
		},
	
		reposition: function(elem) {
			// reposition our floating div, optionally to new container
			// warning: container CANNOT change size, only position
			if (elem) {
				this.domElement = ZeroClipboard_TableTools.$(elem);
				if (!this.domElement) {
					this.hide();
				}
			}
	
			if (this.domElement && this.div) {
				var box = ZeroClipboard_TableTools.getDOMObjectPosition(this.domElement);
				var style = this.div.style;
				style.left = '' + box.left + 'px';
				style.top = '' + box.top + 'px';
			}
		},
	
		clearText: function() {
			// clear the text to be copy / saved
			this.clipText = '';
			if (this.ready) {
				this.movie.clearText();
			}
		},
	
		appendText: function(newText) {
			// append text to that which is to be copied / saved
			this.clipText += newText;
			if (this.ready) { this.movie.appendText(newText) ;}
		},
	
		setText: function(newText) {
			// set text to be copied to be copied / saved
			this.clipText = newText;
			if (this.ready) { this.movie.setText(newText) ;}
		},
	
		setFileName: function(newText) {
			// set the file name
			this.fileName = newText;
			if (this.ready) {
				this.movie.setFileName(newText);
			}
		},
	
		setSheetData: function(data) {
			// set the xlsx sheet data
			if (this.ready) {
				this.movie.setSheetData( JSON.stringify( data ) );
			}
		},
	
		setAction: function(newText) {
			// set action (save or copy)
			this.action = newText;
			if (this.ready) {
				this.movie.setAction(newText);
			}
		},
	
		addEventListener: function(eventName, func) {
			// add user event listener for event
			// event types: load, queueStart, fileStart, fileComplete, queueComplete, progress, error, cancel
			eventName = eventName.toString().toLowerCase().replace(/^on/, '');
			if (!this.handlers[eventName]) {
				this.handlers[eventName] = [];
			}
			this.handlers[eventName].push(func);
		},
	
		setHandCursor: function(enabled) {
			// enable hand cursor (true), or default arrow cursor (false)
			this.handCursorEnabled = enabled;
			if (this.ready) {
				this.movie.setHandCursor(enabled);
			}
		},
	
		setCSSEffects: function(enabled) {
			// enable or disable CSS effects on DOM container
			this.cssEffects = !!enabled;
		},
	
		receiveEvent: function(eventName, args) {
			var self;
	
			// receive event from flash
			eventName = eventName.toString().toLowerCase().replace(/^on/, '');
	
			// special behavior for certain events
			switch (eventName) {
				case 'load':
					// movie claims it is ready, but in IE this isn't always the case...
					// bug fix: Cannot extend EMBED DOM elements in Firefox, must use traditional function
					this.movie = document.getElementById(this.movieId);
					if (!this.movie) {
						self = this;
						setTimeout( function() { self.receiveEvent('load', null); }, 1 );
						return;
					}
	
					// firefox on pc needs a "kick" in order to set these in certain cases
					if (!this.ready && navigator.userAgent.match(/Firefox/) && navigator.userAgent.match(/Windows/)) {
						self = this;
						setTimeout( function() { self.receiveEvent('load', null); }, 100 );
						this.ready = true;
						return;
					}
	
					this.ready = true;
					this.movie.clearText();
					this.movie.appendText( this.clipText );
					this.movie.setFileName( this.fileName );
					this.movie.setAction( this.action );
					this.movie.setHandCursor( this.handCursorEnabled );
					break;
	
				case 'mouseover':
					if (this.domElement && this.cssEffects) {
						//this.domElement.addClass('hover');
						if (this.recoverActive) {
							this.domElement.addClass('active');
						}
					}
					break;
	
				case 'mouseout':
					if (this.domElement && this.cssEffects) {
						this.recoverActive = false;
						if (this.domElement.hasClass('active')) {
							this.domElement.removeClass('active');
							this.recoverActive = true;
						}
						//this.domElement.removeClass('hover');
					}
					break;
	
				case 'mousedown':
					if (this.domElement && this.cssEffects) {
						this.domElement.addClass('active');
					}
					break;
	
				case 'mouseup':
					if (this.domElement && this.cssEffects) {
						this.domElement.removeClass('active');
						this.recoverActive = false;
					}
					break;
			} // switch eventName
	
			if (this.handlers[eventName]) {
				for (var idx = 0, len = this.handlers[eventName].length; idx < len; idx++) {
					var func = this.handlers[eventName][idx];
	
					if (typeof(func) == 'function') {
						// actual function reference
						func(this, args);
					}
					else if ((typeof(func) == 'object') && (func.length == 2)) {
						// PHP style object + method, i.e. [myObject, 'myMethod']
						func[0][ func[1] ](this, args);
					}
					else if (typeof(func) == 'string') {
						// name of function
						window[func](this, args);
					}
				} // foreach event handler defined
			} // user defined handler for event
		}
	};
	
	ZeroClipboard_TableTools.hasFlash = function ()
	{
		try {
			var fo = new ActiveXObject('ShockwaveFlash.ShockwaveFlash');
			if (fo) {
				return true;
			}
		}
		catch (e) {
			if (
				navigator.mimeTypes &&
				navigator.mimeTypes['application/x-shockwave-flash'] !== undefined &&
				navigator.mimeTypes['application/x-shockwave-flash'].enabledPlugin
			) {
				return true;
			}
		}
	
		return false;
	};
	
	// For the Flash binding to work, ZeroClipboard_TableTools must be on the global
	// object list
	window.ZeroClipboard_TableTools = ZeroClipboard_TableTools;
	
	
	
	/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	 * Local (private) functions
	 */
	
	/**
	 * If a Buttons instance is initlaised before it is placed into the DOM, Flash
	 * won't be able to bind to it, so we need to wait until it is available, this
	 * method abstracts that out.
	 *
	 * @param {ZeroClipboard} flash ZeroClipboard instance
	 * @param {jQuery} node  Button
	 */
	var _glue = function ( flash, node )
	{
		var id = node.attr('id');
	
		if ( node.parents('html').length ) {
			flash.glue( node[0], '' );
		}
		else {
			setTimeout( function () {
				_glue( flash, node );
			}, 500 );
		}
	};
	
	/**
	 * Get the file name for an exported file.
	 *
	 * @param {object}  config       Button configuration
	 * @param {boolean} incExtension Include the file name extension
	 */
	var _filename = function ( config, incExtension )
	{
		// Backwards compatibility
		var filename = config.filename === '*' && config.title !== '*' && config.title !== undefined ?
			config.title :
			config.filename;
	
		if ( typeof filename === 'function' ) {
			filename = filename();
		}
	
		if ( filename.indexOf( '*' ) !== -1 ) {
			filename = $.trim( filename.replace( '*', $('title').text() ) );
		}
	
		// Strip characters which the OS will object to
		filename = filename.replace(/[^a-zA-Z0-9_\u00A1-\uFFFF\.,\-_ !\(\)]/g, "");
	
		return incExtension === undefined || incExtension === true ?
			filename+config.extension :
			filename;
	};
	
	/**
	 * Get the sheet name for Excel exports.
	 *
	 * @param {object}  config       Button configuration
	 */
	var _sheetname = function ( config )
	{
		var sheetName = 'Sheet1';
	
		if ( config.sheetName ) {
			sheetName = config.sheetName.replace(/[\[\]\*\/\\\?\:]/g, '');
		}
	
		return sheetName;
	};
	
	/**
	 * Get the title for an exported file.
	 *
	 * @param {object}  config  Button configuration
	 */
	var _title = function ( config )
	{
		var title = config.title;
	
		if ( typeof title === 'function' ) {
			title = title();
		}
	
		return title.indexOf( '*' ) !== -1 ?
			title.replace( '*', $('title').text() || 'Exported data' ) :
			title;
	};
	
	/**
	 * Set the flash text. This has to be broken up into chunks as the Javascript /
	 * Flash bridge has a size limit. There is no indication in the Flash
	 * documentation what this is, and it probably depends upon the browser.
	 * Experimentation shows that the point is around 50k when data starts to get
	 * lost, so an 8K limit used here is safe.
	 *
	 * @param {ZeroClipboard} flash ZeroClipboard instance
	 * @param {string}        data  Data to send to Flash
	 */
	var _setText = function ( flash, data )
	{
		var parts = data.match(/[\s\S]{1,8192}/g) || [];
	
		flash.clearText();
		for ( var i=0, len=parts.length ; i<len ; i++ )
		{
			flash.appendText( parts[i] );
		}
	};
	
	/**
	 * Get the newline character(s)
	 *
	 * @param {object}  config Button configuration
	 * @return {string}        Newline character
	 */
	var _newLine = function ( config )
	{
		return config.newline ?
			config.newline :
			navigator.userAgent.match(/Windows/) ?
				'\r\n' :
				'\n';
	};
	
	/**
	 * Combine the data from the `buttons.exportData` method into a string that
	 * will be used in the export file.
	 *
	 * @param  {DataTable.Api} dt     DataTables API instance
	 * @param  {object}        config Button configuration
	 * @return {object}               The data to export
	 */
	var _exportData = function ( dt, config )
	{
		var newLine = _newLine( config );
		var data = dt.buttons.exportData( config.exportOptions );
		var boundary = config.fieldBoundary;
		var separator = config.fieldSeparator;
		var reBoundary = new RegExp( boundary, 'g' );
		var escapeChar = config.escapeChar !== undefined ?
			config.escapeChar :
			'\\';
		var join = function ( a ) {
			var s = '';
	
			// If there is a field boundary, then we might need to escape it in
			// the source data
			for ( var i=0, ien=a.length ; i<ien ; i++ ) {
				if ( i > 0 ) {
					s += separator;
				}
	
				s += boundary ?
					boundary + ('' + a[i]).replace( reBoundary, escapeChar+boundary ) + boundary :
					a[i];
			}
	
			return s;
		};
	
		var header = config.header ? join( data.header )+newLine : '';
		var footer = config.footer && data.footer ? newLine+join( data.footer ) : '';
		var body = [];
	
		for ( var i=0, ien=data.body.length ; i<ien ; i++ ) {
			body.push( join( data.body[i] ) );
		}
	
		return {
			str: header + body.join( newLine ) + footer,
			rows: body.length
		};
	};
	
	
	// Basic initialisation for the buttons is common between them
	var flashButton = {
		available: function () {
			return ZeroClipboard_TableTools.hasFlash();
		},
	
		init: function ( dt, button, config ) {
			// Insert the Flash movie
			ZeroClipboard_TableTools.moviePath = DataTable.Buttons.swfPath;
			var flash = new ZeroClipboard_TableTools.Client();
	
			flash.setHandCursor( true );
			flash.addEventListener('mouseDown', function(client) {
				config._fromFlash = true;
				dt.button( button[0] ).trigger();
				config._fromFlash = false;
			} );
	
			_glue( flash, button );
	
			config._flash = flash;
		},
	
		destroy: function ( dt, button, config ) {
			config._flash.destroy();
		},
	
		fieldSeparator: ',',
	
		fieldBoundary: '"',
	
		exportOptions: {},
	
		title: '*',
	
		filename: '*',
	
		extension: '.csv',
	
		header: true,
	
		footer: false
	};
	
	
	/**
	 * Convert from numeric position to letter for column names in Excel
	 * @param  {int} n Column number
	 * @return {string} Column letter(s) name
	 */
	function createCellPos( n ){
		var ordA = 'A'.charCodeAt(0);
		var ordZ = 'Z'.charCodeAt(0);
		var len = ordZ - ordA + 1;
		var s = "";
	
		while( n >= 0 ) {
			s = String.fromCharCode(n % len + ordA) + s;
			n = Math.floor(n / len) - 1;
		}
	
		return s;
	}
	
	/**
	 * Create an XML node and add any children, attributes, etc without needing to
	 * be verbose in the DOM.
	 *
	 * @param  {object} doc      XML document
	 * @param  {string} nodeName Node name
	 * @param  {object} opts     Options - can be `attr` (attributes), `children`
	 *   (child nodes) and `text` (text content)
	 * @return {node}            Created node
	 */
	function _createNode( doc, nodeName, opts ){
		var tempNode = doc.createElement( nodeName );
	
		if ( opts ) {
			if ( opts.attr ) {
				$(tempNode).attr( opts.attr );
			}
	
			if( opts.children ) {
				$.each( opts.children, function ( key, value ) {
					tempNode.appendChild( value );
				});
			}
	
			if( opts.text ) {
				tempNode.appendChild( doc.createTextNode( opts.text ) );
			}
		}
	
		return tempNode;
	}
	
	/**
	 * Get the width for an Excel column based on the contents of that column
	 * @param  {object} data Data for export
	 * @param  {int}    col  Column index
	 * @return {int}         Column width
	 */
	function _excelColWidth( data, col ) {
		var max = data.header[col].length;
		var len;
	
		if ( data.footer && data.footer[col].length > max ) {
			max = data.footer[col].length;
		}
	
		for ( var i=0, ien=data.body.length ; i<ien ; i++ ) {
			len = data.body[i][col].toString().length;
	
			if ( len > max ) {
				max = len;
			}
	
			// Max width rather than having potentially massive column widths
			if ( max > 40 ) {
				break;
			}
		}
	
		// And a min width
		return max > 5 ? max : 5;
	}
	
	try {
		var _serialiser = new XMLSerializer();
		var _ieExcel;
	}
	catch (t) {}
	
	/**
	 * Convert XML documents in an object to strings
	 * @param  {object} obj XLSX document object
	 */
	function _xlsxToStrings( obj ) {
		if ( _ieExcel === undefined ) {
			// Detect if we are dealing with IE's _awful_ serialiser by seeing if it
			// drop attributes
			_ieExcel = _serialiser
				.serializeToString(
					$.parseXML( excelStrings['xl/worksheets/sheet1.xml'] )
				)
				.indexOf( 'xmlns:r' ) === -1;
		}
	
		$.each( obj, function ( name, val ) {
			if ( $.isPlainObject( val ) ) {
				_xlsxToStrings( val );
			}
			else {
				if ( _ieExcel ) {
					// IE's XML serialiser will drop some name space attributes from
					// from the root node, so we need to save them. Do this by
					// replacing the namespace nodes with a regular attribute that
					// we convert back when serialised. Edge does not have this
					// issue
					var worksheet = val.childNodes[0];
					var i, ien;
					var attrs = [];
	
					for ( i=worksheet.attributes.length-1 ; i>=0 ; i-- ) {
						var attrName = worksheet.attributes[i].nodeName;
						var attrValue = worksheet.attributes[i].nodeValue;
	
						if ( attrName.indexOf( ':' ) !== -1 ) {
							attrs.push( { name: attrName, value: attrValue } );
	
							worksheet.removeAttribute( attrName );
						}
					}
	
					for ( i=0, ien=attrs.length ; i<ien ; i++ ) {
						var attr = val.createAttribute( attrs[i].name.replace( ':', '_dt_b_namespace_token_' ) );
						attr.value = attrs[i].value;
						worksheet.setAttributeNode( attr );
					}
				}
	
				var str = _serialiser.serializeToString(val);
	
				// Fix IE's XML
				if ( _ieExcel ) {
					// IE doesn't include the XML declaration
					if ( str.indexOf( '<?xml' ) === -1 ) {
						str = '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>'+str;
					}
	
					// Return namespace attributes to being as such
					str = str.replace( /_dt_b_namespace_token_/g, ':' );
				}
	
				// Both IE and Edge will put empty name space attributes onto the
				// rows and columns making them useless
				str = str
					.replace( /<row xmlns="" /g, '<row ' )
					.replace( /<cols xmlns="">/g, '<cols>' );
	
				obj[ name ] = str;
			}
		} );
	}
	
	// Excel - Pre-defined strings to build a basic XLSX file
	var excelStrings = {
		"_rels/.rels":
			'<?xml version="1.0" encoding="UTF-8" standalone="yes"?>'+
			'<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">'+
				'<Relationship Id="rId1" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument" Target="xl/workbook.xml"/>'+
			'</Relationships>',
	
		"xl/_rels/workbook.xml.rels":
			'<?xml version="1.0" encoding="UTF-8" standalone="yes"?>'+
			'<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">'+
				'<Relationship Id="rId1" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/worksheet" Target="worksheets/sheet1.xml"/>'+
				'<Relationship Id="rId2" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/styles" Target="styles.xml"/>'+
			'</Relationships>',
	
		"[Content_Types].xml":
			'<?xml version="1.0" encoding="UTF-8" standalone="yes"?>'+
			'<Types xmlns="http://schemas.openxmlformats.org/package/2006/content-types">'+
				'<Default Extension="xml" ContentType="application/xml" />'+
				'<Default Extension="rels" ContentType="application/vnd.openxmlformats-package.relationships+xml" />'+
				'<Default Extension="jpeg" ContentType="image/jpeg" />'+
				'<Override PartName="/xl/workbook.xml" ContentType="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml" />'+
				'<Override PartName="/xl/worksheets/sheet1.xml" ContentType="application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml" />'+
				'<Override PartName="/xl/styles.xml" ContentType="application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml" />'+
			'</Types>',
	
		"xl/workbook.xml":
			'<?xml version="1.0" encoding="UTF-8" standalone="yes"?>'+
			'<workbook xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main" xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships">'+
				'<fileVersion appName="xl" lastEdited="5" lowestEdited="5" rupBuild="24816"/>'+
				'<workbookPr showInkAnnotation="0" autoCompressPictures="0"/>'+
				'<bookViews>'+
					'<workbookView xWindow="0" yWindow="0" windowWidth="25600" windowHeight="19020" tabRatio="500"/>'+
				'</bookViews>'+
				'<sheets>'+
					'<sheet name="" sheetId="1" r:id="rId1"/>'+
				'</sheets>'+
			'</workbook>',
	
		"xl/worksheets/sheet1.xml":
			'<?xml version="1.0" encoding="UTF-8" standalone="yes"?>'+
			'<worksheet xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main" xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships" xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" mc:Ignorable="x14ac" xmlns:x14ac="http://schemas.microsoft.com/office/spreadsheetml/2009/9/ac">'+
				'<sheetData/>'+
			'</worksheet>',
	
		"xl/styles.xml":
			'<?xml version="1.0" encoding="UTF-8"?>'+
			'<styleSheet xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main" xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" mc:Ignorable="x14ac" xmlns:x14ac="http://schemas.microsoft.com/office/spreadsheetml/2009/9/ac">'+
				'<fonts count="5" x14ac:knownFonts="1">'+
					'<font>'+
						'<sz val="11" />'+
						'<name val="Calibri" />'+
					'</font>'+
					'<font>'+
						'<sz val="11" />'+
						'<name val="Calibri" />'+
						'<color rgb="FFFFFFFF" />'+
					'</font>'+
					'<font>'+
						'<sz val="11" />'+
						'<name val="Calibri" />'+
						'<b />'+
					'</font>'+
					'<font>'+
						'<sz val="11" />'+
						'<name val="Calibri" />'+
						'<i />'+
					'</font>'+
					'<font>'+
						'<sz val="11" />'+
						'<name val="Calibri" />'+
						'<u />'+
					'</font>'+
				'</fonts>'+
				'<fills count="6">'+
					'<fill>'+
						'<patternFill patternType="none" />'+
					'</fill>'+
					'<fill/>'+ // Excel appears to use this as a dotted background regardless of values
					'<fill>'+
						'<patternFill patternType="solid">'+
							'<fgColor rgb="FFD9D9D9" />'+
							'<bgColor indexed="64" />'+
						'</patternFill>'+
					'</fill>'+
					'<fill>'+
						'<patternFill patternType="solid">'+
							'<fgColor rgb="FFD99795" />'+
							'<bgColor indexed="64" />'+
						'</patternFill>'+
					'</fill>'+
					'<fill>'+
						'<patternFill patternType="solid">'+
							'<fgColor rgb="ffc6efce" />'+
							'<bgColor indexed="64" />'+
						'</patternFill>'+
					'</fill>'+
					'<fill>'+
						'<patternFill patternType="solid">'+
							'<fgColor rgb="ffc6cfef" />'+
							'<bgColor indexed="64" />'+
						'</patternFill>'+
					'</fill>'+
				'</fills>'+
				'<borders count="2">'+
					'<border>'+
						'<left />'+
						'<right />'+
						'<top />'+
						'<bottom />'+
						'<diagonal />'+
					'</border>'+
					'<border diagonalUp="false" diagonalDown="false">'+
						'<left style="thin">'+
							'<color auto="1" />'+
						'</left>'+
						'<right style="thin">'+
							'<color auto="1" />'+
						'</right>'+
						'<top style="thin">'+
							'<color auto="1" />'+
						'</top>'+
						'<bottom style="thin">'+
							'<color auto="1" />'+
						'</bottom>'+
						'<diagonal />'+
					'</border>'+
				'</borders>'+
				'<cellStyleXfs count="1">'+
					'<xf numFmtId="0" fontId="0" fillId="0" borderId="0" />'+
				'</cellStyleXfs>'+
				'<cellXfs count="56">'+
					'<xf numFmtId="0" fontId="0" fillId="0" borderId="0" applyFont="1" applyFill="1" applyBorder="1"/>'+
					'<xf numFmtId="0" fontId="1" fillId="0" borderId="0" applyFont="1" applyFill="1" applyBorder="1"/>'+
					'<xf numFmtId="0" fontId="2" fillId="0" borderId="0" applyFont="1" applyFill="1" applyBorder="1"/>'+
					'<xf numFmtId="0" fontId="3" fillId="0" borderId="0" applyFont="1" applyFill="1" applyBorder="1"/>'+
					'<xf numFmtId="0" fontId="4" fillId="0" borderId="0" applyFont="1" applyFill="1" applyBorder="1"/>'+
					'<xf numFmtId="0" fontId="0" fillId="2" borderId="0" applyFont="1" applyFill="1" applyBorder="1"/>'+
					'<xf numFmtId="0" fontId="1" fillId="2" borderId="0" applyFont="1" applyFill="1" applyBorder="1"/>'+
					'<xf numFmtId="0" fontId="2" fillId="2" borderId="0" applyFont="1" applyFill="1" applyBorder="1"/>'+
					'<xf numFmtId="0" fontId="3" fillId="2" borderId="0" applyFont="1" applyFill="1" applyBorder="1"/>'+
					'<xf numFmtId="0" fontId="4" fillId="2" borderId="0" applyFont="1" applyFill="1" applyBorder="1"/>'+
					'<xf numFmtId="0" fontId="0" fillId="4" borderId="0" applyFont="1" applyFill="1" applyBorder="1"/>'+
					'<xf numFmtId="0" fontId="1" fillId="4" borderId="0" applyFont="1" applyFill="1" applyBorder="1"/>'+
					'<xf numFmtId="0" fontId="2" fillId="4" borderId="0" applyFont="1" applyFill="1" applyBorder="1"/>'+
					'<xf numFmtId="0" fontId="3" fillId="4" borderId="0" applyFont="1" applyFill="1" applyBorder="1"/>'+
					'<xf numFmtId="0" fontId="4" fillId="4" borderId="0" applyFont="1" applyFill="1" applyBorder="1"/>'+
					'<xf numFmtId="0" fontId="0" fillId="4" borderId="0" applyFont="1" applyFill="1" applyBorder="1"/>'+
					'<xf numFmtId="0" fontId="1" fillId="4" borderId="0" applyFont="1" applyFill="1" applyBorder="1"/>'+
					'<xf numFmtId="0" fontId="2" fillId="4" borderId="0" applyFont="1" applyFill="1" applyBorder="1"/>'+
					'<xf numFmtId="0" fontId="3" fillId="4" borderId="0" applyFont="1" applyFill="1" applyBorder="1"/>'+
					'<xf numFmtId="0" fontId="4" fillId="4" borderId="0" applyFont="1" applyFill="1" applyBorder="1"/>'+
					'<xf numFmtId="0" fontId="0" fillId="5" borderId="0" applyFont="1" applyFill="1" applyBorder="1"/>'+
					'<xf numFmtId="0" fontId="1" fillId="5" borderId="0" applyFont="1" applyFill="1" applyBorder="1"/>'+
					'<xf numFmtId="0" fontId="2" fillId="5" borderId="0" applyFont="1" applyFill="1" applyBorder="1"/>'+
					'<xf numFmtId="0" fontId="3" fillId="5" borderId="0" applyFont="1" applyFill="1" applyBorder="1"/>'+
					'<xf numFmtId="0" fontId="4" fillId="5" borderId="0" applyFont="1" applyFill="1" applyBorder="1"/>'+
					'<xf numFmtId="0" fontId="0" fillId="0" borderId="1" applyFont="1" applyFill="1" applyBorder="1"/>'+
					'<xf numFmtId="0" fontId="1" fillId="0" borderId="1" applyFont="1" applyFill="1" applyBorder="1"/>'+
					'<xf numFmtId="0" fontId="2" fillId="0" borderId="1" applyFont="1" applyFill="1" applyBorder="1"/>'+
					'<xf numFmtId="0" fontId="3" fillId="0" borderId="1" applyFont="1" applyFill="1" applyBorder="1"/>'+
					'<xf numFmtId="0" fontId="4" fillId="0" borderId="1" applyFont="1" applyFill="1" applyBorder="1"/>'+
					'<xf numFmtId="0" fontId="0" fillId="2" borderId="1" applyFont="1" applyFill="1" applyBorder="1"/>'+
					'<xf numFmtId="0" fontId="1" fillId="2" borderId="1" applyFont="1" applyFill="1" applyBorder="1"/>'+
					'<xf numFmtId="0" fontId="2" fillId="2" borderId="1" applyFont="1" applyFill="1" applyBorder="1"/>'+
					'<xf numFmtId="0" fontId="3" fillId="2" borderId="1" applyFont="1" applyFill="1" applyBorder="1"/>'+
					'<xf numFmtId="0" fontId="4" fillId="2" borderId="1" applyFont="1" applyFill="1" applyBorder="1"/>'+
					'<xf numFmtId="0" fontId="0" fillId="3" borderId="1" applyFont="1" applyFill="1" applyBorder="1"/>'+
					'<xf numFmtId="0" fontId="1" fillId="3" borderId="1" applyFont="1" applyFill="1" applyBorder="1"/>'+
					'<xf numFmtId="0" fontId="2" fillId="3" borderId="1" applyFont="1" applyFill="1" applyBorder="1"/>'+
					'<xf numFmtId="0" fontId="3" fillId="3" borderId="1" applyFont="1" applyFill="1" applyBorder="1"/>'+
					'<xf numFmtId="0" fontId="4" fillId="3" borderId="1" applyFont="1" applyFill="1" applyBorder="1"/>'+
					'<xf numFmtId="0" fontId="0" fillId="4" borderId="1" applyFont="1" applyFill="1" applyBorder="1"/>'+
					'<xf numFmtId="0" fontId="1" fillId="4" borderId="1" applyFont="1" applyFill="1" applyBorder="1"/>'+
					'<xf numFmtId="0" fontId="2" fillId="4" borderId="1" applyFont="1" applyFill="1" applyBorder="1"/>'+
					'<xf numFmtId="0" fontId="3" fillId="4" borderId="1" applyFont="1" applyFill="1" applyBorder="1"/>'+
					'<xf numFmtId="0" fontId="4" fillId="4" borderId="1" applyFont="1" applyFill="1" applyBorder="1"/>'+
					'<xf numFmtId="0" fontId="0" fillId="5" borderId="1" applyFont="1" applyFill="1" applyBorder="1"/>'+
					'<xf numFmtId="0" fontId="1" fillId="5" borderId="1" applyFont="1" applyFill="1" applyBorder="1"/>'+
					'<xf numFmtId="0" fontId="2" fillId="5" borderId="1" applyFont="1" applyFill="1" applyBorder="1"/>'+
					'<xf numFmtId="0" fontId="3" fillId="5" borderId="1" applyFont="1" applyFill="1" applyBorder="1"/>'+
					'<xf numFmtId="0" fontId="4" fillId="5" borderId="1" applyFont="1" applyFill="1" applyBorder="1"/>'+
					'<xf numFmtId="0" fontId="0" fillId="0" borderId="0" applyFont="1" applyFill="1" applyBorder="1" xfId="0" applyAlignment="1">'+
						'<alignment horizontal="left"/>'+
					'</xf>'+
					'<xf numFmtId="0" fontId="0" fillId="0" borderId="0" applyFont="1" applyFill="1" applyBorder="1" xfId="0" applyAlignment="1">'+
						'<alignment horizontal="center"/>'+
					'</xf>'+
					'<xf numFmtId="0" fontId="0" fillId="0" borderId="0" applyFont="1" applyFill="1" applyBorder="1" xfId="0" applyAlignment="1">'+
						'<alignment horizontal="right"/>'+
					'</xf>'+
					'<xf numFmtId="0" fontId="0" fillId="0" borderId="0" applyFont="1" applyFill="1" applyBorder="1" xfId="0" applyAlignment="1">'+
						'<alignment horizontal="fill"/>'+
					'</xf>'+
					'<xf numFmtId="0" fontId="0" fillId="0" borderId="0" applyFont="1" applyFill="1" applyBorder="1" xfId="0" applyAlignment="1">'+
						'<alignment textRotation="90"/>'+
					'</xf>'+
					'<xf numFmtId="0" fontId="0" fillId="0" borderId="0" applyFont="1" applyFill="1" applyBorder="1" xfId="0" applyAlignment="1">'+
						'<alignment wrapText="1"/>'+
					'</xf>'+
				'</cellXfs>'+
				'<cellStyles count="1">'+
					'<cellStyle name="Normal" xfId="0" builtinId="0" />'+
				'</cellStyles>'+
				'<dxfs count="0" />'+
				'<tableStyles count="0" defaultTableStyle="TableStyleMedium9" defaultPivotStyle="PivotStyleMedium4" />'+
			'</styleSheet>'
	};
	// Note we could use 3 `for` loops for the styles, but when gzipped there is
	// virtually no difference in size, since the above can be easily compressed
	
	
	
	/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	 * DataTables options and methods
	 */
	
	// Set the default SWF path
	DataTable.Buttons.swfPath = '//cdn.datatables.net/buttons/1.2.0/swf/flashExport.swf';
	
	// Method to allow Flash buttons to be resized when made visible - as they are
	// of zero height and width if initialised hidden
	DataTable.Api.register( 'buttons.resize()', function () {
		$.each( ZeroClipboard_TableTools.clients, function ( i, client ) {
			if ( client.domElement !== undefined && client.domElement.parentNode ) {
				client.positionElement();
			}
		} );
	} );
	
	
	/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	 * Button definitions
	 */
	
	// Copy to clipboard
	DataTable.ext.buttons.copyFlash = $.extend( {}, flashButton, {
		className: 'buttons-copy buttons-flash',
	
		text: function ( dt ) {
			return dt.i18n( 'buttons.copy', 'Copy' );
		},
	
		action: function ( e, dt, button, config ) {
			// Check that the trigger did actually occur due to a Flash activation
			if ( ! config._fromFlash ) {
				return;
			}
	
			var flash = config._flash;
			var data = _exportData( dt, config );
			var output = config.customize ?
				config.customize( data.str, config ) :
				data.str;
	
			flash.setAction( 'copy' );
			_setText( flash, output );
	
			dt.buttons.info(
				dt.i18n( 'buttons.copyTitle', 'Copy to clipboard' ),
				dt.i18n( 'buttons.copySuccess', {
					_: 'Copied %d rows to clipboard',
					1: 'Copied 1 row to clipboard'
				}, data.rows ),
				3000
			);
		},
	
		fieldSeparator: '\t',
	
		fieldBoundary: ''
	} );
	
	// CSV save file
	DataTable.ext.buttons.csvFlash = $.extend( {}, flashButton, {
		className: 'buttons-csv buttons-flash',
	
		text: function ( dt ) {
			return dt.i18n( 'buttons.csv', 'CSV' );
		},
	
		action: function ( e, dt, button, config ) {
			// Set the text
			var flash = config._flash;
			var data = _exportData( dt, config );
			var output = config.customize ?
				config.customize( data.str, config ) :
				data.str;
	
			flash.setAction( 'csv' );
			flash.setFileName( _filename( config ) );
			_setText( flash, output );
		},
	
		escapeChar: '"'
	} );
	
	// Excel save file - this is really a CSV file using UTF-8 that Excel can read
	DataTable.ext.buttons.excelFlash = $.extend( {}, flashButton, {
		className: 'buttons-excel buttons-flash',
	
		text: function ( dt ) {
			return dt.i18n( 'buttons.excel', 'Excel' );
		},
	
		action: function ( e, dt, button, config ) {
			var flash = config._flash;
			var rowPos = 0;
			var rels = $.parseXML( excelStrings['xl/worksheets/sheet1.xml'] ) ; //Parses xml
			var relsGet = rels.getElementsByTagName( "sheetData" )[0];
	
			var xlsx = {
				_rels: {
					".rels": $.parseXML( excelStrings['_rels/.rels'] )
				},
				xl: {
					_rels: {
						"workbook.xml.rels": $.parseXML( excelStrings['xl/_rels/workbook.xml.rels'] )
					},
					"workbook.xml": $.parseXML( excelStrings['xl/workbook.xml'] ),
					"styles.xml": $.parseXML( excelStrings['xl/styles.xml'] ),
					"worksheets": {
						"sheet1.xml": rels
					}
	
				},
				"[Content_Types].xml": $.parseXML( excelStrings['[Content_Types].xml'])
			};
	
			var data = dt.buttons.exportData( config.exportOptions );
			var currentRow, rowNode;
			var addRow = function ( row ) {
				currentRow = rowPos+1;
				rowNode = _createNode( rels, "row", { attr: {r:currentRow} } );
	
				for ( var i=0, ien=row.length ; i<ien ; i++ ) {
					// Concat both the Cell Columns as a letter and the Row of the cell.
					var cellId = createCellPos(i) + '' + currentRow;
					var cell;
	
					if ( row[i] === null || row[i] === undefined ) {
						row[i] = '';
					}
	
					// Detect numbers - don't match numbers with leading zeros or a negative
					// anywhere but the start
					if ( typeof row[i] === 'number' || (
							row[i].match &&
							$.trim(row[i]).match(/^-?\d+(\.\d+)?$/) &&
							! $.trim(row[i]).match(/^0\d+/) )
					) {
						cell = _createNode( rels, 'c', {
							attr: {
								t: 'n',
								r: cellId
							},
							children: [
								_createNode( rels, 'v', { text: row[i] } )
							]
						} );
					}
					else {
						// Replace non standard characters for text output
						var text = ! row[i].replace ?
							row[i] :
							row[i].replace(/[\x00-\x09\x0B\x0C\x0E-\x1F\x7F-\x9F]/g, '');
	
						cell = _createNode( rels, 'c', {
							attr: {
								t: 'inlineStr',
								r: cellId
							},
							children:{
								row: _createNode( rels, 'is', {
									children: {
										row: _createNode( rels, 't', {
											text: text
										} )
									}
								} )
							}
						} );
					}
	
					rowNode.appendChild( cell );
				}
				relsGet.appendChild(rowNode);
				rowPos++;
			};
	
			$( 'sheets sheet', xlsx.xl['workbook.xml'] ).attr( 'name', _sheetname( config ) );
	
			if ( config.customizeData ) {
				config.customizeData( data );
			}
	
			if ( config.header ) {
				addRow( data.header, rowPos );
				$('row c', rels).attr( 's', '2' ); // bold
			}
	
			for ( var n=0, ie=data.body.length ; n<ie ; n++ ) {
				addRow( data.body[n], rowPos );
			}
	
			if ( config.footer && data.footer ) {
				addRow( data.footer, rowPos);
				$('row:last c', rels).attr( 's', '2' ); // bold
			}
	
			// Set column widths
			var cols = _createNode( rels, 'cols' );
			$('worksheet', rels).prepend( cols );
	
			for ( var i=0, ien=data.header.length ; i<ien ; i++ ) {
				cols.appendChild( _createNode( rels, 'col', {
					attr: {
						min: i+1,
						max: i+1,
						width: _excelColWidth( data, i ),
						customWidth: 1
					}
				} ) );
			}
	
			// Let the developer customise the document if they want to
			if ( config.customize ) {
				config.customize( xlsx );
			}
	
			_xlsxToStrings( xlsx );
	
			flash.setAction( 'excel' );
			flash.setFileName( _filename( config ) );
			flash.setSheetData( xlsx );
			_setText( flash, '' );
		},
	
		extension: '.xlsx'
	} );
	
	
	
	// PDF export
	DataTable.ext.buttons.pdfFlash = $.extend( {}, flashButton, {
		className: 'buttons-pdf buttons-flash',
	
		text: function ( dt ) {
			return dt.i18n( 'buttons.pdf', 'PDF' );
		},
	
		action: function ( e, dt, button, config ) {
			// Set the text
			var flash = config._flash;
			var data = dt.buttons.exportData( config.exportOptions );
			var totalWidth = dt.table().node().offsetWidth;
	
			// Calculate the column width ratios for layout of the table in the PDF
			var ratios = dt.columns( config.columns ).indexes().map( function ( idx ) {
				return dt.column( idx ).header().offsetWidth / totalWidth;
			} );
	
			flash.setAction( 'pdf' );
			flash.setFileName( _filename( config ) );
	
			_setText( flash, JSON.stringify( {
				title:       _filename(config, false),
				message: typeof config.message == 'function' ? config.message(dt, button, config) : config.message,
				colWidth:    ratios.toArray(),
				orientation: config.orientation,
				size:        config.pageSize,
				header:      config.header ? data.header : null,
				footer:      config.footer ? data.footer : null,
				body:        data.body
			} ) );
		},
	
		extension: '.pdf',
	
		orientation: 'portrait',
	
		pageSize: 'A4',
	
		message: '',
	
		newline: '\n'
	} );
	
	
	return DataTable.Buttons;
	}));


/***/ },
/* 21 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*! Bootstrap integration for DataTables' Buttons
	 * Â©2016 SpryMedia Ltd - datatables.net/license
	 */
	
	(function( factory ){
		if ( true ) {
			// AMD
			!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(1), __webpack_require__(22), __webpack_require__(17)], __WEBPACK_AMD_DEFINE_RESULT__ = function ( $ ) {
				return factory( $, window, document );
			}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
		}
		else if ( typeof exports === 'object' ) {
			// CommonJS
			module.exports = function (root, $) {
				if ( ! root ) {
					root = window;
				}
	
				if ( ! $ || ! $.fn.dataTable ) {
					$ = require('datatables.net-bs')(root, $).$;
				}
	
				if ( ! $.fn.dataTable.Buttons ) {
					require('datatables.net-buttons')(root, $);
				}
	
				return factory( $, root, root.document );
			};
		}
		else {
			// Browser
			factory( jQuery, window, document );
		}
	}(function( $, window, document, undefined ) {
	'use strict';
	var DataTable = $.fn.dataTable;
	
	
	$.extend( true, DataTable.Buttons.defaults, {
		dom: {
			container: {
				className: 'dt-buttons btn-group'
			},
			button: {
				className: 'btn btn-default'
			},
			collection: {
				tag: 'ul',
				className: 'dt-button-collection dropdown-menu',
				button: {
					tag: 'li',
					className: 'dt-button'
				},
				buttonLiner: {
					tag: 'a',
					className: ''
				}
			}
		}
	} );
	
	DataTable.ext.buttons.collection.text = function ( dt ) {
		return dt.i18n('buttons.collection', 'Collection <span class="caret"/>');
	};
	
	
	return DataTable.Buttons;
	}));


/***/ },
/* 22 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*! DataTables Bootstrap 3 integration
	 * Â©2011-2015 SpryMedia Ltd - datatables.net/license
	 */
	
	/**
	 * DataTables integration for Bootstrap 3. This requires Bootstrap 3 and
	 * DataTables 1.10 or newer.
	 *
	 * This file sets the defaults and adds options to DataTables to style its
	 * controls using Bootstrap. See http://datatables.net/manual/styling/bootstrap
	 * for further information.
	 */
	(function( factory ){
		if ( true ) {
			// AMD
			!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(1), __webpack_require__(4)], __WEBPACK_AMD_DEFINE_RESULT__ = function ( $ ) {
				return factory( $, window, document );
			}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
		}
		else if ( typeof exports === 'object' ) {
			// CommonJS
			module.exports = function (root, $) {
				if ( ! root ) {
					root = window;
				}
	
				if ( ! $ || ! $.fn.dataTable ) {
					// Require DataTables, which attaches to jQuery, including
					// jQuery if needed and have a $ property so we can access the
					// jQuery object that is used
					$ = require('datatables.net')(root, $).$;
				}
	
				return factory( $, root, root.document );
			};
		}
		else {
			// Browser
			factory( jQuery, window, document );
		}
	}(function( $, window, document, undefined ) {
	'use strict';
	var DataTable = $.fn.dataTable;
	
	
	/* Set the defaults for DataTables initialisation */
	$.extend( true, DataTable.defaults, {
		dom:
			"<'row'<'col-sm-6'l><'col-sm-6'f>>" +
			"<'row'<'col-sm-12'tr>>" +
			"<'row'<'col-sm-5'i><'col-sm-7'p>>",
		renderer: 'bootstrap'
	} );
	
	
	/* Default class modification */
	$.extend( DataTable.ext.classes, {
		sWrapper:      "dataTables_wrapper form-inline dt-bootstrap",
		sFilterInput:  "form-control input-sm",
		sLengthSelect: "form-control input-sm",
		sProcessing:   "dataTables_processing panel panel-default"
	} );
	
	
	/* Bootstrap paging button renderer */
	DataTable.ext.renderer.pageButton.bootstrap = function ( settings, host, idx, buttons, page, pages ) {
		var api     = new DataTable.Api( settings );
		var classes = settings.oClasses;
		var lang    = settings.oLanguage.oPaginate;
		var aria = settings.oLanguage.oAria.paginate || {};
		var btnDisplay, btnClass, counter=0;
	
		var attach = function( container, buttons ) {
			var i, ien, node, button;
			var clickHandler = function ( e ) {
				e.preventDefault();
				if ( !$(e.currentTarget).hasClass('disabled') && api.page() != e.data.action ) {
					api.page( e.data.action ).draw( 'page' );
				}
			};
	
			for ( i=0, ien=buttons.length ; i<ien ; i++ ) {
				button = buttons[i];
	
				if ( $.isArray( button ) ) {
					attach( container, button );
				}
				else {
					btnDisplay = '';
					btnClass = '';
	
					switch ( button ) {
						case 'ellipsis':
							btnDisplay = '&#x2026;';
							btnClass = 'disabled';
							break;
	
						case 'first':
							btnDisplay = lang.sFirst;
							btnClass = button + (page > 0 ?
								'' : ' disabled');
							break;
	
						case 'previous':
							btnDisplay = lang.sPrevious;
							btnClass = button + (page > 0 ?
								'' : ' disabled');
							break;
	
						case 'next':
							btnDisplay = lang.sNext;
							btnClass = button + (page < pages-1 ?
								'' : ' disabled');
							break;
	
						case 'last':
							btnDisplay = lang.sLast;
							btnClass = button + (page < pages-1 ?
								'' : ' disabled');
							break;
	
						default:
							btnDisplay = button + 1;
							btnClass = page === button ?
								'active' : '';
							break;
					}
	
					if ( btnDisplay ) {
						node = $('<li>', {
								'class': classes.sPageButton+' '+btnClass,
								'id': idx === 0 && typeof button === 'string' ?
									settings.sTableId +'_'+ button :
									null
							} )
							.append( $('<a>', {
									'href': '#',
									'aria-controls': settings.sTableId,
									'aria-label': aria[ button ],
									'data-dt-idx': counter,
									'tabindex': settings.iTabIndex
								} )
								.html( btnDisplay )
							)
							.appendTo( container );
	
						settings.oApi._fnBindAction(
							node, {action: button}, clickHandler
						);
	
						counter++;
					}
				}
			}
		};
	
		// IE9 throws an 'unknown error' if document.activeElement is used
		// inside an iframe or frame. 
		var activeEl;
	
		try {
			// Because this approach is destroying and recreating the paging
			// elements, focus is lost on the select button which is bad for
			// accessibility. So we want to restore focus once the draw has
			// completed
			activeEl = $(host).find(document.activeElement).data('dt-idx');
		}
		catch (e) {}
	
		attach(
			$(host).empty().html('<ul class="pagination"/>').children('ul'),
			buttons
		);
	
		if ( activeEl ) {
			$(host).find( '[data-dt-idx='+activeEl+']' ).focus();
		}
	};
	
	
	return DataTable;
	}));

/***/ },
/* 23 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(setImmediate) {/*** IMPORTS FROM imports-loader ***/
	(function() {
	
	// 4.3.13 (2016-06-08)
	
	/**
	 * Compiled inline version. (Library mode)
	 */
	
	/*jshint smarttabs:true, undef:true, latedef:true, curly:true, bitwise:true, camelcase:true */
	/*globals $code */
	
	(function(exports, undefined) {
		"use strict";
	
		var modules = {};
	
		function require(ids, callback) {
			var module, defs = [];
	
			for (var i = 0; i < ids.length; ++i) {
				module = modules[ids[i]] || resolve(ids[i]);
				if (!module) {
					throw 'module definition dependecy not found: ' + ids[i];
				}
	
				defs.push(module);
			}
	
			callback.apply(null, defs);
		}
	
		function define(id, dependencies, definition) {
			if (typeof id !== 'string') {
				throw 'invalid module definition, module id must be defined and be a string';
			}
	
			if (dependencies === undefined) {
				throw 'invalid module definition, dependencies must be specified';
			}
	
			if (definition === undefined) {
				throw 'invalid module definition, definition function must be specified';
			}
	
			require(dependencies, function() {
				modules[id] = definition.apply(null, arguments);
			});
		}
	
		function defined(id) {
			return !!modules[id];
		}
	
		function resolve(id) {
			var target = exports;
			var fragments = id.split(/[.\/]/);
	
			for (var fi = 0; fi < fragments.length; ++fi) {
				if (!target[fragments[fi]]) {
					return;
				}
	
				target = target[fragments[fi]];
			}
	
			return target;
		}
	
		function expose(ids) {
			var i, target, id, fragments, privateModules;
	
			for (i = 0; i < ids.length; i++) {
				target = exports;
				id = ids[i];
				fragments = id.split(/[.\/]/);
	
				for (var fi = 0; fi < fragments.length - 1; ++fi) {
					if (target[fragments[fi]] === undefined) {
						target[fragments[fi]] = {};
					}
	
					target = target[fragments[fi]];
				}
	
				target[fragments[fragments.length - 1]] = modules[id];
			}
			
			// Expose private modules for unit tests
			if (exports.AMDLC_TESTS) {
				privateModules = exports.privateModules || {};
	
				for (id in modules) {
					privateModules[id] = modules[id];
				}
	
				for (i = 0; i < ids.length; i++) {
					delete privateModules[ids[i]];
				}
	
				exports.privateModules = privateModules;
			}
		}
	
	// Included from: js/tinymce/classes/geom/Rect.js
	
	/**
	 * Rect.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * Contains various tools for rect/position calculation.
	 *
	 * @class tinymce.geom.Rect
	 */
	define("tinymce/geom/Rect", [
	], function() {
		"use strict";
	
		var min = Math.min, max = Math.max, round = Math.round;
	
		/**
		 * Returns the rect positioned based on the relative position name
		 * to the target rect.
		 *
		 * @method relativePosition
		 * @param {Rect} rect Source rect to modify into a new rect.
		 * @param {Rect} targetRect Rect to move relative to based on the rel option.
		 * @param {String} rel Relative position. For example: tr-bl.
		 */
		function relativePosition(rect, targetRect, rel) {
			var x, y, w, h, targetW, targetH;
	
			x = targetRect.x;
			y = targetRect.y;
			w = rect.w;
			h = rect.h;
			targetW = targetRect.w;
			targetH = targetRect.h;
	
			rel = (rel || '').split('');
	
			if (rel[0] === 'b') {
				y += targetH;
			}
	
			if (rel[1] === 'r') {
				x += targetW;
			}
	
			if (rel[0] === 'c') {
				y += round(targetH / 2);
			}
	
			if (rel[1] === 'c') {
				x += round(targetW / 2);
			}
	
			if (rel[3] === 'b') {
				y -= h;
			}
	
			if (rel[4] === 'r') {
				x -= w;
			}
	
			if (rel[3] === 'c') {
				y -= round(h / 2);
			}
	
			if (rel[4] === 'c') {
				x -= round(w / 2);
			}
	
			return create(x, y, w, h);
		}
	
		/**
		 * Tests various positions to get the most suitable one.
		 *
		 * @method findBestRelativePosition
		 * @param {Rect} rect Rect to use as source.
		 * @param {Rect} targetRect Rect to move relative to.
		 * @param {Rect} constrainRect Rect to constrain within.
		 * @param {Array} rels Array of relative positions to test against.
		 */
		function findBestRelativePosition(rect, targetRect, constrainRect, rels) {
			var pos, i;
	
			for (i = 0; i < rels.length; i++) {
				pos = relativePosition(rect, targetRect, rels[i]);
	
				if (pos.x >= constrainRect.x && pos.x + pos.w <= constrainRect.w + constrainRect.x &&
					pos.y >= constrainRect.y && pos.y + pos.h <= constrainRect.h + constrainRect.y) {
					return rels[i];
				}
			}
	
			return null;
		}
	
		/**
		 * Inflates the rect in all directions.
		 *
		 * @method inflate
		 * @param {Rect} rect Rect to expand.
		 * @param {Number} w Relative width to expand by.
		 * @param {Number} h Relative height to expand by.
		 * @return {Rect} New expanded rect.
		 */
		function inflate(rect, w, h) {
			return create(rect.x - w, rect.y - h, rect.w + w * 2, rect.h + h * 2);
		}
	
		/**
		 * Returns the intersection of the specified rectangles.
		 *
		 * @method intersect
		 * @param {Rect} rect The first rectangle to compare.
		 * @param {Rect} cropRect The second rectangle to compare.
		 * @return {Rect} The intersection of the two rectangles or null if they don't intersect.
		 */
		function intersect(rect, cropRect) {
			var x1, y1, x2, y2;
	
			x1 = max(rect.x, cropRect.x);
			y1 = max(rect.y, cropRect.y);
			x2 = min(rect.x + rect.w, cropRect.x + cropRect.w);
			y2 = min(rect.y + rect.h, cropRect.y + cropRect.h);
	
			if (x2 - x1 < 0 || y2 - y1 < 0) {
				return null;
			}
	
			return create(x1, y1, x2 - x1, y2 - y1);
		}
	
		/**
		 * Returns a rect clamped within the specified clamp rect. This forces the
		 * rect to be inside the clamp rect.
		 *
		 * @method clamp
		 * @param {Rect} rect Rectangle to force within clamp rect.
		 * @param {Rect} clampRect Rectable to force within.
		 * @param {Boolean} fixedSize True/false if size should be fixed.
		 * @return {Rect} Clamped rect.
		 */
		function clamp(rect, clampRect, fixedSize) {
			var underflowX1, underflowY1, overflowX2, overflowY2,
				x1, y1, x2, y2, cx2, cy2;
	
			x1 = rect.x;
			y1 = rect.y;
			x2 = rect.x + rect.w;
			y2 = rect.y + rect.h;
			cx2 = clampRect.x + clampRect.w;
			cy2 = clampRect.y + clampRect.h;
	
			underflowX1 = max(0, clampRect.x - x1);
			underflowY1 = max(0, clampRect.y - y1);
			overflowX2 = max(0, x2 - cx2);
			overflowY2 = max(0, y2 - cy2);
	
			x1 += underflowX1;
			y1 += underflowY1;
	
			if (fixedSize) {
				x2 += underflowX1;
				y2 += underflowY1;
				x1 -= overflowX2;
				y1 -= overflowY2;
			}
	
			x2 -= overflowX2;
			y2 -= overflowY2;
	
			return create(x1, y1, x2 - x1, y2 - y1);
		}
	
		/**
		 * Creates a new rectangle object.
		 *
		 * @method create
		 * @param {Number} x Rectangle x location.
		 * @param {Number} y Rectangle y location.
		 * @param {Number} w Rectangle width.
		 * @param {Number} h Rectangle height.
		 * @return {Rect} New rectangle object.
		 */
		function create(x, y, w, h) {
			return {x: x, y: y, w: w, h: h};
		}
	
		/**
		 * Creates a new rectangle object form a clientRects object.
		 *
		 * @method fromClientRect
		 * @param {ClientRect} clientRect DOM ClientRect object.
		 * @return {Rect} New rectangle object.
		 */
		function fromClientRect(clientRect) {
			return create(clientRect.left, clientRect.top, clientRect.width, clientRect.height);
		}
	
		return {
			inflate: inflate,
			relativePosition: relativePosition,
			findBestRelativePosition: findBestRelativePosition,
			intersect: intersect,
			clamp: clamp,
			create: create,
			fromClientRect: fromClientRect
		};
	});
	
	// Included from: js/tinymce/classes/util/Promise.js
	
	/**
	 * Promise.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * Promise polyfill under MIT license: https://github.com/taylorhakes/promise-polyfill
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/* eslint-disable */
	/* jshint ignore:start */
	
	/**
	 * Modifed to be a feature fill and wrapped as tinymce module.
	 */
	define("tinymce/util/Promise", [], function() {
		if (window.Promise) {
			return window.Promise;
		}
	
		// Use polyfill for setImmediate for performance gains
		var asap = Promise.immediateFn || (typeof setImmediate === 'function' && setImmediate) ||
			function(fn) { setTimeout(fn, 1); };
	
		// Polyfill for Function.prototype.bind
		function bind(fn, thisArg) {
			return function() {
				fn.apply(thisArg, arguments);
			};
		}
	
		var isArray = Array.isArray || function(value) { return Object.prototype.toString.call(value) === "[object Array]"; };
	
		function Promise(fn) {
			if (typeof this !== 'object') throw new TypeError('Promises must be constructed via new');
			if (typeof fn !== 'function') throw new TypeError('not a function');
			this._state = null;
			this._value = null;
			this._deferreds = [];
	
			doResolve(fn, bind(resolve, this), bind(reject, this));
		}
	
		function handle(deferred) {
			var me = this;
			if (this._state === null) {
				this._deferreds.push(deferred);
				return;
			}
			asap(function() {
				var cb = me._state ? deferred.onFulfilled : deferred.onRejected;
				if (cb === null) {
					(me._state ? deferred.resolve : deferred.reject)(me._value);
					return;
				}
				var ret;
				try {
					ret = cb(me._value);
				}
				catch (e) {
					deferred.reject(e);
					return;
				}
				deferred.resolve(ret);
			});
		}
	
		function resolve(newValue) {
			try { //Promise Resolution Procedure: https://github.com/promises-aplus/promises-spec#the-promise-resolution-procedure
				if (newValue === this) throw new TypeError('A promise cannot be resolved with itself.');
				if (newValue && (typeof newValue === 'object' || typeof newValue === 'function')) {
					var then = newValue.then;
					if (typeof then === 'function') {
						doResolve(bind(then, newValue), bind(resolve, this), bind(reject, this));
						return;
					}
				}
				this._state = true;
				this._value = newValue;
				finale.call(this);
			} catch (e) { reject.call(this, e); }
		}
	
		function reject(newValue) {
			this._state = false;
			this._value = newValue;
			finale.call(this);
		}
	
		function finale() {
			for (var i = 0, len = this._deferreds.length; i < len; i++) {
				handle.call(this, this._deferreds[i]);
			}
			this._deferreds = null;
		}
	
		function Handler(onFulfilled, onRejected, resolve, reject){
			this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;
			this.onRejected = typeof onRejected === 'function' ? onRejected : null;
			this.resolve = resolve;
			this.reject = reject;
		}
	
		/**
		 * Take a potentially misbehaving resolver function and make sure
		 * onFulfilled and onRejected are only called once.
		 *
		 * Makes no guarantees about asynchrony.
		 */
		function doResolve(fn, onFulfilled, onRejected) {
			var done = false;
			try {
				fn(function (value) {
					if (done) return;
					done = true;
					onFulfilled(value);
				}, function (reason) {
					if (done) return;
					done = true;
					onRejected(reason);
				});
			} catch (ex) {
				if (done) return;
				done = true;
				onRejected(ex);
			}
		}
	
		Promise.prototype['catch'] = function (onRejected) {
			return this.then(null, onRejected);
		};
	
		Promise.prototype.then = function(onFulfilled, onRejected) {
			var me = this;
			return new Promise(function(resolve, reject) {
				handle.call(me, new Handler(onFulfilled, onRejected, resolve, reject));
			});
		};
	
		Promise.all = function () {
			var args = Array.prototype.slice.call(arguments.length === 1 && isArray(arguments[0]) ? arguments[0] : arguments);
	
			return new Promise(function (resolve, reject) {
				if (args.length === 0) return resolve([]);
				var remaining = args.length;
				function res(i, val) {
					try {
						if (val && (typeof val === 'object' || typeof val === 'function')) {
							var then = val.then;
							if (typeof then === 'function') {
								then.call(val, function (val) { res(i, val); }, reject);
								return;
							}
						}
						args[i] = val;
						if (--remaining === 0) {
							resolve(args);
						}
					} catch (ex) {
						reject(ex);
					}
				}
				for (var i = 0; i < args.length; i++) {
					res(i, args[i]);
				}
			});
		};
	
		Promise.resolve = function (value) {
			if (value && typeof value === 'object' && value.constructor === Promise) {
				return value;
			}
	
			return new Promise(function (resolve) {
				resolve(value);
			});
		};
	
		Promise.reject = function (value) {
			return new Promise(function (resolve, reject) {
				reject(value);
			});
		};
	
		Promise.race = function (values) {
			return new Promise(function (resolve, reject) {
				for(var i = 0, len = values.length; i < len; i++) {
					values[i].then(resolve, reject);
				}
			});
		};
	
		return Promise;
	});
	
	/* jshint ignore:end */
	/* eslint-enable */
	
	// Included from: js/tinymce/classes/util/Delay.js
	
	/**
	 * Delay.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * Utility class for working with delayed actions like setTimeout.
	 *
	 * @class tinymce.util.Delay
	 */
	define("tinymce/util/Delay", [
		"tinymce/util/Promise"
	], function(Promise) {
		var requestAnimationFramePromise;
	
		function requestAnimationFrame(callback, element) {
			var i, requestAnimationFrameFunc = window.requestAnimationFrame, vendors = ['ms', 'moz', 'webkit'];
	
			function featurefill(callback) {
				window.setTimeout(callback, 0);
			}
	
			for (i = 0; i < vendors.length && !requestAnimationFrameFunc; i++) {
				requestAnimationFrameFunc = window[vendors[i] + 'RequestAnimationFrame'];
			}
	
			if (!requestAnimationFrameFunc) {
				requestAnimationFrameFunc = featurefill;
			}
	
			requestAnimationFrameFunc(callback, element);
		}
	
		function wrappedSetTimeout(callback, time) {
			if (typeof time != 'number') {
				time = 0;
			}
	
			return setTimeout(callback, time);
		}
	
		function wrappedSetInterval(callback, time) {
			if (typeof time != 'number') {
				time = 0;
			}
	
			return setInterval(callback, time);
		}
	
		function wrappedClearTimeout(id) {
			return clearTimeout(id);
		}
	
		function wrappedClearInterval(id) {
			return clearInterval(id);
		}
	
		return {
			/**
			 * Requests an animation frame and fallbacks to a timeout on older browsers.
			 *
			 * @method requestAnimationFrame
			 * @param {function} callback Callback to execute when a new frame is available.
			 * @param {DOMElement} element Optional element to scope it to.
			 */
			requestAnimationFrame: function(callback, element) {
				if (requestAnimationFramePromise) {
					requestAnimationFramePromise.then(callback);
					return;
				}
	
				requestAnimationFramePromise = new Promise(function(resolve) {
					if (!element) {
						element = document.body;
					}
	
					requestAnimationFrame(resolve, element);
				}).then(callback);
			},
	
			/**
			 * Sets a timer in ms and executes the specified callback when the timer runs out.
			 *
			 * @method setTimeout
			 * @param {function} callback Callback to execute when timer runs out.
			 * @param {Number} time Optional time to wait before the callback is executed, defaults to 0.
			 * @return {Number} Timeout id number.
			 */
			setTimeout: wrappedSetTimeout,
	
			/**
			 * Sets an interval timer in ms and executes the specified callback at every interval of that time.
			 *
			 * @method setInterval
			 * @param {function} callback Callback to execute when interval time runs out.
			 * @param {Number} time Optional time to wait before the callback is executed, defaults to 0.
			 * @return {Number} Timeout id number.
			 */
			setInterval: wrappedSetInterval,
	
			/**
			 * Sets an editor timeout it's similar to setTimeout except that it checks if the editor instance is
			 * still alive when the callback gets executed.
			 *
			 * @method setEditorTimeout
			 * @param {tinymce.Editor} editor Editor instance to check the removed state on.
			 * @param {function} callback Callback to execute when timer runs out.
			 * @param {Number} time Optional time to wait before the callback is executed, defaults to 0.
			 * @return {Number} Timeout id number.
			 */
			setEditorTimeout: function(editor, callback, time) {
				return wrappedSetTimeout(function() {
					if (!editor.removed) {
						callback();
					}
				}, time);
			},
	
			/**
			 * Sets an interval timer it's similar to setInterval except that it checks if the editor instance is
			 * still alive when the callback gets executed.
			 *
			 * @method setEditorInterval
			 * @param {function} callback Callback to execute when interval time runs out.
			 * @param {Number} time Optional time to wait before the callback is executed, defaults to 0.
			 * @return {Number} Timeout id number.
			 */
			setEditorInterval: function(editor, callback, time) {
				var timer;
	
				timer = wrappedSetInterval(function() {
					if (!editor.removed) {
						callback();
					} else {
						clearInterval(timer);
					}
				}, time);
	
				return timer;
			},
	
			/**
			 * Creates throttled callback function that only gets executed once within the specified time.
			 *
			 * @method throttle
			 * @param {function} callback Callback to execute when timer finishes.
			 * @param {Number} time Optional time to wait before the callback is executed, defaults to 0.
			 * @return {Function} Throttled function callback.
			 */
			throttle: function(callback, time) {
				var timer, func;
	
				func = function() {
					var args = arguments;
	
					clearTimeout(timer);
	
					timer = wrappedSetTimeout(function() {
						callback.apply(this, args);
					}, time);
				};
	
				func.stop = function() {
					clearTimeout(timer);
				};
	
				return func;
			},
	
			/**
			 * Clears an interval timer so it won't execute.
			 *
			 * @method clearInterval
			 * @param {Number} Interval timer id number.
			 */
			clearInterval: wrappedClearInterval,
	
			/**
			 * Clears an timeout timer so it won't execute.
			 *
			 * @method clearTimeout
			 * @param {Number} Timeout timer id number.
			 */
			clearTimeout: wrappedClearTimeout
		};
	});
	
	// Included from: js/tinymce/classes/Env.js
	
	/**
	 * Env.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * This class contains various environment constants like browser versions etc.
	 * Normally you don't want to sniff specific browser versions but sometimes you have
	 * to when it's impossible to feature detect. So use this with care.
	 *
	 * @class tinymce.Env
	 * @static
	 */
	define("tinymce/Env", [], function() {
		var nav = navigator, userAgent = nav.userAgent;
		var opera, webkit, ie, ie11, ie12, gecko, mac, iDevice, android, fileApi, phone, tablet, windowsPhone;
	
		function matchMediaQuery(query) {
			return "matchMedia" in window ? matchMedia(query).matches : false;
		}
	
		opera = window.opera && window.opera.buildNumber;
		android = /Android/.test(userAgent);
		webkit = /WebKit/.test(userAgent);
		ie = !webkit && !opera && (/MSIE/gi).test(userAgent) && (/Explorer/gi).test(nav.appName);
		ie = ie && /MSIE (\w+)\./.exec(userAgent)[1];
		ie11 = userAgent.indexOf('Trident/') != -1 && (userAgent.indexOf('rv:') != -1 || nav.appName.indexOf('Netscape') != -1) ? 11 : false;
		ie12 = (userAgent.indexOf('Edge/') != -1 && !ie && !ie11) ? 12 : false;
		ie = ie || ie11 || ie12;
		gecko = !webkit && !ie11 && /Gecko/.test(userAgent);
		mac = userAgent.indexOf('Mac') != -1;
		iDevice = /(iPad|iPhone)/.test(userAgent);
		fileApi = "FormData" in window && "FileReader" in window && "URL" in window && !!URL.createObjectURL;
		phone = matchMediaQuery("only screen and (max-device-width: 480px)") && (android || iDevice);
		tablet = matchMediaQuery("only screen and (min-width: 800px)") && (android || iDevice);
		windowsPhone = userAgent.indexOf('Windows Phone') != -1;
	
		if (ie12) {
			webkit = false;
		}
	
		// Is a iPad/iPhone and not on iOS5 sniff the WebKit version since older iOS WebKit versions
		// says it has contentEditable support but there is no visible caret.
		var contentEditable = !iDevice || fileApi || userAgent.match(/AppleWebKit\/(\d*)/)[1] >= 534;
	
		return {
			/**
			 * Constant that is true if the browser is Opera.
			 *
			 * @property opera
			 * @type Boolean
			 * @final
			 */
			opera: opera,
	
			/**
			 * Constant that is true if the browser is WebKit (Safari/Chrome).
			 *
			 * @property webKit
			 * @type Boolean
			 * @final
			 */
			webkit: webkit,
	
			/**
			 * Constant that is more than zero if the browser is IE.
			 *
			 * @property ie
			 * @type Boolean
			 * @final
			 */
			ie: ie,
	
			/**
			 * Constant that is true if the browser is Gecko.
			 *
			 * @property gecko
			 * @type Boolean
			 * @final
			 */
			gecko: gecko,
	
			/**
			 * Constant that is true if the os is Mac OS.
			 *
			 * @property mac
			 * @type Boolean
			 * @final
			 */
			mac: mac,
	
			/**
			 * Constant that is true if the os is iOS.
			 *
			 * @property iOS
			 * @type Boolean
			 * @final
			 */
			iOS: iDevice,
	
			/**
			 * Constant that is true if the os is android.
			 *
			 * @property android
			 * @type Boolean
			 * @final
			 */
			android: android,
	
			/**
			 * Constant that is true if the browser supports editing.
			 *
			 * @property contentEditable
			 * @type Boolean
			 * @final
			 */
			contentEditable: contentEditable,
	
			/**
			 * Transparent image data url.
			 *
			 * @property transparentSrc
			 * @type Boolean
			 * @final
			 */
			transparentSrc: "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7",
	
			/**
			 * Returns true/false if the browser can or can't place the caret after a inline block like an image.
			 *
			 * @property noCaretAfter
			 * @type Boolean
			 * @final
			 */
			caretAfter: ie != 8,
	
			/**
			 * Constant that is true if the browser supports native DOM Ranges. IE 9+.
			 *
			 * @property range
			 * @type Boolean
			 */
			range: window.getSelection && "Range" in window,
	
			/**
			 * Returns the IE document mode for non IE browsers this will fake IE 10.
			 *
			 * @property documentMode
			 * @type Number
			 */
			documentMode: ie && !ie12 ? (document.documentMode || 7) : 10,
	
			/**
			 * Constant that is true if the browser has a modern file api.
			 *
			 * @property fileApi
			 * @type Boolean
			 */
			fileApi: fileApi,
	
			/**
			 * Constant that is true if the browser supports contentEditable=false regions.
			 *
			 * @property ceFalse
			 * @type Boolean
			 */
			ceFalse: (ie === false || ie > 8),
	
			desktop: !phone && !tablet,
			windowsPhone: windowsPhone
		};
	});
	
	// Included from: js/tinymce/classes/dom/EventUtils.js
	
	/**
	 * EventUtils.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/*jshint loopfunc:true*/
	/*eslint no-loop-func:0 */
	
	/**
	 * This class wraps the browsers native event logic with more convenient methods.
	 *
	 * @class tinymce.dom.EventUtils
	 */
	define("tinymce/dom/EventUtils", [
		"tinymce/util/Delay",
		"tinymce/Env"
	], function(Delay, Env) {
		"use strict";
	
		var eventExpandoPrefix = "mce-data-";
		var mouseEventRe = /^(?:mouse|contextmenu)|click/;
		var deprecated = {
			keyLocation: 1, layerX: 1, layerY: 1, returnValue: 1,
			webkitMovementX: 1, webkitMovementY: 1, keyIdentifier: 1
		};
	
		/**
		 * Binds a native event to a callback on the speified target.
		 */
		function addEvent(target, name, callback, capture) {
			if (target.addEventListener) {
				target.addEventListener(name, callback, capture || false);
			} else if (target.attachEvent) {
				target.attachEvent('on' + name, callback);
			}
		}
	
		/**
		 * Unbinds a native event callback on the specified target.
		 */
		function removeEvent(target, name, callback, capture) {
			if (target.removeEventListener) {
				target.removeEventListener(name, callback, capture || false);
			} else if (target.detachEvent) {
				target.detachEvent('on' + name, callback);
			}
		}
	
		/**
		 * Gets the event target based on shadow dom properties like path and deepPath.
		 */
		function getTargetFromShadowDom(event, defaultTarget) {
			var path, target = defaultTarget;
	
			// When target element is inside Shadow DOM we need to take first element from path
			// otherwise we'll get Shadow Root parent, not actual target element
	
			// Normalize target for WebComponents v0 implementation (in Chrome)
			path = event.path;
			if (path && path.length > 0) {
				target = path[0];
			}
	
			// Normalize target for WebComponents v1 implementation (standard)
			if (event.deepPath) {
				path = event.deepPath();
				if (path && path.length > 0) {
					target = path[0];
				}
			}
	
			return target;
		}
	
		/**
		 * Normalizes a native event object or just adds the event specific methods on a custom event.
		 */
		function fix(originalEvent, data) {
			var name, event = data || {}, undef;
	
			// Dummy function that gets replaced on the delegation state functions
			function returnFalse() {
				return false;
			}
	
			// Dummy function that gets replaced on the delegation state functions
			function returnTrue() {
				return true;
			}
	
			// Copy all properties from the original event
			for (name in originalEvent) {
				// layerX/layerY is deprecated in Chrome and produces a warning
				if (!deprecated[name]) {
					event[name] = originalEvent[name];
				}
			}
	
			// Normalize target IE uses srcElement
			if (!event.target) {
				event.target = event.srcElement || document;
			}
	
			// Experimental shadow dom support
			if (Env.experimentalShadowDom) {
				event.target = getTargetFromShadowDom(originalEvent, event.target);
			}
	
			// Calculate pageX/Y if missing and clientX/Y available
			if (originalEvent && mouseEventRe.test(originalEvent.type) && originalEvent.pageX === undef && originalEvent.clientX !== undef) {
				var eventDoc = event.target.ownerDocument || document;
				var doc = eventDoc.documentElement;
				var body = eventDoc.body;
	
				event.pageX = originalEvent.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) -
					(doc && doc.clientLeft || body && body.clientLeft || 0);
	
				event.pageY = originalEvent.clientY + (doc && doc.scrollTop || body && body.scrollTop || 0) -
					(doc && doc.clientTop || body && body.clientTop || 0);
			}
	
			// Add preventDefault method
			event.preventDefault = function() {
				event.isDefaultPrevented = returnTrue;
	
				// Execute preventDefault on the original event object
				if (originalEvent) {
					if (originalEvent.preventDefault) {
						originalEvent.preventDefault();
					} else {
						originalEvent.returnValue = false; // IE
					}
				}
			};
	
			// Add stopPropagation
			event.stopPropagation = function() {
				event.isPropagationStopped = returnTrue;
	
				// Execute stopPropagation on the original event object
				if (originalEvent) {
					if (originalEvent.stopPropagation) {
						originalEvent.stopPropagation();
					} else {
						originalEvent.cancelBubble = true; // IE
					}
				}
			};
	
			// Add stopImmediatePropagation
			event.stopImmediatePropagation = function() {
				event.isImmediatePropagationStopped = returnTrue;
				event.stopPropagation();
			};
	
			// Add event delegation states
			if (!event.isDefaultPrevented) {
				event.isDefaultPrevented = returnFalse;
				event.isPropagationStopped = returnFalse;
				event.isImmediatePropagationStopped = returnFalse;
			}
	
			// Add missing metaKey for IE 8
			if (typeof event.metaKey == 'undefined') {
				event.metaKey = false;
			}
	
			return event;
		}
	
		/**
		 * Bind a DOMContentLoaded event across browsers and executes the callback once the page DOM is initialized.
		 * It will also set/check the domLoaded state of the event_utils instance so ready isn't called multiple times.
		 */
		function bindOnReady(win, callback, eventUtils) {
			var doc = win.document, event = {type: 'ready'};
	
			if (eventUtils.domLoaded) {
				callback(event);
				return;
			}
	
			// Gets called when the DOM is ready
			function readyHandler() {
				if (!eventUtils.domLoaded) {
					eventUtils.domLoaded = true;
					callback(event);
				}
			}
	
			function waitForDomLoaded() {
				// Check complete or interactive state if there is a body
				// element on some iframes IE 8 will produce a null body
				if (doc.readyState === "complete" || (doc.readyState === "interactive" && doc.body)) {
					removeEvent(doc, "readystatechange", waitForDomLoaded);
					readyHandler();
				}
			}
	
			function tryScroll() {
				try {
					// If IE is used, use the trick by Diego Perini licensed under MIT by request to the author.
					// http://javascript.nwbox.com/IEContentLoaded/
					doc.documentElement.doScroll("left");
				} catch (ex) {
					Delay.setTimeout(tryScroll);
					return;
				}
	
				readyHandler();
			}
	
			// Use W3C method
			if (doc.addEventListener) {
				if (doc.readyState === "complete") {
					readyHandler();
				} else {
					addEvent(win, 'DOMContentLoaded', readyHandler);
				}
			} else {
				// Use IE method
				addEvent(doc, "readystatechange", waitForDomLoaded);
	
				// Wait until we can scroll, when we can the DOM is initialized
				if (doc.documentElement.doScroll && win.self === win.top) {
					tryScroll();
				}
			}
	
			// Fallback if any of the above methods should fail for some odd reason
			addEvent(win, 'load', readyHandler);
		}
	
		/**
		 * This class enables you to bind/unbind native events to elements and normalize it's behavior across browsers.
		 */
		function EventUtils() {
			var self = this, events = {}, count, expando, hasFocusIn, hasMouseEnterLeave, mouseEnterLeave;
	
			expando = eventExpandoPrefix + (+new Date()).toString(32);
			hasMouseEnterLeave = "onmouseenter" in document.documentElement;
			hasFocusIn = "onfocusin" in document.documentElement;
			mouseEnterLeave = {mouseenter: 'mouseover', mouseleave: 'mouseout'};
			count = 1;
	
			// State if the DOMContentLoaded was executed or not
			self.domLoaded = false;
			self.events = events;
	
			/**
			 * Executes all event handler callbacks for a specific event.
			 *
			 * @private
			 * @param {Event} evt Event object.
			 * @param {String} id Expando id value to look for.
			 */
			function executeHandlers(evt, id) {
				var callbackList, i, l, callback, container = events[id];
	
				callbackList = container && container[evt.type];
				if (callbackList) {
					for (i = 0, l = callbackList.length; i < l; i++) {
						callback = callbackList[i];
	
						// Check if callback exists might be removed if a unbind is called inside the callback
						if (callback && callback.func.call(callback.scope, evt) === false) {
							evt.preventDefault();
						}
	
						// Should we stop propagation to immediate listeners
						if (evt.isImmediatePropagationStopped()) {
							return;
						}
					}
				}
			}
	
			/**
			 * Binds a callback to an event on the specified target.
			 *
			 * @method bind
			 * @param {Object} target Target node/window or custom object.
			 * @param {String} names Name of the event to bind.
			 * @param {function} callback Callback function to execute when the event occurs.
			 * @param {Object} scope Scope to call the callback function on, defaults to target.
			 * @return {function} Callback function that got bound.
			 */
			self.bind = function(target, names, callback, scope) {
				var id, callbackList, i, name, fakeName, nativeHandler, capture, win = window;
	
				// Native event handler function patches the event and executes the callbacks for the expando
				function defaultNativeHandler(evt) {
					executeHandlers(fix(evt || win.event), id);
				}
	
				// Don't bind to text nodes or comments
				if (!target || target.nodeType === 3 || target.nodeType === 8) {
					return;
				}
	
				// Create or get events id for the target
				if (!target[expando]) {
					id = count++;
					target[expando] = id;
					events[id] = {};
				} else {
					id = target[expando];
				}
	
				// Setup the specified scope or use the target as a default
				scope = scope || target;
	
				// Split names and bind each event, enables you to bind multiple events with one call
				names = names.split(' ');
				i = names.length;
				while (i--) {
					name = names[i];
					nativeHandler = defaultNativeHandler;
					fakeName = capture = false;
	
					// Use ready instead of DOMContentLoaded
					if (name === "DOMContentLoaded") {
						name = "ready";
					}
	
					// DOM is already ready
					if (self.domLoaded && name === "ready" && target.readyState == 'complete') {
						callback.call(scope, fix({type: name}));
						continue;
					}
	
					// Handle mouseenter/mouseleaver
					if (!hasMouseEnterLeave) {
						fakeName = mouseEnterLeave[name];
	
						if (fakeName) {
							nativeHandler = function(evt) {
								var current, related;
	
								current = evt.currentTarget;
								related = evt.relatedTarget;
	
								// Check if related is inside the current target if it's not then the event should
								// be ignored since it's a mouseover/mouseout inside the element
								if (related && current.contains) {
									// Use contains for performance
									related = current.contains(related);
								} else {
									while (related && related !== current) {
										related = related.parentNode;
									}
								}
	
								// Fire fake event
								if (!related) {
									evt = fix(evt || win.event);
									evt.type = evt.type === 'mouseout' ? 'mouseleave' : 'mouseenter';
									evt.target = current;
									executeHandlers(evt, id);
								}
							};
						}
					}
	
					// Fake bubbling of focusin/focusout
					if (!hasFocusIn && (name === "focusin" || name === "focusout")) {
						capture = true;
						fakeName = name === "focusin" ? "focus" : "blur";
						nativeHandler = function(evt) {
							evt = fix(evt || win.event);
							evt.type = evt.type === 'focus' ? 'focusin' : 'focusout';
							executeHandlers(evt, id);
						};
					}
	
					// Setup callback list and bind native event
					callbackList = events[id][name];
					if (!callbackList) {
						events[id][name] = callbackList = [{func: callback, scope: scope}];
						callbackList.fakeName = fakeName;
						callbackList.capture = capture;
						//callbackList.callback = callback;
	
						// Add the nativeHandler to the callback list so that we can later unbind it
						callbackList.nativeHandler = nativeHandler;
	
						// Check if the target has native events support
	
						if (name === "ready") {
							bindOnReady(target, nativeHandler, self);
						} else {
							addEvent(target, fakeName || name, nativeHandler, capture);
						}
					} else {
						if (name === "ready" && self.domLoaded) {
							callback({type: name});
						} else {
							// If it already has an native handler then just push the callback
							callbackList.push({func: callback, scope: scope});
						}
					}
				}
	
				target = callbackList = 0; // Clean memory for IE
	
				return callback;
			};
	
			/**
			 * Unbinds the specified event by name, name and callback or all events on the target.
			 *
			 * @method unbind
			 * @param {Object} target Target node/window or custom object.
			 * @param {String} names Optional event name to unbind.
			 * @param {function} callback Optional callback function to unbind.
			 * @return {EventUtils} Event utils instance.
			 */
			self.unbind = function(target, names, callback) {
				var id, callbackList, i, ci, name, eventMap;
	
				// Don't bind to text nodes or comments
				if (!target || target.nodeType === 3 || target.nodeType === 8) {
					return self;
				}
	
				// Unbind event or events if the target has the expando
				id = target[expando];
				if (id) {
					eventMap = events[id];
	
					// Specific callback
					if (names) {
						names = names.split(' ');
						i = names.length;
						while (i--) {
							name = names[i];
							callbackList = eventMap[name];
	
							// Unbind the event if it exists in the map
							if (callbackList) {
								// Remove specified callback
								if (callback) {
									ci = callbackList.length;
									while (ci--) {
										if (callbackList[ci].func === callback) {
											var nativeHandler = callbackList.nativeHandler;
											var fakeName = callbackList.fakeName, capture = callbackList.capture;
	
											// Clone callbackList since unbind inside a callback would otherwise break the handlers loop
											callbackList = callbackList.slice(0, ci).concat(callbackList.slice(ci + 1));
											callbackList.nativeHandler = nativeHandler;
											callbackList.fakeName = fakeName;
											callbackList.capture = capture;
	
											eventMap[name] = callbackList;
										}
									}
								}
	
								// Remove all callbacks if there isn't a specified callback or there is no callbacks left
								if (!callback || callbackList.length === 0) {
									delete eventMap[name];
									removeEvent(target, callbackList.fakeName || name, callbackList.nativeHandler, callbackList.capture);
								}
							}
						}
					} else {
						// All events for a specific element
						for (name in eventMap) {
							callbackList = eventMap[name];
							removeEvent(target, callbackList.fakeName || name, callbackList.nativeHandler, callbackList.capture);
						}
	
						eventMap = {};
					}
	
					// Check if object is empty, if it isn't then we won't remove the expando map
					for (name in eventMap) {
						return self;
					}
	
					// Delete event object
					delete events[id];
	
					// Remove expando from target
					try {
						// IE will fail here since it can't delete properties from window
						delete target[expando];
					} catch (ex) {
						// IE will set it to null
						target[expando] = null;
					}
				}
	
				return self;
			};
	
			/**
			 * Fires the specified event on the specified target.
			 *
			 * @method fire
			 * @param {Object} target Target node/window or custom object.
			 * @param {String} name Event name to fire.
			 * @param {Object} args Optional arguments to send to the observers.
			 * @return {EventUtils} Event utils instance.
			 */
			self.fire = function(target, name, args) {
				var id;
	
				// Don't bind to text nodes or comments
				if (!target || target.nodeType === 3 || target.nodeType === 8) {
					return self;
				}
	
				// Build event object by patching the args
				args = fix(null, args);
				args.type = name;
				args.target = target;
	
				do {
					// Found an expando that means there is listeners to execute
					id = target[expando];
					if (id) {
						executeHandlers(args, id);
					}
	
					// Walk up the DOM
					target = target.parentNode || target.ownerDocument || target.defaultView || target.parentWindow;
				} while (target && !args.isPropagationStopped());
	
				return self;
			};
	
			/**
			 * Removes all bound event listeners for the specified target. This will also remove any bound
			 * listeners to child nodes within that target.
			 *
			 * @method clean
			 * @param {Object} target Target node/window object.
			 * @return {EventUtils} Event utils instance.
			 */
			self.clean = function(target) {
				var i, children, unbind = self.unbind;
	
				// Don't bind to text nodes or comments
				if (!target || target.nodeType === 3 || target.nodeType === 8) {
					return self;
				}
	
				// Unbind any element on the specified target
				if (target[expando]) {
					unbind(target);
				}
	
				// Target doesn't have getElementsByTagName it's probably a window object then use it's document to find the children
				if (!target.getElementsByTagName) {
					target = target.document;
				}
	
				// Remove events from each child element
				if (target && target.getElementsByTagName) {
					unbind(target);
	
					children = target.getElementsByTagName('*');
					i = children.length;
					while (i--) {
						target = children[i];
	
						if (target[expando]) {
							unbind(target);
						}
					}
				}
	
				return self;
			};
	
			/**
			 * Destroys the event object. Call this on IE to remove memory leaks.
			 */
			self.destroy = function() {
				events = {};
			};
	
			// Legacy function for canceling events
			self.cancel = function(e) {
				if (e) {
					e.preventDefault();
					e.stopImmediatePropagation();
				}
	
				return false;
			};
		}
	
		EventUtils.Event = new EventUtils();
		EventUtils.Event.bind(window, 'ready', function() {});
	
		return EventUtils;
	});
	
	// Included from: js/tinymce/classes/dom/Sizzle.js
	
	/**
	 * Sizzle.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 *
	 * @ignore-file
	 */
	
	/*jshint bitwise:false, expr:true, noempty:false, sub:true, eqnull:true, latedef:false, maxlen:255 */
	/*eslint-disable */
	
	/**
	 * Sizzle CSS Selector Engine v@VERSION
	 * http://sizzlejs.com/
	 *
	 * Copyright 2008, 2014 jQuery Foundation, Inc. and other contributors
	 * Released under the MIT license
	 * http://jquery.org/license
	 *
	 * Date: @DATE
	 */
	define("tinymce/dom/Sizzle", [], function() {
	var i,
		support,
		Expr,
		getText,
		isXML,
		tokenize,
		compile,
		select,
		outermostContext,
		sortInput,
		hasDuplicate,
	
		// Local document vars
		setDocument,
		document,
		docElem,
		documentIsHTML,
		rbuggyQSA,
		rbuggyMatches,
		matches,
		contains,
	
		// Instance-specific data
		expando = "sizzle" + -(new Date()),
		preferredDoc = window.document,
		dirruns = 0,
		done = 0,
		classCache = createCache(),
		tokenCache = createCache(),
		compilerCache = createCache(),
		sortOrder = function( a, b ) {
			if ( a === b ) {
				hasDuplicate = true;
			}
			return 0;
		},
	
		// General-purpose constants
		strundefined = typeof undefined,
		MAX_NEGATIVE = 1 << 31,
	
		// Instance methods
		hasOwn = ({}).hasOwnProperty,
		arr = [],
		pop = arr.pop,
		push_native = arr.push,
		push = arr.push,
		slice = arr.slice,
		// Use a stripped-down indexOf if we can't use a native one
		indexOf = arr.indexOf || function( elem ) {
			var i = 0,
				len = this.length;
			for ( ; i < len; i++ ) {
				if ( this[i] === elem ) {
					return i;
				}
			}
			return -1;
		},
	
		booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",
	
		// Regular expressions
	
		// http://www.w3.org/TR/css3-selectors/#whitespace
		whitespace = "[\\x20\\t\\r\\n\\f]",
	
		// http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
		identifier = "(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",
	
		// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
		attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace +
			// Operator (capture 2)
			"*([*^$|!~]?=)" + whitespace +
			// "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
			"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace +
			"*\\]",
	
		pseudos = ":(" + identifier + ")(?:\\((" +
			// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
			// 1. quoted (capture 3; capture 4 or capture 5)
			"('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +
			// 2. simple (capture 6)
			"((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +
			// 3. anything else (capture 2)
			".*" +
			")\\)|)",
	
		// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
		rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g" ),
	
		rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
		rcombinators = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*" ),
	
		rattributeQuotes = new RegExp( "=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g" ),
	
		rpseudo = new RegExp( pseudos ),
		ridentifier = new RegExp( "^" + identifier + "$" ),
	
		matchExpr = {
			"ID": new RegExp( "^#(" + identifier + ")" ),
			"CLASS": new RegExp( "^\\.(" + identifier + ")" ),
			"TAG": new RegExp( "^(" + identifier + "|[*])" ),
			"ATTR": new RegExp( "^" + attributes ),
			"PSEUDO": new RegExp( "^" + pseudos ),
			"CHILD": new RegExp( "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace +
				"*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +
				"*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
			"bool": new RegExp( "^(?:" + booleans + ")$", "i" ),
			// For use in libraries implementing .is()
			// We use this for POS matching in `select`
			"needsContext": new RegExp( "^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" +
				whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )
		},
	
		rinputs = /^(?:input|select|textarea|button)$/i,
		rheader = /^h\d$/i,
	
		rnative = /^[^{]+\{\s*\[native \w/,
	
		// Easily-parseable/retrievable ID or TAG or CLASS selectors
		rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,
	
		rsibling = /[+~]/,
		rescape = /'|\\/g,
	
		// CSS escapes http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
		runescape = new RegExp( "\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig" ),
		funescape = function( _, escaped, escapedWhitespace ) {
			var high = "0x" + escaped - 0x10000;
			// NaN means non-codepoint
			// Support: Firefox<24
			// Workaround erroneous numeric interpretation of +"0x"
			return high !== high || escapedWhitespace ?
				escaped :
				high < 0 ?
					// BMP codepoint
					String.fromCharCode( high + 0x10000 ) :
					// Supplemental Plane codepoint (surrogate pair)
					String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
		};
	
	// Optimize for push.apply( _, NodeList )
	try {
		push.apply(
			(arr = slice.call( preferredDoc.childNodes )),
			preferredDoc.childNodes
		);
		// Support: Android<4.0
		// Detect silently failing push.apply
		arr[ preferredDoc.childNodes.length ].nodeType;
	} catch ( e ) {
		push = { apply: arr.length ?
	
			// Leverage slice if possible
			function( target, els ) {
				push_native.apply( target, slice.call(els) );
			} :
	
			// Support: IE<9
			// Otherwise append directly
			function( target, els ) {
				var j = target.length,
					i = 0;
				// Can't trust NodeList.length
				while ( (target[j++] = els[i++]) ) {}
				target.length = j - 1;
			}
		};
	}
	
	function Sizzle( selector, context, results, seed ) {
		var match, elem, m, nodeType,
			// QSA vars
			i, groups, old, nid, newContext, newSelector;
	
		if ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {
			setDocument( context );
		}
	
		context = context || document;
		results = results || [];
	
		if ( !selector || typeof selector !== "string" ) {
			return results;
		}
	
		if ( (nodeType = context.nodeType) !== 1 && nodeType !== 9 ) {
			return [];
		}
	
		if ( documentIsHTML && !seed ) {
	
			// Shortcuts
			if ( (match = rquickExpr.exec( selector )) ) {
				// Speed-up: Sizzle("#ID")
				if ( (m = match[1]) ) {
					if ( nodeType === 9 ) {
						elem = context.getElementById( m );
						// Check parentNode to catch when Blackberry 4.6 returns
						// nodes that are no longer in the document (jQuery #6963)
						if ( elem && elem.parentNode ) {
							// Handle the case where IE, Opera, and Webkit return items
							// by name instead of ID
							if ( elem.id === m ) {
								results.push( elem );
								return results;
							}
						} else {
							return results;
						}
					} else {
						// Context is not a document
						if ( context.ownerDocument && (elem = context.ownerDocument.getElementById( m )) &&
							contains( context, elem ) && elem.id === m ) {
							results.push( elem );
							return results;
						}
					}
	
				// Speed-up: Sizzle("TAG")
				} else if ( match[2] ) {
					push.apply( results, context.getElementsByTagName( selector ) );
					return results;
	
				// Speed-up: Sizzle(".CLASS")
				} else if ( (m = match[3]) && support.getElementsByClassName ) {
					push.apply( results, context.getElementsByClassName( m ) );
					return results;
				}
			}
	
			// QSA path
			if ( support.qsa && (!rbuggyQSA || !rbuggyQSA.test( selector )) ) {
				nid = old = expando;
				newContext = context;
				newSelector = nodeType === 9 && selector;
	
				// qSA works strangely on Element-rooted queries
				// We can work around this by specifying an extra ID on the root
				// and working up from there (Thanks to Andrew Dupont for the technique)
				// IE 8 doesn't work on object elements
				if ( nodeType === 1 && context.nodeName.toLowerCase() !== "object" ) {
					groups = tokenize( selector );
	
					if ( (old = context.getAttribute("id")) ) {
						nid = old.replace( rescape, "\\$&" );
					} else {
						context.setAttribute( "id", nid );
					}
					nid = "[id='" + nid + "'] ";
	
					i = groups.length;
					while ( i-- ) {
						groups[i] = nid + toSelector( groups[i] );
					}
					newContext = rsibling.test( selector ) && testContext( context.parentNode ) || context;
					newSelector = groups.join(",");
				}
	
				if ( newSelector ) {
					try {
						push.apply( results,
							newContext.querySelectorAll( newSelector )
						);
						return results;
					} catch(qsaError) {
					} finally {
						if ( !old ) {
							context.removeAttribute("id");
						}
					}
				}
			}
		}
	
		// All others
		return select( selector.replace( rtrim, "$1" ), context, results, seed );
	}
	
	/**
	 * Create key-value caches of limited size
	 * @returns {Function(string, Object)} Returns the Object data after storing it on itself with
	 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
	 *	deleting the oldest entry
	 */
	function createCache() {
		var keys = [];
	
		function cache( key, value ) {
			// Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
			if ( keys.push( key + " " ) > Expr.cacheLength ) {
				// Only keep the most recent entries
				delete cache[ keys.shift() ];
			}
			return (cache[ key + " " ] = value);
		}
		return cache;
	}
	
	/**
	 * Mark a function for special use by Sizzle
	 * @param {Function} fn The function to mark
	 */
	function markFunction( fn ) {
		fn[ expando ] = true;
		return fn;
	}
	
	/**
	 * Support testing using an element
	 * @param {Function} fn Passed the created div and expects a boolean result
	 */
	function assert( fn ) {
		var div = document.createElement("div");
	
		try {
			return !!fn( div );
		} catch (e) {
			return false;
		} finally {
			// Remove from its parent by default
			if ( div.parentNode ) {
				div.parentNode.removeChild( div );
			}
			// release memory in IE
			div = null;
		}
	}
	
	/**
	 * Adds the same handler for all of the specified attrs
	 * @param {String} attrs Pipe-separated list of attributes
	 * @param {Function} handler The method that will be applied
	 */
	function addHandle( attrs, handler ) {
		var arr = attrs.split("|"),
			i = attrs.length;
	
		while ( i-- ) {
			Expr.attrHandle[ arr[i] ] = handler;
		}
	}
	
	/**
	 * Checks document order of two siblings
	 * @param {Element} a
	 * @param {Element} b
	 * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
	 */
	function siblingCheck( a, b ) {
		var cur = b && a,
			diff = cur && a.nodeType === 1 && b.nodeType === 1 &&
				( ~b.sourceIndex || MAX_NEGATIVE ) -
				( ~a.sourceIndex || MAX_NEGATIVE );
	
		// Use IE sourceIndex if available on both nodes
		if ( diff ) {
			return diff;
		}
	
		// Check if b follows a
		if ( cur ) {
			while ( (cur = cur.nextSibling) ) {
				if ( cur === b ) {
					return -1;
				}
			}
		}
	
		return a ? 1 : -1;
	}
	
	/**
	 * Returns a function to use in pseudos for input types
	 * @param {String} type
	 */
	function createInputPseudo( type ) {
		return function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return name === "input" && elem.type === type;
		};
	}
	
	/**
	 * Returns a function to use in pseudos for buttons
	 * @param {String} type
	 */
	function createButtonPseudo( type ) {
		return function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return (name === "input" || name === "button") && elem.type === type;
		};
	}
	
	/**
	 * Returns a function to use in pseudos for positionals
	 * @param {Function} fn
	 */
	function createPositionalPseudo( fn ) {
		return markFunction(function( argument ) {
			argument = +argument;
			return markFunction(function( seed, matches ) {
				var j,
					matchIndexes = fn( [], seed.length, argument ),
					i = matchIndexes.length;
	
				// Match elements found at the specified indexes
				while ( i-- ) {
					if ( seed[ (j = matchIndexes[i]) ] ) {
						seed[j] = !(matches[j] = seed[j]);
					}
				}
			});
		});
	}
	
	/**
	 * Checks a node for validity as a Sizzle context
	 * @param {Element|Object=} context
	 * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
	 */
	function testContext( context ) {
		return context && typeof context.getElementsByTagName !== strundefined && context;
	}
	
	// Expose support vars for convenience
	support = Sizzle.support = {};
	
	/**
	 * Detects XML nodes
	 * @param {Element|Object} elem An element or a document
	 * @returns {Boolean} True iff elem is a non-HTML XML node
	 */
	isXML = Sizzle.isXML = function( elem ) {
		// documentElement is verified for cases where it doesn't yet exist
		// (such as loading iframes in IE - #4833)
		var documentElement = elem && (elem.ownerDocument || elem).documentElement;
		return documentElement ? documentElement.nodeName !== "HTML" : false;
	};
	
	/**
	 * Sets document-related variables once based on the current document
	 * @param {Element|Object} [doc] An element or document object to use to set the document
	 * @returns {Object} Returns the current document
	 */
	setDocument = Sizzle.setDocument = function( node ) {
		var hasCompare,
			doc = node ? node.ownerDocument || node : preferredDoc,
			parent = doc.defaultView;
	
		function getTop(win) {
			// Edge throws a lovely Object expected if you try to get top on a detached reference see #2642
			try {
				return win.top;
			} catch (ex) {
				// Ignore
			}
	
			return null;
		}
	
		// If no document and documentElement is available, return
		if ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {
			return document;
		}
	
		// Set our document
		document = doc;
		docElem = doc.documentElement;
	
		// Support tests
		documentIsHTML = !isXML( doc );
	
		// Support: IE>8
		// If iframe document is assigned to "document" variable and if iframe has been reloaded,
		// IE will throw "permission denied" error when accessing "document" variable, see jQuery #13936
		// IE6-8 do not support the defaultView property so parent will be undefined
		if ( parent && parent !== getTop(parent) ) {
			// IE11 does not have attachEvent, so all must suffer
			if ( parent.addEventListener ) {
				parent.addEventListener( "unload", function() {
					setDocument();
				}, false );
			} else if ( parent.attachEvent ) {
				parent.attachEvent( "onunload", function() {
					setDocument();
				});
			}
		}
	
		/* Attributes
		---------------------------------------------------------------------- */
	
		// Support: IE<8
		// Verify that getAttribute really returns attributes and not properties (excepting IE8 booleans)
		support.attributes = assert(function( div ) {
			div.className = "i";
			return !div.getAttribute("className");
		});
	
		/* getElement(s)By*
		---------------------------------------------------------------------- */
	
		// Check if getElementsByTagName("*") returns only elements
		support.getElementsByTagName = assert(function( div ) {
			div.appendChild( doc.createComment("") );
			return !div.getElementsByTagName("*").length;
		});
	
		// Support: IE<9
		support.getElementsByClassName = rnative.test( doc.getElementsByClassName );
	
		// Support: IE<10
		// Check if getElementById returns elements by name
		// The broken getElementById methods don't pick up programatically-set names,
		// so use a roundabout getElementsByName test
		support.getById = assert(function( div ) {
			docElem.appendChild( div ).id = expando;
			return !doc.getElementsByName || !doc.getElementsByName( expando ).length;
		});
	
		// ID find and filter
		if ( support.getById ) {
			Expr.find["ID"] = function( id, context ) {
				if ( typeof context.getElementById !== strundefined && documentIsHTML ) {
					var m = context.getElementById( id );
					// Check parentNode to catch when Blackberry 4.6 returns
					// nodes that are no longer in the document #6963
					return m && m.parentNode ? [ m ] : [];
				}
			};
			Expr.filter["ID"] = function( id ) {
				var attrId = id.replace( runescape, funescape );
				return function( elem ) {
					return elem.getAttribute("id") === attrId;
				};
			};
		} else {
			// Support: IE6/7
			// getElementById is not reliable as a find shortcut
			delete Expr.find["ID"];
	
			Expr.filter["ID"] =  function( id ) {
				var attrId = id.replace( runescape, funescape );
				return function( elem ) {
					var node = typeof elem.getAttributeNode !== strundefined && elem.getAttributeNode("id");
					return node && node.value === attrId;
				};
			};
		}
	
		// Tag
		Expr.find["TAG"] = support.getElementsByTagName ?
			function( tag, context ) {
				if ( typeof context.getElementsByTagName !== strundefined ) {
					return context.getElementsByTagName( tag );
				}
			} :
			function( tag, context ) {
				var elem,
					tmp = [],
					i = 0,
					results = context.getElementsByTagName( tag );
	
				// Filter out possible comments
				if ( tag === "*" ) {
					while ( (elem = results[i++]) ) {
						if ( elem.nodeType === 1 ) {
							tmp.push( elem );
						}
					}
	
					return tmp;
				}
				return results;
			};
	
		// Class
		Expr.find["CLASS"] = support.getElementsByClassName && function( className, context ) {
			if ( documentIsHTML ) {
				return context.getElementsByClassName( className );
			}
		};
	
		/* QSA/matchesSelector
		---------------------------------------------------------------------- */
	
		// QSA and matchesSelector support
	
		// matchesSelector(:active) reports false when true (IE9/Opera 11.5)
		rbuggyMatches = [];
	
		// qSa(:focus) reports false when true (Chrome 21)
		// We allow this because of a bug in IE8/9 that throws an error
		// whenever `document.activeElement` is accessed on an iframe
		// So, we allow :focus to pass through QSA all the time to avoid the IE error
		// See http://bugs.jquery.com/ticket/13378
		rbuggyQSA = [];
	
		if ( (support.qsa = rnative.test( doc.querySelectorAll )) ) {
			// Build QSA regex
			// Regex strategy adopted from Diego Perini
			assert(function( div ) {
				// Select is set to empty string on purpose
				// This is to test IE's treatment of not explicitly
				// setting a boolean content attribute,
				// since its presence should be enough
				// http://bugs.jquery.com/ticket/12359
				div.innerHTML = "<select msallowcapture=''><option selected=''></option></select>";
	
				// Support: IE8, Opera 11-12.16
				// Nothing should be selected when empty strings follow ^= or $= or *=
				// The test attribute must be unknown in Opera but "safe" for WinRT
				// http://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
				if ( div.querySelectorAll("[msallowcapture^='']").length ) {
					rbuggyQSA.push( "[*^$]=" + whitespace + "*(?:''|\"\")" );
				}
	
				// Support: IE8
				// Boolean attributes and "value" are not treated correctly
				if ( !div.querySelectorAll("[selected]").length ) {
					rbuggyQSA.push( "\\[" + whitespace + "*(?:value|" + booleans + ")" );
				}
	
				// Webkit/Opera - :checked should return selected option elements
				// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
				// IE8 throws error here and will not see later tests
				if ( !div.querySelectorAll(":checked").length ) {
					rbuggyQSA.push(":checked");
				}
			});
	
			assert(function( div ) {
				// Support: Windows 8 Native Apps
				// The type and name attributes are restricted during .innerHTML assignment
				var input = doc.createElement("input");
				input.setAttribute( "type", "hidden" );
				div.appendChild( input ).setAttribute( "name", "D" );
	
				// Support: IE8
				// Enforce case-sensitivity of name attribute
				if ( div.querySelectorAll("[name=d]").length ) {
					rbuggyQSA.push( "name" + whitespace + "*[*^$|!~]?=" );
				}
	
				// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
				// IE8 throws error here and will not see later tests
				if ( !div.querySelectorAll(":enabled").length ) {
					rbuggyQSA.push( ":enabled", ":disabled" );
				}
	
				// Opera 10-11 does not throw on post-comma invalid pseudos
				div.querySelectorAll("*,:x");
				rbuggyQSA.push(",.*:");
			});
		}
	
		if ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||
			docElem.webkitMatchesSelector ||
			docElem.mozMatchesSelector ||
			docElem.oMatchesSelector ||
			docElem.msMatchesSelector) )) ) {
	
			assert(function( div ) {
				// Check to see if it's possible to do matchesSelector
				// on a disconnected node (IE 9)
				support.disconnectedMatch = matches.call( div, "div" );
	
				// This should fail with an exception
				// Gecko does not error, returns false instead
				matches.call( div, "[s!='']:x" );
				rbuggyMatches.push( "!=", pseudos );
			});
		}
	
		rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join("|") );
		rbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join("|") );
	
		/* Contains
		---------------------------------------------------------------------- */
		hasCompare = rnative.test( docElem.compareDocumentPosition );
	
		// Element contains another
		// Purposefully does not implement inclusive descendent
		// As in, an element does not contain itself
		contains = hasCompare || rnative.test( docElem.contains ) ?
			function( a, b ) {
				var adown = a.nodeType === 9 ? a.documentElement : a,
					bup = b && b.parentNode;
				return a === bup || !!( bup && bup.nodeType === 1 && (
					adown.contains ?
						adown.contains( bup ) :
						a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
				));
			} :
			function( a, b ) {
				if ( b ) {
					while ( (b = b.parentNode) ) {
						if ( b === a ) {
							return true;
						}
					}
				}
				return false;
			};
	
		/* Sorting
		---------------------------------------------------------------------- */
	
		// Document order sorting
		sortOrder = hasCompare ?
		function( a, b ) {
	
			// Flag for duplicate removal
			if ( a === b ) {
				hasDuplicate = true;
				return 0;
			}
	
			// Sort on method existence if only one input has compareDocumentPosition
			var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
			if ( compare ) {
				return compare;
			}
	
			// Calculate position if both inputs belong to the same document
			compare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?
				a.compareDocumentPosition( b ) :
	
				// Otherwise we know they are disconnected
				1;
	
			// Disconnected nodes
			if ( compare & 1 ||
				(!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {
	
				// Choose the first element that is related to our preferred document
				if ( a === doc || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {
					return -1;
				}
				if ( b === doc || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {
					return 1;
				}
	
				// Maintain original order
				return sortInput ?
					( indexOf.call( sortInput, a ) - indexOf.call( sortInput, b ) ) :
					0;
			}
	
			return compare & 4 ? -1 : 1;
		} :
		function( a, b ) {
			// Exit early if the nodes are identical
			if ( a === b ) {
				hasDuplicate = true;
				return 0;
			}
	
			var cur,
				i = 0,
				aup = a.parentNode,
				bup = b.parentNode,
				ap = [ a ],
				bp = [ b ];
	
			// Parentless nodes are either documents or disconnected
			if ( !aup || !bup ) {
				return a === doc ? -1 :
					b === doc ? 1 :
					aup ? -1 :
					bup ? 1 :
					sortInput ?
					( indexOf.call( sortInput, a ) - indexOf.call( sortInput, b ) ) :
					0;
	
			// If the nodes are siblings, we can do a quick check
			} else if ( aup === bup ) {
				return siblingCheck( a, b );
			}
	
			// Otherwise we need full lists of their ancestors for comparison
			cur = a;
			while ( (cur = cur.parentNode) ) {
				ap.unshift( cur );
			}
			cur = b;
			while ( (cur = cur.parentNode) ) {
				bp.unshift( cur );
			}
	
			// Walk down the tree looking for a discrepancy
			while ( ap[i] === bp[i] ) {
				i++;
			}
	
			return i ?
				// Do a sibling check if the nodes have a common ancestor
				siblingCheck( ap[i], bp[i] ) :
	
				// Otherwise nodes in our document sort first
				ap[i] === preferredDoc ? -1 :
				bp[i] === preferredDoc ? 1 :
				0;
		};
	
		return doc;
	};
	
	Sizzle.matches = function( expr, elements ) {
		return Sizzle( expr, null, null, elements );
	};
	
	Sizzle.matchesSelector = function( elem, expr ) {
		// Set document vars if needed
		if ( ( elem.ownerDocument || elem ) !== document ) {
			setDocument( elem );
		}
	
		// Make sure that attribute selectors are quoted
		expr = expr.replace( rattributeQuotes, "='$1']" );
	
		if ( support.matchesSelector && documentIsHTML &&
			( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&
			( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {
	
			try {
				var ret = matches.call( elem, expr );
	
				// IE 9's matchesSelector returns false on disconnected nodes
				if ( ret || support.disconnectedMatch ||
						// As well, disconnected nodes are said to be in a document
						// fragment in IE 9
						elem.document && elem.document.nodeType !== 11 ) {
					return ret;
				}
			} catch(e) {}
		}
	
		return Sizzle( expr, document, null, [ elem ] ).length > 0;
	};
	
	Sizzle.contains = function( context, elem ) {
		// Set document vars if needed
		if ( ( context.ownerDocument || context ) !== document ) {
			setDocument( context );
		}
		return contains( context, elem );
	};
	
	Sizzle.attr = function( elem, name ) {
		// Set document vars if needed
		if ( ( elem.ownerDocument || elem ) !== document ) {
			setDocument( elem );
		}
	
		var fn = Expr.attrHandle[ name.toLowerCase() ],
			// Don't get fooled by Object.prototype properties (jQuery #13807)
			val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
				fn( elem, name, !documentIsHTML ) :
				undefined;
	
		return val !== undefined ?
			val :
			support.attributes || !documentIsHTML ?
				elem.getAttribute( name ) :
				(val = elem.getAttributeNode(name)) && val.specified ?
					val.value :
					null;
	};
	
	Sizzle.error = function( msg ) {
		throw new Error( "Syntax error, unrecognized expression: " + msg );
	};
	
	/**
	 * Document sorting and removing duplicates
	 * @param {ArrayLike} results
	 */
	Sizzle.uniqueSort = function( results ) {
		var elem,
			duplicates = [],
			j = 0,
			i = 0;
	
		// Unless we *know* we can detect duplicates, assume their presence
		hasDuplicate = !support.detectDuplicates;
		sortInput = !support.sortStable && results.slice( 0 );
		results.sort( sortOrder );
	
		if ( hasDuplicate ) {
			while ( (elem = results[i++]) ) {
				if ( elem === results[ i ] ) {
					j = duplicates.push( i );
				}
			}
			while ( j-- ) {
				results.splice( duplicates[ j ], 1 );
			}
		}
	
		// Clear input after sorting to release objects
		// See https://github.com/jquery/sizzle/pull/225
		sortInput = null;
	
		return results;
	};
	
	/**
	 * Utility function for retrieving the text value of an array of DOM nodes
	 * @param {Array|Element} elem
	 */
	getText = Sizzle.getText = function( elem ) {
		var node,
			ret = "",
			i = 0,
			nodeType = elem.nodeType;
	
		if ( !nodeType ) {
			// If no nodeType, this is expected to be an array
			while ( (node = elem[i++]) ) {
				// Do not traverse comment nodes
				ret += getText( node );
			}
		} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {
			// Use textContent for elements
			// innerText usage removed for consistency of new lines (jQuery #11153)
			if ( typeof elem.textContent === "string" ) {
				return elem.textContent;
			} else {
				// Traverse its children
				for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
					ret += getText( elem );
				}
			}
		} else if ( nodeType === 3 || nodeType === 4 ) {
			return elem.nodeValue;
		}
		// Do not include comment or processing instruction nodes
	
		return ret;
	};
	
	Expr = Sizzle.selectors = {
	
		// Can be adjusted by the user
		cacheLength: 50,
	
		createPseudo: markFunction,
	
		match: matchExpr,
	
		attrHandle: {},
	
		find: {},
	
		relative: {
			">": { dir: "parentNode", first: true },
			" ": { dir: "parentNode" },
			"+": { dir: "previousSibling", first: true },
			"~": { dir: "previousSibling" }
		},
	
		preFilter: {
			"ATTR": function( match ) {
				match[1] = match[1].replace( runescape, funescape );
	
				// Move the given value to match[3] whether quoted or unquoted
				match[3] = ( match[3] || match[4] || match[5] || "" ).replace( runescape, funescape );
	
				if ( match[2] === "~=" ) {
					match[3] = " " + match[3] + " ";
				}
	
				return match.slice( 0, 4 );
			},
	
			"CHILD": function( match ) {
				/* matches from matchExpr["CHILD"]
					1 type (only|nth|...)
					2 what (child|of-type)
					3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
					4 xn-component of xn+y argument ([+-]?\d*n|)
					5 sign of xn-component
					6 x of xn-component
					7 sign of y-component
					8 y of y-component
				*/
				match[1] = match[1].toLowerCase();
	
				if ( match[1].slice( 0, 3 ) === "nth" ) {
					// nth-* requires argument
					if ( !match[3] ) {
						Sizzle.error( match[0] );
					}
	
					// numeric x and y parameters for Expr.filter.CHILD
					// remember that false/true cast respectively to 0/1
					match[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === "even" || match[3] === "odd" ) );
					match[5] = +( ( match[7] + match[8] ) || match[3] === "odd" );
	
				// other types prohibit arguments
				} else if ( match[3] ) {
					Sizzle.error( match[0] );
				}
	
				return match;
			},
	
			"PSEUDO": function( match ) {
				var excess,
					unquoted = !match[6] && match[2];
	
				if ( matchExpr["CHILD"].test( match[0] ) ) {
					return null;
				}
	
				// Accept quoted arguments as-is
				if ( match[3] ) {
					match[2] = match[4] || match[5] || "";
	
				// Strip excess characters from unquoted arguments
				} else if ( unquoted && rpseudo.test( unquoted ) &&
					// Get excess from tokenize (recursively)
					(excess = tokenize( unquoted, true )) &&
					// advance to the next closing parenthesis
					(excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length) ) {
	
					// excess is a negative index
					match[0] = match[0].slice( 0, excess );
					match[2] = unquoted.slice( 0, excess );
				}
	
				// Return only captures needed by the pseudo filter method (type and argument)
				return match.slice( 0, 3 );
			}
		},
	
		filter: {
	
			"TAG": function( nodeNameSelector ) {
				var nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
				return nodeNameSelector === "*" ?
					function() { return true; } :
					function( elem ) {
						return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
					};
			},
	
			"CLASS": function( className ) {
				var pattern = classCache[ className + " " ];
	
				return pattern ||
					(pattern = new RegExp( "(^|" + whitespace + ")" + className + "(" + whitespace + "|$)" )) &&
					classCache( className, function( elem ) {
						return pattern.test( typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== strundefined && elem.getAttribute("class") || "" );
					});
			},
	
			"ATTR": function( name, operator, check ) {
				return function( elem ) {
					var result = Sizzle.attr( elem, name );
	
					if ( result == null ) {
						return operator === "!=";
					}
					if ( !operator ) {
						return true;
					}
	
					result += "";
	
					return operator === "=" ? result === check :
						operator === "!=" ? result !== check :
						operator === "^=" ? check && result.indexOf( check ) === 0 :
						operator === "*=" ? check && result.indexOf( check ) > -1 :
						operator === "$=" ? check && result.slice( -check.length ) === check :
						operator === "~=" ? ( " " + result + " " ).indexOf( check ) > -1 :
						operator === "|=" ? result === check || result.slice( 0, check.length + 1 ) === check + "-" :
						false;
				};
			},
	
			"CHILD": function( type, what, argument, first, last ) {
				var simple = type.slice( 0, 3 ) !== "nth",
					forward = type.slice( -4 ) !== "last",
					ofType = what === "of-type";
	
				return first === 1 && last === 0 ?
	
					// Shortcut for :nth-*(n)
					function( elem ) {
						return !!elem.parentNode;
					} :
	
					function( elem, context, xml ) {
						var cache, outerCache, node, diff, nodeIndex, start,
							dir = simple !== forward ? "nextSibling" : "previousSibling",
							parent = elem.parentNode,
							name = ofType && elem.nodeName.toLowerCase(),
							useCache = !xml && !ofType;
	
						if ( parent ) {
	
							// :(first|last|only)-(child|of-type)
							if ( simple ) {
								while ( dir ) {
									node = elem;
									while ( (node = node[ dir ]) ) {
										if ( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1 ) {
											return false;
										}
									}
									// Reverse direction for :only-* (if we haven't yet done so)
									start = dir = type === "only" && !start && "nextSibling";
								}
								return true;
							}
	
							start = [ forward ? parent.firstChild : parent.lastChild ];
	
							// non-xml :nth-child(...) stores cache data on `parent`
							if ( forward && useCache ) {
								// Seek `elem` from a previously-cached index
								outerCache = parent[ expando ] || (parent[ expando ] = {});
								cache = outerCache[ type ] || [];
								nodeIndex = cache[0] === dirruns && cache[1];
								diff = cache[0] === dirruns && cache[2];
								node = nodeIndex && parent.childNodes[ nodeIndex ];
	
								while ( (node = ++nodeIndex && node && node[ dir ] ||
	
									// Fallback to seeking `elem` from the start
									(diff = nodeIndex = 0) || start.pop()) ) {
	
									// When found, cache indexes on `parent` and break
									if ( node.nodeType === 1 && ++diff && node === elem ) {
										outerCache[ type ] = [ dirruns, nodeIndex, diff ];
										break;
									}
								}
	
							// Use previously-cached element index if available
							} else if ( useCache && (cache = (elem[ expando ] || (elem[ expando ] = {}))[ type ]) && cache[0] === dirruns ) {
								diff = cache[1];
	
							// xml :nth-child(...) or :nth-last-child(...) or :nth(-last)?-of-type(...)
							} else {
								// Use the same loop as above to seek `elem` from the start
								while ( (node = ++nodeIndex && node && node[ dir ] ||
									(diff = nodeIndex = 0) || start.pop()) ) {
	
									if ( ( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1 ) && ++diff ) {
										// Cache the index of each encountered element
										if ( useCache ) {
											(node[ expando ] || (node[ expando ] = {}))[ type ] = [ dirruns, diff ];
										}
	
										if ( node === elem ) {
											break;
										}
									}
								}
							}
	
							// Incorporate the offset, then check against cycle size
							diff -= last;
							return diff === first || ( diff % first === 0 && diff / first >= 0 );
						}
					};
			},
	
			"PSEUDO": function( pseudo, argument ) {
				// pseudo-class names are case-insensitive
				// http://www.w3.org/TR/selectors/#pseudo-classes
				// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
				// Remember that setFilters inherits from pseudos
				var args,
					fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
						Sizzle.error( "unsupported pseudo: " + pseudo );
	
				// The user may use createPseudo to indicate that
				// arguments are needed to create the filter function
				// just as Sizzle does
				if ( fn[ expando ] ) {
					return fn( argument );
				}
	
				// But maintain support for old signatures
				if ( fn.length > 1 ) {
					args = [ pseudo, pseudo, "", argument ];
					return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
						markFunction(function( seed, matches ) {
							var idx,
								matched = fn( seed, argument ),
								i = matched.length;
							while ( i-- ) {
								idx = indexOf.call( seed, matched[i] );
								seed[ idx ] = !( matches[ idx ] = matched[i] );
							}
						}) :
						function( elem ) {
							return fn( elem, 0, args );
						};
				}
	
				return fn;
			}
		},
	
		pseudos: {
			// Potentially complex pseudos
			"not": markFunction(function( selector ) {
				// Trim the selector passed to compile
				// to avoid treating leading and trailing
				// spaces as combinators
				var input = [],
					results = [],
					matcher = compile( selector.replace( rtrim, "$1" ) );
	
				return matcher[ expando ] ?
					markFunction(function( seed, matches, context, xml ) {
						var elem,
							unmatched = matcher( seed, null, xml, [] ),
							i = seed.length;
	
						// Match elements unmatched by `matcher`
						while ( i-- ) {
							if ( (elem = unmatched[i]) ) {
								seed[i] = !(matches[i] = elem);
							}
						}
					}) :
					function( elem, context, xml ) {
						input[0] = elem;
						matcher( input, null, xml, results );
						return !results.pop();
					};
			}),
	
			"has": markFunction(function( selector ) {
				return function( elem ) {
					return Sizzle( selector, elem ).length > 0;
				};
			}),
	
			"contains": markFunction(function( text ) {
				text = text.replace( runescape, funescape );
				return function( elem ) {
					return ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;
				};
			}),
	
			// "Whether an element is represented by a :lang() selector
			// is based solely on the element's language value
			// being equal to the identifier C,
			// or beginning with the identifier C immediately followed by "-".
			// The matching of C against the element's language value is performed case-insensitively.
			// The identifier C does not have to be a valid language name."
			// http://www.w3.org/TR/selectors/#lang-pseudo
			"lang": markFunction( function( lang ) {
				// lang value must be a valid identifier
				if ( !ridentifier.test(lang || "") ) {
					Sizzle.error( "unsupported lang: " + lang );
				}
				lang = lang.replace( runescape, funescape ).toLowerCase();
				return function( elem ) {
					var elemLang;
					do {
						if ( (elemLang = documentIsHTML ?
							elem.lang :
							elem.getAttribute("xml:lang") || elem.getAttribute("lang")) ) {
	
							elemLang = elemLang.toLowerCase();
							return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
						}
					} while ( (elem = elem.parentNode) && elem.nodeType === 1 );
					return false;
				};
			}),
	
			// Miscellaneous
			"target": function( elem ) {
				var hash = window.location && window.location.hash;
				return hash && hash.slice( 1 ) === elem.id;
			},
	
			"root": function( elem ) {
				return elem === docElem;
			},
	
			"focus": function( elem ) {
				return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
			},
	
			// Boolean properties
			"enabled": function( elem ) {
				return elem.disabled === false;
			},
	
			"disabled": function( elem ) {
				return elem.disabled === true;
			},
	
			"checked": function( elem ) {
				// In CSS3, :checked should return both checked and selected elements
				// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
				var nodeName = elem.nodeName.toLowerCase();
				return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
			},
	
			"selected": function( elem ) {
				// Accessing this property makes selected-by-default
				// options in Safari work properly
				if ( elem.parentNode ) {
					elem.parentNode.selectedIndex;
				}
	
				return elem.selected === true;
			},
	
			// Contents
			"empty": function( elem ) {
				// http://www.w3.org/TR/selectors/#empty-pseudo
				// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
				//   but not by others (comment: 8; processing instruction: 7; etc.)
				// nodeType < 6 works because attributes (2) do not appear as children
				for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
					if ( elem.nodeType < 6 ) {
						return false;
					}
				}
				return true;
			},
	
			"parent": function( elem ) {
				return !Expr.pseudos["empty"]( elem );
			},
	
			// Element/input types
			"header": function( elem ) {
				return rheader.test( elem.nodeName );
			},
	
			"input": function( elem ) {
				return rinputs.test( elem.nodeName );
			},
	
			"button": function( elem ) {
				var name = elem.nodeName.toLowerCase();
				return name === "input" && elem.type === "button" || name === "button";
			},
	
			"text": function( elem ) {
				var attr;
				return elem.nodeName.toLowerCase() === "input" &&
					elem.type === "text" &&
	
					// Support: IE<8
					// New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
					( (attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text" );
			},
	
			// Position-in-collection
			"first": createPositionalPseudo(function() {
				return [ 0 ];
			}),
	
			"last": createPositionalPseudo(function( matchIndexes, length ) {
				return [ length - 1 ];
			}),
	
			"eq": createPositionalPseudo(function( matchIndexes, length, argument ) {
				return [ argument < 0 ? argument + length : argument ];
			}),
	
			"even": createPositionalPseudo(function( matchIndexes, length ) {
				var i = 0;
				for ( ; i < length; i += 2 ) {
					matchIndexes.push( i );
				}
				return matchIndexes;
			}),
	
			"odd": createPositionalPseudo(function( matchIndexes, length ) {
				var i = 1;
				for ( ; i < length; i += 2 ) {
					matchIndexes.push( i );
				}
				return matchIndexes;
			}),
	
			"lt": createPositionalPseudo(function( matchIndexes, length, argument ) {
				var i = argument < 0 ? argument + length : argument;
				for ( ; --i >= 0; ) {
					matchIndexes.push( i );
				}
				return matchIndexes;
			}),
	
			"gt": createPositionalPseudo(function( matchIndexes, length, argument ) {
				var i = argument < 0 ? argument + length : argument;
				for ( ; ++i < length; ) {
					matchIndexes.push( i );
				}
				return matchIndexes;
			})
		}
	};
	
	Expr.pseudos["nth"] = Expr.pseudos["eq"];
	
	// Add button/input type pseudos
	for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
		Expr.pseudos[ i ] = createInputPseudo( i );
	}
	for ( i in { submit: true, reset: true } ) {
		Expr.pseudos[ i ] = createButtonPseudo( i );
	}
	
	// Easy API for creating new setFilters
	function setFilters() {}
	setFilters.prototype = Expr.filters = Expr.pseudos;
	Expr.setFilters = new setFilters();
	
	tokenize = Sizzle.tokenize = function( selector, parseOnly ) {
		var matched, match, tokens, type,
			soFar, groups, preFilters,
			cached = tokenCache[ selector + " " ];
	
		if ( cached ) {
			return parseOnly ? 0 : cached.slice( 0 );
		}
	
		soFar = selector;
		groups = [];
		preFilters = Expr.preFilter;
	
		while ( soFar ) {
	
			// Comma and first run
			if ( !matched || (match = rcomma.exec( soFar )) ) {
				if ( match ) {
					// Don't consume trailing commas as valid
					soFar = soFar.slice( match[0].length ) || soFar;
				}
				groups.push( (tokens = []) );
			}
	
			matched = false;
	
			// Combinators
			if ( (match = rcombinators.exec( soFar )) ) {
				matched = match.shift();
				tokens.push({
					value: matched,
					// Cast descendant combinators to space
					type: match[0].replace( rtrim, " " )
				});
				soFar = soFar.slice( matched.length );
			}
	
			// Filters
			for ( type in Expr.filter ) {
				if ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||
					(match = preFilters[ type ]( match ))) ) {
					matched = match.shift();
					tokens.push({
						value: matched,
						type: type,
						matches: match
					});
					soFar = soFar.slice( matched.length );
				}
			}
	
			if ( !matched ) {
				break;
			}
		}
	
		// Return the length of the invalid excess
		// if we're just parsing
		// Otherwise, throw an error or return tokens
		return parseOnly ?
			soFar.length :
			soFar ?
				Sizzle.error( selector ) :
				// Cache the tokens
				tokenCache( selector, groups ).slice( 0 );
	};
	
	function toSelector( tokens ) {
		var i = 0,
			len = tokens.length,
			selector = "";
		for ( ; i < len; i++ ) {
			selector += tokens[i].value;
		}
		return selector;
	}
	
	function addCombinator( matcher, combinator, base ) {
		var dir = combinator.dir,
			checkNonElements = base && dir === "parentNode",
			doneName = done++;
	
		return combinator.first ?
			// Check against closest ancestor/preceding element
			function( elem, context, xml ) {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						return matcher( elem, context, xml );
					}
				}
			} :
	
			// Check against all ancestor/preceding elements
			function( elem, context, xml ) {
				var oldCache, outerCache,
					newCache = [ dirruns, doneName ];
	
				// We can't set arbitrary data on XML nodes, so they don't benefit from dir caching
				if ( xml ) {
					while ( (elem = elem[ dir ]) ) {
						if ( elem.nodeType === 1 || checkNonElements ) {
							if ( matcher( elem, context, xml ) ) {
								return true;
							}
						}
					}
				} else {
					while ( (elem = elem[ dir ]) ) {
						if ( elem.nodeType === 1 || checkNonElements ) {
							outerCache = elem[ expando ] || (elem[ expando ] = {});
							if ( (oldCache = outerCache[ dir ]) &&
								oldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {
	
								// Assign to newCache so results back-propagate to previous elements
								return (newCache[ 2 ] = oldCache[ 2 ]);
							} else {
								// Reuse newcache so results back-propagate to previous elements
								outerCache[ dir ] = newCache;
	
								// A match means we're done; a fail means we have to keep checking
								if ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {
									return true;
								}
							}
						}
					}
				}
			};
	}
	
	function elementMatcher( matchers ) {
		return matchers.length > 1 ?
			function( elem, context, xml ) {
				var i = matchers.length;
				while ( i-- ) {
					if ( !matchers[i]( elem, context, xml ) ) {
						return false;
					}
				}
				return true;
			} :
			matchers[0];
	}
	
	function multipleContexts( selector, contexts, results ) {
		var i = 0,
			len = contexts.length;
		for ( ; i < len; i++ ) {
			Sizzle( selector, contexts[i], results );
		}
		return results;
	}
	
	function condense( unmatched, map, filter, context, xml ) {
		var elem,
			newUnmatched = [],
			i = 0,
			len = unmatched.length,
			mapped = map != null;
	
		for ( ; i < len; i++ ) {
			if ( (elem = unmatched[i]) ) {
				if ( !filter || filter( elem, context, xml ) ) {
					newUnmatched.push( elem );
					if ( mapped ) {
						map.push( i );
					}
				}
			}
		}
	
		return newUnmatched;
	}
	
	function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
		if ( postFilter && !postFilter[ expando ] ) {
			postFilter = setMatcher( postFilter );
		}
		if ( postFinder && !postFinder[ expando ] ) {
			postFinder = setMatcher( postFinder, postSelector );
		}
		return markFunction(function( seed, results, context, xml ) {
			var temp, i, elem,
				preMap = [],
				postMap = [],
				preexisting = results.length,
	
				// Get initial elements from seed or context
				elems = seed || multipleContexts( selector || "*", context.nodeType ? [ context ] : context, [] ),
	
				// Prefilter to get matcher input, preserving a map for seed-results synchronization
				matcherIn = preFilter && ( seed || !selector ) ?
					condense( elems, preMap, preFilter, context, xml ) :
					elems,
	
				matcherOut = matcher ?
					// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
					postFinder || ( seed ? preFilter : preexisting || postFilter ) ?
	
						// ...intermediate processing is necessary
						[] :
	
						// ...otherwise use results directly
						results :
					matcherIn;
	
			// Find primary matches
			if ( matcher ) {
				matcher( matcherIn, matcherOut, context, xml );
			}
	
			// Apply postFilter
			if ( postFilter ) {
				temp = condense( matcherOut, postMap );
				postFilter( temp, [], context, xml );
	
				// Un-match failing elements by moving them back to matcherIn
				i = temp.length;
				while ( i-- ) {
					if ( (elem = temp[i]) ) {
						matcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);
					}
				}
			}
	
			if ( seed ) {
				if ( postFinder || preFilter ) {
					if ( postFinder ) {
						// Get the final matcherOut by condensing this intermediate into postFinder contexts
						temp = [];
						i = matcherOut.length;
						while ( i-- ) {
							if ( (elem = matcherOut[i]) ) {
								// Restore matcherIn since elem is not yet a final match
								temp.push( (matcherIn[i] = elem) );
							}
						}
						postFinder( null, (matcherOut = []), temp, xml );
					}
	
					// Move matched elements from seed to results to keep them synchronized
					i = matcherOut.length;
					while ( i-- ) {
						if ( (elem = matcherOut[i]) &&
							(temp = postFinder ? indexOf.call( seed, elem ) : preMap[i]) > -1 ) {
	
							seed[temp] = !(results[temp] = elem);
						}
					}
				}
	
			// Add elements to results, through postFinder if defined
			} else {
				matcherOut = condense(
					matcherOut === results ?
						matcherOut.splice( preexisting, matcherOut.length ) :
						matcherOut
				);
				if ( postFinder ) {
					postFinder( null, results, matcherOut, xml );
				} else {
					push.apply( results, matcherOut );
				}
			}
		});
	}
	
	function matcherFromTokens( tokens ) {
		var checkContext, matcher, j,
			len = tokens.length,
			leadingRelative = Expr.relative[ tokens[0].type ],
			implicitRelative = leadingRelative || Expr.relative[" "],
			i = leadingRelative ? 1 : 0,
	
			// The foundational matcher ensures that elements are reachable from top-level context(s)
			matchContext = addCombinator( function( elem ) {
				return elem === checkContext;
			}, implicitRelative, true ),
			matchAnyContext = addCombinator( function( elem ) {
				return indexOf.call( checkContext, elem ) > -1;
			}, implicitRelative, true ),
			matchers = [ function( elem, context, xml ) {
				return ( !leadingRelative && ( xml || context !== outermostContext ) ) || (
					(checkContext = context).nodeType ?
						matchContext( elem, context, xml ) :
						matchAnyContext( elem, context, xml ) );
			} ];
	
		for ( ; i < len; i++ ) {
			if ( (matcher = Expr.relative[ tokens[i].type ]) ) {
				matchers = [ addCombinator(elementMatcher( matchers ), matcher) ];
			} else {
				matcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );
	
				// Return special upon seeing a positional matcher
				if ( matcher[ expando ] ) {
					// Find the next relative operator (if any) for proper handling
					j = ++i;
					for ( ; j < len; j++ ) {
						if ( Expr.relative[ tokens[j].type ] ) {
							break;
						}
					}
					return setMatcher(
						i > 1 && elementMatcher( matchers ),
						i > 1 && toSelector(
							// If the preceding token was a descendant combinator, insert an implicit any-element `*`
							tokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === " " ? "*" : "" })
						).replace( rtrim, "$1" ),
						matcher,
						i < j && matcherFromTokens( tokens.slice( i, j ) ),
						j < len && matcherFromTokens( (tokens = tokens.slice( j )) ),
						j < len && toSelector( tokens )
					);
				}
				matchers.push( matcher );
			}
		}
	
		return elementMatcher( matchers );
	}
	
	function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
		var bySet = setMatchers.length > 0,
			byElement = elementMatchers.length > 0,
			superMatcher = function( seed, context, xml, results, outermost ) {
				var elem, j, matcher,
					matchedCount = 0,
					i = "0",
					unmatched = seed && [],
					setMatched = [],
					contextBackup = outermostContext,
					// We must always have either seed elements or outermost context
					elems = seed || byElement && Expr.find["TAG"]( "*", outermost ),
					// Use integer dirruns iff this is the outermost matcher
					dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),
					len = elems.length;
	
				if ( outermost ) {
					outermostContext = context !== document && context;
				}
	
				// Add elements passing elementMatchers directly to results
				// Keep `i` a string if there are no elements so `matchedCount` will be "00" below
				// Support: IE<9, Safari
				// Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
				for ( ; i !== len && (elem = elems[i]) != null; i++ ) {
					if ( byElement && elem ) {
						j = 0;
						while ( (matcher = elementMatchers[j++]) ) {
							if ( matcher( elem, context, xml ) ) {
								results.push( elem );
								break;
							}
						}
						if ( outermost ) {
							dirruns = dirrunsUnique;
						}
					}
	
					// Track unmatched elements for set filters
					if ( bySet ) {
						// They will have gone through all possible matchers
						if ( (elem = !matcher && elem) ) {
							matchedCount--;
						}
	
						// Lengthen the array for every element, matched or not
						if ( seed ) {
							unmatched.push( elem );
						}
					}
				}
	
				// Apply set filters to unmatched elements
				matchedCount += i;
				if ( bySet && i !== matchedCount ) {
					j = 0;
					while ( (matcher = setMatchers[j++]) ) {
						matcher( unmatched, setMatched, context, xml );
					}
	
					if ( seed ) {
						// Reintegrate element matches to eliminate the need for sorting
						if ( matchedCount > 0 ) {
							while ( i-- ) {
								if ( !(unmatched[i] || setMatched[i]) ) {
									setMatched[i] = pop.call( results );
								}
							}
						}
	
						// Discard index placeholder values to get only actual matches
						setMatched = condense( setMatched );
					}
	
					// Add matches to results
					push.apply( results, setMatched );
	
					// Seedless set matches succeeding multiple successful matchers stipulate sorting
					if ( outermost && !seed && setMatched.length > 0 &&
						( matchedCount + setMatchers.length ) > 1 ) {
	
						Sizzle.uniqueSort( results );
					}
				}
	
				// Override manipulation of globals by nested matchers
				if ( outermost ) {
					dirruns = dirrunsUnique;
					outermostContext = contextBackup;
				}
	
				return unmatched;
			};
	
		return bySet ?
			markFunction( superMatcher ) :
			superMatcher;
	}
	
	compile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {
		var i,
			setMatchers = [],
			elementMatchers = [],
			cached = compilerCache[ selector + " " ];
	
		if ( !cached ) {
			// Generate a function of recursive functions that can be used to check each element
			if ( !match ) {
				match = tokenize( selector );
			}
			i = match.length;
			while ( i-- ) {
				cached = matcherFromTokens( match[i] );
				if ( cached[ expando ] ) {
					setMatchers.push( cached );
				} else {
					elementMatchers.push( cached );
				}
			}
	
			// Cache the compiled function
			cached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );
	
			// Save selector and tokenization
			cached.selector = selector;
		}
		return cached;
	};
	
	/**
	 * A low-level selection function that works with Sizzle's compiled
	 *  selector functions
	 * @param {String|Function} selector A selector or a pre-compiled
	 *  selector function built with Sizzle.compile
	 * @param {Element} context
	 * @param {Array} [results]
	 * @param {Array} [seed] A set of elements to match against
	 */
	select = Sizzle.select = function( selector, context, results, seed ) {
		var i, tokens, token, type, find,
			compiled = typeof selector === "function" && selector,
			match = !seed && tokenize( (selector = compiled.selector || selector) );
	
		results = results || [];
	
		// Try to minimize operations if there is no seed and only one group
		if ( match.length === 1 ) {
	
			// Take a shortcut and set the context if the root selector is an ID
			tokens = match[0] = match[0].slice( 0 );
			if ( tokens.length > 2 && (token = tokens[0]).type === "ID" &&
					support.getById && context.nodeType === 9 && documentIsHTML &&
					Expr.relative[ tokens[1].type ] ) {
	
				context = ( Expr.find["ID"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];
				if ( !context ) {
					return results;
	
				// Precompiled matchers will still verify ancestry, so step up a level
				} else if ( compiled ) {
					context = context.parentNode;
				}
	
				selector = selector.slice( tokens.shift().value.length );
			}
	
			// Fetch a seed set for right-to-left matching
			i = matchExpr["needsContext"].test( selector ) ? 0 : tokens.length;
			while ( i-- ) {
				token = tokens[i];
	
				// Abort if we hit a combinator
				if ( Expr.relative[ (type = token.type) ] ) {
					break;
				}
				if ( (find = Expr.find[ type ]) ) {
					// Search, expanding context for leading sibling combinators
					if ( (seed = find(
						token.matches[0].replace( runescape, funescape ),
						rsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context
					)) ) {
	
						// If seed is empty or no tokens remain, we can return early
						tokens.splice( i, 1 );
						selector = seed.length && toSelector( tokens );
						if ( !selector ) {
							push.apply( results, seed );
							return results;
						}
	
						break;
					}
				}
			}
		}
	
		// Compile and execute a filtering function if one is not provided
		// Provide `match` to avoid retokenization if we modified the selector above
		( compiled || compile( selector, match ) )(
			seed,
			context,
			!documentIsHTML,
			results,
			rsibling.test( selector ) && testContext( context.parentNode ) || context
		);
		return results;
	};
	
	// One-time assignments
	
	// Sort stability
	support.sortStable = expando.split("").sort( sortOrder ).join("") === expando;
	
	// Support: Chrome 14-35+
	// Always assume duplicates if they aren't passed to the comparison function
	support.detectDuplicates = !!hasDuplicate;
	
	// Initialize against the default document
	setDocument();
	
	// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
	// Detached nodes confoundingly follow *each other*
	support.sortDetached = assert(function( div1 ) {
		// Should return 1, but returns 4 (following)
		return div1.compareDocumentPosition( document.createElement("div") ) & 1;
	});
	
	// Support: IE<8
	// Prevent attribute/property "interpolation"
	// http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
	if ( !assert(function( div ) {
		div.innerHTML = "<a href='#'></a>";
		return div.firstChild.getAttribute("href") === "#" ;
	}) ) {
		addHandle( "type|href|height|width", function( elem, name, isXML ) {
			if ( !isXML ) {
				return elem.getAttribute( name, name.toLowerCase() === "type" ? 1 : 2 );
			}
		});
	}
	
	// Support: IE<9
	// Use defaultValue in place of getAttribute("value")
	if ( !support.attributes || !assert(function( div ) {
		div.innerHTML = "<input/>";
		div.firstChild.setAttribute( "value", "" );
		return div.firstChild.getAttribute( "value" ) === "";
	}) ) {
		addHandle( "value", function( elem, name, isXML ) {
			if ( !isXML && elem.nodeName.toLowerCase() === "input" ) {
				return elem.defaultValue;
			}
		});
	}
	
	// Support: IE<9
	// Use getAttributeNode to fetch booleans when getAttribute lies
	if ( !assert(function( div ) {
		return div.getAttribute("disabled") == null;
	}) ) {
		addHandle( booleans, function( elem, name, isXML ) {
			var val;
			if ( !isXML ) {
				return elem[ name ] === true ? name.toLowerCase() :
						(val = elem.getAttributeNode( name )) && val.specified ?
						val.value :
					null;
			}
		});
	}
	
	// EXPOSE
	return Sizzle;
	});
	
	/*eslint-enable */
	
	// Included from: js/tinymce/classes/util/Arr.js
	
	/**
	 * Arr.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * Array utility class.
	 *
	 * @private
	 * @class tinymce.util.Arr
	 */
	define("tinymce/util/Arr", [], function() {
		var isArray = Array.isArray || function(obj) {
			return Object.prototype.toString.call(obj) === "[object Array]";
		};
	
		function toArray(obj) {
			var array = obj, i, l;
	
			if (!isArray(obj)) {
				array = [];
				for (i = 0, l = obj.length; i < l; i++) {
					array[i] = obj[i];
				}
			}
	
			return array;
		}
	
		function each(o, cb, s) {
			var n, l;
	
			if (!o) {
				return 0;
			}
	
			s = s || o;
	
			if (o.length !== undefined) {
				// Indexed arrays, needed for Safari
				for (n = 0, l = o.length; n < l; n++) {
					if (cb.call(s, o[n], n, o) === false) {
						return 0;
					}
				}
			} else {
				// Hashtables
				for (n in o) {
					if (o.hasOwnProperty(n)) {
						if (cb.call(s, o[n], n, o) === false) {
							return 0;
						}
					}
				}
			}
	
			return 1;
		}
	
		function map(array, callback) {
			var out = [];
	
			each(array, function(item, index) {
				out.push(callback(item, index, array));
			});
	
			return out;
		}
	
		function filter(a, f) {
			var o = [];
	
			each(a, function(v, index) {
				if (!f || f(v, index, a)) {
					o.push(v);
				}
			});
	
			return o;
		}
	
		function indexOf(a, v) {
			var i, l;
	
			if (a) {
				for (i = 0, l = a.length; i < l; i++) {
					if (a[i] === v) {
						return i;
					}
				}
			}
	
			return -1;
		}
	
		function reduce(collection, iteratee, accumulator, thisArg) {
			var i = 0;
	
			if (arguments.length < 3) {
				accumulator = collection[0];
			}
	
			for (; i < collection.length; i++) {
				accumulator = iteratee.call(thisArg, accumulator, collection[i], i);
			}
	
			return accumulator;
		}
	
		function findIndex(array, predicate, thisArg) {
			var i, l;
	
			for (i = 0, l = array.length; i < l; i++) {
				if (predicate.call(thisArg, array[i], i, array)) {
					return i;
				}
			}
	
			return -1;
		}
	
		function find(array, predicate, thisArg) {
			var idx = findIndex(array, predicate, thisArg);
	
			if (idx !== -1) {
				return array[idx];
			}
	
			return undefined;
		}
	
		function last(collection) {
			return collection[collection.length - 1];
		}
	
		return {
			isArray: isArray,
			toArray: toArray,
			each: each,
			map: map,
			filter: filter,
			indexOf: indexOf,
			reduce: reduce,
			findIndex: findIndex,
			find: find,
			last: last
		};
	});
	
	// Included from: js/tinymce/classes/util/Tools.js
	
	/**
	 * Tools.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * This class contains various utlity functions. These are also exposed
	 * directly on the tinymce namespace.
	 *
	 * @class tinymce.util.Tools
	 */
	define("tinymce/util/Tools", [
		"tinymce/Env",
		"tinymce/util/Arr"
	], function(Env, Arr) {
		/**
		 * Removes whitespace from the beginning and end of a string.
		 *
		 * @method trim
		 * @param {String} s String to remove whitespace from.
		 * @return {String} New string with removed whitespace.
		 */
		var whiteSpaceRegExp = /^\s*|\s*$/g;
	
		function trim(str) {
			return (str === null || str === undefined) ? '' : ("" + str).replace(whiteSpaceRegExp, '');
		}
	
		/**
		 * Checks if a object is of a specific type for example an array.
		 *
		 * @method is
		 * @param {Object} obj Object to check type of.
		 * @param {string} type Optional type to check for.
		 * @return {Boolean} true/false if the object is of the specified type.
		 */
		function is(obj, type) {
			if (!type) {
				return obj !== undefined;
			}
	
			if (type == 'array' && Arr.isArray(obj)) {
				return true;
			}
	
			return typeof obj == type;
		}
	
		/**
		 * Makes a name/object map out of an array with names.
		 *
		 * @method makeMap
		 * @param {Array/String} items Items to make map out of.
		 * @param {String} delim Optional delimiter to split string by.
		 * @param {Object} map Optional map to add items to.
		 * @return {Object} Name/value map of items.
		 */
		function makeMap(items, delim, map) {
			var i;
	
			items = items || [];
			delim = delim || ',';
	
			if (typeof items == "string") {
				items = items.split(delim);
			}
	
			map = map || {};
	
			i = items.length;
			while (i--) {
				map[items[i]] = {};
			}
	
			return map;
		}
	
		/**
		 * Creates a class, subclass or static singleton.
		 * More details on this method can be found in the Wiki.
		 *
		 * @method create
		 * @param {String} s Class name, inheritance and prefix.
		 * @param {Object} p Collection of methods to add to the class.
		 * @param {Object} root Optional root object defaults to the global window object.
		 * @example
		 * // Creates a basic class
		 * tinymce.create('tinymce.somepackage.SomeClass', {
		 *     SomeClass: function() {
		 *         // Class constructor
		 *     },
		 *
		 *     method: function() {
		 *         // Some method
		 *     }
		 * });
		 *
		 * // Creates a basic subclass class
		 * tinymce.create('tinymce.somepackage.SomeSubClass:tinymce.somepackage.SomeClass', {
		 *     SomeSubClass: function() {
		 *         // Class constructor
		 *         this.parent(); // Call parent constructor
		 *     },
		 *
		 *     method: function() {
		 *         // Some method
		 *         this.parent(); // Call parent method
		 *     },
		 *
		 *     'static': {
		 *         staticMethod: function() {
		 *             // Static method
		 *         }
		 *     }
		 * });
		 *
		 * // Creates a singleton/static class
		 * tinymce.create('static tinymce.somepackage.SomeSingletonClass', {
		 *     method: function() {
		 *         // Some method
		 *     }
		 * });
		 */
		function create(s, p, root) {
			var self = this, sp, ns, cn, scn, c, de = 0;
	
			// Parse : <prefix> <class>:<super class>
			s = /^((static) )?([\w.]+)(:([\w.]+))?/.exec(s);
			cn = s[3].match(/(^|\.)(\w+)$/i)[2]; // Class name
	
			// Create namespace for new class
			ns = self.createNS(s[3].replace(/\.\w+$/, ''), root);
	
			// Class already exists
			if (ns[cn]) {
				return;
			}
	
			// Make pure static class
			if (s[2] == 'static') {
				ns[cn] = p;
	
				if (this.onCreate) {
					this.onCreate(s[2], s[3], ns[cn]);
				}
	
				return;
			}
	
			// Create default constructor
			if (!p[cn]) {
				p[cn] = function() {};
				de = 1;
			}
	
			// Add constructor and methods
			ns[cn] = p[cn];
			self.extend(ns[cn].prototype, p);
	
			// Extend
			if (s[5]) {
				sp = self.resolve(s[5]).prototype;
				scn = s[5].match(/\.(\w+)$/i)[1]; // Class name
	
				// Extend constructor
				c = ns[cn];
				if (de) {
					// Add passthrough constructor
					ns[cn] = function() {
						return sp[scn].apply(this, arguments);
					};
				} else {
					// Add inherit constructor
					ns[cn] = function() {
						this.parent = sp[scn];
						return c.apply(this, arguments);
					};
				}
				ns[cn].prototype[cn] = ns[cn];
	
				// Add super methods
				self.each(sp, function(f, n) {
					ns[cn].prototype[n] = sp[n];
				});
	
				// Add overridden methods
				self.each(p, function(f, n) {
					// Extend methods if needed
					if (sp[n]) {
						ns[cn].prototype[n] = function() {
							this.parent = sp[n];
							return f.apply(this, arguments);
						};
					} else {
						if (n != cn) {
							ns[cn].prototype[n] = f;
						}
					}
				});
			}
	
			// Add static methods
			/*jshint sub:true*/
			/*eslint dot-notation:0*/
			self.each(p['static'], function(f, n) {
				ns[cn][n] = f;
			});
		}
	
		function extend(obj, ext) {
			var i, l, name, args = arguments, value;
	
			for (i = 1, l = args.length; i < l; i++) {
				ext = args[i];
				for (name in ext) {
					if (ext.hasOwnProperty(name)) {
						value = ext[name];
	
						if (value !== undefined) {
							obj[name] = value;
						}
					}
				}
			}
	
			return obj;
		}
	
		/**
		 * Executed the specified function for each item in a object tree.
		 *
		 * @method walk
		 * @param {Object} o Object tree to walk though.
		 * @param {function} f Function to call for each item.
		 * @param {String} n Optional name of collection inside the objects to walk for example childNodes.
		 * @param {String} s Optional scope to execute the function in.
		 */
		function walk(o, f, n, s) {
			s = s || this;
	
			if (o) {
				if (n) {
					o = o[n];
				}
	
				Arr.each(o, function(o, i) {
					if (f.call(s, o, i, n) === false) {
						return false;
					}
	
					walk(o, f, n, s);
				});
			}
		}
	
		/**
		 * Creates a namespace on a specific object.
		 *
		 * @method createNS
		 * @param {String} n Namespace to create for example a.b.c.d.
		 * @param {Object} o Optional object to add namespace to, defaults to window.
		 * @return {Object} New namespace object the last item in path.
		 * @example
		 * // Create some namespace
		 * tinymce.createNS('tinymce.somepackage.subpackage');
		 *
		 * // Add a singleton
		 * var tinymce.somepackage.subpackage.SomeSingleton = {
		 *     method: function() {
		 *         // Some method
		 *     }
		 * };
		 */
		function createNS(n, o) {
			var i, v;
	
			o = o || window;
	
			n = n.split('.');
			for (i = 0; i < n.length; i++) {
				v = n[i];
	
				if (!o[v]) {
					o[v] = {};
				}
	
				o = o[v];
			}
	
			return o;
		}
	
		/**
		 * Resolves a string and returns the object from a specific structure.
		 *
		 * @method resolve
		 * @param {String} n Path to resolve for example a.b.c.d.
		 * @param {Object} o Optional object to search though, defaults to window.
		 * @return {Object} Last object in path or null if it couldn't be resolved.
		 * @example
		 * // Resolve a path into an object reference
		 * var obj = tinymce.resolve('a.b.c.d');
		 */
		function resolve(n, o) {
			var i, l;
	
			o = o || window;
	
			n = n.split('.');
			for (i = 0, l = n.length; i < l; i++) {
				o = o[n[i]];
	
				if (!o) {
					break;
				}
			}
	
			return o;
		}
	
		/**
		 * Splits a string but removes the whitespace before and after each value.
		 *
		 * @method explode
		 * @param {string} s String to split.
		 * @param {string} d Delimiter to split by.
		 * @example
		 * // Split a string into an array with a,b,c
		 * var arr = tinymce.explode('a, b,   c');
		 */
		function explode(s, d) {
			if (!s || is(s, 'array')) {
				return s;
			}
	
			return Arr.map(s.split(d || ','), trim);
		}
	
		function _addCacheSuffix(url) {
			var cacheSuffix = Env.cacheSuffix;
	
			if (cacheSuffix) {
				url += (url.indexOf('?') === -1 ? '?' : '&') + cacheSuffix;
			}
	
			return url;
		}
	
		return {
			trim: trim,
	
			/**
			 * Returns true/false if the object is an array or not.
			 *
			 * @method isArray
			 * @param {Object} obj Object to check.
			 * @return {boolean} true/false state if the object is an array or not.
			 */
			isArray: Arr.isArray,
	
			is: is,
	
			/**
			 * Converts the specified object into a real JavaScript array.
			 *
			 * @method toArray
			 * @param {Object} obj Object to convert into array.
			 * @return {Array} Array object based in input.
			 */
			toArray: Arr.toArray,
			makeMap: makeMap,
	
			/**
			 * Performs an iteration of all items in a collection such as an object or array. This method will execure the
			 * callback function for each item in the collection, if the callback returns false the iteration will terminate.
			 * The callback has the following format: cb(value, key_or_index).
			 *
			 * @method each
			 * @param {Object} o Collection to iterate.
			 * @param {function} cb Callback function to execute for each item.
			 * @param {Object} s Optional scope to execute the callback in.
			 * @example
			 * // Iterate an array
			 * tinymce.each([1,2,3], function(v, i) {
			 *     console.debug("Value: " + v + ", Index: " + i);
			 * });
			 *
			 * // Iterate an object
			 * tinymce.each({a: 1, b: 2, c: 3], function(v, k) {
			 *     console.debug("Value: " + v + ", Key: " + k);
			 * });
			 */
			each: Arr.each,
	
			/**
			 * Creates a new array by the return value of each iteration function call. This enables you to convert
			 * one array list into another.
			 *
			 * @method map
			 * @param {Array} array Array of items to iterate.
			 * @param {function} callback Function to call for each item. It's return value will be the new value.
			 * @return {Array} Array with new values based on function return values.
			 */
			map: Arr.map,
	
			/**
			 * Filters out items from the input array by calling the specified function for each item.
			 * If the function returns false the item will be excluded if it returns true it will be included.
			 *
			 * @method grep
			 * @param {Array} a Array of items to loop though.
			 * @param {function} f Function to call for each item. Include/exclude depends on it's return value.
			 * @return {Array} New array with values imported and filtered based in input.
			 * @example
			 * // Filter out some items, this will return an array with 4 and 5
			 * var items = tinymce.grep([1,2,3,4,5], function(v) {return v > 3;});
			 */
			grep: Arr.filter,
	
			/**
			 * Returns true/false if the object is an array or not.
			 *
			 * @method isArray
			 * @param {Object} obj Object to check.
			 * @return {boolean} true/false state if the object is an array or not.
			 */
			inArray: Arr.indexOf,
	
			extend: extend,
			create: create,
			walk: walk,
			createNS: createNS,
			resolve: resolve,
			explode: explode,
			_addCacheSuffix: _addCacheSuffix
		};
	});
	
	// Included from: js/tinymce/classes/dom/DomQuery.js
	
	/**
	 * DomQuery.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * This class mimics most of the jQuery API:
	 *
	 * This is whats currently implemented:
	 * - Utility functions
	 * - DOM traversial
	 * - DOM manipulation
	 * - Event binding
	 *
	 * This is not currently implemented:
	 * - Dimension
	 * - Ajax
	 * - Animation
	 * - Advanced chaining
	 *
	 * @example
	 * var $ = tinymce.dom.DomQuery;
	 * $('p').attr('attr', 'value').addClass('class');
	 *
	 * @class tinymce.dom.DomQuery
	 */
	define("tinymce/dom/DomQuery", [
		"tinymce/dom/EventUtils",
		"tinymce/dom/Sizzle",
		"tinymce/util/Tools",
		"tinymce/Env"
	], function(EventUtils, Sizzle, Tools, Env) {
		var doc = document, push = Array.prototype.push, slice = Array.prototype.slice;
		var rquickExpr = /^(?:[^#<]*(<[\w\W]+>)[^>]*$|#([\w\-]*)$)/;
		var Event = EventUtils.Event, undef;
		var skipUniques = Tools.makeMap('children,contents,next,prev');
	
		function isDefined(obj) {
			return typeof obj !== 'undefined';
		}
	
		function isString(obj) {
			return typeof obj === 'string';
		}
	
		function isWindow(obj) {
			return obj && obj == obj.window;
		}
	
		function createFragment(html, fragDoc) {
			var frag, node, container;
	
			fragDoc = fragDoc || doc;
			container = fragDoc.createElement('div');
			frag = fragDoc.createDocumentFragment();
			container.innerHTML = html;
	
			while ((node = container.firstChild)) {
				frag.appendChild(node);
			}
	
			return frag;
		}
	
		function domManipulate(targetNodes, sourceItem, callback, reverse) {
			var i;
	
			if (isString(sourceItem)) {
				sourceItem = createFragment(sourceItem, getElementDocument(targetNodes[0]));
			} else if (sourceItem.length && !sourceItem.nodeType) {
				sourceItem = DomQuery.makeArray(sourceItem);
	
				if (reverse) {
					for (i = sourceItem.length - 1; i >= 0; i--) {
						domManipulate(targetNodes, sourceItem[i], callback, reverse);
					}
				} else {
					for (i = 0; i < sourceItem.length; i++) {
						domManipulate(targetNodes, sourceItem[i], callback, reverse);
					}
				}
	
				return targetNodes;
			}
	
			if (sourceItem.nodeType) {
				i = targetNodes.length;
				while (i--) {
					callback.call(targetNodes[i], sourceItem);
				}
			}
	
			return targetNodes;
		}
	
		function hasClass(node, className) {
			return node && className && (' ' + node.className + ' ').indexOf(' ' + className + ' ') !== -1;
		}
	
		function wrap(elements, wrapper, all) {
			var lastParent, newWrapper;
	
			wrapper = DomQuery(wrapper)[0];
	
			elements.each(function() {
				var self = this;
	
				if (!all || lastParent != self.parentNode) {
					lastParent = self.parentNode;
					newWrapper = wrapper.cloneNode(false);
					self.parentNode.insertBefore(newWrapper, self);
					newWrapper.appendChild(self);
				} else {
					newWrapper.appendChild(self);
				}
			});
	
			return elements;
		}
	
		var numericCssMap = Tools.makeMap('fillOpacity fontWeight lineHeight opacity orphans widows zIndex zoom', ' ');
		var booleanMap = Tools.makeMap('checked compact declare defer disabled ismap multiple nohref noshade nowrap readonly selected', ' ');
		var propFix = {
			'for': 'htmlFor',
			'class': 'className',
			'readonly': 'readOnly'
		};
		var cssFix = {
			'float': 'cssFloat'
		};
	
		var attrHooks = {}, cssHooks = {};
	
		function DomQuery(selector, context) {
			/*eslint new-cap:0 */
			return new DomQuery.fn.init(selector, context);
		}
	
		function inArray(item, array) {
			var i;
	
			if (array.indexOf) {
				return array.indexOf(item);
			}
	
			i = array.length;
			while (i--) {
				if (array[i] === item) {
					return i;
				}
			}
	
			return -1;
		}
	
		var whiteSpaceRegExp = /^\s*|\s*$/g;
	
		function trim(str) {
			return (str === null || str === undef) ? '' : ("" + str).replace(whiteSpaceRegExp, '');
		}
	
		function each(obj, callback) {
			var length, key, i, undef, value;
	
			if (obj) {
				length = obj.length;
	
				if (length === undef) {
					// Loop object items
					for (key in obj) {
						if (obj.hasOwnProperty(key)) {
							value = obj[key];
							if (callback.call(value, key, value) === false) {
								break;
							}
						}
					}
				} else {
					// Loop array items
					for (i = 0; i < length; i++) {
						value = obj[i];
						if (callback.call(value, i, value) === false) {
							break;
						}
					}
				}
			}
	
			return obj;
		}
	
		function grep(array, callback) {
			var out = [];
	
			each(array, function(i, item) {
				if (callback(item, i)) {
					out.push(item);
				}
			});
	
			return out;
		}
	
		function getElementDocument(element) {
			if (!element) {
				return doc;
			}
	
			if (element.nodeType == 9) {
				return element;
			}
	
			return element.ownerDocument;
		}
	
		DomQuery.fn = DomQuery.prototype = {
			constructor: DomQuery,
	
			/**
			 * Selector for the current set.
			 *
			 * @property selector
			 * @type String
			 */
			selector: "",
	
			/**
			 * Context used to create the set.
			 *
			 * @property context
			 * @type Element
			 */
			context: null,
	
			/**
			 * Number of items in the current set.
			 *
			 * @property length
			 * @type Number
			 */
			length: 0,
	
			/**
			 * Constructs a new DomQuery instance with the specified selector or context.
			 *
			 * @constructor
			 * @method init
			 * @param {String/Array/DomQuery} selector Optional CSS selector/Array or array like object or HTML string.
			 * @param {Document/Element} context Optional context to search in.
			 */
			init: function(selector, context) {
				var self = this, match, node;
	
				if (!selector) {
					return self;
				}
	
				if (selector.nodeType) {
					self.context = self[0] = selector;
					self.length = 1;
	
					return self;
				}
	
				if (context && context.nodeType) {
					self.context = context;
				} else {
					if (context) {
						return DomQuery(selector).attr(context);
					}
	
					self.context = context = document;
				}
	
				if (isString(selector)) {
					self.selector = selector;
	
					if (selector.charAt(0) === "<" && selector.charAt(selector.length - 1) === ">" && selector.length >= 3) {
						match = [null, selector, null];
					} else {
						match = rquickExpr.exec(selector);
					}
	
					if (match) {
						if (match[1]) {
							node = createFragment(selector, getElementDocument(context)).firstChild;
	
							while (node) {
								push.call(self, node);
								node = node.nextSibling;
							}
						} else {
							node = getElementDocument(context).getElementById(match[2]);
	
							if (!node) {
								return self;
							}
	
							if (node.id !== match[2]) {
								return self.find(selector);
							}
	
							self.length = 1;
							self[0] = node;
						}
					} else {
						return DomQuery(context).find(selector);
					}
				} else {
					this.add(selector, false);
				}
	
				return self;
			},
	
			/**
			 * Converts the current set to an array.
			 *
			 * @method toArray
			 * @return {Array} Array of all nodes in set.
			 */
			toArray: function() {
				return Tools.toArray(this);
			},
	
			/**
			 * Adds new nodes to the set.
			 *
			 * @method add
			 * @param {Array/tinymce.dom.DomQuery} items Array of all nodes to add to set.
			 * @param {Boolean} sort Optional sort flag that enables sorting of elements.
			 * @return {tinymce.dom.DomQuery} New instance with nodes added.
			 */
			add: function(items, sort) {
				var self = this, nodes, i;
	
				if (isString(items)) {
					return self.add(DomQuery(items));
				}
	
				if (sort !== false) {
					nodes = DomQuery.unique(self.toArray().concat(DomQuery.makeArray(items)));
					self.length = nodes.length;
					for (i = 0; i < nodes.length; i++) {
						self[i] = nodes[i];
					}
				} else {
					push.apply(self, DomQuery.makeArray(items));
				}
	
				return self;
			},
	
			/**
			 * Sets/gets attributes on the elements in the current set.
			 *
			 * @method attr
			 * @param {String/Object} name Name of attribute to get or an object with attributes to set.
			 * @param {String} value Optional value to set.
			 * @return {tinymce.dom.DomQuery/String} Current set or the specified attribute when only the name is specified.
			 */
			attr: function(name, value) {
				var self = this, hook;
	
				if (typeof name === "object") {
					each(name, function(name, value) {
						self.attr(name, value);
					});
				} else if (isDefined(value)) {
					this.each(function() {
						var hook;
	
						if (this.nodeType === 1) {
							hook = attrHooks[name];
							if (hook && hook.set) {
								hook.set(this, value);
								return;
							}
	
							if (value === null) {
								this.removeAttribute(name, 2);
							} else {
								this.setAttribute(name, value, 2);
							}
						}
					});
				} else {
					if (self[0] && self[0].nodeType === 1) {
						hook = attrHooks[name];
						if (hook && hook.get) {
							return hook.get(self[0], name);
						}
	
						if (booleanMap[name]) {
							return self.prop(name) ? name : undef;
						}
	
						value = self[0].getAttribute(name, 2);
	
						if (value === null) {
							value = undef;
						}
					}
	
					return value;
				}
	
				return self;
			},
	
			/**
			 * Removes attributse on the elements in the current set.
			 *
			 * @method removeAttr
			 * @param {String/Object} name Name of attribute to remove.
			 * @return {tinymce.dom.DomQuery/String} Current set.
			 */
			removeAttr: function(name) {
				return this.attr(name, null);
			},
	
			/**
			 * Sets/gets properties on the elements in the current set.
			 *
			 * @method attr
			 * @param {String/Object} name Name of property to get or an object with properties to set.
			 * @param {String} value Optional value to set.
			 * @return {tinymce.dom.DomQuery/String} Current set or the specified property when only the name is specified.
			 */
			prop: function(name, value) {
				var self = this;
	
				name = propFix[name] || name;
	
				if (typeof name === "object") {
					each(name, function(name, value) {
						self.prop(name, value);
					});
				} else if (isDefined(value)) {
					this.each(function() {
						if (this.nodeType == 1) {
							this[name] = value;
						}
					});
				} else {
					if (self[0] && self[0].nodeType && name in self[0]) {
						return self[0][name];
					}
	
					return value;
				}
	
				return self;
			},
	
			/**
			 * Sets/gets styles on the elements in the current set.
			 *
			 * @method css
			 * @param {String/Object} name Name of style to get or an object with styles to set.
			 * @param {String} value Optional value to set.
			 * @return {tinymce.dom.DomQuery/String} Current set or the specified style when only the name is specified.
			 */
			css: function(name, value) {
				var self = this, elm, hook;
	
				function camel(name) {
					return name.replace(/-(\D)/g, function(a, b) {
						return b.toUpperCase();
					});
				}
	
				function dashed(name) {
					return name.replace(/[A-Z]/g, function(a) {
						return '-' + a;
					});
				}
	
				if (typeof name === "object") {
					each(name, function(name, value) {
						self.css(name, value);
					});
				} else {
					if (isDefined(value)) {
						name = camel(name);
	
						// Default px suffix on these
						if (typeof value === 'number' && !numericCssMap[name]) {
							value += 'px';
						}
	
						self.each(function() {
							var style = this.style;
	
							hook = cssHooks[name];
							if (hook && hook.set) {
								hook.set(this, value);
								return;
							}
	
							try {
								this.style[cssFix[name] || name] = value;
							} catch (ex) {
								// Ignore
							}
	
							if (value === null || value === '') {
								if (style.removeProperty) {
									style.removeProperty(dashed(name));
								} else {
									style.removeAttribute(name);
								}
							}
						});
					} else {
						elm = self[0];
	
						hook = cssHooks[name];
						if (hook && hook.get) {
							return hook.get(elm);
						}
	
						if (elm.ownerDocument.defaultView) {
							try {
								return elm.ownerDocument.defaultView.getComputedStyle(elm, null).getPropertyValue(dashed(name));
							} catch (ex) {
								return undef;
							}
						} else if (elm.currentStyle) {
							return elm.currentStyle[camel(name)];
						}
					}
				}
	
				return self;
			},
	
			/**
			 * Removes all nodes in set from the document.
			 *
			 * @method remove
			 * @return {tinymce.dom.DomQuery} Current set with the removed nodes.
			 */
			remove: function() {
				var self = this, node, i = this.length;
	
				while (i--) {
					node = self[i];
					Event.clean(node);
	
					if (node.parentNode) {
						node.parentNode.removeChild(node);
					}
				}
	
				return this;
			},
	
			/**
			 * Empties all elements in set.
			 *
			 * @method empty
			 * @return {tinymce.dom.DomQuery} Current set with the empty nodes.
			 */
			empty: function() {
				var self = this, node, i = this.length;
	
				while (i--) {
					node = self[i];
					while (node.firstChild) {
						node.removeChild(node.firstChild);
					}
				}
	
				return this;
			},
	
			/**
			 * Sets or gets the HTML of the current set or first set node.
			 *
			 * @method html
			 * @param {String} value Optional innerHTML value to set on each element.
			 * @return {tinymce.dom.DomQuery/String} Current set or the innerHTML of the first element.
			 */
			html: function(value) {
				var self = this, i;
	
				if (isDefined(value)) {
					i = self.length;
	
					try {
						while (i--) {
							self[i].innerHTML = value;
						}
					} catch (ex) {
						// Workaround for "Unknown runtime error" when DIV is added to P on IE
						DomQuery(self[i]).empty().append(value);
					}
	
					return self;
				}
	
				return self[0] ? self[0].innerHTML : '';
			},
	
			/**
			 * Sets or gets the text of the current set or first set node.
			 *
			 * @method text
			 * @param {String} value Optional innerText value to set on each element.
			 * @return {tinymce.dom.DomQuery/String} Current set or the innerText of the first element.
			 */
			text: function(value) {
				var self = this, i;
	
				if (isDefined(value)) {
					i = self.length;
					while (i--) {
						if ("innerText" in self[i]) {
							self[i].innerText = value;
						} else {
							self[0].textContent = value;
						}
					}
	
					return self;
				}
	
				return self[0] ? (self[0].innerText || self[0].textContent) : '';
			},
	
			/**
			 * Appends the specified node/html or node set to the current set nodes.
			 *
			 * @method append
			 * @param {String/Element/Array/tinymce.dom.DomQuery} content Content to append to each element in set.
			 * @return {tinymce.dom.DomQuery} Current set.
			 */
			append: function() {
				return domManipulate(this, arguments, function(node) {
					// Either element or Shadow Root
					if (this.nodeType === 1 || (this.host && this.host.nodeType === 1)) {
						this.appendChild(node);
					}
				});
			},
	
			/**
			 * Prepends the specified node/html or node set to the current set nodes.
			 *
			 * @method prepend
			 * @param {String/Element/Array/tinymce.dom.DomQuery} content Content to prepend to each element in set.
			 * @return {tinymce.dom.DomQuery} Current set.
			 */
			prepend: function() {
				return domManipulate(this, arguments, function(node) {
					// Either element or Shadow Root
					if (this.nodeType === 1 || (this.host && this.host.nodeType === 1)) {
						this.insertBefore(node, this.firstChild);
					}
				}, true);
			},
	
			/**
			 * Adds the specified elements before current set nodes.
			 *
			 * @method before
			 * @param {String/Element/Array/tinymce.dom.DomQuery} content Content to add before to each element in set.
			 * @return {tinymce.dom.DomQuery} Current set.
			 */
			before: function() {
				var self = this;
	
				if (self[0] && self[0].parentNode) {
					return domManipulate(self, arguments, function(node) {
						this.parentNode.insertBefore(node, this);
					});
				}
	
				return self;
			},
	
			/**
			 * Adds the specified elements after current set nodes.
			 *
			 * @method after
			 * @param {String/Element/Array/tinymce.dom.DomQuery} content Content to add after to each element in set.
			 * @return {tinymce.dom.DomQuery} Current set.
			 */
			after: function() {
				var self = this;
	
				if (self[0] && self[0].parentNode) {
					return domManipulate(self, arguments, function(node) {
						this.parentNode.insertBefore(node, this.nextSibling);
					}, true);
				}
	
				return self;
			},
	
			/**
			 * Appends the specified set nodes to the specified selector/instance.
			 *
			 * @method appendTo
			 * @param {String/Element/Array/tinymce.dom.DomQuery} val Item to append the current set to.
			 * @return {tinymce.dom.DomQuery} Current set with the appended nodes.
			 */
			appendTo: function(val) {
				DomQuery(val).append(this);
	
				return this;
			},
	
			/**
			 * Prepends the specified set nodes to the specified selector/instance.
			 *
			 * @method prependTo
			 * @param {String/Element/Array/tinymce.dom.DomQuery} val Item to prepend the current set to.
			 * @return {tinymce.dom.DomQuery} Current set with the prepended nodes.
			 */
			prependTo: function(val) {
				DomQuery(val).prepend(this);
	
				return this;
			},
	
			/**
			 * Replaces the nodes in set with the specified content.
			 *
			 * @method replaceWith
			 * @param {String/Element/Array/tinymce.dom.DomQuery} content Content to replace nodes with.
			 * @return {tinymce.dom.DomQuery} Set with replaced nodes.
			 */
			replaceWith: function(content) {
				return this.before(content).remove();
			},
	
			/**
			 * Wraps all elements in set with the specified wrapper.
			 *
			 * @method wrap
			 * @param {String/Element/Array/tinymce.dom.DomQuery} content Content to wrap nodes with.
			 * @return {tinymce.dom.DomQuery} Set with wrapped nodes.
			 */
			wrap: function(content) {
				return wrap(this, content);
			},
	
			/**
			 * Wraps all nodes in set with the specified wrapper. If the nodes are siblings all of them
			 * will be wrapped in the same wrapper.
			 *
			 * @method wrapAll
			 * @param {String/Element/Array/tinymce.dom.DomQuery} content Content to wrap nodes with.
			 * @return {tinymce.dom.DomQuery} Set with wrapped nodes.
			 */
			wrapAll: function(content) {
				return wrap(this, content, true);
			},
	
			/**
			 * Wraps all elements inner contents in set with the specified wrapper.
			 *
			 * @method wrapInner
			 * @param {String/Element/Array/tinymce.dom.DomQuery} content Content to wrap nodes with.
			 * @return {tinymce.dom.DomQuery} Set with wrapped nodes.
			 */
			wrapInner: function(content) {
				this.each(function() {
					DomQuery(this).contents().wrapAll(content);
				});
	
				return this;
			},
	
			/**
			 * Unwraps all elements by removing the parent element of each item in set.
			 *
			 * @method unwrap
			 * @return {tinymce.dom.DomQuery} Set with unwrapped nodes.
			 */
			unwrap: function() {
				return this.parent().each(function() {
					DomQuery(this).replaceWith(this.childNodes);
				});
			},
	
			/**
			 * Clones all nodes in set.
			 *
			 * @method clone
			 * @return {tinymce.dom.DomQuery} Set with cloned nodes.
			 */
			clone: function() {
				var result = [];
	
				this.each(function() {
					result.push(this.cloneNode(true));
				});
	
				return DomQuery(result);
			},
	
			/**
			 * Adds the specified class name to the current set elements.
			 *
			 * @method addClass
			 * @param {String} className Class name to add.
			 * @return {tinymce.dom.DomQuery} Current set.
			 */
			addClass: function(className) {
				return this.toggleClass(className, true);
			},
	
			/**
			 * Removes the specified class name to the current set elements.
			 *
			 * @method removeClass
			 * @param {String} className Class name to remove.
			 * @return {tinymce.dom.DomQuery} Current set.
			 */
			removeClass: function(className) {
				return this.toggleClass(className, false);
			},
	
			/**
			 * Toggles the specified class name on the current set elements.
			 *
			 * @method toggleClass
			 * @param {String} className Class name to add/remove.
			 * @param {Boolean} state Optional state to toggle on/off.
			 * @return {tinymce.dom.DomQuery} Current set.
			 */
			toggleClass: function(className, state) {
				var self = this;
	
				// Functions are not supported
				if (typeof className != 'string') {
					return self;
				}
	
				if (className.indexOf(' ') !== -1) {
					each(className.split(' '), function() {
						self.toggleClass(this, state);
					});
				} else {
					self.each(function(index, node) {
						var existingClassName, classState;
	
						classState = hasClass(node, className);
						if (classState !== state) {
							existingClassName = node.className;
	
							if (classState) {
								node.className = trim((" " + existingClassName + " ").replace(' ' + className + ' ', ' '));
							} else {
								node.className += existingClassName ? ' ' + className : className;
							}
						}
					});
				}
	
				return self;
			},
	
			/**
			 * Returns true/false if the first item in set has the specified class.
			 *
			 * @method hasClass
			 * @param {String} className Class name to check for.
			 * @return {Boolean} True/false if the set has the specified class.
			 */
			hasClass: function(className) {
				return hasClass(this[0], className);
			},
	
			/**
			 * Executes the callback function for each item DomQuery collection. If you return false in the
			 * callback it will break the loop.
			 *
			 * @method each
			 * @param {function} callback Callback function to execute for each item.
			 * @return {tinymce.dom.DomQuery} Current set.
			 */
			each: function(callback) {
				return each(this, callback);
			},
	
			/**
			 * Binds an event with callback function to the elements in set.
			 *
			 * @method on
			 * @param {String} name Name of the event to bind.
			 * @param {function} callback Callback function to execute when the event occurs.
			 * @return {tinymce.dom.DomQuery} Current set.
			 */
			on: function(name, callback) {
				return this.each(function() {
					Event.bind(this, name, callback);
				});
			},
	
			/**
			 * Unbinds an event with callback function to the elements in set.
			 *
			 * @method off
			 * @param {String} name Optional name of the event to bind.
			 * @param {function} callback Optional callback function to execute when the event occurs.
			 * @return {tinymce.dom.DomQuery} Current set.
			 */
			off: function(name, callback) {
				return this.each(function() {
					Event.unbind(this, name, callback);
				});
			},
	
			/**
			 * Triggers the specified event by name or event object.
			 *
			 * @method trigger
			 * @param {String/Object} name Name of the event to trigger or event object.
			 * @return {tinymce.dom.DomQuery} Current set.
			 */
			trigger: function(name) {
				return this.each(function() {
					if (typeof name == 'object') {
						Event.fire(this, name.type, name);
					} else {
						Event.fire(this, name);
					}
				});
			},
	
			/**
			 * Shows all elements in set.
			 *
			 * @method show
			 * @return {tinymce.dom.DomQuery} Current set.
			 */
			show: function() {
				return this.css('display', '');
			},
	
			/**
			 * Hides all elements in set.
			 *
			 * @method hide
			 * @return {tinymce.dom.DomQuery} Current set.
			 */
			hide: function() {
				return this.css('display', 'none');
			},
	
			/**
			 * Slices the current set.
			 *
			 * @method slice
			 * @param {Number} start Start index to slice at.
			 * @param {Number} end Optional end index to end slice at.
			 * @return {tinymce.dom.DomQuery} Sliced set.
			 */
			slice: function() {
				return new DomQuery(slice.apply(this, arguments));
			},
	
			/**
			 * Makes the set equal to the specified index.
			 *
			 * @method eq
			 * @param {Number} index Index to set it equal to.
			 * @return {tinymce.dom.DomQuery} Single item set.
			 */
			eq: function(index) {
				return index === -1 ? this.slice(index) : this.slice(index, +index + 1);
			},
	
			/**
			 * Makes the set equal to first element in set.
			 *
			 * @method first
			 * @return {tinymce.dom.DomQuery} Single item set.
			 */
			first: function() {
				return this.eq(0);
			},
	
			/**
			 * Makes the set equal to last element in set.
			 *
			 * @method last
			 * @return {tinymce.dom.DomQuery} Single item set.
			 */
			last: function() {
				return this.eq(-1);
			},
	
			/**
			 * Finds elements by the specified selector for each element in set.
			 *
			 * @method find
			 * @param {String} selector Selector to find elements by.
			 * @return {tinymce.dom.DomQuery} Set with matches elements.
			 */
			find: function(selector) {
				var i, l, ret = [];
	
				for (i = 0, l = this.length; i < l; i++) {
					DomQuery.find(selector, this[i], ret);
				}
	
				return DomQuery(ret);
			},
	
			/**
			 * Filters the current set with the specified selector.
			 *
			 * @method filter
			 * @param {String/function} selector Selector to filter elements by.
			 * @return {tinymce.dom.DomQuery} Set with filtered elements.
			 */
			filter: function(selector) {
				if (typeof selector == 'function') {
					return DomQuery(grep(this.toArray(), function(item, i) {
						return selector(i, item);
					}));
				}
	
				return DomQuery(DomQuery.filter(selector, this.toArray()));
			},
	
			/**
			 * Gets the current node or any parent matching the specified selector.
			 *
			 * @method closest
			 * @param {String/Element/tinymce.dom.DomQuery} selector Selector or element to find.
			 * @return {tinymce.dom.DomQuery} Set with closest elements.
			 */
			closest: function(selector) {
				var result = [];
	
				if (selector instanceof DomQuery) {
					selector = selector[0];
				}
	
				this.each(function(i, node) {
					while (node) {
						if (typeof selector == 'string' && DomQuery(node).is(selector)) {
							result.push(node);
							break;
						} else if (node == selector) {
							result.push(node);
							break;
						}
	
						node = node.parentNode;
					}
				});
	
				return DomQuery(result);
			},
	
			/**
			 * Returns the offset of the first element in set or sets the top/left css properties of all elements in set.
			 *
			 * @method offset
			 * @param {Object} offset Optional offset object to set on each item.
			 * @return {Object/tinymce.dom.DomQuery} Returns the first element offset or the current set if you specified an offset.
			 */
			offset: function(offset) {
				var elm, doc, docElm;
				var x = 0, y = 0, pos;
	
				if (!offset) {
					elm = this[0];
	
					if (elm) {
						doc = elm.ownerDocument;
						docElm = doc.documentElement;
	
						if (elm.getBoundingClientRect) {
							pos = elm.getBoundingClientRect();
							x = pos.left + (docElm.scrollLeft || doc.body.scrollLeft) - docElm.clientLeft;
							y = pos.top + (docElm.scrollTop || doc.body.scrollTop) - docElm.clientTop;
						}
					}
	
					return {
						left: x,
						top: y
					};
				}
	
				return this.css(offset);
			},
	
			push: push,
			sort: [].sort,
			splice: [].splice
		};
	
		// Static members
		Tools.extend(DomQuery, {
			/**
			 * Extends the specified object with one or more objects.
			 *
			 * @static
			 * @method extend
			 * @param {Object} target Target object to extend with new items.
			 * @param {Object..} object Object to extend the target with.
			 * @return {Object} Extended input object.
			 */
			extend: Tools.extend,
	
			/**
			 * Creates an array out of an array like object.
			 *
			 * @static
			 * @method makeArray
			 * @param {Object} object Object to convert to array.
			 * @return {Array} Array produced from object.
			 */
			makeArray: function(object) {
				if (isWindow(object) || object.nodeType) {
					return [object];
				}
	
				return Tools.toArray(object);
			},
	
			/**
			 * Returns the index of the specified item inside the array.
			 *
			 * @static
			 * @method inArray
			 * @param {Object} item Item to look for.
			 * @param {Array} array Array to look for item in.
			 * @return {Number} Index of the item or -1.
			 */
			inArray: inArray,
	
			/**
			 * Returns true/false if the specified object is an array or not.
			 *
			 * @static
			 * @method isArray
			 * @param {Object} array Object to check if it's an array or not.
			 * @return {Boolean} True/false if the object is an array.
			 */
			isArray: Tools.isArray,
	
			/**
			 * Executes the callback function for each item in array/object. If you return false in the
			 * callback it will break the loop.
			 *
			 * @static
			 * @method each
			 * @param {Object} obj Object to iterate.
			 * @param {function} callback Callback function to execute for each item.
			 */
			each: each,
	
			/**
			 * Removes whitespace from the beginning and end of a string.
			 *
			 * @static
			 * @method trim
			 * @param {String} str String to remove whitespace from.
			 * @return {String} New string with removed whitespace.
			 */
			trim: trim,
	
			/**
			 * Filters out items from the input array by calling the specified function for each item.
			 * If the function returns false the item will be excluded if it returns true it will be included.
			 *
			 * @static
			 * @method grep
			 * @param {Array} array Array of items to loop though.
			 * @param {function} callback Function to call for each item. Include/exclude depends on it's return value.
			 * @return {Array} New array with values imported and filtered based in input.
			 * @example
			 * // Filter out some items, this will return an array with 4 and 5
			 * var items = DomQuery.grep([1, 2, 3, 4, 5], function(v) {return v > 3;});
			 */
			grep: grep,
	
			// Sizzle
			find: Sizzle,
			expr: Sizzle.selectors,
			unique: Sizzle.uniqueSort,
			text: Sizzle.getText,
			contains: Sizzle.contains,
			filter: function(expr, elems, not) {
				var i = elems.length;
	
				if (not) {
					expr = ":not(" + expr + ")";
				}
	
				while (i--) {
					if (elems[i].nodeType != 1) {
						elems.splice(i, 1);
					}
				}
	
				if (elems.length === 1) {
					elems = DomQuery.find.matchesSelector(elems[0], expr) ? [elems[0]] : [];
				} else {
					elems = DomQuery.find.matches(expr, elems);
				}
	
				return elems;
			}
		});
	
		function dir(el, prop, until) {
			var matched = [], cur = el[prop];
	
			if (typeof until != 'string' && until instanceof DomQuery) {
				until = until[0];
			}
	
			while (cur && cur.nodeType !== 9) {
				if (until !== undefined) {
					if (cur === until) {
						break;
					}
	
					if (typeof until == 'string' && DomQuery(cur).is(until)) {
						break;
					}
				}
	
				if (cur.nodeType === 1) {
					matched.push(cur);
				}
	
				cur = cur[prop];
			}
	
			return matched;
		}
	
		function sibling(node, siblingName, nodeType, until) {
			var result = [];
	
			if (until instanceof DomQuery) {
				until = until[0];
			}
	
			for (; node; node = node[siblingName]) {
				if (nodeType && node.nodeType !== nodeType) {
					continue;
				}
	
				if (until !== undefined) {
					if (node === until) {
						break;
					}
	
					if (typeof until == 'string' && DomQuery(node).is(until)) {
						break;
					}
				}
	
				result.push(node);
			}
	
			return result;
		}
	
		function firstSibling(node, siblingName, nodeType) {
			for (node = node[siblingName]; node; node = node[siblingName]) {
				if (node.nodeType == nodeType) {
					return node;
				}
			}
	
			return null;
		}
	
		each({
			/**
			 * Returns a new collection with the parent of each item in current collection matching the optional selector.
			 *
			 * @method parent
			 * @param {Element/tinymce.dom.DomQuery} node Node to match parents against.
			 * @return {tinymce.dom.DomQuery} New DomQuery instance with all matching parents.
			 */
			parent: function(node) {
				var parent = node.parentNode;
	
				return parent && parent.nodeType !== 11 ? parent : null;
			},
	
			/**
			 * Returns a new collection with the all the parents of each item in current collection matching the optional selector.
			 *
			 * @method parents
			 * @param {Element/tinymce.dom.DomQuery} node Node to match parents against.
			 * @return {tinymce.dom.DomQuery} New DomQuery instance with all matching parents.
			 */
			parents: function(node) {
				return dir(node, "parentNode");
			},
	
			/**
			 * Returns a new collection with next sibling of each item in current collection matching the optional selector.
			 *
			 * @method next
			 * @param {Element/tinymce.dom.DomQuery} node Node to match the next element against.
			 * @return {tinymce.dom.DomQuery} New DomQuery instance with all matching elements.
			 */
			next: function(node) {
				return firstSibling(node, 'nextSibling', 1);
			},
	
			/**
			 * Returns a new collection with previous sibling of each item in current collection matching the optional selector.
			 *
			 * @method prev
			 * @param {Element/tinymce.dom.DomQuery} node Node to match the previous element against.
			 * @return {tinymce.dom.DomQuery} New DomQuery instance with all matching elements.
			 */
			prev: function(node) {
				return firstSibling(node, 'previousSibling', 1);
			},
	
			/**
			 * Returns all child elements matching the optional selector.
			 *
			 * @method children
			 * @param {Element/tinymce.dom.DomQuery} node Node to match the elements against.
			 * @return {tinymce.dom.DomQuery} New DomQuery instance with all matching elements.
			 */
			children: function(node) {
				return sibling(node.firstChild, 'nextSibling', 1);
			},
	
			/**
			 * Returns all child nodes matching the optional selector.
			 *
			 * @method contents
			 * @param {Element/tinymce.dom.DomQuery} node Node to get the contents of.
			 * @return {tinymce.dom.DomQuery} New DomQuery instance with all matching elements.
			 */
			contents: function(node) {
				return Tools.toArray((node.nodeName === "iframe" ? node.contentDocument || node.contentWindow.document : node).childNodes);
			}
		}, function(name, fn) {
			DomQuery.fn[name] = function(selector) {
				var self = this, result = [];
	
				self.each(function() {
					var nodes = fn.call(result, this, selector, result);
	
					if (nodes) {
						if (DomQuery.isArray(nodes)) {
							result.push.apply(result, nodes);
						} else {
							result.push(nodes);
						}
					}
				});
	
				// If traversing on multiple elements we might get the same elements twice
				if (this.length > 1) {
					if (!skipUniques[name]) {
						result = DomQuery.unique(result);
					}
	
					if (name.indexOf('parents') === 0) {
						result = result.reverse();
					}
				}
	
				result = DomQuery(result);
	
				if (selector) {
					return result.filter(selector);
				}
	
				return result;
			};
		});
	
		each({
			/**
			 * Returns a new collection with the all the parents until the matching selector/element
			 * of each item in current collection matching the optional selector.
			 *
			 * @method parentsUntil
			 * @param {Element/tinymce.dom.DomQuery} node Node to find parent of.
			 * @param {String/Element/tinymce.dom.DomQuery} until Until the matching selector or element.
			 * @return {tinymce.dom.DomQuery} New DomQuery instance with all matching parents.
			 */
			parentsUntil: function(node, until) {
				return dir(node, "parentNode", until);
			},
	
			/**
			 * Returns a new collection with all next siblings of each item in current collection matching the optional selector.
			 *
			 * @method nextUntil
			 * @param {Element/tinymce.dom.DomQuery} node Node to find next siblings on.
			 * @param {String/Element/tinymce.dom.DomQuery} until Until the matching selector or element.
			 * @return {tinymce.dom.DomQuery} New DomQuery instance with all matching elements.
			 */
			nextUntil: function(node, until) {
				return sibling(node, 'nextSibling', 1, until).slice(1);
			},
	
			/**
			 * Returns a new collection with all previous siblings of each item in current collection matching the optional selector.
			 *
			 * @method prevUntil
			 * @param {Element/tinymce.dom.DomQuery} node Node to find previous siblings on.
			 * @param {String/Element/tinymce.dom.DomQuery} until Until the matching selector or element.
			 * @return {tinymce.dom.DomQuery} New DomQuery instance with all matching elements.
			 */
			prevUntil: function(node, until) {
				return sibling(node, 'previousSibling', 1, until).slice(1);
			}
		}, function(name, fn) {
			DomQuery.fn[name] = function(selector, filter) {
				var self = this, result = [];
	
				self.each(function() {
					var nodes = fn.call(result, this, selector, result);
	
					if (nodes) {
						if (DomQuery.isArray(nodes)) {
							result.push.apply(result, nodes);
						} else {
							result.push(nodes);
						}
					}
				});
	
				// If traversing on multiple elements we might get the same elements twice
				if (this.length > 1) {
					result = DomQuery.unique(result);
	
					if (name.indexOf('parents') === 0 || name === 'prevUntil') {
						result = result.reverse();
					}
				}
	
				result = DomQuery(result);
	
				if (filter) {
					return result.filter(filter);
				}
	
				return result;
			};
		});
	
		/**
		 * Returns true/false if the current set items matches the selector.
		 *
		 * @method is
		 * @param {String} selector Selector to match the elements against.
		 * @return {Boolean} True/false if the current set matches the selector.
		 */
		DomQuery.fn.is = function(selector) {
			return !!selector && this.filter(selector).length > 0;
		};
	
		DomQuery.fn.init.prototype = DomQuery.fn;
	
		DomQuery.overrideDefaults = function(callback) {
			var defaults;
	
			function sub(selector, context) {
				defaults = defaults || callback();
	
				if (arguments.length === 0) {
					selector = defaults.element;
				}
	
				if (!context) {
					context = defaults.context;
				}
	
				return new sub.fn.init(selector, context);
			}
	
			DomQuery.extend(sub, this);
	
			return sub;
		};
	
		function appendHooks(targetHooks, prop, hooks) {
			each(hooks, function(name, func) {
				targetHooks[name] = targetHooks[name] || {};
				targetHooks[name][prop] = func;
			});
		}
	
		if (Env.ie && Env.ie < 8) {
			appendHooks(attrHooks, 'get', {
				maxlength: function(elm) {
					var value = elm.maxLength;
	
					if (value === 0x7fffffff) {
						return undef;
					}
	
					return value;
				},
	
				size: function(elm) {
					var value = elm.size;
	
					if (value === 20) {
						return undef;
					}
	
					return value;
				},
	
				'class': function(elm) {
					return elm.className;
				},
	
				style: function(elm) {
					var value = elm.style.cssText;
	
					if (value.length === 0) {
						return undef;
					}
	
					return value;
				}
			});
	
			appendHooks(attrHooks, 'set', {
				'class': function(elm, value) {
					elm.className = value;
				},
	
				style: function(elm, value) {
					elm.style.cssText = value;
				}
			});
		}
	
		if (Env.ie && Env.ie < 9) {
			/*jshint sub:true */
			/*eslint dot-notation: 0*/
			cssFix['float'] = 'styleFloat';
	
			appendHooks(cssHooks, 'set', {
				opacity: function(elm, value) {
					var style = elm.style;
	
					if (value === null || value === '') {
						style.removeAttribute('filter');
					} else {
						style.zoom = 1;
						style.filter = 'alpha(opacity=' + (value * 100) + ')';
					}
				}
			});
		}
	
		DomQuery.attrHooks = attrHooks;
		DomQuery.cssHooks = cssHooks;
	
		return DomQuery;
	});
	
	// Included from: js/tinymce/classes/html/Styles.js
	
	/**
	 * Styles.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * This class is used to parse CSS styles it also compresses styles to reduce the output size.
	 *
	 * @example
	 * var Styles = new tinymce.html.Styles({
	 *    url_converter: function(url) {
	 *       return url;
	 *    }
	 * });
	 *
	 * styles = Styles.parse('border: 1px solid red');
	 * styles.color = 'red';
	 *
	 * console.log(new tinymce.html.StyleSerializer().serialize(styles));
	 *
	 * @class tinymce.html.Styles
	 * @version 3.4
	 */
	define("tinymce/html/Styles", [], function() {
		return function(settings, schema) {
			/*jshint maxlen:255 */
			/*eslint max-len:0 */
			var rgbRegExp = /rgb\s*\(\s*([0-9]+)\s*,\s*([0-9]+)\s*,\s*([0-9]+)\s*\)/gi,
				urlOrStrRegExp = /(?:url(?:(?:\(\s*\"([^\"]+)\"\s*\))|(?:\(\s*\'([^\']+)\'\s*\))|(?:\(\s*([^)\s]+)\s*\))))|(?:\'([^\']+)\')|(?:\"([^\"]+)\")/gi,
				styleRegExp = /\s*([^:]+):\s*([^;]+);?/g,
				trimRightRegExp = /\s+$/,
				undef, i, encodingLookup = {}, encodingItems, validStyles, invalidStyles, invisibleChar = '\uFEFF';
	
			settings = settings || {};
	
			if (schema) {
				validStyles = schema.getValidStyles();
				invalidStyles = schema.getInvalidStyles();
			}
	
			encodingItems = ('\\" \\\' \\; \\: ; : ' + invisibleChar).split(' ');
			for (i = 0; i < encodingItems.length; i++) {
				encodingLookup[encodingItems[i]] = invisibleChar + i;
				encodingLookup[invisibleChar + i] = encodingItems[i];
			}
	
			function toHex(match, r, g, b) {
				function hex(val) {
					val = parseInt(val, 10).toString(16);
	
					return val.length > 1 ? val : '0' + val; // 0 -> 00
				}
	
				return '#' + hex(r) + hex(g) + hex(b);
			}
	
			return {
				/**
				 * Parses the specified RGB color value and returns a hex version of that color.
				 *
				 * @method toHex
				 * @param {String} color RGB string value like rgb(1,2,3)
				 * @return {String} Hex version of that RGB value like #FF00FF.
				 */
				toHex: function(color) {
					return color.replace(rgbRegExp, toHex);
				},
	
				/**
				 * Parses the specified style value into an object collection. This parser will also
				 * merge and remove any redundant items that browsers might have added. It will also convert non hex
				 * colors to hex values. Urls inside the styles will also be converted to absolute/relative based on settings.
				 *
				 * @method parse
				 * @param {String} css Style value to parse for example: border:1px solid red;.
				 * @return {Object} Object representation of that style like {border: '1px solid red'}
				 */
				parse: function(css) {
					var styles = {}, matches, name, value, isEncoded, urlConverter = settings.url_converter;
					var urlConverterScope = settings.url_converter_scope || this;
	
					function compress(prefix, suffix, noJoin) {
						var top, right, bottom, left;
	
						top = styles[prefix + '-top' + suffix];
						if (!top) {
							return;
						}
	
						right = styles[prefix + '-right' + suffix];
						if (!right) {
							return;
						}
	
						bottom = styles[prefix + '-bottom' + suffix];
						if (!bottom) {
							return;
						}
	
						left = styles[prefix + '-left' + suffix];
						if (!left) {
							return;
						}
	
						var box = [top, right, bottom, left];
						i = box.length - 1;
						while (i--) {
							if (box[i] !== box[i + 1]) {
								break;
							}
						}
	
						if (i > -1 && noJoin) {
							return;
						}
	
						styles[prefix + suffix] = i == -1 ? box[0] : box.join(' ');
						delete styles[prefix + '-top' + suffix];
						delete styles[prefix + '-right' + suffix];
						delete styles[prefix + '-bottom' + suffix];
						delete styles[prefix + '-left' + suffix];
					}
	
					/**
					 * Checks if the specific style can be compressed in other words if all border-width are equal.
					 */
					function canCompress(key) {
						var value = styles[key], i;
	
						if (!value) {
							return;
						}
	
						value = value.split(' ');
						i = value.length;
						while (i--) {
							if (value[i] !== value[0]) {
								return false;
							}
						}
	
						styles[key] = value[0];
	
						return true;
					}
	
					/**
					 * Compresses multiple styles into one style.
					 */
					function compress2(target, a, b, c) {
						if (!canCompress(a)) {
							return;
						}
	
						if (!canCompress(b)) {
							return;
						}
	
						if (!canCompress(c)) {
							return;
						}
	
						// Compress
						styles[target] = styles[a] + ' ' + styles[b] + ' ' + styles[c];
						delete styles[a];
						delete styles[b];
						delete styles[c];
					}
	
					// Encodes the specified string by replacing all \" \' ; : with _<num>
					function encode(str) {
						isEncoded = true;
	
						return encodingLookup[str];
					}
	
					// Decodes the specified string by replacing all _<num> with it's original value \" \' etc
					// It will also decode the \" \' if keep_slashes is set to fale or omitted
					function decode(str, keep_slashes) {
						if (isEncoded) {
							str = str.replace(/\uFEFF[0-9]/g, function(str) {
								return encodingLookup[str];
							});
						}
	
						if (!keep_slashes) {
							str = str.replace(/\\([\'\";:])/g, "$1");
						}
	
						return str;
					}
	
					function processUrl(match, url, url2, url3, str, str2) {
						str = str || str2;
	
						if (str) {
							str = decode(str);
	
							// Force strings into single quote format
							return "'" + str.replace(/\'/g, "\\'") + "'";
						}
	
						url = decode(url || url2 || url3);
	
						if (!settings.allow_script_urls) {
							var scriptUrl = url.replace(/[\s\r\n]+/, '');
	
							if (/(java|vb)script:/i.test(scriptUrl)) {
								return "";
							}
	
							if (!settings.allow_svg_data_urls && /^data:image\/svg/i.test(scriptUrl)) {
								return "";
							}
						}
	
						// Convert the URL to relative/absolute depending on config
						if (urlConverter) {
							url = urlConverter.call(urlConverterScope, url, 'style');
						}
	
						// Output new URL format
						return "url('" + url.replace(/\'/g, "\\'") + "')";
					}
	
					if (css) {
						css = css.replace(/[\u0000-\u001F]/g, '');
	
						// Encode \" \' % and ; and : inside strings so they don't interfere with the style parsing
						css = css.replace(/\\[\"\';:\uFEFF]/g, encode).replace(/\"[^\"]+\"|\'[^\']+\'/g, function(str) {
							return str.replace(/[;:]/g, encode);
						});
	
						// Parse styles
						while ((matches = styleRegExp.exec(css))) {
							name = matches[1].replace(trimRightRegExp, '').toLowerCase();
							value = matches[2].replace(trimRightRegExp, '');
	
							// Decode escaped sequences like \65 -> e
							/*jshint loopfunc:true*/
							/*eslint no-loop-func:0 */
							value = value.replace(/\\[0-9a-f]+/g, function(e) {
								return String.fromCharCode(parseInt(e.substr(1), 16));
							});
	
							if (name && value.length > 0) {
								// Don't allow behavior name or expression/comments within the values
								if (!settings.allow_script_urls && (name == "behavior" || /expression\s*\(|\/\*|\*\//.test(value))) {
									continue;
								}
	
								// Opera will produce 700 instead of bold in their style values
								if (name === 'font-weight' && value === '700') {
									value = 'bold';
								} else if (name === 'color' || name === 'background-color') { // Lowercase colors like RED
									value = value.toLowerCase();
								}
	
								// Convert RGB colors to HEX
								value = value.replace(rgbRegExp, toHex);
	
								// Convert URLs and force them into url('value') format
								value = value.replace(urlOrStrRegExp, processUrl);
								styles[name] = isEncoded ? decode(value, true) : value;
							}
	
							styleRegExp.lastIndex = matches.index + matches[0].length;
						}
						// Compress the styles to reduce it's size for example IE will expand styles
						compress("border", "", true);
						compress("border", "-width");
						compress("border", "-color");
						compress("border", "-style");
						compress("padding", "");
						compress("margin", "");
						compress2('border', 'border-width', 'border-style', 'border-color');
	
						// Remove pointless border, IE produces these
						if (styles.border === 'medium none') {
							delete styles.border;
						}
	
						// IE 11 will produce a border-image: none when getting the style attribute from <p style="border: 1px solid red"></p>
						// So let us assume it shouldn't be there
						if (styles['border-image'] === 'none') {
							delete styles['border-image'];
						}
					}
	
					return styles;
				},
	
				/**
				 * Serializes the specified style object into a string.
				 *
				 * @method serialize
				 * @param {Object} styles Object to serialize as string for example: {border: '1px solid red'}
				 * @param {String} elementName Optional element name, if specified only the styles that matches the schema will be serialized.
				 * @return {String} String representation of the style object for example: border: 1px solid red.
				 */
				serialize: function(styles, elementName) {
					var css = '', name, value;
	
					function serializeStyles(name) {
						var styleList, i, l, value;
	
						styleList = validStyles[name];
						if (styleList) {
							for (i = 0, l = styleList.length; i < l; i++) {
								name = styleList[i];
								value = styles[name];
	
								if (value !== undef && value.length > 0) {
									css += (css.length > 0 ? ' ' : '') + name + ': ' + value + ';';
								}
							}
						}
					}
	
					function isValid(name, elementName) {
						var styleMap;
	
						styleMap = invalidStyles['*'];
						if (styleMap && styleMap[name]) {
							return false;
						}
	
						styleMap = invalidStyles[elementName];
						if (styleMap && styleMap[name]) {
							return false;
						}
	
						return true;
					}
	
					// Serialize styles according to schema
					if (elementName && validStyles) {
						// Serialize global styles and element specific styles
						serializeStyles('*');
						serializeStyles(elementName);
					} else {
						// Output the styles in the order they are inside the object
						for (name in styles) {
							value = styles[name];
	
							if (value !== undef && value.length > 0) {
								if (!invalidStyles || isValid(name, elementName)) {
									css += (css.length > 0 ? ' ' : '') + name + ': ' + value + ';';
								}
							}
						}
					}
	
					return css;
				}
			};
		};
	});
	
	// Included from: js/tinymce/classes/dom/TreeWalker.js
	
	/**
	 * TreeWalker.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * TreeWalker class enables you to walk the DOM in a linear manner.
	 *
	 * @class tinymce.dom.TreeWalker
	 * @example
	 * var walker = new tinymce.dom.TreeWalker(startNode);
	 *
	 * do {
	 *     console.log(walker.current());
	 * } while (walker.next());
	 */
	define("tinymce/dom/TreeWalker", [], function() {
		/**
		 * Constructs a new TreeWalker instance.
		 *
		 * @constructor
		 * @method TreeWalker
		 * @param {Node} startNode Node to start walking from.
		 * @param {node} rootNode Optional root node to never walk out of.
		 */
		return function(startNode, rootNode) {
			var node = startNode;
	
			function findSibling(node, startName, siblingName, shallow) {
				var sibling, parent;
	
				if (node) {
					// Walk into nodes if it has a start
					if (!shallow && node[startName]) {
						return node[startName];
					}
	
					// Return the sibling if it has one
					if (node != rootNode) {
						sibling = node[siblingName];
						if (sibling) {
							return sibling;
						}
	
						// Walk up the parents to look for siblings
						for (parent = node.parentNode; parent && parent != rootNode; parent = parent.parentNode) {
							sibling = parent[siblingName];
							if (sibling) {
								return sibling;
							}
						}
					}
				}
			}
	
			function findPreviousNode(node, startName, siblingName, shallow) {
				var sibling, parent, child;
	
				if (node) {
					sibling = node[siblingName];
					if (rootNode && sibling === rootNode) {
						return;
					}
	
					if (sibling) {
						if (!shallow) {
							// Walk up the parents to look for siblings
							for (child = sibling[startName]; child; child = child[startName]) {
								if (!child[startName]) {
									return child;
								}
							}
						}
	
						return sibling;
					}
	
					parent = node.parentNode;
					if (parent && parent !== rootNode) {
						return parent;
					}
				}
			}
	
			/**
			 * Returns the current node.
			 *
			 * @method current
			 * @return {Node} Current node where the walker is.
			 */
			this.current = function() {
				return node;
			};
	
			/**
			 * Walks to the next node in tree.
			 *
			 * @method next
			 * @return {Node} Current node where the walker is after moving to the next node.
			 */
			this.next = function(shallow) {
				node = findSibling(node, 'firstChild', 'nextSibling', shallow);
				return node;
			};
	
			/**
			 * Walks to the previous node in tree.
			 *
			 * @method prev
			 * @return {Node} Current node where the walker is after moving to the previous node.
			 */
			this.prev = function(shallow) {
				node = findSibling(node, 'lastChild', 'previousSibling', shallow);
				return node;
			};
	
			this.prev2 = function(shallow) {
				node = findPreviousNode(node, 'lastChild', 'previousSibling', shallow);
				return node;
			};
		};
	});
	
	// Included from: js/tinymce/classes/dom/Range.js
	
	/**
	 * Range.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * Old IE Range.
	 *
	 * @private
	 * @class tinymce.dom.Range
	 */
	define("tinymce/dom/Range", [
		"tinymce/util/Tools"
	], function(Tools) {
		// Range constructor
		function Range(dom) {
			var self = this,
				doc = dom.doc,
				EXTRACT = 0,
				CLONE = 1,
				DELETE = 2,
				TRUE = true,
				FALSE = false,
				START_OFFSET = 'startOffset',
				START_CONTAINER = 'startContainer',
				END_CONTAINER = 'endContainer',
				END_OFFSET = 'endOffset',
				extend = Tools.extend,
				nodeIndex = dom.nodeIndex;
	
			function createDocumentFragment() {
				return doc.createDocumentFragment();
			}
	
			function setStart(n, o) {
				_setEndPoint(TRUE, n, o);
			}
	
			function setEnd(n, o) {
				_setEndPoint(FALSE, n, o);
			}
	
			function setStartBefore(n) {
				setStart(n.parentNode, nodeIndex(n));
			}
	
			function setStartAfter(n) {
				setStart(n.parentNode, nodeIndex(n) + 1);
			}
	
			function setEndBefore(n) {
				setEnd(n.parentNode, nodeIndex(n));
			}
	
			function setEndAfter(n) {
				setEnd(n.parentNode, nodeIndex(n) + 1);
			}
	
			function collapse(ts) {
				if (ts) {
					self[END_CONTAINER] = self[START_CONTAINER];
					self[END_OFFSET] = self[START_OFFSET];
				} else {
					self[START_CONTAINER] = self[END_CONTAINER];
					self[START_OFFSET] = self[END_OFFSET];
				}
	
				self.collapsed = TRUE;
			}
	
			function selectNode(n) {
				setStartBefore(n);
				setEndAfter(n);
			}
	
			function selectNodeContents(n) {
				setStart(n, 0);
				setEnd(n, n.nodeType === 1 ? n.childNodes.length : n.nodeValue.length);
			}
	
			function compareBoundaryPoints(h, r) {
				var sc = self[START_CONTAINER], so = self[START_OFFSET], ec = self[END_CONTAINER], eo = self[END_OFFSET],
				rsc = r.startContainer, rso = r.startOffset, rec = r.endContainer, reo = r.endOffset;
	
				// Check START_TO_START
				if (h === 0) {
					return _compareBoundaryPoints(sc, so, rsc, rso);
				}
	
				// Check START_TO_END
				if (h === 1) {
					return _compareBoundaryPoints(ec, eo, rsc, rso);
				}
	
				// Check END_TO_END
				if (h === 2) {
					return _compareBoundaryPoints(ec, eo, rec, reo);
				}
	
				// Check END_TO_START
				if (h === 3) {
					return _compareBoundaryPoints(sc, so, rec, reo);
				}
			}
	
			function deleteContents() {
				_traverse(DELETE);
			}
	
			function extractContents() {
				return _traverse(EXTRACT);
			}
	
			function cloneContents() {
				return _traverse(CLONE);
			}
	
			function insertNode(n) {
				var startContainer = this[START_CONTAINER],
					startOffset = this[START_OFFSET], nn, o;
	
				// Node is TEXT_NODE or CDATA
				if ((startContainer.nodeType === 3 || startContainer.nodeType === 4) && startContainer.nodeValue) {
					if (!startOffset) {
						// At the start of text
						startContainer.parentNode.insertBefore(n, startContainer);
					} else if (startOffset >= startContainer.nodeValue.length) {
						// At the end of text
						dom.insertAfter(n, startContainer);
					} else {
						// Middle, need to split
						nn = startContainer.splitText(startOffset);
						startContainer.parentNode.insertBefore(n, nn);
					}
				} else {
					// Insert element node
					if (startContainer.childNodes.length > 0) {
						o = startContainer.childNodes[startOffset];
					}
	
					if (o) {
						startContainer.insertBefore(n, o);
					} else {
						if (startContainer.nodeType == 3) {
							dom.insertAfter(n, startContainer);
						} else {
							startContainer.appendChild(n);
						}
					}
				}
			}
	
			function surroundContents(n) {
				var f = self.extractContents();
	
				self.insertNode(n);
				n.appendChild(f);
				self.selectNode(n);
			}
	
			function cloneRange() {
				return extend(new Range(dom), {
					startContainer: self[START_CONTAINER],
					startOffset: self[START_OFFSET],
					endContainer: self[END_CONTAINER],
					endOffset: self[END_OFFSET],
					collapsed: self.collapsed,
					commonAncestorContainer: self.commonAncestorContainer
				});
			}
	
			// Private methods
	
			function _getSelectedNode(container, offset) {
				var child;
	
				// TEXT_NODE
				if (container.nodeType == 3) {
					return container;
				}
	
				if (offset < 0) {
					return container;
				}
	
				child = container.firstChild;
				while (child && offset > 0) {
					--offset;
					child = child.nextSibling;
				}
	
				if (child) {
					return child;
				}
	
				return container;
			}
	
			function _isCollapsed() {
				return (self[START_CONTAINER] == self[END_CONTAINER] && self[START_OFFSET] == self[END_OFFSET]);
			}
	
			function _compareBoundaryPoints(containerA, offsetA, containerB, offsetB) {
				var c, offsetC, n, cmnRoot, childA, childB;
	
				// In the first case the boundary-points have the same container. A is before B
				// if its offset is less than the offset of B, A is equal to B if its offset is
				// equal to the offset of B, and A is after B if its offset is greater than the
				// offset of B.
				if (containerA == containerB) {
					if (offsetA == offsetB) {
						return 0; // equal
					}
	
					if (offsetA < offsetB) {
						return -1; // before
					}
	
					return 1; // after
				}
	
				// In the second case a child node C of the container of A is an ancestor
				// container of B. In this case, A is before B if the offset of A is less than or
				// equal to the index of the child node C and A is after B otherwise.
				c = containerB;
				while (c && c.parentNode != containerA) {
					c = c.parentNode;
				}
	
				if (c) {
					offsetC = 0;
					n = containerA.firstChild;
	
					while (n != c && offsetC < offsetA) {
						offsetC++;
						n = n.nextSibling;
					}
	
					if (offsetA <= offsetC) {
						return -1; // before
					}
	
					return 1; // after
				}
	
				// In the third case a child node C of the container of B is an ancestor container
				// of A. In this case, A is before B if the index of the child node C is less than
				// the offset of B and A is after B otherwise.
				c = containerA;
				while (c && c.parentNode != containerB) {
					c = c.parentNode;
				}
	
				if (c) {
					offsetC = 0;
					n = containerB.firstChild;
	
					while (n != c && offsetC < offsetB) {
						offsetC++;
						n = n.nextSibling;
					}
	
					if (offsetC < offsetB) {
						return -1; // before
					}
	
					return 1; // after
				}
	
				// In the fourth case, none of three other cases hold: the containers of A and B
				// are siblings or descendants of sibling nodes. In this case, A is before B if
				// the container of A is before the container of B in a pre-order traversal of the
				// Ranges' context tree and A is after B otherwise.
				cmnRoot = dom.findCommonAncestor(containerA, containerB);
				childA = containerA;
	
				while (childA && childA.parentNode != cmnRoot) {
					childA = childA.parentNode;
				}
	
				if (!childA) {
					childA = cmnRoot;
				}
	
				childB = containerB;
				while (childB && childB.parentNode != cmnRoot) {
					childB = childB.parentNode;
				}
	
				if (!childB) {
					childB = cmnRoot;
				}
	
				if (childA == childB) {
					return 0; // equal
				}
	
				n = cmnRoot.firstChild;
				while (n) {
					if (n == childA) {
						return -1; // before
					}
	
					if (n == childB) {
						return 1; // after
					}
	
					n = n.nextSibling;
				}
			}
	
			function _setEndPoint(st, n, o) {
				var ec, sc;
	
				if (st) {
					self[START_CONTAINER] = n;
					self[START_OFFSET] = o;
				} else {
					self[END_CONTAINER] = n;
					self[END_OFFSET] = o;
				}
	
				// If one boundary-point of a Range is set to have a root container
				// other than the current one for the Range, the Range is collapsed to
				// the new position. This enforces the restriction that both boundary-
				// points of a Range must have the same root container.
				ec = self[END_CONTAINER];
				while (ec.parentNode) {
					ec = ec.parentNode;
				}
	
				sc = self[START_CONTAINER];
				while (sc.parentNode) {
					sc = sc.parentNode;
				}
	
				if (sc == ec) {
					// The start position of a Range is guaranteed to never be after the
					// end position. To enforce this restriction, if the start is set to
					// be at a position after the end, the Range is collapsed to that
					// position.
					if (_compareBoundaryPoints(self[START_CONTAINER], self[START_OFFSET], self[END_CONTAINER], self[END_OFFSET]) > 0) {
						self.collapse(st);
					}
				} else {
					self.collapse(st);
				}
	
				self.collapsed = _isCollapsed();
				self.commonAncestorContainer = dom.findCommonAncestor(self[START_CONTAINER], self[END_CONTAINER]);
			}
	
			function _traverse(how) {
				var c, endContainerDepth = 0, startContainerDepth = 0, p, depthDiff, startNode, endNode, sp, ep;
	
				if (self[START_CONTAINER] == self[END_CONTAINER]) {
					return _traverseSameContainer(how);
				}
	
				for (c = self[END_CONTAINER], p = c.parentNode; p; c = p, p = p.parentNode) {
					if (p == self[START_CONTAINER]) {
						return _traverseCommonStartContainer(c, how);
					}
	
					++endContainerDepth;
				}
	
				for (c = self[START_CONTAINER], p = c.parentNode; p; c = p, p = p.parentNode) {
					if (p == self[END_CONTAINER]) {
						return _traverseCommonEndContainer(c, how);
					}
	
					++startContainerDepth;
				}
	
				depthDiff = startContainerDepth - endContainerDepth;
	
				startNode = self[START_CONTAINER];
				while (depthDiff > 0) {
					startNode = startNode.parentNode;
					depthDiff--;
				}
	
				endNode = self[END_CONTAINER];
				while (depthDiff < 0) {
					endNode = endNode.parentNode;
					depthDiff++;
				}
	
				// ascend the ancestor hierarchy until we have a common parent.
				for (sp = startNode.parentNode, ep = endNode.parentNode; sp != ep; sp = sp.parentNode, ep = ep.parentNode) {
					startNode = sp;
					endNode = ep;
				}
	
				return _traverseCommonAncestors(startNode, endNode, how);
			}
	
			function _traverseSameContainer(how) {
				var frag, s, sub, n, cnt, sibling, xferNode, start, len;
	
				if (how != DELETE) {
					frag = createDocumentFragment();
				}
	
				// If selection is empty, just return the fragment
				if (self[START_OFFSET] == self[END_OFFSET]) {
					return frag;
				}
	
				// Text node needs special case handling
				if (self[START_CONTAINER].nodeType == 3) { // TEXT_NODE
					// get the substring
					s = self[START_CONTAINER].nodeValue;
					sub = s.substring(self[START_OFFSET], self[END_OFFSET]);
	
					// set the original text node to its new value
					if (how != CLONE) {
						n = self[START_CONTAINER];
						start = self[START_OFFSET];
						len = self[END_OFFSET] - self[START_OFFSET];
	
						if (start === 0 && len >= n.nodeValue.length - 1) {
							n.parentNode.removeChild(n);
						} else {
							n.deleteData(start, len);
						}
	
						// Nothing is partially selected, so collapse to start point
						self.collapse(TRUE);
					}
	
					if (how == DELETE) {
						return;
					}
	
					if (sub.length > 0) {
						frag.appendChild(doc.createTextNode(sub));
					}
	
					return frag;
				}
	
				// Copy nodes between the start/end offsets.
				n = _getSelectedNode(self[START_CONTAINER], self[START_OFFSET]);
				cnt = self[END_OFFSET] - self[START_OFFSET];
	
				while (n && cnt > 0) {
					sibling = n.nextSibling;
					xferNode = _traverseFullySelected(n, how);
	
					if (frag) {
						frag.appendChild(xferNode);
					}
	
					--cnt;
					n = sibling;
				}
	
				// Nothing is partially selected, so collapse to start point
				if (how != CLONE) {
					self.collapse(TRUE);
				}
	
				return frag;
			}
	
			function _traverseCommonStartContainer(endAncestor, how) {
				var frag, n, endIdx, cnt, sibling, xferNode;
	
				if (how != DELETE) {
					frag = createDocumentFragment();
				}
	
				n = _traverseRightBoundary(endAncestor, how);
	
				if (frag) {
					frag.appendChild(n);
				}
	
				endIdx = nodeIndex(endAncestor);
				cnt = endIdx - self[START_OFFSET];
	
				if (cnt <= 0) {
					// Collapse to just before the endAncestor, which
					// is partially selected.
					if (how != CLONE) {
						self.setEndBefore(endAncestor);
						self.collapse(FALSE);
					}
	
					return frag;
				}
	
				n = endAncestor.previousSibling;
				while (cnt > 0) {
					sibling = n.previousSibling;
					xferNode = _traverseFullySelected(n, how);
	
					if (frag) {
						frag.insertBefore(xferNode, frag.firstChild);
					}
	
					--cnt;
					n = sibling;
				}
	
				// Collapse to just before the endAncestor, which
				// is partially selected.
				if (how != CLONE) {
					self.setEndBefore(endAncestor);
					self.collapse(FALSE);
				}
	
				return frag;
			}
	
			function _traverseCommonEndContainer(startAncestor, how) {
				var frag, startIdx, n, cnt, sibling, xferNode;
	
				if (how != DELETE) {
					frag = createDocumentFragment();
				}
	
				n = _traverseLeftBoundary(startAncestor, how);
				if (frag) {
					frag.appendChild(n);
				}
	
				startIdx = nodeIndex(startAncestor);
				++startIdx; // Because we already traversed it
	
				cnt = self[END_OFFSET] - startIdx;
				n = startAncestor.nextSibling;
				while (n && cnt > 0) {
					sibling = n.nextSibling;
					xferNode = _traverseFullySelected(n, how);
	
					if (frag) {
						frag.appendChild(xferNode);
					}
	
					--cnt;
					n = sibling;
				}
	
				if (how != CLONE) {
					self.setStartAfter(startAncestor);
					self.collapse(TRUE);
				}
	
				return frag;
			}
	
			function _traverseCommonAncestors(startAncestor, endAncestor, how) {
				var n, frag, startOffset, endOffset, cnt, sibling, nextSibling;
	
				if (how != DELETE) {
					frag = createDocumentFragment();
				}
	
				n = _traverseLeftBoundary(startAncestor, how);
				if (frag) {
					frag.appendChild(n);
				}
	
				startOffset = nodeIndex(startAncestor);
				endOffset = nodeIndex(endAncestor);
				++startOffset;
	
				cnt = endOffset - startOffset;
				sibling = startAncestor.nextSibling;
	
				while (cnt > 0) {
					nextSibling = sibling.nextSibling;
					n = _traverseFullySelected(sibling, how);
	
					if (frag) {
						frag.appendChild(n);
					}
	
					sibling = nextSibling;
					--cnt;
				}
	
				n = _traverseRightBoundary(endAncestor, how);
	
				if (frag) {
					frag.appendChild(n);
				}
	
				if (how != CLONE) {
					self.setStartAfter(startAncestor);
					self.collapse(TRUE);
				}
	
				return frag;
			}
	
			function _traverseRightBoundary(root, how) {
				var next = _getSelectedNode(self[END_CONTAINER], self[END_OFFSET] - 1), parent, clonedParent;
				var prevSibling, clonedChild, clonedGrandParent, isFullySelected = next != self[END_CONTAINER];
	
				if (next == root) {
					return _traverseNode(next, isFullySelected, FALSE, how);
				}
	
				parent = next.parentNode;
				clonedParent = _traverseNode(parent, FALSE, FALSE, how);
	
				while (parent) {
					while (next) {
						prevSibling = next.previousSibling;
						clonedChild = _traverseNode(next, isFullySelected, FALSE, how);
	
						if (how != DELETE) {
							clonedParent.insertBefore(clonedChild, clonedParent.firstChild);
						}
	
						isFullySelected = TRUE;
						next = prevSibling;
					}
	
					if (parent == root) {
						return clonedParent;
					}
	
					next = parent.previousSibling;
					parent = parent.parentNode;
	
					clonedGrandParent = _traverseNode(parent, FALSE, FALSE, how);
	
					if (how != DELETE) {
						clonedGrandParent.appendChild(clonedParent);
					}
	
					clonedParent = clonedGrandParent;
				}
			}
	
			function _traverseLeftBoundary(root, how) {
				var next = _getSelectedNode(self[START_CONTAINER], self[START_OFFSET]), isFullySelected = next != self[START_CONTAINER];
				var parent, clonedParent, nextSibling, clonedChild, clonedGrandParent;
	
				if (next == root) {
					return _traverseNode(next, isFullySelected, TRUE, how);
				}
	
				parent = next.parentNode;
				clonedParent = _traverseNode(parent, FALSE, TRUE, how);
	
				while (parent) {
					while (next) {
						nextSibling = next.nextSibling;
						clonedChild = _traverseNode(next, isFullySelected, TRUE, how);
	
						if (how != DELETE) {
							clonedParent.appendChild(clonedChild);
						}
	
						isFullySelected = TRUE;
						next = nextSibling;
					}
	
					if (parent == root) {
						return clonedParent;
					}
	
					next = parent.nextSibling;
					parent = parent.parentNode;
	
					clonedGrandParent = _traverseNode(parent, FALSE, TRUE, how);
	
					if (how != DELETE) {
						clonedGrandParent.appendChild(clonedParent);
					}
	
					clonedParent = clonedGrandParent;
				}
			}
	
			function _traverseNode(n, isFullySelected, isLeft, how) {
				var txtValue, newNodeValue, oldNodeValue, offset, newNode;
	
				if (isFullySelected) {
					return _traverseFullySelected(n, how);
				}
	
				// TEXT_NODE
				if (n.nodeType == 3) {
					txtValue = n.nodeValue;
	
					if (isLeft) {
						offset = self[START_OFFSET];
						newNodeValue = txtValue.substring(offset);
						oldNodeValue = txtValue.substring(0, offset);
					} else {
						offset = self[END_OFFSET];
						newNodeValue = txtValue.substring(0, offset);
						oldNodeValue = txtValue.substring(offset);
					}
	
					if (how != CLONE) {
						n.nodeValue = oldNodeValue;
					}
	
					if (how == DELETE) {
						return;
					}
	
					newNode = dom.clone(n, FALSE);
					newNode.nodeValue = newNodeValue;
	
					return newNode;
				}
	
				if (how == DELETE) {
					return;
				}
	
				return dom.clone(n, FALSE);
			}
	
			function _traverseFullySelected(n, how) {
				if (how != DELETE) {
					return how == CLONE ? dom.clone(n, TRUE) : n;
				}
	
				n.parentNode.removeChild(n);
			}
	
			function toStringIE() {
				return dom.create('body', null, cloneContents()).outerText;
			}
	
			extend(self, {
				// Initial states
				startContainer: doc,
				startOffset: 0,
				endContainer: doc,
				endOffset: 0,
				collapsed: TRUE,
				commonAncestorContainer: doc,
	
				// Range constants
				START_TO_START: 0,
				START_TO_END: 1,
				END_TO_END: 2,
				END_TO_START: 3,
	
				// Public methods
				setStart: setStart,
				setEnd: setEnd,
				setStartBefore: setStartBefore,
				setStartAfter: setStartAfter,
				setEndBefore: setEndBefore,
				setEndAfter: setEndAfter,
				collapse: collapse,
				selectNode: selectNode,
				selectNodeContents: selectNodeContents,
				compareBoundaryPoints: compareBoundaryPoints,
				deleteContents: deleteContents,
				extractContents: extractContents,
				cloneContents: cloneContents,
				insertNode: insertNode,
				surroundContents: surroundContents,
				cloneRange: cloneRange,
				toStringIE: toStringIE
			});
	
			return self;
		}
	
		// Older IE versions doesn't let you override toString by it's constructor so we have to stick it in the prototype
		Range.prototype.toString = function() {
			return this.toStringIE();
		};
	
		return Range;
	});
	
	// Included from: js/tinymce/classes/html/Entities.js
	
	/**
	 * Entities.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/*jshint bitwise:false */
	/*eslint no-bitwise:0 */
	
	/**
	 * Entity encoder class.
	 *
	 * @class tinymce.html.Entities
	 * @static
	 * @version 3.4
	 */
	define("tinymce/html/Entities", [
		"tinymce/util/Tools"
	], function(Tools) {
		var makeMap = Tools.makeMap;
	
		var namedEntities, baseEntities, reverseEntities,
			attrsCharsRegExp = /[&<>\"\u0060\u007E-\uD7FF\uE000-\uFFEF]|[\uD800-\uDBFF][\uDC00-\uDFFF]/g,
			textCharsRegExp = /[<>&\u007E-\uD7FF\uE000-\uFFEF]|[\uD800-\uDBFF][\uDC00-\uDFFF]/g,
			rawCharsRegExp = /[<>&\"\']/g,
			entityRegExp = /&#([a-z0-9]+);?|&([a-z0-9]+);/gi,
			asciiMap = {
				128: "\u20AC", 130: "\u201A", 131: "\u0192", 132: "\u201E", 133: "\u2026", 134: "\u2020",
				135: "\u2021", 136: "\u02C6", 137: "\u2030", 138: "\u0160", 139: "\u2039", 140: "\u0152",
				142: "\u017D", 145: "\u2018", 146: "\u2019", 147: "\u201C", 148: "\u201D", 149: "\u2022",
				150: "\u2013", 151: "\u2014", 152: "\u02DC", 153: "\u2122", 154: "\u0161", 155: "\u203A",
				156: "\u0153", 158: "\u017E", 159: "\u0178"
			};
	
		// Raw entities
		baseEntities = {
			'\"': '&quot;', // Needs to be escaped since the YUI compressor would otherwise break the code
			"'": '&#39;',
			'<': '&lt;',
			'>': '&gt;',
			'&': '&amp;',
			'\u0060': '&#96;'
		};
	
		// Reverse lookup table for raw entities
		reverseEntities = {
			'&lt;': '<',
			'&gt;': '>',
			'&amp;': '&',
			'&quot;': '"',
			'&apos;': "'"
		};
	
		// Decodes text by using the browser
		function nativeDecode(text) {
			var elm;
	
			elm = document.createElement("div");
			elm.innerHTML = text;
	
			return elm.textContent || elm.innerText || text;
		}
	
		// Build a two way lookup table for the entities
		function buildEntitiesLookup(items, radix) {
			var i, chr, entity, lookup = {};
	
			if (items) {
				items = items.split(',');
				radix = radix || 10;
	
				// Build entities lookup table
				for (i = 0; i < items.length; i += 2) {
					chr = String.fromCharCode(parseInt(items[i], radix));
	
					// Only add non base entities
					if (!baseEntities[chr]) {
						entity = '&' + items[i + 1] + ';';
						lookup[chr] = entity;
						lookup[entity] = chr;
					}
				}
	
				return lookup;
			}
		}
	
		// Unpack entities lookup where the numbers are in radix 32 to reduce the size
		namedEntities = buildEntitiesLookup(
			'50,nbsp,51,iexcl,52,cent,53,pound,54,curren,55,yen,56,brvbar,57,sect,58,uml,59,copy,' +
			'5a,ordf,5b,laquo,5c,not,5d,shy,5e,reg,5f,macr,5g,deg,5h,plusmn,5i,sup2,5j,sup3,5k,acute,' +
			'5l,micro,5m,para,5n,middot,5o,cedil,5p,sup1,5q,ordm,5r,raquo,5s,frac14,5t,frac12,5u,frac34,' +
			'5v,iquest,60,Agrave,61,Aacute,62,Acirc,63,Atilde,64,Auml,65,Aring,66,AElig,67,Ccedil,' +
			'68,Egrave,69,Eacute,6a,Ecirc,6b,Euml,6c,Igrave,6d,Iacute,6e,Icirc,6f,Iuml,6g,ETH,6h,Ntilde,' +
			'6i,Ograve,6j,Oacute,6k,Ocirc,6l,Otilde,6m,Ouml,6n,times,6o,Oslash,6p,Ugrave,6q,Uacute,' +
			'6r,Ucirc,6s,Uuml,6t,Yacute,6u,THORN,6v,szlig,70,agrave,71,aacute,72,acirc,73,atilde,74,auml,' +
			'75,aring,76,aelig,77,ccedil,78,egrave,79,eacute,7a,ecirc,7b,euml,7c,igrave,7d,iacute,7e,icirc,' +
			'7f,iuml,7g,eth,7h,ntilde,7i,ograve,7j,oacute,7k,ocirc,7l,otilde,7m,ouml,7n,divide,7o,oslash,' +
			'7p,ugrave,7q,uacute,7r,ucirc,7s,uuml,7t,yacute,7u,thorn,7v,yuml,ci,fnof,sh,Alpha,si,Beta,' +
			'sj,Gamma,sk,Delta,sl,Epsilon,sm,Zeta,sn,Eta,so,Theta,sp,Iota,sq,Kappa,sr,Lambda,ss,Mu,' +
			'st,Nu,su,Xi,sv,Omicron,t0,Pi,t1,Rho,t3,Sigma,t4,Tau,t5,Upsilon,t6,Phi,t7,Chi,t8,Psi,' +
			't9,Omega,th,alpha,ti,beta,tj,gamma,tk,delta,tl,epsilon,tm,zeta,tn,eta,to,theta,tp,iota,' +
			'tq,kappa,tr,lambda,ts,mu,tt,nu,tu,xi,tv,omicron,u0,pi,u1,rho,u2,sigmaf,u3,sigma,u4,tau,' +
			'u5,upsilon,u6,phi,u7,chi,u8,psi,u9,omega,uh,thetasym,ui,upsih,um,piv,812,bull,816,hellip,' +
			'81i,prime,81j,Prime,81u,oline,824,frasl,88o,weierp,88h,image,88s,real,892,trade,89l,alefsym,' +
			'8cg,larr,8ch,uarr,8ci,rarr,8cj,darr,8ck,harr,8dl,crarr,8eg,lArr,8eh,uArr,8ei,rArr,8ej,dArr,' +
			'8ek,hArr,8g0,forall,8g2,part,8g3,exist,8g5,empty,8g7,nabla,8g8,isin,8g9,notin,8gb,ni,8gf,prod,' +
			'8gh,sum,8gi,minus,8gn,lowast,8gq,radic,8gt,prop,8gu,infin,8h0,ang,8h7,and,8h8,or,8h9,cap,8ha,cup,' +
			'8hb,int,8hk,there4,8hs,sim,8i5,cong,8i8,asymp,8j0,ne,8j1,equiv,8j4,le,8j5,ge,8k2,sub,8k3,sup,8k4,' +
			'nsub,8k6,sube,8k7,supe,8kl,oplus,8kn,otimes,8l5,perp,8m5,sdot,8o8,lceil,8o9,rceil,8oa,lfloor,8ob,' +
			'rfloor,8p9,lang,8pa,rang,9ea,loz,9j0,spades,9j3,clubs,9j5,hearts,9j6,diams,ai,OElig,aj,oelig,b0,' +
			'Scaron,b1,scaron,bo,Yuml,m6,circ,ms,tilde,802,ensp,803,emsp,809,thinsp,80c,zwnj,80d,zwj,80e,lrm,' +
			'80f,rlm,80j,ndash,80k,mdash,80o,lsquo,80p,rsquo,80q,sbquo,80s,ldquo,80t,rdquo,80u,bdquo,810,dagger,' +
			'811,Dagger,81g,permil,81p,lsaquo,81q,rsaquo,85c,euro', 32);
	
		var Entities = {
			/**
			 * Encodes the specified string using raw entities. This means only the required XML base entities will be encoded.
			 *
			 * @method encodeRaw
			 * @param {String} text Text to encode.
			 * @param {Boolean} attr Optional flag to specify if the text is attribute contents.
			 * @return {String} Entity encoded text.
			 */
			encodeRaw: function(text, attr) {
				return text.replace(attr ? attrsCharsRegExp : textCharsRegExp, function(chr) {
					return baseEntities[chr] || chr;
				});
			},
	
			/**
			 * Encoded the specified text with both the attributes and text entities. This function will produce larger text contents
			 * since it doesn't know if the context is within a attribute or text node. This was added for compatibility
			 * and is exposed as the DOMUtils.encode function.
			 *
			 * @method encodeAllRaw
			 * @param {String} text Text to encode.
			 * @return {String} Entity encoded text.
			 */
			encodeAllRaw: function(text) {
				return ('' + text).replace(rawCharsRegExp, function(chr) {
					return baseEntities[chr] || chr;
				});
			},
	
			/**
			 * Encodes the specified string using numeric entities. The core entities will be
			 * encoded as named ones but all non lower ascii characters will be encoded into numeric entities.
			 *
			 * @method encodeNumeric
			 * @param {String} text Text to encode.
			 * @param {Boolean} attr Optional flag to specify if the text is attribute contents.
			 * @return {String} Entity encoded text.
			 */
			encodeNumeric: function(text, attr) {
				return text.replace(attr ? attrsCharsRegExp : textCharsRegExp, function(chr) {
					// Multi byte sequence convert it to a single entity
					if (chr.length > 1) {
						return '&#' + (((chr.charCodeAt(0) - 0xD800) * 0x400) + (chr.charCodeAt(1) - 0xDC00) + 0x10000) + ';';
					}
	
					return baseEntities[chr] || '&#' + chr.charCodeAt(0) + ';';
				});
			},
	
			/**
			 * Encodes the specified string using named entities. The core entities will be encoded
			 * as named ones but all non lower ascii characters will be encoded into named entities.
			 *
			 * @method encodeNamed
			 * @param {String} text Text to encode.
			 * @param {Boolean} attr Optional flag to specify if the text is attribute contents.
			 * @param {Object} entities Optional parameter with entities to use.
			 * @return {String} Entity encoded text.
			 */
			encodeNamed: function(text, attr, entities) {
				entities = entities || namedEntities;
	
				return text.replace(attr ? attrsCharsRegExp : textCharsRegExp, function(chr) {
					return baseEntities[chr] || entities[chr] || chr;
				});
			},
	
			/**
			 * Returns an encode function based on the name(s) and it's optional entities.
			 *
			 * @method getEncodeFunc
			 * @param {String} name Comma separated list of encoders for example named,numeric.
			 * @param {String} entities Optional parameter with entities to use instead of the built in set.
			 * @return {function} Encode function to be used.
			 */
			getEncodeFunc: function(name, entities) {
				entities = buildEntitiesLookup(entities) || namedEntities;
	
				function encodeNamedAndNumeric(text, attr) {
					return text.replace(attr ? attrsCharsRegExp : textCharsRegExp, function(chr) {
						return baseEntities[chr] || entities[chr] || '&#' + chr.charCodeAt(0) + ';' || chr;
					});
				}
	
				function encodeCustomNamed(text, attr) {
					return Entities.encodeNamed(text, attr, entities);
				}
	
				// Replace + with , to be compatible with previous TinyMCE versions
				name = makeMap(name.replace(/\+/g, ','));
	
				// Named and numeric encoder
				if (name.named && name.numeric) {
					return encodeNamedAndNumeric;
				}
	
				// Named encoder
				if (name.named) {
					// Custom names
					if (entities) {
						return encodeCustomNamed;
					}
	
					return Entities.encodeNamed;
				}
	
				// Numeric
				if (name.numeric) {
					return Entities.encodeNumeric;
				}
	
				// Raw encoder
				return Entities.encodeRaw;
			},
	
			/**
			 * Decodes the specified string, this will replace entities with raw UTF characters.
			 *
			 * @method decode
			 * @param {String} text Text to entity decode.
			 * @return {String} Entity decoded string.
			 */
			decode: function(text) {
				return text.replace(entityRegExp, function(all, numeric) {
					if (numeric) {
						if (numeric.charAt(0).toLowerCase() === 'x') {
							numeric = parseInt(numeric.substr(1), 16);
						} else {
							numeric = parseInt(numeric, 10);
						}
	
						// Support upper UTF
						if (numeric > 0xFFFF) {
							numeric -= 0x10000;
	
							return String.fromCharCode(0xD800 + (numeric >> 10), 0xDC00 + (numeric & 0x3FF));
						}
	
						return asciiMap[numeric] || String.fromCharCode(numeric);
					}
	
					return reverseEntities[all] || namedEntities[all] || nativeDecode(all);
				});
			}
		};
	
		return Entities;
	});
	
	// Included from: js/tinymce/classes/dom/StyleSheetLoader.js
	
	/**
	 * StyleSheetLoader.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * This class handles loading of external stylesheets and fires events when these are loaded.
	 *
	 * @class tinymce.dom.StyleSheetLoader
	 * @private
	 */
	define("tinymce/dom/StyleSheetLoader", [
		"tinymce/util/Tools",
		"tinymce/util/Delay"
	], function(Tools, Delay) {
		"use strict";
	
		return function(document, settings) {
			var idCount = 0, loadedStates = {}, maxLoadTime;
	
			settings = settings || {};
			maxLoadTime = settings.maxLoadTime || 5000;
	
			function appendToHead(node) {
				document.getElementsByTagName('head')[0].appendChild(node);
			}
	
			/**
			 * Loads the specified css style sheet file and call the loadedCallback once it's finished loading.
			 *
			 * @method load
			 * @param {String} url Url to be loaded.
			 * @param {Function} loadedCallback Callback to be executed when loaded.
			 * @param {Function} errorCallback Callback to be executed when failed loading.
			 */
			function load(url, loadedCallback, errorCallback) {
				var link, style, startTime, state;
	
				function passed() {
					var callbacks = state.passed, i = callbacks.length;
	
					while (i--) {
						callbacks[i]();
					}
	
					state.status = 2;
					state.passed = [];
					state.failed = [];
				}
	
				function failed() {
					var callbacks = state.failed, i = callbacks.length;
	
					while (i--) {
						callbacks[i]();
					}
	
					state.status = 3;
					state.passed = [];
					state.failed = [];
				}
	
				// Sniffs for older WebKit versions that have the link.onload but a broken one
				function isOldWebKit() {
					var webKitChunks = navigator.userAgent.match(/WebKit\/(\d*)/);
					return !!(webKitChunks && webKitChunks[1] < 536);
				}
	
				// Calls the waitCallback until the test returns true or the timeout occurs
				function wait(testCallback, waitCallback) {
					if (!testCallback()) {
						// Wait for timeout
						if ((new Date().getTime()) - startTime < maxLoadTime) {
							Delay.setTimeout(waitCallback);
						} else {
							failed();
						}
					}
				}
	
				// Workaround for WebKit that doesn't properly support the onload event for link elements
				// Or WebKit that fires the onload event before the StyleSheet is added to the document
				function waitForWebKitLinkLoaded() {
					wait(function() {
						var styleSheets = document.styleSheets, styleSheet, i = styleSheets.length, owner;
	
						while (i--) {
							styleSheet = styleSheets[i];
							owner = styleSheet.ownerNode ? styleSheet.ownerNode : styleSheet.owningElement;
							if (owner && owner.id === link.id) {
								passed();
								return true;
							}
						}
					}, waitForWebKitLinkLoaded);
				}
	
				// Workaround for older Geckos that doesn't have any onload event for StyleSheets
				function waitForGeckoLinkLoaded() {
					wait(function() {
						try {
							// Accessing the cssRules will throw an exception until the CSS file is loaded
							var cssRules = style.sheet.cssRules;
							passed();
							return !!cssRules;
						} catch (ex) {
							// Ignore
						}
					}, waitForGeckoLinkLoaded);
				}
	
				url = Tools._addCacheSuffix(url);
	
				if (!loadedStates[url]) {
					state = {
						passed: [],
						failed: []
					};
	
					loadedStates[url] = state;
				} else {
					state = loadedStates[url];
				}
	
				if (loadedCallback) {
					state.passed.push(loadedCallback);
				}
	
				if (errorCallback) {
					state.failed.push(errorCallback);
				}
	
				// Is loading wait for it to pass
				if (state.status == 1) {
					return;
				}
	
				// Has finished loading and was success
				if (state.status == 2) {
					passed();
					return;
				}
	
				// Has finished loading and was a failure
				if (state.status == 3) {
					failed();
					return;
				}
	
				// Start loading
				state.status = 1;
				link = document.createElement('link');
				link.rel = 'stylesheet';
				link.type = 'text/css';
				link.id = 'u' + (idCount++);
				link.async = false;
				link.defer = false;
				startTime = new Date().getTime();
	
				// Feature detect onload on link element and sniff older webkits since it has an broken onload event
				if ("onload" in link && !isOldWebKit()) {
					link.onload = waitForWebKitLinkLoaded;
					link.onerror = failed;
				} else {
					// Sniff for old Firefox that doesn't support the onload event on link elements
					// TODO: Remove this in the future when everyone uses modern browsers
					if (navigator.userAgent.indexOf("Firefox") > 0) {
						style = document.createElement('style');
						style.textContent = '@import "' + url + '"';
						waitForGeckoLinkLoaded();
						appendToHead(style);
						return;
					}
	
					// Use the id owner on older webkits
					waitForWebKitLinkLoaded();
				}
	
				appendToHead(link);
				link.href = url;
			}
	
			this.load = load;
		};
	});
	
	// Included from: js/tinymce/classes/dom/DOMUtils.js
	
	/**
	 * DOMUtils.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * Utility class for various DOM manipulation and retrieval functions.
	 *
	 * @class tinymce.dom.DOMUtils
	 * @example
	 * // Add a class to an element by id in the page
	 * tinymce.DOM.addClass('someid', 'someclass');
	 *
	 * // Add a class to an element by id inside the editor
	 * tinymce.activeEditor.dom.addClass('someid', 'someclass');
	 */
	define("tinymce/dom/DOMUtils", [
		"tinymce/dom/Sizzle",
		"tinymce/dom/DomQuery",
		"tinymce/html/Styles",
		"tinymce/dom/EventUtils",
		"tinymce/dom/TreeWalker",
		"tinymce/dom/Range",
		"tinymce/html/Entities",
		"tinymce/Env",
		"tinymce/util/Tools",
		"tinymce/dom/StyleSheetLoader"
	], function(Sizzle, $, Styles, EventUtils, TreeWalker, Range, Entities, Env, Tools, StyleSheetLoader) {
		// Shorten names
		var each = Tools.each, is = Tools.is, grep = Tools.grep, trim = Tools.trim;
		var isIE = Env.ie;
		var simpleSelectorRe = /^([a-z0-9],?)+$/i;
		var whiteSpaceRegExp = /^[ \t\r\n]*$/;
	
		function setupAttrHooks(domUtils, settings) {
			var attrHooks = {}, keepValues = settings.keep_values, keepUrlHook;
	
			keepUrlHook = {
				set: function($elm, value, name) {
					if (settings.url_converter) {
						value = settings.url_converter.call(settings.url_converter_scope || domUtils, value, name, $elm[0]);
					}
	
					$elm.attr('data-mce-' + name, value).attr(name, value);
				},
	
				get: function($elm, name) {
					return $elm.attr('data-mce-' + name) || $elm.attr(name);
				}
			};
	
			attrHooks = {
				style: {
					set: function($elm, value) {
						if (value !== null && typeof value === 'object') {
							$elm.css(value);
							return;
						}
	
						if (keepValues) {
							$elm.attr('data-mce-style', value);
						}
	
						$elm.attr('style', value);
					},
	
					get: function($elm) {
						var value = $elm.attr('data-mce-style') || $elm.attr('style');
	
						value = domUtils.serializeStyle(domUtils.parseStyle(value), $elm[0].nodeName);
	
						return value;
					}
				}
			};
	
			if (keepValues) {
				attrHooks.href = attrHooks.src = keepUrlHook;
			}
	
			return attrHooks;
		}
	
		function updateInternalStyleAttr(domUtils, $elm) {
			var value = $elm.attr('style');
	
			value = domUtils.serializeStyle(domUtils.parseStyle(value), $elm[0].nodeName);
	
			if (!value) {
				value = null;
			}
	
			$elm.attr('data-mce-style', value);
		}
	
		function nodeIndex(node, normalized) {
			var idx = 0, lastNodeType, nodeType;
	
			if (node) {
				for (lastNodeType = node.nodeType, node = node.previousSibling; node; node = node.previousSibling) {
					nodeType = node.nodeType;
	
					// Normalize text nodes
					if (normalized && nodeType == 3) {
						if (nodeType == lastNodeType || !node.nodeValue.length) {
							continue;
						}
					}
					idx++;
					lastNodeType = nodeType;
				}
			}
	
			return idx;
		}
	
		/**
		 * Constructs a new DOMUtils instance. Consult the Wiki for more details on settings etc for this class.
		 *
		 * @constructor
		 * @method DOMUtils
		 * @param {Document} doc Document reference to bind the utility class to.
		 * @param {settings} settings Optional settings collection.
		 */
		function DOMUtils(doc, settings) {
			var self = this, blockElementsMap;
	
			self.doc = doc;
			self.win = window;
			self.files = {};
			self.counter = 0;
			self.stdMode = !isIE || doc.documentMode >= 8;
			self.boxModel = !isIE || doc.compatMode == "CSS1Compat" || self.stdMode;
			self.styleSheetLoader = new StyleSheetLoader(doc);
			self.boundEvents = [];
			self.settings = settings = settings || {};
			self.schema = settings.schema;
			self.styles = new Styles({
				url_converter: settings.url_converter,
				url_converter_scope: settings.url_converter_scope
			}, settings.schema);
	
			self.fixDoc(doc);
			self.events = settings.ownEvents ? new EventUtils(settings.proxy) : EventUtils.Event;
			self.attrHooks = setupAttrHooks(self, settings);
			blockElementsMap = settings.schema ? settings.schema.getBlockElements() : {};
			self.$ = $.overrideDefaults(function() {
				return {
					context: doc,
					element: self.getRoot()
				};
			});
	
			/**
			 * Returns true/false if the specified element is a block element or not.
			 *
			 * @method isBlock
			 * @param {Node/String} node Element/Node to check.
			 * @return {Boolean} True/False state if the node is a block element or not.
			 */
			self.isBlock = function(node) {
				// Fix for #5446
				if (!node) {
					return false;
				}
	
				// This function is called in module pattern style since it might be executed with the wrong this scope
				var type = node.nodeType;
	
				// If it's a node then check the type and use the nodeName
				if (type) {
					return !!(type === 1 && blockElementsMap[node.nodeName]);
				}
	
				return !!blockElementsMap[node];
			};
		}
	
		DOMUtils.prototype = {
			$$: function(elm) {
				if (typeof elm == 'string') {
					elm = this.get(elm);
				}
	
				return this.$(elm);
			},
	
			root: null,
	
			fixDoc: function(doc) {
				var settings = this.settings, name;
	
				if (isIE && settings.schema) {
					// Add missing HTML 4/5 elements to IE
					('abbr article aside audio canvas ' +
					'details figcaption figure footer ' +
					'header hgroup mark menu meter nav ' +
					'output progress section summary ' +
					'time video').replace(/\w+/g, function(name) {
						doc.createElement(name);
					});
	
					// Create all custom elements
					for (name in settings.schema.getCustomElements()) {
						doc.createElement(name);
					}
				}
			},
	
			clone: function(node, deep) {
				var self = this, clone, doc;
	
				// TODO: Add feature detection here in the future
				if (!isIE || node.nodeType !== 1 || deep) {
					return node.cloneNode(deep);
				}
	
				doc = self.doc;
	
				// Make a HTML5 safe shallow copy
				if (!deep) {
					clone = doc.createElement(node.nodeName);
	
					// Copy attribs
					each(self.getAttribs(node), function(attr) {
						self.setAttrib(clone, attr.nodeName, self.getAttrib(node, attr.nodeName));
					});
	
					return clone;
				}
	
				return clone.firstChild;
			},
	
			/**
			 * Returns the root node of the document. This is normally the body but might be a DIV. Parents like getParent will not
			 * go above the point of this root node.
			 *
			 * @method getRoot
			 * @return {Element} Root element for the utility class.
			 */
			getRoot: function() {
				var self = this;
	
				return self.settings.root_element || self.doc.body;
			},
	
			/**
			 * Returns the viewport of the window.
			 *
			 * @method getViewPort
			 * @param {Window} win Optional window to get viewport of.
			 * @return {Object} Viewport object with fields x, y, w and h.
			 */
			getViewPort: function(win) {
				var doc, rootElm;
	
				win = !win ? this.win : win;
				doc = win.document;
				rootElm = this.boxModel ? doc.documentElement : doc.body;
	
				// Returns viewport size excluding scrollbars
				return {
					x: win.pageXOffset || rootElm.scrollLeft,
					y: win.pageYOffset || rootElm.scrollTop,
					w: win.innerWidth || rootElm.clientWidth,
					h: win.innerHeight || rootElm.clientHeight
				};
			},
	
			/**
			 * Returns the rectangle for a specific element.
			 *
			 * @method getRect
			 * @param {Element/String} elm Element object or element ID to get rectangle from.
			 * @return {object} Rectangle for specified element object with x, y, w, h fields.
			 */
			getRect: function(elm) {
				var self = this, pos, size;
	
				elm = self.get(elm);
				pos = self.getPos(elm);
				size = self.getSize(elm);
	
				return {
					x: pos.x, y: pos.y,
					w: size.w, h: size.h
				};
			},
	
			/**
			 * Returns the size dimensions of the specified element.
			 *
			 * @method getSize
			 * @param {Element/String} elm Element object or element ID to get rectangle from.
			 * @return {object} Rectangle for specified element object with w, h fields.
			 */
			getSize: function(elm) {
				var self = this, w, h;
	
				elm = self.get(elm);
				w = self.getStyle(elm, 'width');
				h = self.getStyle(elm, 'height');
	
				// Non pixel value, then force offset/clientWidth
				if (w.indexOf('px') === -1) {
					w = 0;
				}
	
				// Non pixel value, then force offset/clientWidth
				if (h.indexOf('px') === -1) {
					h = 0;
				}
	
				return {
					w: parseInt(w, 10) || elm.offsetWidth || elm.clientWidth,
					h: parseInt(h, 10) || elm.offsetHeight || elm.clientHeight
				};
			},
	
			/**
			 * Returns a node by the specified selector function. This function will
			 * loop through all parent nodes and call the specified function for each node.
			 * If the function then returns true indicating that it has found what it was looking for, the loop execution will then end
			 * and the node it found will be returned.
			 *
			 * @method getParent
			 * @param {Node/String} node DOM node to search parents on or ID string.
			 * @param {function} selector Selection function or CSS selector to execute on each node.
			 * @param {Node} root Optional root element, never go below this point.
			 * @return {Node} DOM Node or null if it wasn't found.
			 */
			getParent: function(node, selector, root) {
				return this.getParents(node, selector, root, false);
			},
	
			/**
			 * Returns a node list of all parents matching the specified selector function or pattern.
			 * If the function then returns true indicating that it has found what it was looking for and that node will be collected.
			 *
			 * @method getParents
			 * @param {Node/String} node DOM node to search parents on or ID string.
			 * @param {function} selector Selection function to execute on each node or CSS pattern.
			 * @param {Node} root Optional root element, never go below this point.
			 * @return {Array} Array of nodes or null if it wasn't found.
			 */
			getParents: function(node, selector, root, collect) {
				var self = this, selectorVal, result = [];
	
				node = self.get(node);
				collect = collect === undefined;
	
				// Default root on inline mode
				root = root || (self.getRoot().nodeName != 'BODY' ? self.getRoot().parentNode : null);
	
				// Wrap node name as func
				if (is(selector, 'string')) {
					selectorVal = selector;
	
					if (selector === '*') {
						selector = function(node) {
							return node.nodeType == 1;
						};
					} else {
						selector = function(node) {
							return self.is(node, selectorVal);
						};
					}
				}
	
				while (node) {
					if (node == root || !node.nodeType || node.nodeType === 9) {
						break;
					}
	
					if (!selector || selector(node)) {
						if (collect) {
							result.push(node);
						} else {
							return node;
						}
					}
	
					node = node.parentNode;
				}
	
				return collect ? result : null;
			},
	
			/**
			 * Returns the specified element by ID or the input element if it isn't a string.
			 *
			 * @method get
			 * @param {String/Element} n Element id to look for or element to just pass though.
			 * @return {Element} Element matching the specified id or null if it wasn't found.
			 */
			get: function(elm) {
				var name;
	
				if (elm && this.doc && typeof elm == 'string') {
					name = elm;
					elm = this.doc.getElementById(elm);
	
					// IE and Opera returns meta elements when they match the specified input ID, but getElementsByName seems to do the trick
					if (elm && elm.id !== name) {
						return this.doc.getElementsByName(name)[1];
					}
				}
	
				return elm;
			},
	
			/**
			 * Returns the next node that matches selector or function
			 *
			 * @method getNext
			 * @param {Node} node Node to find siblings from.
			 * @param {String/function} selector Selector CSS expression or function.
			 * @return {Node} Next node item matching the selector or null if it wasn't found.
			 */
			getNext: function(node, selector) {
				return this._findSib(node, selector, 'nextSibling');
			},
	
			/**
			 * Returns the previous node that matches selector or function
			 *
			 * @method getPrev
			 * @param {Node} node Node to find siblings from.
			 * @param {String/function} selector Selector CSS expression or function.
			 * @return {Node} Previous node item matching the selector or null if it wasn't found.
			 */
			getPrev: function(node, selector) {
				return this._findSib(node, selector, 'previousSibling');
			},
	
			// #ifndef jquery
	
			/**
			 * Selects specific elements by a CSS level 3 pattern. For example "div#a1 p.test".
			 * This function is optimized for the most common patterns needed in TinyMCE but it also performs well enough
			 * on more complex patterns.
			 *
			 * @method select
			 * @param {String} selector CSS level 3 pattern to select/find elements by.
			 * @param {Object} scope Optional root element/scope element to search in.
			 * @return {Array} Array with all matched elements.
			 * @example
			 * // Adds a class to all paragraphs in the currently active editor
			 * tinymce.activeEditor.dom.addClass(tinymce.activeEditor.dom.select('p'), 'someclass');
			 *
			 * // Adds a class to all spans that have the test class in the currently active editor
			 * tinymce.activeEditor.dom.addClass(tinymce.activeEditor.dom.select('span.test'), 'someclass')
			 */
			select: function(selector, scope) {
				var self = this;
	
				/*eslint new-cap:0 */
				return Sizzle(selector, self.get(scope) || self.settings.root_element || self.doc, []);
			},
	
			/**
			 * Returns true/false if the specified element matches the specified css pattern.
			 *
			 * @method is
			 * @param {Node/NodeList} elm DOM node to match or an array of nodes to match.
			 * @param {String} selector CSS pattern to match the element against.
			 */
			is: function(elm, selector) {
				var i;
	
				// If it isn't an array then try to do some simple selectors instead of Sizzle for to boost performance
				if (elm.length === undefined) {
					// Simple all selector
					if (selector === '*') {
						return elm.nodeType == 1;
					}
	
					// Simple selector just elements
					if (simpleSelectorRe.test(selector)) {
						selector = selector.toLowerCase().split(/,/);
						elm = elm.nodeName.toLowerCase();
	
						for (i = selector.length - 1; i >= 0; i--) {
							if (selector[i] == elm) {
								return true;
							}
						}
	
						return false;
					}
				}
	
				// Is non element
				if (elm.nodeType && elm.nodeType != 1) {
					return false;
				}
	
				var elms = elm.nodeType ? [elm] : elm;
	
				/*eslint new-cap:0 */
				return Sizzle(selector, elms[0].ownerDocument || elms[0], null, elms).length > 0;
			},
	
			// #endif
	
			/**
			 * Adds the specified element to another element or elements.
			 *
			 * @method add
			 * @param {String/Element/Array} parentElm Element id string, DOM node element or array of ids or elements to add to.
			 * @param {String/Element} name Name of new element to add or existing element to add.
			 * @param {Object} attrs Optional object collection with arguments to add to the new element(s).
			 * @param {String} html Optional inner HTML contents to add for each element.
			 * @param {Boolean} create Optional flag if the element should be created or added.
			 * @return {Element/Array} Element that got created, or an array of created elements if multiple input elements
			 * were passed in.
			 * @example
			 * // Adds a new paragraph to the end of the active editor
			 * tinymce.activeEditor.dom.add(tinymce.activeEditor.getBody(), 'p', {title: 'my title'}, 'Some content');
			 */
			add: function(parentElm, name, attrs, html, create) {
				var self = this;
	
				return this.run(parentElm, function(parentElm) {
					var newElm;
	
					newElm = is(name, 'string') ? self.doc.createElement(name) : name;
					self.setAttribs(newElm, attrs);
	
					if (html) {
						if (html.nodeType) {
							newElm.appendChild(html);
						} else {
							self.setHTML(newElm, html);
						}
					}
	
					return !create ? parentElm.appendChild(newElm) : newElm;
				});
			},
	
			/**
			 * Creates a new element.
			 *
			 * @method create
			 * @param {String} name Name of new element.
			 * @param {Object} attrs Optional object name/value collection with element attributes.
			 * @param {String} html Optional HTML string to set as inner HTML of the element.
			 * @return {Element} HTML DOM node element that got created.
			 * @example
			 * // Adds an element where the caret/selection is in the active editor
			 * var el = tinymce.activeEditor.dom.create('div', {id: 'test', 'class': 'myclass'}, 'some content');
			 * tinymce.activeEditor.selection.setNode(el);
			 */
			create: function(name, attrs, html) {
				return this.add(this.doc.createElement(name), name, attrs, html, 1);
			},
	
			/**
			 * Creates HTML string for element. The element will be closed unless an empty inner HTML string is passed in.
			 *
			 * @method createHTML
			 * @param {String} name Name of new element.
			 * @param {Object} attrs Optional object name/value collection with element attributes.
			 * @param {String} html Optional HTML string to set as inner HTML of the element.
			 * @return {String} String with new HTML element, for example: <a href="#">test</a>.
			 * @example
			 * // Creates a html chunk and inserts it at the current selection/caret location
			 * tinymce.activeEditor.selection.setContent(tinymce.activeEditor.dom.createHTML('a', {href: 'test.html'}, 'some line'));
			 */
			createHTML: function(name, attrs, html) {
				var outHtml = '', key;
	
				outHtml += '<' + name;
	
				for (key in attrs) {
					if (attrs.hasOwnProperty(key) && attrs[key] !== null && typeof attrs[key] != 'undefined') {
						outHtml += ' ' + key + '="' + this.encode(attrs[key]) + '"';
					}
				}
	
				// A call to tinymce.is doesn't work for some odd reason on IE9 possible bug inside their JS runtime
				if (typeof html != "undefined") {
					return outHtml + '>' + html + '</' + name + '>';
				}
	
				return outHtml + ' />';
			},
	
			/**
			 * Creates a document fragment out of the specified HTML string.
			 *
			 * @method createFragment
			 * @param {String} html Html string to create fragment from.
			 * @return {DocumentFragment} Document fragment node.
			 */
			createFragment: function(html) {
				var frag, node, doc = this.doc, container;
	
				container = doc.createElement("div");
				frag = doc.createDocumentFragment();
	
				if (html) {
					container.innerHTML = html;
				}
	
				while ((node = container.firstChild)) {
					frag.appendChild(node);
				}
	
				return frag;
			},
	
			/**
			 * Removes/deletes the specified element(s) from the DOM.
			 *
			 * @method remove
			 * @param {String/Element/Array} node ID of element or DOM element object or array containing multiple elements/ids.
			 * @param {Boolean} keepChildren Optional state to keep children or not. If set to true all children will be
			 * placed at the location of the removed element.
			 * @return {Element/Array} HTML DOM element that got removed, or an array of removed elements if multiple input elements
			 * were passed in.
			 * @example
			 * // Removes all paragraphs in the active editor
			 * tinymce.activeEditor.dom.remove(tinymce.activeEditor.dom.select('p'));
			 *
			 * // Removes an element by id in the document
			 * tinymce.DOM.remove('mydiv');
			 */
			remove: function(node, keepChildren) {
				node = this.$$(node);
	
				if (keepChildren) {
					node.each(function() {
						var child;
	
						while ((child = this.firstChild)) {
							if (child.nodeType == 3 && child.data.length === 0) {
								this.removeChild(child);
							} else {
								this.parentNode.insertBefore(child, this);
							}
						}
					}).remove();
				} else {
					node.remove();
				}
	
				return node.length > 1 ? node.toArray() : node[0];
			},
	
			/**
			 * Sets the CSS style value on a HTML element. The name can be a camelcase string
			 * or the CSS style name like background-color.
			 *
			 * @method setStyle
			 * @param {String/Element/Array} elm HTML element/Array of elements to set CSS style value on.
			 * @param {String} name Name of the style value to set.
			 * @param {String} value Value to set on the style.
			 * @example
			 * // Sets a style value on all paragraphs in the currently active editor
			 * tinymce.activeEditor.dom.setStyle(tinymce.activeEditor.dom.select('p'), 'background-color', 'red');
			 *
			 * // Sets a style value to an element by id in the current document
			 * tinymce.DOM.setStyle('mydiv', 'background-color', 'red');
			 */
			setStyle: function(elm, name, value) {
				elm = this.$$(elm).css(name, value);
	
				if (this.settings.update_styles) {
					updateInternalStyleAttr(this, elm);
				}
			},
	
			/**
			 * Returns the current style or runtime/computed value of an element.
			 *
			 * @method getStyle
			 * @param {String/Element} elm HTML element or element id string to get style from.
			 * @param {String} name Style name to return.
			 * @param {Boolean} computed Computed style.
			 * @return {String} Current style or computed style value of an element.
			 */
			getStyle: function(elm, name, computed) {
				elm = this.$$(elm);
	
				if (computed) {
					return elm.css(name);
				}
	
				// Camelcase it, if needed
				name = name.replace(/-(\D)/g, function(a, b) {
					return b.toUpperCase();
				});
	
				if (name == 'float') {
					name = Env.ie && Env.ie < 12 ? 'styleFloat' : 'cssFloat';
				}
	
				return elm[0] && elm[0].style ? elm[0].style[name] : undefined;
			},
	
			/**
			 * Sets multiple styles on the specified element(s).
			 *
			 * @method setStyles
			 * @param {Element/String/Array} elm DOM element, element id string or array of elements/ids to set styles on.
			 * @param {Object} styles Name/Value collection of style items to add to the element(s).
			 * @example
			 * // Sets styles on all paragraphs in the currently active editor
			 * tinymce.activeEditor.dom.setStyles(tinymce.activeEditor.dom.select('p'), {'background-color': 'red', 'color': 'green'});
			 *
			 * // Sets styles to an element by id in the current document
			 * tinymce.DOM.setStyles('mydiv', {'background-color': 'red', 'color': 'green'});
			 */
			setStyles: function(elm, styles) {
				elm = this.$$(elm).css(styles);
	
				if (this.settings.update_styles) {
					updateInternalStyleAttr(this, elm);
				}
			},
	
			/**
			 * Removes all attributes from an element or elements.
			 *
			 * @method removeAllAttribs
			 * @param {Element/String/Array} e DOM element, element id string or array of elements/ids to remove attributes from.
			 */
			removeAllAttribs: function(e) {
				return this.run(e, function(e) {
					var i, attrs = e.attributes;
					for (i = attrs.length - 1; i >= 0; i--) {
						e.removeAttributeNode(attrs.item(i));
					}
				});
			},
	
			/**
			 * Sets the specified attribute of an element or elements.
			 *
			 * @method setAttrib
			 * @param {Element/String/Array} elm DOM element, element id string or array of elements/ids to set attribute on.
			 * @param {String} name Name of attribute to set.
			 * @param {String} value Value to set on the attribute - if this value is falsy like null, 0 or '' it will remove
			 * the attribute instead.
			 * @example
			 * // Sets class attribute on all paragraphs in the active editor
			 * tinymce.activeEditor.dom.setAttrib(tinymce.activeEditor.dom.select('p'), 'class', 'myclass');
			 *
			 * // Sets class attribute on a specific element in the current page
			 * tinymce.dom.setAttrib('mydiv', 'class', 'myclass');
			 */
			setAttrib: function(elm, name, value) {
				var self = this, originalValue, hook, settings = self.settings;
	
				if (value === '') {
					value = null;
				}
	
				elm = self.$$(elm);
				originalValue = elm.attr(name);
	
				if (!elm.length) {
					return;
				}
	
				hook = self.attrHooks[name];
				if (hook && hook.set) {
					hook.set(elm, value, name);
				} else {
					elm.attr(name, value);
				}
	
				if (originalValue != value && settings.onSetAttrib) {
					settings.onSetAttrib({
						attrElm: elm,
						attrName: name,
						attrValue: value
					});
				}
			},
	
			/**
			 * Sets two or more specified attributes of an element or elements.
			 *
			 * @method setAttribs
			 * @param {Element/String/Array} elm DOM element, element id string or array of elements/ids to set attributes on.
			 * @param {Object} attrs Name/Value collection of attribute items to add to the element(s).
			 * @example
			 * // Sets class and title attributes on all paragraphs in the active editor
			 * tinymce.activeEditor.dom.setAttribs(tinymce.activeEditor.dom.select('p'), {'class': 'myclass', title: 'some title'});
			 *
			 * // Sets class and title attributes on a specific element in the current page
			 * tinymce.DOM.setAttribs('mydiv', {'class': 'myclass', title: 'some title'});
			 */
			setAttribs: function(elm, attrs) {
				var self = this;
	
				self.$$(elm).each(function(i, node) {
					each(attrs, function(value, name) {
						self.setAttrib(node, name, value);
					});
				});
			},
	
			/**
			 * Returns the specified attribute by name.
			 *
			 * @method getAttrib
			 * @param {String/Element} elm Element string id or DOM element to get attribute from.
			 * @param {String} name Name of attribute to get.
			 * @param {String} defaultVal Optional default value to return if the attribute didn't exist.
			 * @return {String} Attribute value string, default value or null if the attribute wasn't found.
			 */
			getAttrib: function(elm, name, defaultVal) {
				var self = this, hook, value;
	
				elm = self.$$(elm);
	
				if (elm.length) {
					hook = self.attrHooks[name];
	
					if (hook && hook.get) {
						value = hook.get(elm, name);
					} else {
						value = elm.attr(name);
					}
				}
	
				if (typeof value == 'undefined') {
					value = defaultVal || '';
				}
	
				return value;
			},
	
			/**
			 * Returns the absolute x, y position of a node. The position will be returned in an object with x, y fields.
			 *
			 * @method getPos
			 * @param {Element/String} elm HTML element or element id to get x, y position from.
			 * @param {Element} rootElm Optional root element to stop calculations at.
			 * @return {object} Absolute position of the specified element object with x, y fields.
			 */
			getPos: function(elm, rootElm) {
				var self = this, x = 0, y = 0, offsetParent, doc = self.doc, body = doc.body, pos;
	
				elm = self.get(elm);
				rootElm = rootElm || body;
	
				if (elm) {
					// Use getBoundingClientRect if it exists since it's faster than looping offset nodes
					// Fallback to offsetParent calculations if the body isn't static better since it stops at the body root
					if (rootElm === body && elm.getBoundingClientRect && $(body).css('position') === 'static') {
						pos = elm.getBoundingClientRect();
						rootElm = self.boxModel ? doc.documentElement : body;
	
						// Add scroll offsets from documentElement or body since IE with the wrong box model will use d.body and so do WebKit
						// Also remove the body/documentelement clientTop/clientLeft on IE 6, 7 since they offset the position
						x = pos.left + (doc.documentElement.scrollLeft || body.scrollLeft) - rootElm.clientLeft;
						y = pos.top + (doc.documentElement.scrollTop || body.scrollTop) - rootElm.clientTop;
	
						return {x: x, y: y};
					}
	
					offsetParent = elm;
					while (offsetParent && offsetParent != rootElm && offsetParent.nodeType) {
						x += offsetParent.offsetLeft || 0;
						y += offsetParent.offsetTop || 0;
						offsetParent = offsetParent.offsetParent;
					}
	
					offsetParent = elm.parentNode;
					while (offsetParent && offsetParent != rootElm && offsetParent.nodeType) {
						x -= offsetParent.scrollLeft || 0;
						y -= offsetParent.scrollTop || 0;
						offsetParent = offsetParent.parentNode;
					}
				}
	
				return {x: x, y: y};
			},
	
			/**
			 * Parses the specified style value into an object collection. This parser will also
			 * merge and remove any redundant items that browsers might have added. It will also convert non-hex
			 * colors to hex values. Urls inside the styles will also be converted to absolute/relative based on settings.
			 *
			 * @method parseStyle
			 * @param {String} cssText Style value to parse, for example: border:1px solid red;.
			 * @return {Object} Object representation of that style, for example: {border: '1px solid red'}
			 */
			parseStyle: function(cssText) {
				return this.styles.parse(cssText);
			},
	
			/**
			 * Serializes the specified style object into a string.
			 *
			 * @method serializeStyle
			 * @param {Object} styles Object to serialize as string, for example: {border: '1px solid red'}
			 * @param {String} name Optional element name.
			 * @return {String} String representation of the style object, for example: border: 1px solid red.
			 */
			serializeStyle: function(styles, name) {
				return this.styles.serialize(styles, name);
			},
	
			/**
			 * Adds a style element at the top of the document with the specified cssText content.
			 *
			 * @method addStyle
			 * @param {String} cssText CSS Text style to add to top of head of document.
			 */
			addStyle: function(cssText) {
				var self = this, doc = self.doc, head, styleElm;
	
				// Prevent inline from loading the same styles twice
				if (self !== DOMUtils.DOM && doc === document) {
					var addedStyles = DOMUtils.DOM.addedStyles;
	
					addedStyles = addedStyles || [];
					if (addedStyles[cssText]) {
						return;
					}
	
					addedStyles[cssText] = true;
					DOMUtils.DOM.addedStyles = addedStyles;
				}
	
				// Create style element if needed
				styleElm = doc.getElementById('mceDefaultStyles');
				if (!styleElm) {
					styleElm = doc.createElement('style');
					styleElm.id = 'mceDefaultStyles';
					styleElm.type = 'text/css';
	
					head = doc.getElementsByTagName('head')[0];
					if (head.firstChild) {
						head.insertBefore(styleElm, head.firstChild);
					} else {
						head.appendChild(styleElm);
					}
				}
	
				// Append style data to old or new style element
				if (styleElm.styleSheet) {
					styleElm.styleSheet.cssText += cssText;
				} else {
					styleElm.appendChild(doc.createTextNode(cssText));
				}
			},
	
			/**
			 * Imports/loads the specified CSS file into the document bound to the class.
			 *
			 * @method loadCSS
			 * @param {String} url URL to CSS file to load.
			 * @example
			 * // Loads a CSS file dynamically into the current document
			 * tinymce.DOM.loadCSS('somepath/some.css');
			 *
			 * // Loads a CSS file into the currently active editor instance
			 * tinymce.activeEditor.dom.loadCSS('somepath/some.css');
			 *
			 * // Loads a CSS file into an editor instance by id
			 * tinymce.get('someid').dom.loadCSS('somepath/some.css');
			 *
			 * // Loads multiple CSS files into the current document
			 * tinymce.DOM.loadCSS('somepath/some.css,somepath/someother.css');
			 */
			loadCSS: function(url) {
				var self = this, doc = self.doc, head;
	
				// Prevent inline from loading the same CSS file twice
				if (self !== DOMUtils.DOM && doc === document) {
					DOMUtils.DOM.loadCSS(url);
					return;
				}
	
				if (!url) {
					url = '';
				}
	
				head = doc.getElementsByTagName('head')[0];
	
				each(url.split(','), function(url) {
					var link;
	
					url = Tools._addCacheSuffix(url);
	
					if (self.files[url]) {
						return;
					}
	
					self.files[url] = true;
					link = self.create('link', {rel: 'stylesheet', href: url});
	
					// IE 8 has a bug where dynamically loading stylesheets would produce a 1 item remaining bug
					// This fix seems to resolve that issue by recalcing the document once a stylesheet finishes loading
					// It's ugly but it seems to work fine.
					if (isIE && doc.documentMode && doc.recalc) {
						link.onload = function() {
							if (doc.recalc) {
								doc.recalc();
							}
	
							link.onload = null;
						};
					}
	
					head.appendChild(link);
				});
			},
	
			/**
			 * Adds a class to the specified element or elements.
			 *
			 * @method addClass
			 * @param {String/Element/Array} elm Element ID string or DOM element or array with elements or IDs.
			 * @param {String} cls Class name to add to each element.
			 * @return {String/Array} String with new class value or array with new class values for all elements.
			 * @example
			 * // Adds a class to all paragraphs in the active editor
			 * tinymce.activeEditor.dom.addClass(tinymce.activeEditor.dom.select('p'), 'myclass');
			 *
			 * // Adds a class to a specific element in the current page
			 * tinymce.DOM.addClass('mydiv', 'myclass');
			 */
			addClass: function(elm, cls) {
				this.$$(elm).addClass(cls);
			},
	
			/**
			 * Removes a class from the specified element or elements.
			 *
			 * @method removeClass
			 * @param {String/Element/Array} elm Element ID string or DOM element or array with elements or IDs.
			 * @param {String} cls Class name to remove from each element.
			 * @return {String/Array} String of remaining class name(s), or an array of strings if multiple input elements
			 * were passed in.
			 * @example
			 * // Removes a class from all paragraphs in the active editor
			 * tinymce.activeEditor.dom.removeClass(tinymce.activeEditor.dom.select('p'), 'myclass');
			 *
			 * // Removes a class from a specific element in the current page
			 * tinymce.DOM.removeClass('mydiv', 'myclass');
			 */
			removeClass: function(elm, cls) {
				this.toggleClass(elm, cls, false);
			},
	
			/**
			 * Returns true if the specified element has the specified class.
			 *
			 * @method hasClass
			 * @param {String/Element} elm HTML element or element id string to check CSS class on.
			 * @param {String} cls CSS class to check for.
			 * @return {Boolean} true/false if the specified element has the specified class.
			 */
			hasClass: function(elm, cls) {
				return this.$$(elm).hasClass(cls);
			},
	
			/**
			 * Toggles the specified class on/off.
			 *
			 * @method toggleClass
			 * @param {Element} elm Element to toggle class on.
			 * @param {[type]} cls Class to toggle on/off.
			 * @param {[type]} state Optional state to set.
			 */
			toggleClass: function(elm, cls, state) {
				this.$$(elm).toggleClass(cls, state).each(function() {
					if (this.className === '') {
						$(this).attr('class', null);
					}
				});
			},
	
			/**
			 * Shows the specified element(s) by ID by setting the "display" style.
			 *
			 * @method show
			 * @param {String/Element/Array} elm ID of DOM element or DOM element or array with elements or IDs to show.
			 */
			show: function(elm) {
				this.$$(elm).show();
			},
	
			/**
			 * Hides the specified element(s) by ID by setting the "display" style.
			 *
			 * @method hide
			 * @param {String/Element/Array} elm ID of DOM element or DOM element or array with elements or IDs to hide.
			 * @example
			 * // Hides an element by id in the document
			 * tinymce.DOM.hide('myid');
			 */
			hide: function(elm) {
				this.$$(elm).hide();
			},
	
			/**
			 * Returns true/false if the element is hidden or not by checking the "display" style.
			 *
			 * @method isHidden
			 * @param {String/Element} elm Id or element to check display state on.
			 * @return {Boolean} true/false if the element is hidden or not.
			 */
			isHidden: function(elm) {
				return this.$$(elm).css('display') == 'none';
			},
	
			/**
			 * Returns a unique id. This can be useful when generating elements on the fly.
			 * This method will not check if the element already exists.
			 *
			 * @method uniqueId
			 * @param {String} prefix Optional prefix to add in front of all ids - defaults to "mce_".
			 * @return {String} Unique id.
			 */
			uniqueId: function(prefix) {
				return (!prefix ? 'mce_' : prefix) + (this.counter++);
			},
	
			/**
			 * Sets the specified HTML content inside the element or elements. The HTML will first be processed. This means
			 * URLs will get converted, hex color values fixed etc. Check processHTML for details.
			 *
			 * @method setHTML
			 * @param {Element/String/Array} elm DOM element, element id string or array of elements/ids to set HTML inside of.
			 * @param {String} html HTML content to set as inner HTML of the element.
			 * @example
			 * // Sets the inner HTML of all paragraphs in the active editor
			 * tinymce.activeEditor.dom.setHTML(tinymce.activeEditor.dom.select('p'), 'some inner html');
			 *
			 * // Sets the inner HTML of an element by id in the document
			 * tinymce.DOM.setHTML('mydiv', 'some inner html');
			 */
			setHTML: function(elm, html) {
				elm = this.$$(elm);
	
				if (isIE) {
					elm.each(function(i, target) {
						if (target.canHaveHTML === false) {
							return;
						}
	
						// Remove all child nodes, IE keeps empty text nodes in DOM
						while (target.firstChild) {
							target.removeChild(target.firstChild);
						}
	
						try {
							// IE will remove comments from the beginning
							// unless you padd the contents with something
							target.innerHTML = '<br>' + html;
							target.removeChild(target.firstChild);
						} catch (ex) {
							// IE sometimes produces an unknown runtime error on innerHTML if it's a div inside a p
							$('<div>').html('<br>' + html).contents().slice(1).appendTo(target);
						}
	
						return html;
					});
				} else {
					elm.html(html);
				}
			},
	
			/**
			 * Returns the outer HTML of an element.
			 *
			 * @method getOuterHTML
			 * @param {String/Element} elm Element ID or element object to get outer HTML from.
			 * @return {String} Outer HTML string.
			 * @example
			 * tinymce.DOM.getOuterHTML(editorElement);
			 * tinymce.activeEditor.getOuterHTML(tinymce.activeEditor.getBody());
			 */
			getOuterHTML: function(elm) {
				elm = this.get(elm);
	
				// Older FF doesn't have outerHTML 3.6 is still used by some orgaizations
				return elm.nodeType == 1 && "outerHTML" in elm ? elm.outerHTML : $('<div>').append($(elm).clone()).html();
			},
	
			/**
			 * Sets the specified outer HTML on an element or elements.
			 *
			 * @method setOuterHTML
			 * @param {Element/String/Array} elm DOM element, element id string or array of elements/ids to set outer HTML on.
			 * @param {Object} html HTML code to set as outer value for the element.
			 * @example
			 * // Sets the outer HTML of all paragraphs in the active editor
			 * tinymce.activeEditor.dom.setOuterHTML(tinymce.activeEditor.dom.select('p'), '<div>some html</div>');
			 *
			 * // Sets the outer HTML of an element by id in the document
			 * tinymce.DOM.setOuterHTML('mydiv', '<div>some html</div>');
			 */
			setOuterHTML: function(elm, html) {
				var self = this;
	
				self.$$(elm).each(function() {
					try {
						// Older FF doesn't have outerHTML 3.6 is still used by some organizations
						if ("outerHTML" in this) {
							this.outerHTML = html;
							return;
						}
					} catch (ex) {
						// Ignore
					}
	
					// OuterHTML for IE it sometimes produces an "unknown runtime error"
					self.remove($(this).html(html), true);
				});
			},
	
			/**
			 * Entity decodes a string. This method decodes any HTML entities, such as &aring;.
			 *
			 * @method decode
			 * @param {String} s String to decode entities on.
			 * @return {String} Entity decoded string.
			 */
			decode: Entities.decode,
	
			/**
			 * Entity encodes a string. This method encodes the most common entities, such as <>"&.
			 *
			 * @method encode
			 * @param {String} text String to encode with entities.
			 * @return {String} Entity encoded string.
			 */
			encode: Entities.encodeAllRaw,
	
			/**
			 * Inserts an element after the reference element.
			 *
			 * @method insertAfter
			 * @param {Element} node Element to insert after the reference.
			 * @param {Element/String/Array} referenceNode Reference element, element id or array of elements to insert after.
			 * @return {Element/Array} Element that got added or an array with elements.
			 */
			insertAfter: function(node, referenceNode) {
				referenceNode = this.get(referenceNode);
	
				return this.run(node, function(node) {
					var parent, nextSibling;
	
					parent = referenceNode.parentNode;
					nextSibling = referenceNode.nextSibling;
	
					if (nextSibling) {
						parent.insertBefore(node, nextSibling);
					} else {
						parent.appendChild(node);
					}
	
					return node;
				});
			},
	
			/**
			 * Replaces the specified element or elements with the new element specified. The new element will
			 * be cloned if multiple input elements are passed in.
			 *
			 * @method replace
			 * @param {Element} newElm New element to replace old ones with.
			 * @param {Element/String/Array} oldElm Element DOM node, element id or array of elements or ids to replace.
			 * @param {Boolean} keepChildren Optional keep children state, if set to true child nodes from the old object will be added
			 * to new ones.
			 */
			replace: function(newElm, oldElm, keepChildren) {
				var self = this;
	
				return self.run(oldElm, function(oldElm) {
					if (is(oldElm, 'array')) {
						newElm = newElm.cloneNode(true);
					}
	
					if (keepChildren) {
						each(grep(oldElm.childNodes), function(node) {
							newElm.appendChild(node);
						});
					}
	
					return oldElm.parentNode.replaceChild(newElm, oldElm);
				});
			},
	
			/**
			 * Renames the specified element and keeps its attributes and children.
			 *
			 * @method rename
			 * @param {Element} elm Element to rename.
			 * @param {String} name Name of the new element.
			 * @return {Element} New element or the old element if it needed renaming.
			 */
			rename: function(elm, name) {
				var self = this, newElm;
	
				if (elm.nodeName != name.toUpperCase()) {
					// Rename block element
					newElm = self.create(name);
	
					// Copy attribs to new block
					each(self.getAttribs(elm), function(attrNode) {
						self.setAttrib(newElm, attrNode.nodeName, self.getAttrib(elm, attrNode.nodeName));
					});
	
					// Replace block
					self.replace(newElm, elm, 1);
				}
	
				return newElm || elm;
			},
	
			/**
			 * Find the common ancestor of two elements. This is a shorter method than using the DOM Range logic.
			 *
			 * @method findCommonAncestor
			 * @param {Element} a Element to find common ancestor of.
			 * @param {Element} b Element to find common ancestor of.
			 * @return {Element} Common ancestor element of the two input elements.
			 */
			findCommonAncestor: function(a, b) {
				var ps = a, pe;
	
				while (ps) {
					pe = b;
	
					while (pe && ps != pe) {
						pe = pe.parentNode;
					}
	
					if (ps == pe) {
						break;
					}
	
					ps = ps.parentNode;
				}
	
				if (!ps && a.ownerDocument) {
					return a.ownerDocument.documentElement;
				}
	
				return ps;
			},
	
			/**
			 * Parses the specified RGB color value and returns a hex version of that color.
			 *
			 * @method toHex
			 * @param {String} rgbVal RGB string value like rgb(1,2,3)
			 * @return {String} Hex version of that RGB value like #FF00FF.
			 */
			toHex: function(rgbVal) {
				return this.styles.toHex(Tools.trim(rgbVal));
			},
	
			/**
			 * Executes the specified function on the element by id or dom element node or array of elements/id.
			 *
			 * @method run
			 * @param {String/Element/Array} elm ID or DOM element object or array with ids or elements.
			 * @param {function} func Function to execute for each item.
			 * @param {Object} scope Optional scope to execute the function in.
			 * @return {Object/Array} Single object, or an array of objects if multiple input elements were passed in.
			 */
			run: function(elm, func, scope) {
				var self = this, result;
	
				if (typeof elm === 'string') {
					elm = self.get(elm);
				}
	
				if (!elm) {
					return false;
				}
	
				scope = scope || this;
				if (!elm.nodeType && (elm.length || elm.length === 0)) {
					result = [];
	
					each(elm, function(elm, i) {
						if (elm) {
							if (typeof elm == 'string') {
								elm = self.get(elm);
							}
	
							result.push(func.call(scope, elm, i));
						}
					});
	
					return result;
				}
	
				return func.call(scope, elm);
			},
	
			/**
			 * Returns a NodeList with attributes for the element.
			 *
			 * @method getAttribs
			 * @param {HTMLElement/string} elm Element node or string id to get attributes from.
			 * @return {NodeList} NodeList with attributes.
			 */
			getAttribs: function(elm) {
				var attrs;
	
				elm = this.get(elm);
	
				if (!elm) {
					return [];
				}
	
				if (isIE) {
					attrs = [];
	
					// Object will throw exception in IE
					if (elm.nodeName == 'OBJECT') {
						return elm.attributes;
					}
	
					// IE doesn't keep the selected attribute if you clone option elements
					if (elm.nodeName === 'OPTION' && this.getAttrib(elm, 'selected')) {
						attrs.push({specified: 1, nodeName: 'selected'});
					}
	
					// It's crazy that this is faster in IE but it's because it returns all attributes all the time
					var attrRegExp = /<\/?[\w:\-]+ ?|=[\"][^\"]+\"|=\'[^\']+\'|=[\w\-]+|>/gi;
					elm.cloneNode(false).outerHTML.replace(attrRegExp, '').replace(/[\w:\-]+/gi, function(a) {
						attrs.push({specified: 1, nodeName: a});
					});
	
					return attrs;
				}
	
				return elm.attributes;
			},
	
			/**
			 * Returns true/false if the specified node is to be considered empty or not.
			 *
			 * @example
			 * tinymce.DOM.isEmpty(node, {img: true});
			 * @method isEmpty
			 * @param {Object} elements Optional name/value object with elements that are automatically treated as non-empty elements.
			 * @return {Boolean} true/false if the node is empty or not.
			 */
			isEmpty: function(node, elements) {
				var self = this, i, attributes, type, walker, name, brCount = 0;
	
				node = node.firstChild;
				if (node) {
					walker = new TreeWalker(node, node.parentNode);
					elements = elements || (self.schema ? self.schema.getNonEmptyElements() : null);
	
					do {
						type = node.nodeType;
	
						if (type === 1) {
							// Ignore bogus elements
							if (node.getAttribute('data-mce-bogus')) {
								continue;
							}
	
							// Keep empty elements like <img />
							name = node.nodeName.toLowerCase();
							if (elements && elements[name]) {
								// Ignore single BR elements in blocks like <p><br /></p> or <p><span><br /></span></p>
								if (name === 'br') {
									brCount++;
									continue;
								}
	
								return false;
							}
	
							// Keep elements with data-bookmark attributes or name attribute like <a name="1"></a>
							attributes = self.getAttribs(node);
							i = attributes.length;
							while (i--) {
								name = attributes[i].nodeName;
								if (name === "name" || name === 'data-mce-bookmark') {
									return false;
								}
							}
						}
	
						// Keep comment nodes
						if (type == 8) {
							return false;
						}
	
						// Keep non whitespace text nodes
						if ((type === 3 && !whiteSpaceRegExp.test(node.nodeValue))) {
							return false;
						}
					} while ((node = walker.next()));
				}
	
				return brCount <= 1;
			},
	
			/**
			 * Creates a new DOM Range object. This will use the native DOM Range API if it's
			 * available. If it's not, it will fall back to the custom TinyMCE implementation.
			 *
			 * @method createRng
			 * @return {DOMRange} DOM Range object.
			 * @example
			 * var rng = tinymce.DOM.createRng();
			 * alert(rng.startContainer + "," + rng.startOffset);
			 */
			createRng: function() {
				var doc = this.doc;
	
				return doc.createRange ? doc.createRange() : new Range(this);
			},
	
			/**
			 * Returns the index of the specified node within its parent.
			 *
			 * @method nodeIndex
			 * @param {Node} node Node to look for.
			 * @param {boolean} normalized Optional true/false state if the index is what it would be after a normalization.
			 * @return {Number} Index of the specified node.
			 */
			nodeIndex: nodeIndex,
	
			/**
			 * Splits an element into two new elements and places the specified split
			 * element or elements between the new ones. For example splitting the paragraph at the bold element in
			 * this example <p>abc<b>abc</b>123</p> would produce <p>abc</p><b>abc</b><p>123</p>.
			 *
			 * @method split
			 * @param {Element} parentElm Parent element to split.
			 * @param {Element} splitElm Element to split at.
			 * @param {Element} replacementElm Optional replacement element to replace the split element with.
			 * @return {Element} Returns the split element or the replacement element if that is specified.
			 */
			split: function(parentElm, splitElm, replacementElm) {
				var self = this, r = self.createRng(), bef, aft, pa;
	
				// W3C valid browsers tend to leave empty nodes to the left/right side of the contents - this makes sense
				// but we don't want that in our code since it serves no purpose for the end user
				// For example splitting this html at the bold element:
				//   <p>text 1<span><b>CHOP</b></span>text 2</p>
				// would produce:
				//   <p>text 1<span></span></p><b>CHOP</b><p><span></span>text 2</p>
				// this function will then trim off empty edges and produce:
				//   <p>text 1</p><b>CHOP</b><p>text 2</p>
				function trimNode(node) {
					var i, children = node.childNodes, type = node.nodeType;
	
					function surroundedBySpans(node) {
						var previousIsSpan = node.previousSibling && node.previousSibling.nodeName == 'SPAN';
						var nextIsSpan = node.nextSibling && node.nextSibling.nodeName == 'SPAN';
						return previousIsSpan && nextIsSpan;
					}
	
					if (type == 1 && node.getAttribute('data-mce-type') == 'bookmark') {
						return;
					}
	
					for (i = children.length - 1; i >= 0; i--) {
						trimNode(children[i]);
					}
	
					if (type != 9) {
						// Keep non whitespace text nodes
						if (type == 3 && node.nodeValue.length > 0) {
							// If parent element isn't a block or there isn't any useful contents for example "<p>   </p>"
							// Also keep text nodes with only spaces if surrounded by spans.
							// eg. "<p><span>a</span> <span>b</span></p>" should keep space between a and b
							var trimmedLength = trim(node.nodeValue).length;
							if (!self.isBlock(node.parentNode) || trimmedLength > 0 || trimmedLength === 0 && surroundedBySpans(node)) {
								return;
							}
						} else if (type == 1) {
							// If the only child is a bookmark then move it up
							children = node.childNodes;
	
							// TODO fix this complex if
							if (children.length == 1 && children[0] && children[0].nodeType == 1 &&
								children[0].getAttribute('data-mce-type') == 'bookmark') {
								node.parentNode.insertBefore(children[0], node);
							}
	
							// Keep non empty elements or img, hr etc
							if (children.length || /^(br|hr|input|img)$/i.test(node.nodeName)) {
								return;
							}
						}
	
						self.remove(node);
					}
	
					return node;
				}
	
				if (parentElm && splitElm) {
					// Get before chunk
					r.setStart(parentElm.parentNode, self.nodeIndex(parentElm));
					r.setEnd(splitElm.parentNode, self.nodeIndex(splitElm));
					bef = r.extractContents();
	
					// Get after chunk
					r = self.createRng();
					r.setStart(splitElm.parentNode, self.nodeIndex(splitElm) + 1);
					r.setEnd(parentElm.parentNode, self.nodeIndex(parentElm) + 1);
					aft = r.extractContents();
	
					// Insert before chunk
					pa = parentElm.parentNode;
					pa.insertBefore(trimNode(bef), parentElm);
	
					// Insert middle chunk
					if (replacementElm) {
						pa.insertBefore(replacementElm, parentElm);
						//pa.replaceChild(replacementElm, splitElm);
					} else {
						pa.insertBefore(splitElm, parentElm);
					}
	
					// Insert after chunk
					pa.insertBefore(trimNode(aft), parentElm);
					self.remove(parentElm);
	
					return replacementElm || splitElm;
				}
			},
	
			/**
			 * Adds an event handler to the specified object.
			 *
			 * @method bind
			 * @param {Element/Document/Window/Array} target Target element to bind events to.
			 * handler to or an array of elements/ids/documents.
			 * @param {String} name Name of event handler to add, for example: click.
			 * @param {function} func Function to execute when the event occurs.
			 * @param {Object} scope Optional scope to execute the function in.
			 * @return {function} Function callback handler the same as the one passed in.
			 */
			bind: function(target, name, func, scope) {
				var self = this;
	
				if (Tools.isArray(target)) {
					var i = target.length;
	
					while (i--) {
						target[i] = self.bind(target[i], name, func, scope);
					}
	
					return target;
				}
	
				// Collect all window/document events bound by editor instance
				if (self.settings.collect && (target === self.doc || target === self.win)) {
					self.boundEvents.push([target, name, func, scope]);
				}
	
				return self.events.bind(target, name, func, scope || self);
			},
	
			/**
			 * Removes the specified event handler by name and function from an element or collection of elements.
			 *
			 * @method unbind
			 * @param {Element/Document/Window/Array} target Target element to unbind events on.
			 * @param {String} name Event handler name, for example: "click"
			 * @param {function} func Function to remove.
			 * @return {bool/Array} Bool state of true if the handler was removed, or an array of states if multiple input elements
			 * were passed in.
			 */
			unbind: function(target, name, func) {
				var self = this, i;
	
				if (Tools.isArray(target)) {
					i = target.length;
	
					while (i--) {
						target[i] = self.unbind(target[i], name, func);
					}
	
					return target;
				}
	
				// Remove any bound events matching the input
				if (self.boundEvents && (target === self.doc || target === self.win)) {
					i = self.boundEvents.length;
	
					while (i--) {
						var item = self.boundEvents[i];
	
						if (target == item[0] && (!name || name == item[1]) && (!func || func == item[2])) {
							this.events.unbind(item[0], item[1], item[2]);
						}
					}
				}
	
				return this.events.unbind(target, name, func);
			},
	
			/**
			 * Fires the specified event name with object on target.
			 *
			 * @method fire
			 * @param {Node/Document/Window} target Target element or object to fire event on.
			 * @param {String} name Name of the event to fire.
			 * @param {Object} evt Event object to send.
			 * @return {Event} Event object.
			 */
			fire: function(target, name, evt) {
				return this.events.fire(target, name, evt);
			},
	
			// Returns the content editable state of a node
			getContentEditable: function(node) {
				var contentEditable;
	
				// Check type
				if (!node || node.nodeType != 1) {
					return null;
				}
	
				// Check for fake content editable
				contentEditable = node.getAttribute("data-mce-contenteditable");
				if (contentEditable && contentEditable !== "inherit") {
					return contentEditable;
				}
	
				// Check for real content editable
				return node.contentEditable !== "inherit" ? node.contentEditable : null;
			},
	
			getContentEditableParent: function(node) {
				var root = this.getRoot(), state = null;
	
				for (; node && node !== root; node = node.parentNode) {
					state = this.getContentEditable(node);
	
					if (state !== null) {
						break;
					}
				}
	
				return state;
			},
	
			/**
			 * Destroys all internal references to the DOM to solve IE leak issues.
			 *
			 * @method destroy
			 */
			destroy: function() {
				var self = this;
	
				// Unbind all events bound to window/document by editor instance
				if (self.boundEvents) {
					var i = self.boundEvents.length;
	
					while (i--) {
						var item = self.boundEvents[i];
						this.events.unbind(item[0], item[1], item[2]);
					}
	
					self.boundEvents = null;
				}
	
				// Restore sizzle document to window.document
				// Since the current document might be removed producing "Permission denied" on IE see #6325
				if (Sizzle.setDocument) {
					Sizzle.setDocument();
				}
	
				self.win = self.doc = self.root = self.events = self.frag = null;
			},
	
			isChildOf: function(node, parent) {
				while (node) {
					if (parent === node) {
						return true;
					}
	
					node = node.parentNode;
				}
	
				return false;
			},
	
			// #ifdef debug
	
			dumpRng: function(r) {
				return (
					'startContainer: ' + r.startContainer.nodeName +
					', startOffset: ' + r.startOffset +
					', endContainer: ' + r.endContainer.nodeName +
					', endOffset: ' + r.endOffset
				);
			},
	
			// #endif
	
			_findSib: function(node, selector, name) {
				var self = this, func = selector;
	
				if (node) {
					// If expression make a function of it using is
					if (typeof func == 'string') {
						func = function(node) {
							return self.is(node, selector);
						};
					}
	
					// Loop all siblings
					for (node = node[name]; node; node = node[name]) {
						if (func(node)) {
							return node;
						}
					}
				}
	
				return null;
			}
		};
	
		/**
		 * Instance of DOMUtils for the current document.
		 *
		 * @static
		 * @property DOM
		 * @type tinymce.dom.DOMUtils
		 * @example
		 * // Example of how to add a class to some element by id
		 * tinymce.DOM.addClass('someid', 'someclass');
		 */
		DOMUtils.DOM = new DOMUtils(document);
		DOMUtils.nodeIndex = nodeIndex;
	
		return DOMUtils;
	});
	
	// Included from: js/tinymce/classes/dom/ScriptLoader.js
	
	/**
	 * ScriptLoader.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/*globals console*/
	
	/**
	 * This class handles asynchronous/synchronous loading of JavaScript files it will execute callbacks
	 * when various items gets loaded. This class is useful to load external JavaScript files.
	 *
	 * @class tinymce.dom.ScriptLoader
	 * @example
	 * // Load a script from a specific URL using the global script loader
	 * tinymce.ScriptLoader.load('somescript.js');
	 *
	 * // Load a script using a unique instance of the script loader
	 * var scriptLoader = new tinymce.dom.ScriptLoader();
	 *
	 * scriptLoader.load('somescript.js');
	 *
	 * // Load multiple scripts
	 * var scriptLoader = new tinymce.dom.ScriptLoader();
	 *
	 * scriptLoader.add('somescript1.js');
	 * scriptLoader.add('somescript2.js');
	 * scriptLoader.add('somescript3.js');
	 *
	 * scriptLoader.loadQueue(function() {
	 *    alert('All scripts are now loaded.');
	 * });
	 */
	define("tinymce/dom/ScriptLoader", [
		"tinymce/dom/DOMUtils",
		"tinymce/util/Tools"
	], function(DOMUtils, Tools) {
		var DOM = DOMUtils.DOM;
		var each = Tools.each, grep = Tools.grep;
	
		function ScriptLoader() {
			var QUEUED = 0,
				LOADING = 1,
				LOADED = 2,
				states = {},
				queue = [],
				scriptLoadedCallbacks = {},
				queueLoadedCallbacks = [],
				loading = 0,
				undef;
	
			/**
			 * Loads a specific script directly without adding it to the load queue.
			 *
			 * @method load
			 * @param {String} url Absolute URL to script to add.
			 * @param {function} callback Optional callback function to execute ones this script gets loaded.
			 */
			function loadScript(url, callback) {
				var dom = DOM, elm, id;
	
				// Execute callback when script is loaded
				function done() {
					dom.remove(id);
	
					if (elm) {
						elm.onreadystatechange = elm.onload = elm = null;
					}
	
					callback();
				}
	
				function error() {
					/*eslint no-console:0 */
	
					// Report the error so it's easier for people to spot loading errors
					if (typeof console !== "undefined" && console.log) {
						console.log("Failed to load: " + url);
					}
	
					// We can't mark it as done if there is a load error since
					// A) We don't want to produce 404 errors on the server and
					// B) the onerror event won't fire on all browsers.
					// done();
				}
	
				id = dom.uniqueId();
	
				// Create new script element
				elm = document.createElement('script');
				elm.id = id;
				elm.type = 'text/javascript';
				elm.src = Tools._addCacheSuffix(url);
	
				// Seems that onreadystatechange works better on IE 10 onload seems to fire incorrectly
				if ("onreadystatechange" in elm) {
					elm.onreadystatechange = function() {
						if (/loaded|complete/.test(elm.readyState)) {
							done();
						}
					};
				} else {
					elm.onload = done;
				}
	
				// Add onerror event will get fired on some browsers but not all of them
				elm.onerror = error;
	
				// Add script to document
				(document.getElementsByTagName('head')[0] || document.body).appendChild(elm);
			}
	
			/**
			 * Returns true/false if a script has been loaded or not.
			 *
			 * @method isDone
			 * @param {String} url URL to check for.
			 * @return {Boolean} true/false if the URL is loaded.
			 */
			this.isDone = function(url) {
				return states[url] == LOADED;
			};
	
			/**
			 * Marks a specific script to be loaded. This can be useful if a script got loaded outside
			 * the script loader or to skip it from loading some script.
			 *
			 * @method markDone
			 * @param {string} url Absolute URL to the script to mark as loaded.
			 */
			this.markDone = function(url) {
				states[url] = LOADED;
			};
	
			/**
			 * Adds a specific script to the load queue of the script loader.
			 *
			 * @method add
			 * @param {String} url Absolute URL to script to add.
			 * @param {function} callback Optional callback function to execute ones this script gets loaded.
			 * @param {Object} scope Optional scope to execute callback in.
			 */
			this.add = this.load = function(url, callback, scope) {
				var state = states[url];
	
				// Add url to load queue
				if (state == undef) {
					queue.push(url);
					states[url] = QUEUED;
				}
	
				if (callback) {
					// Store away callback for later execution
					if (!scriptLoadedCallbacks[url]) {
						scriptLoadedCallbacks[url] = [];
					}
	
					scriptLoadedCallbacks[url].push({
						func: callback,
						scope: scope || this
					});
				}
			};
	
			this.remove = function(url) {
				delete states[url];
				delete scriptLoadedCallbacks[url];
			};
	
			/**
			 * Starts the loading of the queue.
			 *
			 * @method loadQueue
			 * @param {function} callback Optional callback to execute when all queued items are loaded.
			 * @param {Object} scope Optional scope to execute the callback in.
			 */
			this.loadQueue = function(callback, scope) {
				this.loadScripts(queue, callback, scope);
			};
	
			/**
			 * Loads the specified queue of files and executes the callback ones they are loaded.
			 * This method is generally not used outside this class but it might be useful in some scenarios.
			 *
			 * @method loadScripts
			 * @param {Array} scripts Array of queue items to load.
			 * @param {function} callback Optional callback to execute ones all items are loaded.
			 * @param {Object} scope Optional scope to execute callback in.
			 */
			this.loadScripts = function(scripts, callback, scope) {
				var loadScripts;
	
				function execScriptLoadedCallbacks(url) {
					// Execute URL callback functions
					each(scriptLoadedCallbacks[url], function(callback) {
						callback.func.call(callback.scope);
					});
	
					scriptLoadedCallbacks[url] = undef;
				}
	
				queueLoadedCallbacks.push({
					func: callback,
					scope: scope || this
				});
	
				loadScripts = function() {
					var loadingScripts = grep(scripts);
	
					// Current scripts has been handled
					scripts.length = 0;
	
					// Load scripts that needs to be loaded
					each(loadingScripts, function(url) {
						// Script is already loaded then execute script callbacks directly
						if (states[url] == LOADED) {
							execScriptLoadedCallbacks(url);
							return;
						}
	
						// Is script not loading then start loading it
						if (states[url] != LOADING) {
							states[url] = LOADING;
							loading++;
	
							loadScript(url, function() {
								states[url] = LOADED;
								loading--;
	
								execScriptLoadedCallbacks(url);
	
								// Load more scripts if they where added by the recently loaded script
								loadScripts();
							});
						}
					});
	
					// No scripts are currently loading then execute all pending queue loaded callbacks
					if (!loading) {
						each(queueLoadedCallbacks, function(callback) {
							callback.func.call(callback.scope);
						});
	
						queueLoadedCallbacks.length = 0;
					}
				};
	
				loadScripts();
			};
		}
	
		ScriptLoader.ScriptLoader = new ScriptLoader();
	
		return ScriptLoader;
	});
	
	// Included from: js/tinymce/classes/AddOnManager.js
	
	/**
	 * AddOnManager.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * This class handles the loading of themes/plugins or other add-ons and their language packs.
	 *
	 * @class tinymce.AddOnManager
	 */
	define("tinymce/AddOnManager", [
		"tinymce/dom/ScriptLoader",
		"tinymce/util/Tools"
	], function(ScriptLoader, Tools) {
		var each = Tools.each;
	
		function AddOnManager() {
			var self = this;
	
			self.items = [];
			self.urls = {};
			self.lookup = {};
		}
	
		AddOnManager.prototype = {
			/**
			 * Returns the specified add on by the short name.
			 *
			 * @method get
			 * @param {String} name Add-on to look for.
			 * @return {tinymce.Theme/tinymce.Plugin} Theme or plugin add-on instance or undefined.
			 */
			get: function(name) {
				if (this.lookup[name]) {
					return this.lookup[name].instance;
				}
	
				return undefined;
			},
	
			dependencies: function(name) {
				var result;
	
				if (this.lookup[name]) {
					result = this.lookup[name].dependencies;
				}
	
				return result || [];
			},
	
			/**
			 * Loads a language pack for the specified add-on.
			 *
			 * @method requireLangPack
			 * @param {String} name Short name of the add-on.
			 * @param {String} languages Optional comma or space separated list of languages to check if it matches the name.
			 */
			requireLangPack: function(name, languages) {
				var language = AddOnManager.language;
	
				if (language && AddOnManager.languageLoad !== false) {
					if (languages) {
						languages = ',' + languages + ',';
	
						// Load short form sv.js or long form sv_SE.js
						if (languages.indexOf(',' + language.substr(0, 2) + ',') != -1) {
							language = language.substr(0, 2);
						} else if (languages.indexOf(',' + language + ',') == -1) {
							return;
						}
					}
	
					ScriptLoader.ScriptLoader.add(this.urls[name] + '/langs/' + language + '.js');
				}
			},
	
			/**
			 * Adds a instance of the add-on by it's short name.
			 *
			 * @method add
			 * @param {String} id Short name/id for the add-on.
			 * @param {tinymce.Theme/tinymce.Plugin} addOn Theme or plugin to add.
			 * @return {tinymce.Theme/tinymce.Plugin} The same theme or plugin instance that got passed in.
			 * @example
			 * // Create a simple plugin
			 * tinymce.create('tinymce.plugins.TestPlugin', {
			 *   TestPlugin: function(ed, url) {
			 *   ed.on('click', function(e) {
			 *      ed.windowManager.alert('Hello World!');
			 *   });
			 *   }
			 * });
			 *
			 * // Register plugin using the add method
			 * tinymce.PluginManager.add('test', tinymce.plugins.TestPlugin);
			 *
			 * // Initialize TinyMCE
			 * tinymce.init({
			 *  ...
			 *  plugins: '-test' // Init the plugin but don't try to load it
			 * });
			 */
			add: function(id, addOn, dependencies) {
				this.items.push(addOn);
				this.lookup[id] = {instance: addOn, dependencies: dependencies};
	
				return addOn;
			},
	
			remove: function(name) {
				delete this.urls[name];
				delete this.lookup[name];
			},
	
			createUrl: function(baseUrl, dep) {
				if (typeof dep === "object") {
					return dep;
				}
	
				return {prefix: baseUrl.prefix, resource: dep, suffix: baseUrl.suffix};
			},
	
			/**
			 * Add a set of components that will make up the add-on. Using the url of the add-on name as the base url.
			 * This should be used in development mode.  A new compressor/javascript munger process will ensure that the
			 * components are put together into the plugin.js file and compressed correctly.
			 *
			 * @method addComponents
			 * @param {String} pluginName name of the plugin to load scripts from (will be used to get the base url for the plugins).
			 * @param {Array} scripts Array containing the names of the scripts to load.
			 */
			addComponents: function(pluginName, scripts) {
				var pluginUrl = this.urls[pluginName];
	
				each(scripts, function(script) {
					ScriptLoader.ScriptLoader.add(pluginUrl + "/" + script);
				});
			},
	
			/**
			 * Loads an add-on from a specific url.
			 *
			 * @method load
			 * @param {String} name Short name of the add-on that gets loaded.
			 * @param {String} addOnUrl URL to the add-on that will get loaded.
			 * @param {function} callback Optional callback to execute ones the add-on is loaded.
			 * @param {Object} scope Optional scope to execute the callback in.
			 * @example
			 * // Loads a plugin from an external URL
			 * tinymce.PluginManager.load('myplugin', '/some/dir/someplugin/plugin.js');
			 *
			 * // Initialize TinyMCE
			 * tinymce.init({
			 *  ...
			 *  plugins: '-myplugin' // Don't try to load it again
			 * });
			 */
			load: function(name, addOnUrl, callback, scope) {
				var self = this, url = addOnUrl;
	
				function loadDependencies() {
					var dependencies = self.dependencies(name);
	
					each(dependencies, function(dep) {
						var newUrl = self.createUrl(addOnUrl, dep);
	
						self.load(newUrl.resource, newUrl, undefined, undefined);
					});
	
					if (callback) {
						if (scope) {
							callback.call(scope);
						} else {
							callback.call(ScriptLoader);
						}
					}
				}
	
				if (self.urls[name]) {
					return;
				}
	
				if (typeof addOnUrl === "object") {
					url = addOnUrl.prefix + addOnUrl.resource + addOnUrl.suffix;
				}
	
				if (url.indexOf('/') !== 0 && url.indexOf('://') == -1) {
					url = AddOnManager.baseURL + '/' + url;
				}
	
				self.urls[name] = url.substring(0, url.lastIndexOf('/'));
	
				if (self.lookup[name]) {
					loadDependencies();
				} else {
					ScriptLoader.ScriptLoader.add(url, loadDependencies, scope);
				}
			}
		};
	
		AddOnManager.PluginManager = new AddOnManager();
		AddOnManager.ThemeManager = new AddOnManager();
	
		return AddOnManager;
	});
	
	/**
	 * TinyMCE theme class.
	 *
	 * @class tinymce.Theme
	 */
	
	/**
	 * This method is responsible for rendering/generating the overall user interface with toolbars, buttons, iframe containers etc.
	 *
	 * @method renderUI
	 * @param {Object} obj Object parameter containing the targetNode DOM node that will be replaced visually with an editor instance.
	 * @return {Object} an object with items like iframeContainer, editorContainer, sizeContainer, deltaWidth, deltaHeight.
	 */
	
	/**
	 * Plugin base class, this is a pseudo class that describes how a plugin is to be created for TinyMCE. The methods below are all optional.
	 *
	 * @class tinymce.Plugin
	 * @example
	 * tinymce.PluginManager.add('example', function(editor, url) {
	 *     // Add a button that opens a window
	 *     editor.addButton('example', {
	 *         text: 'My button',
	 *         icon: false,
	 *         onclick: function() {
	 *             // Open window
	 *             editor.windowManager.open({
	 *                 title: 'Example plugin',
	 *                 body: [
	 *                     {type: 'textbox', name: 'title', label: 'Title'}
	 *                 ],
	 *                 onsubmit: function(e) {
	 *                     // Insert content when the window form is submitted
	 *                     editor.insertContent('Title: ' + e.data.title);
	 *                 }
	 *             });
	 *         }
	 *     });
	 *
	 *     // Adds a menu item to the tools menu
	 *     editor.addMenuItem('example', {
	 *         text: 'Example plugin',
	 *         context: 'tools',
	 *         onclick: function() {
	 *             // Open window with a specific url
	 *             editor.windowManager.open({
	 *                 title: 'TinyMCE site',
	 *                 url: 'http://www.tinymce.com',
	 *                 width: 800,
	 *                 height: 600,
	 *                 buttons: [{
	 *                     text: 'Close',
	 *                     onclick: 'close'
	 *                 }]
	 *             });
	 *         }
	 *     });
	 * });
	 */
	
	// Included from: js/tinymce/classes/dom/NodeType.js
	
	/**
	 * NodeType.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * Contains various node validation functions.
	 *
	 * @private
	 * @class tinymce.dom.NodeType
	 */
	define("tinymce/dom/NodeType", [], function() {
		function isNodeType(type) {
			return function(node) {
				return !!node && node.nodeType == type;
			};
		}
	
		var isElement = isNodeType(1);
	
		function matchNodeNames(names) {
			names = names.toLowerCase().split(' ');
	
			return function(node) {
				var i, name;
	
				if (node && node.nodeType) {
					name = node.nodeName.toLowerCase();
	
					for (i = 0; i < names.length; i++) {
						if (name === names[i]) {
							return true;
						}
					}
				}
	
				return false;
			};
		}
	
		function matchStyleValues(name, values) {
			values = values.toLowerCase().split(' ');
	
			return function(node) {
				var i, cssValue;
	
				if (isElement(node)) {
					for (i = 0; i < values.length; i++) {
						cssValue = getComputedStyle(node, null).getPropertyValue(name);
						if (cssValue === values[i]) {
							return true;
						}
					}
				}
	
				return false;
			};
		}
	
		function hasPropValue(propName, propValue) {
			return function(node) {
				return isElement(node) && node[propName] === propValue;
			};
		}
	
		function hasAttributeValue(attrName, attrValue) {
			return function(node) {
				return isElement(node) && node.getAttribute(attrName) === attrValue;
			};
		}
	
		function isBogus(node) {
			return isElement(node) && node.hasAttribute('data-mce-bogus');
		}
	
		function hasContentEditableState(value) {
			return function(node) {
				if (isElement(node)) {
					if (node.contentEditable === value) {
						return true;
					}
	
					if (node.getAttribute('data-mce-contenteditable') === value) {
						return true;
					}
				}
	
				return false;
			};
		}
	
		return {
			isText: isNodeType(3),
			isElement: isElement,
			isComment: isNodeType(8),
			isBr: matchNodeNames('br'),
			isContentEditableTrue: hasContentEditableState('true'),
			isContentEditableFalse: hasContentEditableState('false'),
			matchNodeNames: matchNodeNames,
			hasPropValue: hasPropValue,
			hasAttributeValue: hasAttributeValue,
			matchStyleValues: matchStyleValues,
			isBogus: isBogus
		};
	});
	
	// Included from: js/tinymce/classes/text/Zwsp.js
	
	/**
	 * Zwsp.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * ....
	 *
	 * @private
	 * @class tinymce.text.Zwsp
	 * @example
	 * var isZwsp = Zwsp.isZwsp('\u200b');
	 * var abc = Zwsp.trim('a\u200bc');
	 */
	define("tinymce/text/Zwsp", [], function() {
		var ZWSP = '\u200b';
	
		function isZwsp(chr) {
			return chr == ZWSP;
		}
	
		function trim(str) {
			return str.replace(new RegExp(ZWSP, 'g'), '');
		}
	
		return {
			isZwsp: isZwsp,
			ZWSP: ZWSP,
			trim: trim
		};
	});
	
	// Included from: js/tinymce/classes/caret/CaretContainer.js
	
	/**
	 * CaretContainer.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * This module handles caret containers. A caret container is a node that
	 * holds the caret for positional purposes.
	 *
	 * @private
	 * @class tinymce.caret.CaretContainer
	 */
	define("tinymce/caret/CaretContainer", [
		"tinymce/dom/NodeType",
		"tinymce/text/Zwsp"
	], function(NodeType, Zwsp) {
		var isElement = NodeType.isElement,
			isText = NodeType.isText;
	
		function isCaretContainerBlock(node) {
			if (isText(node)) {
				node = node.parentNode;
			}
	
			return isElement(node) && node.hasAttribute('data-mce-caret');
		}
	
		function isCaretContainerInline(node) {
			return isText(node) && Zwsp.isZwsp(node.data);
		}
	
		function isCaretContainer(node) {
			return isCaretContainerBlock(node) || isCaretContainerInline(node);
		}
	
		function insertInline(node, before) {
			var doc, sibling, textNode, parentNode;
	
			doc = node.ownerDocument;
			textNode = doc.createTextNode(Zwsp.ZWSP);
			parentNode = node.parentNode;
	
			if (!before) {
				sibling = node.nextSibling;
				if (isText(sibling)) {
					if (isCaretContainer(sibling)) {
						return sibling;
					}
	
					if (startsWithCaretContainer(sibling)) {
						sibling.splitText(1);
						return sibling;
					}
				}
	
				if (node.nextSibling) {
					parentNode.insertBefore(textNode, node.nextSibling);
				} else {
					parentNode.appendChild(textNode);
				}
			} else {
				sibling = node.previousSibling;
				if (isText(sibling)) {
					if (isCaretContainer(sibling)) {
						return sibling;
					}
	
					if (endsWithCaretContainer(sibling)) {
						return sibling.splitText(sibling.data.length - 1);
					}
				}
	
				parentNode.insertBefore(textNode, node);
			}
	
			return textNode;
		}
	
		function insertBlock(blockName, node, before) {
			var doc, blockNode, parentNode;
	
			doc = node.ownerDocument;
			blockNode = doc.createElement(blockName);
			blockNode.setAttribute('data-mce-caret', before ? 'before' : 'after');
			blockNode.setAttribute('data-mce-bogus', 'all');
			blockNode.appendChild(doc.createTextNode('\u00a0'));
			parentNode = node.parentNode;
	
			if (!before) {
				if (node.nextSibling) {
					parentNode.insertBefore(blockNode, node.nextSibling);
				} else {
					parentNode.appendChild(blockNode);
				}
			} else {
				parentNode.insertBefore(blockNode, node);
			}
	
			return blockNode;
		}
	
		function remove(caretContainerNode) {
			var text;
	
			if (isElement(caretContainerNode) && isCaretContainer(caretContainerNode)) {
				if (caretContainerNode.innerHTML != '&nbsp;') {
					caretContainerNode.removeAttribute('data-mce-caret');
				} else {
					if (caretContainerNode.parentNode) {
						caretContainerNode.parentNode.removeChild(caretContainerNode);
					}
				}
			}
	
			if (isText(caretContainerNode)) {
				text = Zwsp.trim(caretContainerNode.data);
	
				if (text.length === 0) {
					if (caretContainerNode.parentNode) {
						caretContainerNode.parentNode.removeChild(caretContainerNode);
					}
				}
	
				caretContainerNode.nodeValue = text;
			}
		}
	
		function startsWithCaretContainer(node) {
			return isText(node) && node.data[0] == Zwsp.ZWSP;
		}
	
		function endsWithCaretContainer(node) {
			return isText(node) && node.data[node.data.length - 1] == Zwsp.ZWSP;
		}
	
		return {
			isCaretContainer: isCaretContainer,
			isCaretContainerBlock: isCaretContainerBlock,
			isCaretContainerInline: isCaretContainerInline,
			insertInline: insertInline,
			insertBlock: insertBlock,
			remove: remove,
			startsWithCaretContainer: startsWithCaretContainer,
			endsWithCaretContainer: endsWithCaretContainer
		};
	});
	
	// Included from: js/tinymce/classes/dom/RangeUtils.js
	
	/**
	 * RangeUtils.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * This class contains a few utility methods for ranges.
	 *
	 * @class tinymce.dom.RangeUtils
	 */
	define("tinymce/dom/RangeUtils", [
		"tinymce/util/Tools",
		"tinymce/dom/TreeWalker",
		"tinymce/dom/NodeType",
		"tinymce/caret/CaretContainer"
	], function(Tools, TreeWalker, NodeType, CaretContainer) {
		var each = Tools.each,
			isContentEditableFalse = NodeType.isContentEditableFalse,
			isCaretContainer = CaretContainer.isCaretContainer;
	
		function getEndChild(container, index) {
			var childNodes = container.childNodes;
	
			index--;
	
			if (index > childNodes.length - 1) {
				index = childNodes.length - 1;
			} else if (index < 0) {
				index = 0;
			}
	
			return childNodes[index] || container;
		}
	
		function RangeUtils(dom) {
			/**
			 * Walks the specified range like object and executes the callback for each sibling collection it finds.
			 *
			 * @private
			 * @method walk
			 * @param {Object} rng Range like object.
			 * @param {function} callback Callback function to execute for each sibling collection.
			 */
			this.walk = function(rng, callback) {
				var startContainer = rng.startContainer,
					startOffset = rng.startOffset,
					endContainer = rng.endContainer,
					endOffset = rng.endOffset,
					ancestor, startPoint,
					endPoint, node, parent, siblings, nodes;
	
				// Handle table cell selection the table plugin enables
				// you to fake select table cells and perform formatting actions on them
				nodes = dom.select('td[data-mce-selected],th[data-mce-selected]');
				if (nodes.length > 0) {
					each(nodes, function(node) {
						callback([node]);
					});
	
					return;
				}
	
				/**
				 * Excludes start/end text node if they are out side the range
				 *
				 * @private
				 * @param {Array} nodes Nodes to exclude items from.
				 * @return {Array} Array with nodes excluding the start/end container if needed.
				 */
				function exclude(nodes) {
					var node;
	
					// First node is excluded
					node = nodes[0];
					if (node.nodeType === 3 && node === startContainer && startOffset >= node.nodeValue.length) {
						nodes.splice(0, 1);
					}
	
					// Last node is excluded
					node = nodes[nodes.length - 1];
					if (endOffset === 0 && nodes.length > 0 && node === endContainer && node.nodeType === 3) {
						nodes.splice(nodes.length - 1, 1);
					}
	
					return nodes;
				}
	
				/**
				 * Collects siblings
				 *
				 * @private
				 * @param {Node} node Node to collect siblings from.
				 * @param {String} name Name of the sibling to check for.
				 * @param {Node} end_node
				 * @return {Array} Array of collected siblings.
				 */
				function collectSiblings(node, name, end_node) {
					var siblings = [];
	
					for (; node && node != end_node; node = node[name]) {
						siblings.push(node);
					}
	
					return siblings;
				}
	
				/**
				 * Find an end point this is the node just before the common ancestor root.
				 *
				 * @private
				 * @param {Node} node Node to start at.
				 * @param {Node} root Root/ancestor element to stop just before.
				 * @return {Node} Node just before the root element.
				 */
				function findEndPoint(node, root) {
					do {
						if (node.parentNode == root) {
							return node;
						}
	
						node = node.parentNode;
					} while (node);
				}
	
				function walkBoundary(start_node, end_node, next) {
					var siblingName = next ? 'nextSibling' : 'previousSibling';
	
					for (node = start_node, parent = node.parentNode; node && node != end_node; node = parent) {
						parent = node.parentNode;
						siblings = collectSiblings(node == start_node ? node : node[siblingName], siblingName);
	
						if (siblings.length) {
							if (!next) {
								siblings.reverse();
							}
	
							callback(exclude(siblings));
						}
					}
				}
	
				// If index based start position then resolve it
				if (startContainer.nodeType == 1 && startContainer.hasChildNodes()) {
					startContainer = startContainer.childNodes[startOffset];
				}
	
				// If index based end position then resolve it
				if (endContainer.nodeType == 1 && endContainer.hasChildNodes()) {
					endContainer = getEndChild(endContainer, endOffset);
				}
	
				// Same container
				if (startContainer == endContainer) {
					return callback(exclude([startContainer]));
				}
	
				// Find common ancestor and end points
				ancestor = dom.findCommonAncestor(startContainer, endContainer);
	
				// Process left side
				for (node = startContainer; node; node = node.parentNode) {
					if (node === endContainer) {
						return walkBoundary(startContainer, ancestor, true);
					}
	
					if (node === ancestor) {
						break;
					}
				}
	
				// Process right side
				for (node = endContainer; node; node = node.parentNode) {
					if (node === startContainer) {
						return walkBoundary(endContainer, ancestor);
					}
	
					if (node === ancestor) {
						break;
					}
				}
	
				// Find start/end point
				startPoint = findEndPoint(startContainer, ancestor) || startContainer;
				endPoint = findEndPoint(endContainer, ancestor) || endContainer;
	
				// Walk left leaf
				walkBoundary(startContainer, startPoint, true);
	
				// Walk the middle from start to end point
				siblings = collectSiblings(
					startPoint == startContainer ? startPoint : startPoint.nextSibling,
					'nextSibling',
					endPoint == endContainer ? endPoint.nextSibling : endPoint
				);
	
				if (siblings.length) {
					callback(exclude(siblings));
				}
	
				// Walk right leaf
				walkBoundary(endContainer, endPoint);
			};
	
			/**
			 * Splits the specified range at it's start/end points.
			 *
			 * @private
			 * @param {Range/RangeObject} rng Range to split.
			 * @return {Object} Range position object.
			 */
			this.split = function(rng) {
				var startContainer = rng.startContainer,
					startOffset = rng.startOffset,
					endContainer = rng.endContainer,
					endOffset = rng.endOffset;
	
				function splitText(node, offset) {
					return node.splitText(offset);
				}
	
				// Handle single text node
				if (startContainer == endContainer && startContainer.nodeType == 3) {
					if (startOffset > 0 && startOffset < startContainer.nodeValue.length) {
						endContainer = splitText(startContainer, startOffset);
						startContainer = endContainer.previousSibling;
	
						if (endOffset > startOffset) {
							endOffset = endOffset - startOffset;
							startContainer = endContainer = splitText(endContainer, endOffset).previousSibling;
							endOffset = endContainer.nodeValue.length;
							startOffset = 0;
						} else {
							endOffset = 0;
						}
					}
				} else {
					// Split startContainer text node if needed
					if (startContainer.nodeType == 3 && startOffset > 0 && startOffset < startContainer.nodeValue.length) {
						startContainer = splitText(startContainer, startOffset);
						startOffset = 0;
					}
	
					// Split endContainer text node if needed
					if (endContainer.nodeType == 3 && endOffset > 0 && endOffset < endContainer.nodeValue.length) {
						endContainer = splitText(endContainer, endOffset).previousSibling;
						endOffset = endContainer.nodeValue.length;
					}
				}
	
				return {
					startContainer: startContainer,
					startOffset: startOffset,
					endContainer: endContainer,
					endOffset: endOffset
				};
			};
	
			/**
			 * Normalizes the specified range by finding the closest best suitable caret location.
			 *
			 * @private
			 * @param {Range} rng Range to normalize.
			 * @return {Boolean} True/false if the specified range was normalized or not.
			 */
			this.normalize = function(rng) {
				var normalized, collapsed;
	
				function normalizeEndPoint(start) {
					var container, offset, walker, body = dom.getRoot(), node, nonEmptyElementsMap;
					var directionLeft, isAfterNode;
	
					function isTableCell(node) {
						return node && /^(TD|TH|CAPTION)$/.test(node.nodeName);
					}
	
					function hasBrBeforeAfter(node, left) {
						var walker = new TreeWalker(node, dom.getParent(node.parentNode, dom.isBlock) || body);
	
						while ((node = walker[left ? 'prev' : 'next']())) {
							if (node.nodeName === "BR") {
								return true;
							}
						}
					}
	
					function hasContentEditableFalseParent(node) {
						while (node && node != body) {
							if (isContentEditableFalse(node)) {
								return true;
							}
	
							node = node.parentNode;
						}
	
						return false;
					}
	
					function isPrevNode(node, name) {
						return node.previousSibling && node.previousSibling.nodeName == name;
					}
	
					// Walks the dom left/right to find a suitable text node to move the endpoint into
					// It will only walk within the current parent block or body and will stop if it hits a block or a BR/IMG
					function findTextNodeRelative(left, startNode) {
						var walker, lastInlineElement, parentBlockContainer;
	
						startNode = startNode || container;
						parentBlockContainer = dom.getParent(startNode.parentNode, dom.isBlock) || body;
	
						// Lean left before the BR element if it's the only BR within a block element. Gecko bug: #6680
						// This: <p><br>|</p> becomes <p>|<br></p>
						if (left && startNode.nodeName == 'BR' && isAfterNode && dom.isEmpty(parentBlockContainer)) {
							container = startNode.parentNode;
							offset = dom.nodeIndex(startNode);
							normalized = true;
							return;
						}
	
						// Walk left until we hit a text node we can move to or a block/br/img
						walker = new TreeWalker(startNode, parentBlockContainer);
						while ((node = walker[left ? 'prev' : 'next']())) {
							// Break if we hit a non content editable node
							if (dom.getContentEditableParent(node) === "false" || isCaretContainer(node)) {
								return;
							}
	
							// Found text node that has a length
							if (node.nodeType === 3 && node.nodeValue.length > 0) {
								container = node;
								offset = left ? node.nodeValue.length : 0;
								normalized = true;
								return;
							}
	
							// Break if we find a block or a BR/IMG/INPUT etc
							if (dom.isBlock(node) || nonEmptyElementsMap[node.nodeName.toLowerCase()]) {
								return;
							}
	
							lastInlineElement = node;
						}
	
						// Only fetch the last inline element when in caret mode for now
						if (collapsed && lastInlineElement) {
							container = lastInlineElement;
							normalized = true;
							offset = 0;
						}
					}
	
					container = rng[(start ? 'start' : 'end') + 'Container'];
					offset = rng[(start ? 'start' : 'end') + 'Offset'];
					isAfterNode = container.nodeType == 1 && offset === container.childNodes.length;
					nonEmptyElementsMap = dom.schema.getNonEmptyElements();
					directionLeft = start;
	
					if (isCaretContainer(container)) {
						return;
					}
	
					if (container.nodeType == 1 && offset > container.childNodes.length - 1) {
						directionLeft = false;
					}
	
					// If the container is a document move it to the body element
					if (container.nodeType === 9) {
						container = dom.getRoot();
						offset = 0;
					}
	
					// If the container is body try move it into the closest text node or position
					if (container === body) {
						// If start is before/after a image, table etc
						if (directionLeft) {
							node = container.childNodes[offset > 0 ? offset - 1 : 0];
							if (node) {
								if (isCaretContainer(node)) {
									return;
								}
	
								if (nonEmptyElementsMap[node.nodeName] || node.nodeName == "TABLE") {
									return;
								}
							}
						}
	
						// Resolve the index
						if (container.hasChildNodes()) {
							offset = Math.min(!directionLeft && offset > 0 ? offset - 1 : offset, container.childNodes.length - 1);
							container = container.childNodes[offset];
							offset = 0;
	
							if (hasContentEditableFalseParent(container) || isCaretContainer(container)) {
								return;
							}
	
							// Don't walk into elements that doesn't have any child nodes like a IMG
							if (container.hasChildNodes() && !/TABLE/.test(container.nodeName)) {
								// Walk the DOM to find a text node to place the caret at or a BR
								node = container;
								walker = new TreeWalker(container, body);
	
								do {
									if (isContentEditableFalse(node) || isCaretContainer(node)) {
										normalized = false;
										break;
									}
	
									// Found a text node use that position
									if (node.nodeType === 3 && node.nodeValue.length > 0) {
										offset = directionLeft ? 0 : node.nodeValue.length;
										container = node;
										normalized = true;
										break;
									}
	
									// Found a BR/IMG element that we can place the caret before
									if (nonEmptyElementsMap[node.nodeName.toLowerCase()] && !isTableCell(node)) {
										offset = dom.nodeIndex(node);
										container = node.parentNode;
	
										// Put caret after image when moving the end point
										if (node.nodeName == "IMG" && !directionLeft) {
											offset++;
										}
	
										normalized = true;
										break;
									}
								} while ((node = (directionLeft ? walker.next() : walker.prev())));
							}
						}
					}
	
					// Lean the caret to the left if possible
					if (collapsed) {
						// So this: <b>x</b><i>|x</i>
						// Becomes: <b>x|</b><i>x</i>
						// Seems that only gecko has issues with this
						if (container.nodeType === 3 && offset === 0) {
							findTextNodeRelative(true);
						}
	
						// Lean left into empty inline elements when the caret is before a BR
						// So this: <i><b></b><i>|<br></i>
						// Becomes: <i><b>|</b><i><br></i>
						// Seems that only gecko has issues with this.
						// Special edge case for <p><a>x</a>|<br></p> since we don't want <p><a>x|</a><br></p>
						if (container.nodeType === 1) {
							node = container.childNodes[offset];
	
							// Offset is after the containers last child
							// then use the previous child for normalization
							if (!node) {
								node = container.childNodes[offset - 1];
							}
	
							if (node && node.nodeName === 'BR' && !isPrevNode(node, 'A') &&
								!hasBrBeforeAfter(node) && !hasBrBeforeAfter(node, true)) {
								findTextNodeRelative(true, node);
							}
						}
					}
	
					// Lean the start of the selection right if possible
					// So this: x[<b>x]</b>
					// Becomes: x<b>[x]</b>
					if (directionLeft && !collapsed && container.nodeType === 3 && offset === container.nodeValue.length) {
						findTextNodeRelative(false);
					}
	
					// Set endpoint if it was normalized
					if (normalized) {
						rng['set' + (start ? 'Start' : 'End')](container, offset);
					}
				}
	
				collapsed = rng.collapsed;
	
				normalizeEndPoint(true);
	
				if (!collapsed) {
					normalizeEndPoint();
				}
	
				// If it was collapsed then make sure it still is
				if (normalized && collapsed) {
					rng.collapse(true);
				}
	
				return normalized;
			};
		}
	
		/**
		 * Compares two ranges and checks if they are equal.
		 *
		 * @static
		 * @method compareRanges
		 * @param {DOMRange} rng1 First range to compare.
		 * @param {DOMRange} rng2 First range to compare.
		 * @return {Boolean} true/false if the ranges are equal.
		 */
		RangeUtils.compareRanges = function(rng1, rng2) {
			if (rng1 && rng2) {
				// Compare native IE ranges
				if (rng1.item || rng1.duplicate) {
					// Both are control ranges and the selected element matches
					if (rng1.item && rng2.item && rng1.item(0) === rng2.item(0)) {
						return true;
					}
	
					// Both are text ranges and the range matches
					if (rng1.isEqual && rng2.isEqual && rng2.isEqual(rng1)) {
						return true;
					}
				} else {
					// Compare w3c ranges
					return rng1.startContainer == rng2.startContainer && rng1.startOffset == rng2.startOffset;
				}
			}
	
			return false;
		};
	
		/**
		 * Finds the closest selection rect tries to get the range from that.
		 */
		function findClosestIeRange(clientX, clientY, doc) {
			var element, rng, rects;
	
			element = doc.elementFromPoint(clientX, clientY);
			rng = doc.body.createTextRange();
	
			if (!element || element.tagName == 'HTML') {
				element = doc.body;
			}
	
			rng.moveToElementText(element);
			rects = Tools.toArray(rng.getClientRects());
	
			rects = rects.sort(function(a, b) {
				a = Math.abs(Math.max(a.top - clientY, a.bottom - clientY));
				b = Math.abs(Math.max(b.top - clientY, b.bottom - clientY));
	
				return a - b;
			});
	
			if (rects.length > 0) {
				clientY = (rects[0].bottom + rects[0].top) / 2;
	
				try {
					rng.moveToPoint(clientX, clientY);
					rng.collapse(true);
	
					return rng;
				} catch (ex) {
					// At least we tried
				}
			}
	
			return null;
		}
	
		/**
		 * Gets the caret range for the given x/y location.
		 *
		 * @static
		 * @method getCaretRangeFromPoint
		 * @param {Number} clientX X coordinate for range
		 * @param {Number} clientY Y coordinate for range
		 * @param {Document} doc Document that x/y are relative to
		 * @returns {Range} caret range
		 */
		RangeUtils.getCaretRangeFromPoint = function(clientX, clientY, doc) {
			var rng, point;
	
			if (doc.caretPositionFromPoint) {
				point = doc.caretPositionFromPoint(clientX, clientY);
				rng = doc.createRange();
				rng.setStart(point.offsetNode, point.offset);
				rng.collapse(true);
			} else if (doc.caretRangeFromPoint) {
				rng = doc.caretRangeFromPoint(clientX, clientY);
			} else if (doc.body.createTextRange) {
				rng = doc.body.createTextRange();
	
				try {
					rng.moveToPoint(clientX, clientY);
					rng.collapse(true);
				} catch (ex) {
					rng = findClosestIeRange(clientX, clientY, doc);
				}
			}
	
			return rng;
		};
	
		RangeUtils.getSelectedNode = function(range) {
			var startContainer = range.startContainer,
				startOffset = range.startOffset;
	
			if (startContainer.hasChildNodes() && range.endOffset == startOffset + 1) {
				return startContainer.childNodes[startOffset];
			}
	
			return null;
		};
	
		RangeUtils.getNode = function(container, offset) {
			if (container.nodeType == 1 && container.hasChildNodes()) {
				if (offset >= container.childNodes.length) {
					offset = container.childNodes.length - 1;
				}
	
				container = container.childNodes[offset];
			}
	
			return container;
		};
	
		return RangeUtils;
	});
	
	// Included from: js/tinymce/classes/NodeChange.js
	
	/**
	 * NodeChange.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * This class handles the nodechange event dispatching both manual and through selection change events.
	 *
	 * @class tinymce.NodeChange
	 * @private
	 */
	define("tinymce/NodeChange", [
		"tinymce/dom/RangeUtils",
		"tinymce/Env",
		"tinymce/util/Delay"
	], function(RangeUtils, Env, Delay) {
		return function(editor) {
			var lastRng, lastPath = [];
	
			/**
			 * Returns true/false if the current element path has been changed or not.
			 *
			 * @private
			 * @return {Boolean} True if the element path is the same false if it's not.
			 */
			function isSameElementPath(startElm) {
				var i, currentPath;
	
				currentPath = editor.$(startElm).parentsUntil(editor.getBody()).add(startElm);
				if (currentPath.length === lastPath.length) {
					for (i = currentPath.length; i >= 0; i--) {
						if (currentPath[i] !== lastPath[i]) {
							break;
						}
					}
	
					if (i === -1) {
						lastPath = currentPath;
						return true;
					}
				}
	
				lastPath = currentPath;
	
				return false;
			}
	
			// Gecko doesn't support the "selectionchange" event
			if (!('onselectionchange' in editor.getDoc())) {
				editor.on('NodeChange Click MouseUp KeyUp Focus', function(e) {
					var nativeRng, fakeRng;
	
					// Since DOM Ranges mutate on modification
					// of the DOM we need to clone it's contents
					nativeRng = editor.selection.getRng();
					fakeRng = {
						startContainer: nativeRng.startContainer,
						startOffset: nativeRng.startOffset,
						endContainer: nativeRng.endContainer,
						endOffset: nativeRng.endOffset
					};
	
					// Always treat nodechange as a selectionchange since applying
					// formatting to the current range wouldn't update the range but it's parent
					if (e.type == 'nodechange' || !RangeUtils.compareRanges(fakeRng, lastRng)) {
						editor.fire('SelectionChange');
					}
	
					lastRng = fakeRng;
				});
			}
	
			// IE has a bug where it fires a selectionchange on right click that has a range at the start of the body
			// When the contextmenu event fires the selection is located at the right location
			editor.on('contextmenu', function() {
				editor.fire('SelectionChange');
			});
	
			// Selection change is delayed ~200ms on IE when you click inside the current range
			editor.on('SelectionChange', function() {
				var startElm = editor.selection.getStart(true);
	
				// IE 8 will fire a selectionchange event with an incorrect selection
				// when focusing out of table cells. Click inside cell -> toolbar = Invalid SelectionChange event
				if (!Env.range && editor.selection.isCollapsed()) {
					return;
				}
	
				if (!isSameElementPath(startElm) && editor.dom.isChildOf(startElm, editor.getBody())) {
					editor.nodeChanged({selectionChange: true});
				}
			});
	
			// Fire an extra nodeChange on mouseup for compatibility reasons
			editor.on('MouseUp', function(e) {
				if (!e.isDefaultPrevented()) {
					// Delay nodeChanged call for WebKit edge case issue where the range
					// isn't updated until after you click outside a selected image
					if (editor.selection.getNode().nodeName == 'IMG') {
						Delay.setEditorTimeout(editor, function() {
							editor.nodeChanged();
						});
					} else {
						editor.nodeChanged();
					}
				}
			});
	
			/**
			 * Dispatches out a onNodeChange event to all observers. This method should be called when you
			 * need to update the UI states or element path etc.
			 *
			 * @method nodeChanged
			 * @param {Object} args Optional args to pass to NodeChange event handlers.
			 */
			this.nodeChanged = function(args) {
				var selection = editor.selection, node, parents, root;
	
				// Fix for bug #1896577 it seems that this can not be fired while the editor is loading
				if (editor.initialized && selection && !editor.settings.disable_nodechange && !editor.readonly) {
					// Get start node
					root = editor.getBody();
					node = selection.getStart() || root;
	
					// Make sure the node is within the editor root or is the editor root
					if (node.ownerDocument != editor.getDoc() || !editor.dom.isChildOf(node, root)) {
						node = root;
					}
	
					// Edge case for <p>|<img></p>
					if (node.nodeName == 'IMG' && selection.isCollapsed()) {
						node = node.parentNode;
					}
	
					// Get parents and add them to object
					parents = [];
					editor.dom.getParent(node, function(node) {
						if (node === root) {
							return true;
						}
	
						parents.push(node);
					});
	
					args = args || {};
					args.element = node;
					args.parents = parents;
	
					editor.fire('NodeChange', args);
				}
			};
		};
	});
	
	// Included from: js/tinymce/classes/html/Node.js
	
	/**
	 * Node.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * This class is a minimalistic implementation of a DOM like node used by the DomParser class.
	 *
	 * @example
	 * var node = new tinymce.html.Node('strong', 1);
	 * someRoot.append(node);
	 *
	 * @class tinymce.html.Node
	 * @version 3.4
	 */
	define("tinymce/html/Node", [], function() {
		var whiteSpaceRegExp = /^[ \t\r\n]*$/, typeLookup = {
			'#text': 3,
			'#comment': 8,
			'#cdata': 4,
			'#pi': 7,
			'#doctype': 10,
			'#document-fragment': 11
		};
	
		// Walks the tree left/right
		function walk(node, root_node, prev) {
			var sibling, parent, startName = prev ? 'lastChild' : 'firstChild', siblingName = prev ? 'prev' : 'next';
	
			// Walk into nodes if it has a start
			if (node[startName]) {
				return node[startName];
			}
	
			// Return the sibling if it has one
			if (node !== root_node) {
				sibling = node[siblingName];
	
				if (sibling) {
					return sibling;
				}
	
				// Walk up the parents to look for siblings
				for (parent = node.parent; parent && parent !== root_node; parent = parent.parent) {
					sibling = parent[siblingName];
	
					if (sibling) {
						return sibling;
					}
				}
			}
		}
	
		/**
		 * Constructs a new Node instance.
		 *
		 * @constructor
		 * @method Node
		 * @param {String} name Name of the node type.
		 * @param {Number} type Numeric type representing the node.
		 */
		function Node(name, type) {
			this.name = name;
			this.type = type;
	
			if (type === 1) {
				this.attributes = [];
				this.attributes.map = {};
			}
		}
	
		Node.prototype = {
			/**
			 * Replaces the current node with the specified one.
			 *
			 * @example
			 * someNode.replace(someNewNode);
			 *
			 * @method replace
			 * @param {tinymce.html.Node} node Node to replace the current node with.
			 * @return {tinymce.html.Node} The old node that got replaced.
			 */
			replace: function(node) {
				var self = this;
	
				if (node.parent) {
					node.remove();
				}
	
				self.insert(node, self);
				self.remove();
	
				return self;
			},
	
			/**
			 * Gets/sets or removes an attribute by name.
			 *
			 * @example
			 * someNode.attr("name", "value"); // Sets an attribute
			 * console.log(someNode.attr("name")); // Gets an attribute
			 * someNode.attr("name", null); // Removes an attribute
			 *
			 * @method attr
			 * @param {String} name Attribute name to set or get.
			 * @param {String} value Optional value to set.
			 * @return {String/tinymce.html.Node} String or undefined on a get operation or the current node on a set operation.
			 */
			attr: function(name, value) {
				var self = this, attrs, i, undef;
	
				if (typeof name !== "string") {
					for (i in name) {
						self.attr(i, name[i]);
					}
	
					return self;
				}
	
				if ((attrs = self.attributes)) {
					if (value !== undef) {
						// Remove attribute
						if (value === null) {
							if (name in attrs.map) {
								delete attrs.map[name];
	
								i = attrs.length;
								while (i--) {
									if (attrs[i].name === name) {
										attrs = attrs.splice(i, 1);
										return self;
									}
								}
							}
	
							return self;
						}
	
						// Set attribute
						if (name in attrs.map) {
							// Set attribute
							i = attrs.length;
							while (i--) {
								if (attrs[i].name === name) {
									attrs[i].value = value;
									break;
								}
							}
						} else {
							attrs.push({name: name, value: value});
						}
	
						attrs.map[name] = value;
	
						return self;
					}
	
					return attrs.map[name];
				}
			},
	
			/**
			 * Does a shallow clones the node into a new node. It will also exclude id attributes since
			 * there should only be one id per document.
			 *
			 * @example
			 * var clonedNode = node.clone();
			 *
			 * @method clone
			 * @return {tinymce.html.Node} New copy of the original node.
			 */
			clone: function() {
				var self = this, clone = new Node(self.name, self.type), i, l, selfAttrs, selfAttr, cloneAttrs;
	
				// Clone element attributes
				if ((selfAttrs = self.attributes)) {
					cloneAttrs = [];
					cloneAttrs.map = {};
	
					for (i = 0, l = selfAttrs.length; i < l; i++) {
						selfAttr = selfAttrs[i];
	
						// Clone everything except id
						if (selfAttr.name !== 'id') {
							cloneAttrs[cloneAttrs.length] = {name: selfAttr.name, value: selfAttr.value};
							cloneAttrs.map[selfAttr.name] = selfAttr.value;
						}
					}
	
					clone.attributes = cloneAttrs;
				}
	
				clone.value = self.value;
				clone.shortEnded = self.shortEnded;
	
				return clone;
			},
	
			/**
			 * Wraps the node in in another node.
			 *
			 * @example
			 * node.wrap(wrapperNode);
			 *
			 * @method wrap
			 */
			wrap: function(wrapper) {
				var self = this;
	
				self.parent.insert(wrapper, self);
				wrapper.append(self);
	
				return self;
			},
	
			/**
			 * Unwraps the node in other words it removes the node but keeps the children.
			 *
			 * @example
			 * node.unwrap();
			 *
			 * @method unwrap
			 */
			unwrap: function() {
				var self = this, node, next;
	
				for (node = self.firstChild; node;) {
					next = node.next;
					self.insert(node, self, true);
					node = next;
				}
	
				self.remove();
			},
	
			/**
			 * Removes the node from it's parent.
			 *
			 * @example
			 * node.remove();
			 *
			 * @method remove
			 * @return {tinymce.html.Node} Current node that got removed.
			 */
			remove: function() {
				var self = this, parent = self.parent, next = self.next, prev = self.prev;
	
				if (parent) {
					if (parent.firstChild === self) {
						parent.firstChild = next;
	
						if (next) {
							next.prev = null;
						}
					} else {
						prev.next = next;
					}
	
					if (parent.lastChild === self) {
						parent.lastChild = prev;
	
						if (prev) {
							prev.next = null;
						}
					} else {
						next.prev = prev;
					}
	
					self.parent = self.next = self.prev = null;
				}
	
				return self;
			},
	
			/**
			 * Appends a new node as a child of the current node.
			 *
			 * @example
			 * node.append(someNode);
			 *
			 * @method append
			 * @param {tinymce.html.Node} node Node to append as a child of the current one.
			 * @return {tinymce.html.Node} The node that got appended.
			 */
			append: function(node) {
				var self = this, last;
	
				if (node.parent) {
					node.remove();
				}
	
				last = self.lastChild;
				if (last) {
					last.next = node;
					node.prev = last;
					self.lastChild = node;
				} else {
					self.lastChild = self.firstChild = node;
				}
	
				node.parent = self;
	
				return node;
			},
	
			/**
			 * Inserts a node at a specific position as a child of the current node.
			 *
			 * @example
			 * parentNode.insert(newChildNode, oldChildNode);
			 *
			 * @method insert
			 * @param {tinymce.html.Node} node Node to insert as a child of the current node.
			 * @param {tinymce.html.Node} ref_node Reference node to set node before/after.
			 * @param {Boolean} before Optional state to insert the node before the reference node.
			 * @return {tinymce.html.Node} The node that got inserted.
			 */
			insert: function(node, ref_node, before) {
				var parent;
	
				if (node.parent) {
					node.remove();
				}
	
				parent = ref_node.parent || this;
	
				if (before) {
					if (ref_node === parent.firstChild) {
						parent.firstChild = node;
					} else {
						ref_node.prev.next = node;
					}
	
					node.prev = ref_node.prev;
					node.next = ref_node;
					ref_node.prev = node;
				} else {
					if (ref_node === parent.lastChild) {
						parent.lastChild = node;
					} else {
						ref_node.next.prev = node;
					}
	
					node.next = ref_node.next;
					node.prev = ref_node;
					ref_node.next = node;
				}
	
				node.parent = parent;
	
				return node;
			},
	
			/**
			 * Get all children by name.
			 *
			 * @method getAll
			 * @param {String} name Name of the child nodes to collect.
			 * @return {Array} Array with child nodes matchin the specified name.
			 */
			getAll: function(name) {
				var self = this, node, collection = [];
	
				for (node = self.firstChild; node; node = walk(node, self)) {
					if (node.name === name) {
						collection.push(node);
					}
				}
	
				return collection;
			},
	
			/**
			 * Removes all children of the current node.
			 *
			 * @method empty
			 * @return {tinymce.html.Node} The current node that got cleared.
			 */
			empty: function() {
				var self = this, nodes, i, node;
	
				// Remove all children
				if (self.firstChild) {
					nodes = [];
	
					// Collect the children
					for (node = self.firstChild; node; node = walk(node, self)) {
						nodes.push(node);
					}
	
					// Remove the children
					i = nodes.length;
					while (i--) {
						node = nodes[i];
						node.parent = node.firstChild = node.lastChild = node.next = node.prev = null;
					}
				}
	
				self.firstChild = self.lastChild = null;
	
				return self;
			},
	
			/**
			 * Returns true/false if the node is to be considered empty or not.
			 *
			 * @example
			 * node.isEmpty({img: true});
			 * @method isEmpty
			 * @param {Object} elements Name/value object with elements that are automatically treated as non empty elements.
			 * @return {Boolean} true/false if the node is empty or not.
			 */
			isEmpty: function(elements) {
				var self = this, node = self.firstChild, i, name;
	
				if (node) {
					do {
						if (node.type === 1) {
							// Ignore bogus elements
							if (node.attributes.map['data-mce-bogus']) {
								continue;
							}
	
							// Keep empty elements like <img />
							if (elements[node.name]) {
								return false;
							}
	
							// Keep bookmark nodes and name attribute like <a name="1"></a>
							i = node.attributes.length;
							while (i--) {
								name = node.attributes[i].name;
								if (name === "name" || name.indexOf('data-mce-bookmark') === 0) {
									return false;
								}
							}
						}
	
						// Keep comments
						if (node.type === 8) {
							return false;
						}
	
						// Keep non whitespace text nodes
						if ((node.type === 3 && !whiteSpaceRegExp.test(node.value))) {
							return false;
						}
					} while ((node = walk(node, self)));
				}
	
				return true;
			},
	
			/**
			 * Walks to the next or previous node and returns that node or null if it wasn't found.
			 *
			 * @method walk
			 * @param {Boolean} prev Optional previous node state defaults to false.
			 * @return {tinymce.html.Node} Node that is next to or previous of the current node.
			 */
			walk: function(prev) {
				return walk(this, null, prev);
			}
		};
	
		/**
		 * Creates a node of a specific type.
		 *
		 * @static
		 * @method create
		 * @param {String} name Name of the node type to create for example "b" or "#text".
		 * @param {Object} attrs Name/value collection of attributes that will be applied to elements.
		 */
		Node.create = function(name, attrs) {
			var node, attrName;
	
			// Create node
			node = new Node(name, typeLookup[name] || 1);
	
			// Add attributes if needed
			if (attrs) {
				for (attrName in attrs) {
					node.attr(attrName, attrs[attrName]);
				}
			}
	
			return node;
		};
	
		return Node;
	});
	
	// Included from: js/tinymce/classes/html/Schema.js
	
	/**
	 * Schema.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * Schema validator class.
	 *
	 * @class tinymce.html.Schema
	 * @example
	 *  if (tinymce.activeEditor.schema.isValidChild('p', 'span'))
	 *    alert('span is valid child of p.');
	 *
	 *  if (tinymce.activeEditor.schema.getElementRule('p'))
	 *    alert('P is a valid element.');
	 *
	 * @class tinymce.html.Schema
	 * @version 3.4
	 */
	define("tinymce/html/Schema", [
		"tinymce/util/Tools"
	], function(Tools) {
		var mapCache = {}, dummyObj = {};
		var makeMap = Tools.makeMap, each = Tools.each, extend = Tools.extend, explode = Tools.explode, inArray = Tools.inArray;
	
		function split(items, delim) {
			return items ? items.split(delim || ' ') : [];
		}
	
		/**
		 * Builds a schema lookup table
		 *
		 * @private
		 * @param {String} type html4, html5 or html5-strict schema type.
		 * @return {Object} Schema lookup table.
		 */
		function compileSchema(type) {
			var schema = {}, globalAttributes, blockContent;
			var phrasingContent, flowContent, html4BlockContent, html4PhrasingContent;
	
			function add(name, attributes, children) {
				var ni, i, attributesOrder, args = arguments;
	
				function arrayToMap(array, obj) {
					var map = {}, i, l;
	
					for (i = 0, l = array.length; i < l; i++) {
						map[array[i]] = obj || {};
					}
	
					return map;
				}
	
				children = children || [];
				attributes = attributes || "";
	
				if (typeof children === "string") {
					children = split(children);
				}
	
				// Split string children
				for (i = 3; i < args.length; i++) {
					if (typeof args[i] === "string") {
						args[i] = split(args[i]);
					}
	
					children.push.apply(children, args[i]);
				}
	
				name = split(name);
				ni = name.length;
				while (ni--) {
					attributesOrder = [].concat(globalAttributes, split(attributes));
					schema[name[ni]] = {
						attributes: arrayToMap(attributesOrder),
						attributesOrder: attributesOrder,
						children: arrayToMap(children, dummyObj)
					};
				}
			}
	
			function addAttrs(name, attributes) {
				var ni, schemaItem, i, l;
	
				name = split(name);
				ni = name.length;
				attributes = split(attributes);
				while (ni--) {
					schemaItem = schema[name[ni]];
					for (i = 0, l = attributes.length; i < l; i++) {
						schemaItem.attributes[attributes[i]] = {};
						schemaItem.attributesOrder.push(attributes[i]);
					}
				}
			}
	
			// Use cached schema
			if (mapCache[type]) {
				return mapCache[type];
			}
	
			// Attributes present on all elements
			globalAttributes = split("id accesskey class dir lang style tabindex title");
	
			// Event attributes can be opt-in/opt-out
			/*eventAttributes = split("onabort onblur oncancel oncanplay oncanplaythrough onchange onclick onclose oncontextmenu oncuechange " +
					"ondblclick ondrag ondragend ondragenter ondragleave ondragover ondragstart ondrop ondurationchange onemptied onended " +
					"onerror onfocus oninput oninvalid onkeydown onkeypress onkeyup onload onloadeddata onloadedmetadata onloadstart " +
					"onmousedown onmousemove onmouseout onmouseover onmouseup onmousewheel onpause onplay onplaying onprogress onratechange " +
					"onreset onscroll onseeked onseeking onseeking onselect onshow onstalled onsubmit onsuspend ontimeupdate onvolumechange " +
					"onwaiting"
			);*/
	
			// Block content elements
			blockContent = split(
				"address blockquote div dl fieldset form h1 h2 h3 h4 h5 h6 hr menu ol p pre table ul"
			);
	
			// Phrasing content elements from the HTML5 spec (inline)
			phrasingContent = split(
				"a abbr b bdo br button cite code del dfn em embed i iframe img input ins kbd " +
				"label map noscript object q s samp script select small span strong sub sup " +
				"textarea u var #text #comment"
			);
	
			// Add HTML5 items to globalAttributes, blockContent, phrasingContent
			if (type != "html4") {
				globalAttributes.push.apply(globalAttributes, split("contenteditable contextmenu draggable dropzone " +
					"hidden spellcheck translate"));
				blockContent.push.apply(blockContent, split("article aside details dialog figure header footer hgroup section nav"));
				phrasingContent.push.apply(phrasingContent, split("audio canvas command datalist mark meter output picture " +
					"progress time wbr video ruby bdi keygen"));
			}
	
			// Add HTML4 elements unless it's html5-strict
			if (type != "html5-strict") {
				globalAttributes.push("xml:lang");
	
				html4PhrasingContent = split("acronym applet basefont big font strike tt");
				phrasingContent.push.apply(phrasingContent, html4PhrasingContent);
	
				each(html4PhrasingContent, function(name) {
					add(name, "", phrasingContent);
				});
	
				html4BlockContent = split("center dir isindex noframes");
				blockContent.push.apply(blockContent, html4BlockContent);
	
				// Flow content elements from the HTML5 spec (block+inline)
				flowContent = [].concat(blockContent, phrasingContent);
	
				each(html4BlockContent, function(name) {
					add(name, "", flowContent);
				});
			}
	
			// Flow content elements from the HTML5 spec (block+inline)
			flowContent = flowContent || [].concat(blockContent, phrasingContent);
	
			// HTML4 base schema TODO: Move HTML5 specific attributes to HTML5 specific if statement
			// Schema items <element name>, <specific attributes>, <children ..>
			add("html", "manifest", "head body");
			add("head", "", "base command link meta noscript script style title");
			add("title hr noscript br");
			add("base", "href target");
			add("link", "href rel media hreflang type sizes hreflang");
			add("meta", "name http-equiv content charset");
			add("style", "media type scoped");
			add("script", "src async defer type charset");
			add("body", "onafterprint onbeforeprint onbeforeunload onblur onerror onfocus " +
					"onhashchange onload onmessage onoffline ononline onpagehide onpageshow " +
					"onpopstate onresize onscroll onstorage onunload", flowContent);
			add("address dt dd div caption", "", flowContent);
			add("h1 h2 h3 h4 h5 h6 pre p abbr code var samp kbd sub sup i b u bdo span legend em strong small s cite dfn", "", phrasingContent);
			add("blockquote", "cite", flowContent);
			add("ol", "reversed start type", "li");
			add("ul", "", "li");
			add("li", "value", flowContent);
			add("dl", "", "dt dd");
			add("a", "href target rel media hreflang type", phrasingContent);
			add("q", "cite", phrasingContent);
			add("ins del", "cite datetime", flowContent);
			add("img", "src sizes srcset alt usemap ismap width height");
			add("iframe", "src name width height", flowContent);
			add("embed", "src type width height");
			add("object", "data type typemustmatch name usemap form width height", flowContent, "param");
			add("param", "name value");
			add("map", "name", flowContent, "area");
			add("area", "alt coords shape href target rel media hreflang type");
			add("table", "border", "caption colgroup thead tfoot tbody tr" + (type == "html4" ? " col" : ""));
			add("colgroup", "span", "col");
			add("col", "span");
			add("tbody thead tfoot", "", "tr");
			add("tr", "", "td th");
			add("td", "colspan rowspan headers", flowContent);
			add("th", "colspan rowspan headers scope abbr", flowContent);
			add("form", "accept-charset action autocomplete enctype method name novalidate target", flowContent);
			add("fieldset", "disabled form name", flowContent, "legend");
			add("label", "form for", phrasingContent);
			add("input", "accept alt autocomplete checked dirname disabled form formaction formenctype formmethod formnovalidate " +
					"formtarget height list max maxlength min multiple name pattern readonly required size src step type value width"
			);
			add("button", "disabled form formaction formenctype formmethod formnovalidate formtarget name type value",
				type == "html4" ? flowContent : phrasingContent);
			add("select", "disabled form multiple name required size", "option optgroup");
			add("optgroup", "disabled label", "option");
			add("option", "disabled label selected value");
			add("textarea", "cols dirname disabled form maxlength name readonly required rows wrap");
			add("menu", "type label", flowContent, "li");
			add("noscript", "", flowContent);
	
			// Extend with HTML5 elements
			if (type != "html4") {
				add("wbr");
				add("ruby", "", phrasingContent, "rt rp");
				add("figcaption", "", flowContent);
				add("mark rt rp summary bdi", "", phrasingContent);
				add("canvas", "width height", flowContent);
				add("video", "src crossorigin poster preload autoplay mediagroup loop " +
					"muted controls width height buffered", flowContent, "track source");
				add("audio", "src crossorigin preload autoplay mediagroup loop muted controls buffered volume", flowContent, "track source");
				add("picture", "", "img source");
				add("source", "src srcset type media sizes");
				add("track", "kind src srclang label default");
				add("datalist", "", phrasingContent, "option");
				add("article section nav aside header footer", "", flowContent);
				add("hgroup", "", "h1 h2 h3 h4 h5 h6");
				add("figure", "", flowContent, "figcaption");
				add("time", "datetime", phrasingContent);
				add("dialog", "open", flowContent);
				add("command", "type label icon disabled checked radiogroup command");
				add("output", "for form name", phrasingContent);
				add("progress", "value max", phrasingContent);
				add("meter", "value min max low high optimum", phrasingContent);
				add("details", "open", flowContent, "summary");
				add("keygen", "autofocus challenge disabled form keytype name");
			}
	
			// Extend with HTML4 attributes unless it's html5-strict
			if (type != "html5-strict") {
				addAttrs("script", "language xml:space");
				addAttrs("style", "xml:space");
				addAttrs("object", "declare classid code codebase codetype archive standby align border hspace vspace");
				addAttrs("embed", "align name hspace vspace");
				addAttrs("param", "valuetype type");
				addAttrs("a", "charset name rev shape coords");
				addAttrs("br", "clear");
				addAttrs("applet", "codebase archive code object alt name width height align hspace vspace");
				addAttrs("img", "name longdesc align border hspace vspace");
				addAttrs("iframe", "longdesc frameborder marginwidth marginheight scrolling align");
				addAttrs("font basefont", "size color face");
				addAttrs("input", "usemap align");
				addAttrs("select", "onchange");
				addAttrs("textarea");
				addAttrs("h1 h2 h3 h4 h5 h6 div p legend caption", "align");
				addAttrs("ul", "type compact");
				addAttrs("li", "type");
				addAttrs("ol dl menu dir", "compact");
				addAttrs("pre", "width xml:space");
				addAttrs("hr", "align noshade size width");
				addAttrs("isindex", "prompt");
				addAttrs("table", "summary width frame rules cellspacing cellpadding align bgcolor");
				addAttrs("col", "width align char charoff valign");
				addAttrs("colgroup", "width align char charoff valign");
				addAttrs("thead", "align char charoff valign");
				addAttrs("tr", "align char charoff valign bgcolor");
				addAttrs("th", "axis align char charoff valign nowrap bgcolor width height");
				addAttrs("form", "accept");
				addAttrs("td", "abbr axis scope align char charoff valign nowrap bgcolor width height");
				addAttrs("tfoot", "align char charoff valign");
				addAttrs("tbody", "align char charoff valign");
				addAttrs("area", "nohref");
				addAttrs("body", "background bgcolor text link vlink alink");
			}
	
			// Extend with HTML5 attributes unless it's html4
			if (type != "html4") {
				addAttrs("input button select textarea", "autofocus");
				addAttrs("input textarea", "placeholder");
				addAttrs("a", "download");
				addAttrs("link script img", "crossorigin");
				addAttrs("iframe", "sandbox seamless allowfullscreen"); // Excluded: srcdoc
			}
	
			// Special: iframe, ruby, video, audio, label
	
			// Delete children of the same name from it's parent
			// For example: form can't have a child of the name form
			each(split('a form meter progress dfn'), function(name) {
				if (schema[name]) {
					delete schema[name].children[name];
				}
			});
	
			// Delete header, footer, sectioning and heading content descendants
			/*each('dt th address', function(name) {
				delete schema[name].children[name];
			});*/
	
			// Caption can't have tables
			delete schema.caption.children.table;
	
			// Delete scripts by default due to possible XSS
			delete schema.script;
	
			// TODO: LI:s can only have value if parent is OL
	
			// TODO: Handle transparent elements
			// a ins del canvas map
	
			mapCache[type] = schema;
	
			return schema;
		}
	
		function compileElementMap(value, mode) {
			var styles;
	
			if (value) {
				styles = {};
	
				if (typeof value == 'string') {
					value = {
						'*': value
					};
				}
	
				// Convert styles into a rule list
				each(value, function(value, key) {
					styles[key] = styles[key.toUpperCase()] = mode == 'map' ? makeMap(value, /[, ]/) : explode(value, /[, ]/);
				});
			}
	
			return styles;
		}
	
		/**
		 * Constructs a new Schema instance.
		 *
		 * @constructor
		 * @method Schema
		 * @param {Object} settings Name/value settings object.
		 */
		return function(settings) {
			var self = this, elements = {}, children = {}, patternElements = [], validStyles, invalidStyles, schemaItems;
			var whiteSpaceElementsMap, selfClosingElementsMap, shortEndedElementsMap, boolAttrMap, validClasses;
			var blockElementsMap, nonEmptyElementsMap, moveCaretBeforeOnEnterElementsMap, textBlockElementsMap, textInlineElementsMap;
			var customElementsMap = {}, specialElements = {};
	
			// Creates an lookup table map object for the specified option or the default value
			function createLookupTable(option, default_value, extendWith) {
				var value = settings[option];
	
				if (!value) {
					// Get cached default map or make it if needed
					value = mapCache[option];
	
					if (!value) {
						value = makeMap(default_value, ' ', makeMap(default_value.toUpperCase(), ' '));
						value = extend(value, extendWith);
	
						mapCache[option] = value;
					}
				} else {
					// Create custom map
					value = makeMap(value, /[, ]/, makeMap(value.toUpperCase(), /[, ]/));
				}
	
				return value;
			}
	
			settings = settings || {};
			schemaItems = compileSchema(settings.schema);
	
			// Allow all elements and attributes if verify_html is set to false
			if (settings.verify_html === false) {
				settings.valid_elements = '*[*]';
			}
	
			validStyles = compileElementMap(settings.valid_styles);
			invalidStyles = compileElementMap(settings.invalid_styles, 'map');
			validClasses = compileElementMap(settings.valid_classes, 'map');
	
			// Setup map objects
			whiteSpaceElementsMap = createLookupTable('whitespace_elements', 'pre script noscript style textarea video audio iframe object');
			selfClosingElementsMap = createLookupTable('self_closing_elements', 'colgroup dd dt li option p td tfoot th thead tr');
			shortEndedElementsMap = createLookupTable('short_ended_elements', 'area base basefont br col frame hr img input isindex link ' +
				'meta param embed source wbr track');
			boolAttrMap = createLookupTable('boolean_attributes', 'checked compact declare defer disabled ismap multiple nohref noresize ' +
				'noshade nowrap readonly selected autoplay loop controls');
			nonEmptyElementsMap = createLookupTable('non_empty_elements', 'td th iframe video audio object script', shortEndedElementsMap);
			moveCaretBeforeOnEnterElementsMap = createLookupTable('move_caret_before_on_enter_elements', 'table', nonEmptyElementsMap);
			textBlockElementsMap = createLookupTable('text_block_elements', 'h1 h2 h3 h4 h5 h6 p div address pre form ' +
							'blockquote center dir fieldset header footer article section hgroup aside nav figure');
			blockElementsMap = createLookupTable('block_elements', 'hr table tbody thead tfoot ' +
							'th tr td li ol ul caption dl dt dd noscript menu isindex option ' +
							'datalist select optgroup figcaption', textBlockElementsMap);
			textInlineElementsMap = createLookupTable('text_inline_elements', 'span strong b em i font strike u var cite ' +
											'dfn code mark q sup sub samp');
	
			each((settings.special || 'script noscript style textarea').split(' '), function(name) {
				specialElements[name] = new RegExp('<\/' + name + '[^>]*>', 'gi');
			});
	
			// Converts a wildcard expression string to a regexp for example *a will become /.*a/.
			function patternToRegExp(str) {
				return new RegExp('^' + str.replace(/([?+*])/g, '.$1') + '$');
			}
	
			// Parses the specified valid_elements string and adds to the current rules
			// This function is a bit hard to read since it's heavily optimized for speed
			function addValidElements(validElements) {
				var ei, el, ai, al, matches, element, attr, attrData, elementName, attrName, attrType, attributes, attributesOrder,
					prefix, outputName, globalAttributes, globalAttributesOrder, key, value,
					elementRuleRegExp = /^([#+\-])?([^\[!\/]+)(?:\/([^\[!]+))?(?:(!?)\[([^\]]+)\])?$/,
					attrRuleRegExp = /^([!\-])?(\w+::\w+|[^=:<]+)?(?:([=:<])(.*))?$/,
					hasPatternsRegExp = /[*?+]/;
	
				if (validElements) {
					// Split valid elements into an array with rules
					validElements = split(validElements, ',');
	
					if (elements['@']) {
						globalAttributes = elements['@'].attributes;
						globalAttributesOrder = elements['@'].attributesOrder;
					}
	
					// Loop all rules
					for (ei = 0, el = validElements.length; ei < el; ei++) {
						// Parse element rule
						matches = elementRuleRegExp.exec(validElements[ei]);
						if (matches) {
							// Setup local names for matches
							prefix = matches[1];
							elementName = matches[2];
							outputName = matches[3];
							attrData = matches[5];
	
							// Create new attributes and attributesOrder
							attributes = {};
							attributesOrder = [];
	
							// Create the new element
							element = {
								attributes: attributes,
								attributesOrder: attributesOrder
							};
	
							// Padd empty elements prefix
							if (prefix === '#') {
								element.paddEmpty = true;
							}
	
							// Remove empty elements prefix
							if (prefix === '-') {
								element.removeEmpty = true;
							}
	
							if (matches[4] === '!') {
								element.removeEmptyAttrs = true;
							}
	
							// Copy attributes from global rule into current rule
							if (globalAttributes) {
								for (key in globalAttributes) {
									attributes[key] = globalAttributes[key];
								}
	
								attributesOrder.push.apply(attributesOrder, globalAttributesOrder);
							}
	
							// Attributes defined
							if (attrData) {
								attrData = split(attrData, '|');
								for (ai = 0, al = attrData.length; ai < al; ai++) {
									matches = attrRuleRegExp.exec(attrData[ai]);
									if (matches) {
										attr = {};
										attrType = matches[1];
										attrName = matches[2].replace(/::/g, ':');
										prefix = matches[3];
										value = matches[4];
	
										// Required
										if (attrType === '!') {
											element.attributesRequired = element.attributesRequired || [];
											element.attributesRequired.push(attrName);
											attr.required = true;
										}
	
										// Denied from global
										if (attrType === '-') {
											delete attributes[attrName];
											attributesOrder.splice(inArray(attributesOrder, attrName), 1);
											continue;
										}
	
										// Default value
										if (prefix) {
											// Default value
											if (prefix === '=') {
												element.attributesDefault = element.attributesDefault || [];
												element.attributesDefault.push({name: attrName, value: value});
												attr.defaultValue = value;
											}
	
											// Forced value
											if (prefix === ':') {
												element.attributesForced = element.attributesForced || [];
												element.attributesForced.push({name: attrName, value: value});
												attr.forcedValue = value;
											}
	
											// Required values
											if (prefix === '<') {
												attr.validValues = makeMap(value, '?');
											}
										}
	
										// Check for attribute patterns
										if (hasPatternsRegExp.test(attrName)) {
											element.attributePatterns = element.attributePatterns || [];
											attr.pattern = patternToRegExp(attrName);
											element.attributePatterns.push(attr);
										} else {
											// Add attribute to order list if it doesn't already exist
											if (!attributes[attrName]) {
												attributesOrder.push(attrName);
											}
	
											attributes[attrName] = attr;
										}
									}
								}
							}
	
							// Global rule, store away these for later usage
							if (!globalAttributes && elementName == '@') {
								globalAttributes = attributes;
								globalAttributesOrder = attributesOrder;
							}
	
							// Handle substitute elements such as b/strong
							if (outputName) {
								element.outputName = elementName;
								elements[outputName] = element;
							}
	
							// Add pattern or exact element
							if (hasPatternsRegExp.test(elementName)) {
								element.pattern = patternToRegExp(elementName);
								patternElements.push(element);
							} else {
								elements[elementName] = element;
							}
						}
					}
				}
			}
	
			function setValidElements(validElements) {
				elements = {};
				patternElements = [];
	
				addValidElements(validElements);
	
				each(schemaItems, function(element, name) {
					children[name] = element.children;
				});
			}
	
			// Adds custom non HTML elements to the schema
			function addCustomElements(customElements) {
				var customElementRegExp = /^(~)?(.+)$/;
	
				if (customElements) {
					// Flush cached items since we are altering the default maps
					mapCache.text_block_elements = mapCache.block_elements = null;
	
					each(split(customElements, ','), function(rule) {
						var matches = customElementRegExp.exec(rule),
							inline = matches[1] === '~',
							cloneName = inline ? 'span' : 'div',
							name = matches[2];
	
						children[name] = children[cloneName];
						customElementsMap[name] = cloneName;
	
						// If it's not marked as inline then add it to valid block elements
						if (!inline) {
							blockElementsMap[name.toUpperCase()] = {};
							blockElementsMap[name] = {};
						}
	
						// Add elements clone if needed
						if (!elements[name]) {
							var customRule = elements[cloneName];
	
							customRule = extend({}, customRule);
							delete customRule.removeEmptyAttrs;
							delete customRule.removeEmpty;
	
							elements[name] = customRule;
						}
	
						// Add custom elements at span/div positions
						each(children, function(element, elmName) {
							if (element[cloneName]) {
								children[elmName] = element = extend({}, children[elmName]);
								element[name] = element[cloneName];
							}
						});
					});
				}
			}
	
			// Adds valid children to the schema object
			function addValidChildren(validChildren) {
				var childRuleRegExp = /^([+\-]?)(\w+)\[([^\]]+)\]$/;
	
				// Invalidate the schema cache if the schema is mutated
				mapCache[settings.schema] = null;
	
				if (validChildren) {
					each(split(validChildren, ','), function(rule) {
						var matches = childRuleRegExp.exec(rule), parent, prefix;
	
						if (matches) {
							prefix = matches[1];
	
							// Add/remove items from default
							if (prefix) {
								parent = children[matches[2]];
							} else {
								parent = children[matches[2]] = {'#comment': {}};
							}
	
							parent = children[matches[2]];
	
							each(split(matches[3], '|'), function(child) {
								if (prefix === '-') {
									delete parent[child];
								} else {
									parent[child] = {};
								}
							});
						}
					});
				}
			}
	
			function getElementRule(name) {
				var element = elements[name], i;
	
				// Exact match found
				if (element) {
					return element;
				}
	
				// No exact match then try the patterns
				i = patternElements.length;
				while (i--) {
					element = patternElements[i];
	
					if (element.pattern.test(name)) {
						return element;
					}
				}
			}
	
			if (!settings.valid_elements) {
				// No valid elements defined then clone the elements from the schema spec
				each(schemaItems, function(element, name) {
					elements[name] = {
						attributes: element.attributes,
						attributesOrder: element.attributesOrder
					};
	
					children[name] = element.children;
				});
	
				// Switch these on HTML4
				if (settings.schema != "html5") {
					each(split('strong/b em/i'), function(item) {
						item = split(item, '/');
						elements[item[1]].outputName = item[0];
					});
				}
	
				// Add default alt attribute for images, removed since alt="" is treated as presentational.
				// elements.img.attributesDefault = [{name: 'alt', value: ''}];
	
				// Remove these if they are empty by default
				each(split('ol ul sub sup blockquote span font a table tbody tr strong em b i'), function(name) {
					if (elements[name]) {
						elements[name].removeEmpty = true;
					}
				});
	
				// Padd these by default
				each(split('p h1 h2 h3 h4 h5 h6 th td pre div address caption'), function(name) {
					elements[name].paddEmpty = true;
				});
	
				// Remove these if they have no attributes
				each(split('span'), function(name) {
					elements[name].removeEmptyAttrs = true;
				});
	
				// Remove these by default
				// TODO: Reenable in 4.1
				/*each(split('script style'), function(name) {
					delete elements[name];
				});*/
			} else {
				setValidElements(settings.valid_elements);
			}
	
			addCustomElements(settings.custom_elements);
			addValidChildren(settings.valid_children);
			addValidElements(settings.extended_valid_elements);
	
			// Todo: Remove this when we fix list handling to be valid
			addValidChildren('+ol[ul|ol],+ul[ul|ol]');
	
			// Delete invalid elements
			if (settings.invalid_elements) {
				each(explode(settings.invalid_elements), function(item) {
					if (elements[item]) {
						delete elements[item];
					}
				});
			}
	
			// If the user didn't allow span only allow internal spans
			if (!getElementRule('span')) {
				addValidElements('span[!data-mce-type|*]');
			}
	
			/**
			 * Name/value map object with valid parents and children to those parents.
			 *
			 * @example
			 * children = {
			 *    div:{p:{}, h1:{}}
			 * };
			 * @field children
			 * @type Object
			 */
			self.children = children;
	
			/**
			 * Name/value map object with valid styles for each element.
			 *
			 * @method getValidStyles
			 * @type Object
			 */
			self.getValidStyles = function() {
				return validStyles;
			};
	
			/**
			 * Name/value map object with valid styles for each element.
			 *
			 * @method getInvalidStyles
			 * @type Object
			 */
			self.getInvalidStyles = function() {
				return invalidStyles;
			};
	
			/**
			 * Name/value map object with valid classes for each element.
			 *
			 * @method getValidClasses
			 * @type Object
			 */
			self.getValidClasses = function() {
				return validClasses;
			};
	
			/**
			 * Returns a map with boolean attributes.
			 *
			 * @method getBoolAttrs
			 * @return {Object} Name/value lookup map for boolean attributes.
			 */
			self.getBoolAttrs = function() {
				return boolAttrMap;
			};
	
			/**
			 * Returns a map with block elements.
			 *
			 * @method getBlockElements
			 * @return {Object} Name/value lookup map for block elements.
			 */
			self.getBlockElements = function() {
				return blockElementsMap;
			};
	
			/**
			 * Returns a map with text block elements. Such as: p,h1-h6,div,address
			 *
			 * @method getTextBlockElements
			 * @return {Object} Name/value lookup map for block elements.
			 */
			self.getTextBlockElements = function() {
				return textBlockElementsMap;
			};
	
			/**
			 * Returns a map of inline text format nodes for example strong/span or ins.
			 *
			 * @method getTextInlineElements
			 * @return {Object} Name/value lookup map for text format elements.
			 */
			self.getTextInlineElements = function() {
				return textInlineElementsMap;
			};
	
			/**
			 * Returns a map with short ended elements such as BR or IMG.
			 *
			 * @method getShortEndedElements
			 * @return {Object} Name/value lookup map for short ended elements.
			 */
			self.getShortEndedElements = function() {
				return shortEndedElementsMap;
			};
	
			/**
			 * Returns a map with self closing tags such as <li>.
			 *
			 * @method getSelfClosingElements
			 * @return {Object} Name/value lookup map for self closing tags elements.
			 */
			self.getSelfClosingElements = function() {
				return selfClosingElementsMap;
			};
	
			/**
			 * Returns a map with elements that should be treated as contents regardless if it has text
			 * content in them or not such as TD, VIDEO or IMG.
			 *
			 * @method getNonEmptyElements
			 * @return {Object} Name/value lookup map for non empty elements.
			 */
			self.getNonEmptyElements = function() {
				return nonEmptyElementsMap;
			};
	
			/**
			 * Returns a map with elements that the caret should be moved in front of after enter is
			 * pressed
			 *
			 * @method getMoveCaretBeforeOnEnterElements
			 * @return {Object} Name/value lookup map for elements to place the caret in front of.
			 */
			self.getMoveCaretBeforeOnEnterElements = function() {
				return moveCaretBeforeOnEnterElementsMap;
			};
	
			/**
			 * Returns a map with elements where white space is to be preserved like PRE or SCRIPT.
			 *
			 * @method getWhiteSpaceElements
			 * @return {Object} Name/value lookup map for white space elements.
			 */
			self.getWhiteSpaceElements = function() {
				return whiteSpaceElementsMap;
			};
	
			/**
			 * Returns a map with special elements. These are elements that needs to be parsed
			 * in a special way such as script, style, textarea etc. The map object values
			 * are regexps used to find the end of the element.
			 *
			 * @method getSpecialElements
			 * @return {Object} Name/value lookup map for special elements.
			 */
			self.getSpecialElements = function() {
				return specialElements;
			};
	
			/**
			 * Returns true/false if the specified element and it's child is valid or not
			 * according to the schema.
			 *
			 * @method isValidChild
			 * @param {String} name Element name to check for.
			 * @param {String} child Element child to verify.
			 * @return {Boolean} True/false if the element is a valid child of the specified parent.
			 */
			self.isValidChild = function(name, child) {
				var parent = children[name];
	
				return !!(parent && parent[child]);
			};
	
			/**
			 * Returns true/false if the specified element name and optional attribute is
			 * valid according to the schema.
			 *
			 * @method isValid
			 * @param {String} name Name of element to check.
			 * @param {String} attr Optional attribute name to check for.
			 * @return {Boolean} True/false if the element and attribute is valid.
			 */
			self.isValid = function(name, attr) {
				var attrPatterns, i, rule = getElementRule(name);
	
				// Check if it's a valid element
				if (rule) {
					if (attr) {
						// Check if attribute name exists
						if (rule.attributes[attr]) {
							return true;
						}
	
						// Check if attribute matches a regexp pattern
						attrPatterns = rule.attributePatterns;
						if (attrPatterns) {
							i = attrPatterns.length;
							while (i--) {
								if (attrPatterns[i].pattern.test(name)) {
									return true;
								}
							}
						}
					} else {
						return true;
					}
				}
	
				// No match
				return false;
			};
	
			/**
			 * Returns true/false if the specified element is valid or not
			 * according to the schema.
			 *
			 * @method getElementRule
			 * @param {String} name Element name to check for.
			 * @return {Object} Element object or undefined if the element isn't valid.
			 */
			self.getElementRule = getElementRule;
	
			/**
			 * Returns an map object of all custom elements.
			 *
			 * @method getCustomElements
			 * @return {Object} Name/value map object of all custom elements.
			 */
			self.getCustomElements = function() {
				return customElementsMap;
			};
	
			/**
			 * Parses a valid elements string and adds it to the schema. The valid elements
			 * format is for example "element[attr=default|otherattr]".
			 * Existing rules will be replaced with the ones specified, so this extends the schema.
			 *
			 * @method addValidElements
			 * @param {String} valid_elements String in the valid elements format to be parsed.
			 */
			self.addValidElements = addValidElements;
	
			/**
			 * Parses a valid elements string and sets it to the schema. The valid elements
			 * format is for example "element[attr=default|otherattr]".
			 * Existing rules will be replaced with the ones specified, so this extends the schema.
			 *
			 * @method setValidElements
			 * @param {String} valid_elements String in the valid elements format to be parsed.
			 */
			self.setValidElements = setValidElements;
	
			/**
			 * Adds custom non HTML elements to the schema.
			 *
			 * @method addCustomElements
			 * @param {String} custom_elements Comma separated list of custom elements to add.
			 */
			self.addCustomElements = addCustomElements;
	
			/**
			 * Parses a valid children string and adds them to the schema structure. The valid children
			 * format is for example: "element[child1|child2]".
			 *
			 * @method addValidChildren
			 * @param {String} valid_children Valid children elements string to parse
			 */
			self.addValidChildren = addValidChildren;
	
			self.elements = elements;
		};
	});
	
	// Included from: js/tinymce/classes/html/SaxParser.js
	
	/**
	 * SaxParser.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/*eslint max-depth:[2, 9] */
	
	/**
	 * This class parses HTML code using pure JavaScript and executes various events for each item it finds. It will
	 * always execute the events in the right order for tag soup code like <b><p></b></p>. It will also remove elements
	 * and attributes that doesn't fit the schema if the validate setting is enabled.
	 *
	 * @example
	 * var parser = new tinymce.html.SaxParser({
	 *     validate: true,
	 *
	 *     comment: function(text) {
	 *         console.log('Comment:', text);
	 *     },
	 *
	 *     cdata: function(text) {
	 *         console.log('CDATA:', text);
	 *     },
	 *
	 *     text: function(text, raw) {
	 *         console.log('Text:', text, 'Raw:', raw);
	 *     },
	 *
	 *     start: function(name, attrs, empty) {
	 *         console.log('Start:', name, attrs, empty);
	 *     },
	 *
	 *     end: function(name) {
	 *         console.log('End:', name);
	 *     },
	 *
	 *     pi: function(name, text) {
	 *         console.log('PI:', name, text);
	 *     },
	 *
	 *     doctype: function(text) {
	 *         console.log('DocType:', text);
	 *     }
	 * }, schema);
	 * @class tinymce.html.SaxParser
	 * @version 3.4
	 */
	define("tinymce/html/SaxParser", [
		"tinymce/html/Schema",
		"tinymce/html/Entities",
		"tinymce/util/Tools"
	], function(Schema, Entities, Tools) {
		var each = Tools.each;
	
		/**
		 * Returns the index of the end tag for a specific start tag. This can be
		 * used to skip all children of a parent element from being processed.
		 *
		 * @private
		 * @method findEndTag
		 * @param {tinymce.html.Schema} schema Schema instance to use to match short ended elements.
		 * @param {String} html HTML string to find the end tag in.
		 * @param {Number} startIndex Indext to start searching at should be after the start tag.
		 * @return {Number} Index of the end tag.
		 */
		function findEndTag(schema, html, startIndex) {
			var count = 1, index, matches, tokenRegExp, shortEndedElements;
	
			shortEndedElements = schema.getShortEndedElements();
			tokenRegExp = /<([!?\/])?([A-Za-z0-9\-_\:\.]+)((?:\s+[^"\'>]+(?:(?:"[^"]*")|(?:\'[^\']*\')|[^>]*))*|\/|\s+)>/g;
			tokenRegExp.lastIndex = index = startIndex;
	
			while ((matches = tokenRegExp.exec(html))) {
				index = tokenRegExp.lastIndex;
	
				if (matches[1] === '/') { // End element
					count--;
				} else if (!matches[1]) { // Start element
					if (matches[2] in shortEndedElements) {
						continue;
					}
	
					count++;
				}
	
				if (count === 0) {
					break;
				}
			}
	
			return index;
		}
	
		/**
		 * Constructs a new SaxParser instance.
		 *
		 * @constructor
		 * @method SaxParser
		 * @param {Object} settings Name/value collection of settings. comment, cdata, text, start and end are callbacks.
		 * @param {tinymce.html.Schema} schema HTML Schema class to use when parsing.
		 */
		function SaxParser(settings, schema) {
			var self = this;
	
			function noop() {}
	
			settings = settings || {};
			self.schema = schema = schema || new Schema();
	
			if (settings.fix_self_closing !== false) {
				settings.fix_self_closing = true;
			}
	
			// Add handler functions from settings and setup default handlers
			each('comment cdata text start end pi doctype'.split(' '), function(name) {
				if (name) {
					self[name] = settings[name] || noop;
				}
			});
	
			/**
			 * Parses the specified HTML string and executes the callbacks for each item it finds.
			 *
			 * @example
			 * new SaxParser({...}).parse('<b>text</b>');
			 * @method parse
			 * @param {String} html Html string to sax parse.
			 */
			self.parse = function(html) {
				var self = this, matches, index = 0, value, endRegExp, stack = [], attrList, i, text, name;
				var isInternalElement, removeInternalElements, shortEndedElements, fillAttrsMap, isShortEnded;
				var validate, elementRule, isValidElement, attr, attribsValue, validAttributesMap, validAttributePatterns;
				var attributesRequired, attributesDefault, attributesForced;
				var anyAttributesRequired, selfClosing, tokenRegExp, attrRegExp, specialElements, attrValue, idCount = 0;
				var decode = Entities.decode, fixSelfClosing, filteredUrlAttrs = Tools.makeMap('src,href,data,background,formaction,poster');
				var scriptUriRegExp = /((java|vb)script|mhtml):/i, dataUriRegExp = /^data:/i;
	
				function processEndTag(name) {
					var pos, i;
	
					// Find position of parent of the same type
					pos = stack.length;
					while (pos--) {
						if (stack[pos].name === name) {
							break;
						}
					}
	
					// Found parent
					if (pos >= 0) {
						// Close all the open elements
						for (i = stack.length - 1; i >= pos; i--) {
							name = stack[i];
	
							if (name.valid) {
								self.end(name.name);
							}
						}
	
						// Remove the open elements from the stack
						stack.length = pos;
					}
				}
	
				function parseAttribute(match, name, value, val2, val3) {
					var attrRule, i, trimRegExp = /[\s\u0000-\u001F]+/g;
	
					name = name.toLowerCase();
					value = name in fillAttrsMap ? name : decode(value || val2 || val3 || ''); // Handle boolean attribute than value attribute
	
					// Validate name and value pass through all data- attributes
					if (validate && !isInternalElement && name.indexOf('data-') !== 0) {
						attrRule = validAttributesMap[name];
	
						// Find rule by pattern matching
						if (!attrRule && validAttributePatterns) {
							i = validAttributePatterns.length;
							while (i--) {
								attrRule = validAttributePatterns[i];
								if (attrRule.pattern.test(name)) {
									break;
								}
							}
	
							// No rule matched
							if (i === -1) {
								attrRule = null;
							}
						}
	
						// No attribute rule found
						if (!attrRule) {
							return;
						}
	
						// Validate value
						if (attrRule.validValues && !(value in attrRule.validValues)) {
							return;
						}
					}
	
					// Block any javascript: urls or non image data uris
					if (filteredUrlAttrs[name] && !settings.allow_script_urls) {
						var uri = value.replace(trimRegExp, '');
	
						try {
							// Might throw malformed URI sequence
							uri = decodeURIComponent(uri);
						} catch (ex) {
							// Fallback to non UTF-8 decoder
							uri = unescape(uri);
						}
	
						if (scriptUriRegExp.test(uri)) {
							return;
						}
	
						if (!settings.allow_html_data_urls && dataUriRegExp.test(uri) && !/^data:image\//i.test(uri)) {
							return;
						}
					}
	
					// Add attribute to list and map
					attrList.map[name] = value;
					attrList.push({
						name: name,
						value: value
					});
				}
	
				// Precompile RegExps and map objects
				tokenRegExp = new RegExp('<(?:' +
					'(?:!--([\\w\\W]*?)-->)|' + // Comment
					'(?:!\\[CDATA\\[([\\w\\W]*?)\\]\\]>)|' + // CDATA
					'(?:!DOCTYPE([\\w\\W]*?)>)|' + // DOCTYPE
					'(?:\\?([^\\s\\/<>]+) ?([\\w\\W]*?)[?/]>)|' + // PI
					'(?:\\/([^>]+)>)|' + // End element
					'(?:([A-Za-z0-9\\-_\\:\\.]+)((?:\\s+[^"\'>]+(?:(?:"[^"]*")|(?:\'[^\']*\')|[^>]*))*|\\/|\\s+)>)' + // Start element
				')', 'g');
	
				attrRegExp = /([\w:\-]+)(?:\s*=\s*(?:(?:\"((?:[^\"])*)\")|(?:\'((?:[^\'])*)\')|([^>\s]+)))?/g;
	
				// Setup lookup tables for empty elements and boolean attributes
				shortEndedElements = schema.getShortEndedElements();
				selfClosing = settings.self_closing_elements || schema.getSelfClosingElements();
				fillAttrsMap = schema.getBoolAttrs();
				validate = settings.validate;
				removeInternalElements = settings.remove_internals;
				fixSelfClosing = settings.fix_self_closing;
				specialElements = schema.getSpecialElements();
	
				while ((matches = tokenRegExp.exec(html))) {
					// Text
					if (index < matches.index) {
						self.text(decode(html.substr(index, matches.index - index)));
					}
	
					if ((value = matches[6])) { // End element
						value = value.toLowerCase();
	
						// IE will add a ":" in front of elements it doesn't understand like custom elements or HTML5 elements
						if (value.charAt(0) === ':') {
							value = value.substr(1);
						}
	
						processEndTag(value);
					} else if ((value = matches[7])) { // Start element
						value = value.toLowerCase();
	
						// IE will add a ":" in front of elements it doesn't understand like custom elements or HTML5 elements
						if (value.charAt(0) === ':') {
							value = value.substr(1);
						}
	
						isShortEnded = value in shortEndedElements;
	
						// Is self closing tag for example an <li> after an open <li>
						if (fixSelfClosing && selfClosing[value] && stack.length > 0 && stack[stack.length - 1].name === value) {
							processEndTag(value);
						}
	
						// Validate element
						if (!validate || (elementRule = schema.getElementRule(value))) {
							isValidElement = true;
	
							// Grab attributes map and patters when validation is enabled
							if (validate) {
								validAttributesMap = elementRule.attributes;
								validAttributePatterns = elementRule.attributePatterns;
							}
	
							// Parse attributes
							if ((attribsValue = matches[8])) {
								isInternalElement = attribsValue.indexOf('data-mce-type') !== -1; // Check if the element is an internal element
	
								// If the element has internal attributes then remove it if we are told to do so
								if (isInternalElement && removeInternalElements) {
									isValidElement = false;
								}
	
								attrList = [];
								attrList.map = {};
	
								attribsValue.replace(attrRegExp, parseAttribute);
							} else {
								attrList = [];
								attrList.map = {};
							}
	
							// Process attributes if validation is enabled
							if (validate && !isInternalElement) {
								attributesRequired = elementRule.attributesRequired;
								attributesDefault = elementRule.attributesDefault;
								attributesForced = elementRule.attributesForced;
								anyAttributesRequired = elementRule.removeEmptyAttrs;
	
								// Check if any attribute exists
								if (anyAttributesRequired && !attrList.length) {
									isValidElement = false;
								}
	
								// Handle forced attributes
								if (attributesForced) {
									i = attributesForced.length;
									while (i--) {
										attr = attributesForced[i];
										name = attr.name;
										attrValue = attr.value;
	
										if (attrValue === '{$uid}') {
											attrValue = 'mce_' + idCount++;
										}
	
										attrList.map[name] = attrValue;
										attrList.push({name: name, value: attrValue});
									}
								}
	
								// Handle default attributes
								if (attributesDefault) {
									i = attributesDefault.length;
									while (i--) {
										attr = attributesDefault[i];
										name = attr.name;
	
										if (!(name in attrList.map)) {
											attrValue = attr.value;
	
											if (attrValue === '{$uid}') {
												attrValue = 'mce_' + idCount++;
											}
	
											attrList.map[name] = attrValue;
											attrList.push({name: name, value: attrValue});
										}
									}
								}
	
								// Handle required attributes
								if (attributesRequired) {
									i = attributesRequired.length;
									while (i--) {
										if (attributesRequired[i] in attrList.map) {
											break;
										}
									}
	
									// None of the required attributes where found
									if (i === -1) {
										isValidElement = false;
									}
								}
	
								// Invalidate element if it's marked as bogus
								if ((attr = attrList.map['data-mce-bogus'])) {
									if (attr === 'all') {
										index = findEndTag(schema, html, tokenRegExp.lastIndex);
										tokenRegExp.lastIndex = index;
										continue;
									}
	
									isValidElement = false;
								}
							}
	
							if (isValidElement) {
								self.start(value, attrList, isShortEnded);
							}
						} else {
							isValidElement = false;
						}
	
						// Treat script, noscript and style a bit different since they may include code that looks like elements
						if ((endRegExp = specialElements[value])) {
							endRegExp.lastIndex = index = matches.index + matches[0].length;
	
							if ((matches = endRegExp.exec(html))) {
								if (isValidElement) {
									text = html.substr(index, matches.index - index);
								}
	
								index = matches.index + matches[0].length;
							} else {
								text = html.substr(index);
								index = html.length;
							}
	
							if (isValidElement) {
								if (text.length > 0) {
									self.text(text, true);
								}
	
								self.end(value);
							}
	
							tokenRegExp.lastIndex = index;
							continue;
						}
	
						// Push value on to stack
						if (!isShortEnded) {
							if (!attribsValue || attribsValue.indexOf('/') != attribsValue.length - 1) {
								stack.push({name: value, valid: isValidElement});
							} else if (isValidElement) {
								self.end(value);
							}
						}
					} else if ((value = matches[1])) { // Comment
						// Padd comment value to avoid browsers from parsing invalid comments as HTML
						if (value.charAt(0) === '>') {
							value = ' ' + value;
						}
	
						if (!settings.allow_conditional_comments && value.substr(0, 3) === '[if') {
							value = ' ' + value;
						}
	
						self.comment(value);
					} else if ((value = matches[2])) { // CDATA
						self.cdata(value);
					} else if ((value = matches[3])) { // DOCTYPE
						self.doctype(value);
					} else if ((value = matches[4])) { // PI
						self.pi(value, matches[5]);
					}
	
					index = matches.index + matches[0].length;
				}
	
				// Text
				if (index < html.length) {
					self.text(decode(html.substr(index)));
				}
	
				// Close any open elements
				for (i = stack.length - 1; i >= 0; i--) {
					value = stack[i];
	
					if (value.valid) {
						self.end(value.name);
					}
				}
			};
		}
	
		SaxParser.findEndTag = findEndTag;
	
		return SaxParser;
	});
	
	// Included from: js/tinymce/classes/html/DomParser.js
	
	/**
	 * DomParser.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * This class parses HTML code into a DOM like structure of nodes it will remove redundant whitespace and make
	 * sure that the node tree is valid according to the specified schema.
	 * So for example: <p>a<p>b</p>c</p> will become <p>a</p><p>b</p><p>c</p>
	 *
	 * @example
	 * var parser = new tinymce.html.DomParser({validate: true}, schema);
	 * var rootNode = parser.parse('<h1>content</h1>');
	 *
	 * @class tinymce.html.DomParser
	 * @version 3.4
	 */
	define("tinymce/html/DomParser", [
		"tinymce/html/Node",
		"tinymce/html/Schema",
		"tinymce/html/SaxParser",
		"tinymce/util/Tools"
	], function(Node, Schema, SaxParser, Tools) {
		var makeMap = Tools.makeMap, each = Tools.each, explode = Tools.explode, extend = Tools.extend;
	
		/**
		 * Constructs a new DomParser instance.
		 *
		 * @constructor
		 * @method DomParser
		 * @param {Object} settings Name/value collection of settings. comment, cdata, text, start and end are callbacks.
		 * @param {tinymce.html.Schema} schema HTML Schema class to use when parsing.
		 */
		return function(settings, schema) {
			var self = this, nodeFilters = {}, attributeFilters = [], matchedNodes = {}, matchedAttributes = {};
	
			settings = settings || {};
			settings.validate = "validate" in settings ? settings.validate : true;
			settings.root_name = settings.root_name || 'body';
			self.schema = schema = schema || new Schema();
	
			function fixInvalidChildren(nodes) {
				var ni, node, parent, parents, newParent, currentNode, tempNode, childNode, i;
				var nonEmptyElements, nonSplitableElements, textBlockElements, specialElements, sibling, nextNode;
	
				nonSplitableElements = makeMap('tr,td,th,tbody,thead,tfoot,table');
				nonEmptyElements = schema.getNonEmptyElements();
				textBlockElements = schema.getTextBlockElements();
				specialElements = schema.getSpecialElements();
	
				for (ni = 0; ni < nodes.length; ni++) {
					node = nodes[ni];
	
					// Already removed or fixed
					if (!node.parent || node.fixed) {
						continue;
					}
	
					// If the invalid element is a text block and the text block is within a parent LI element
					// Then unwrap the first text block and convert other sibling text blocks to LI elements similar to Word/Open Office
					if (textBlockElements[node.name] && node.parent.name == 'li') {
						// Move sibling text blocks after LI element
						sibling = node.next;
						while (sibling) {
							if (textBlockElements[sibling.name]) {
								sibling.name = 'li';
								sibling.fixed = true;
								node.parent.insert(sibling, node.parent);
							} else {
								break;
							}
	
							sibling = sibling.next;
						}
	
						// Unwrap current text block
						node.unwrap(node);
						continue;
					}
	
					// Get list of all parent nodes until we find a valid parent to stick the child into
					parents = [node];
					for (parent = node.parent; parent && !schema.isValidChild(parent.name, node.name) &&
						!nonSplitableElements[parent.name]; parent = parent.parent) {
						parents.push(parent);
					}
	
					// Found a suitable parent
					if (parent && parents.length > 1) {
						// Reverse the array since it makes looping easier
						parents.reverse();
	
						// Clone the related parent and insert that after the moved node
						newParent = currentNode = self.filterNode(parents[0].clone());
	
						// Start cloning and moving children on the left side of the target node
						for (i = 0; i < parents.length - 1; i++) {
							if (schema.isValidChild(currentNode.name, parents[i].name)) {
								tempNode = self.filterNode(parents[i].clone());
								currentNode.append(tempNode);
							} else {
								tempNode = currentNode;
							}
	
							for (childNode = parents[i].firstChild; childNode && childNode != parents[i + 1];) {
								nextNode = childNode.next;
								tempNode.append(childNode);
								childNode = nextNode;
							}
	
							currentNode = tempNode;
						}
	
						if (!newParent.isEmpty(nonEmptyElements)) {
							parent.insert(newParent, parents[0], true);
							parent.insert(node, newParent);
						} else {
							parent.insert(node, parents[0], true);
						}
	
						// Check if the element is empty by looking through it's contents and special treatment for <p><br /></p>
						parent = parents[0];
						if (parent.isEmpty(nonEmptyElements) || parent.firstChild === parent.lastChild && parent.firstChild.name === 'br') {
							parent.empty().remove();
						}
					} else if (node.parent) {
						// If it's an LI try to find a UL/OL for it or wrap it
						if (node.name === 'li') {
							sibling = node.prev;
							if (sibling && (sibling.name === 'ul' || sibling.name === 'ul')) {
								sibling.append(node);
								continue;
							}
	
							sibling = node.next;
							if (sibling && (sibling.name === 'ul' || sibling.name === 'ul')) {
								sibling.insert(node, sibling.firstChild, true);
								continue;
							}
	
							node.wrap(self.filterNode(new Node('ul', 1)));
							continue;
						}
	
						// Try wrapping the element in a DIV
						if (schema.isValidChild(node.parent.name, 'div') && schema.isValidChild('div', node.name)) {
							node.wrap(self.filterNode(new Node('div', 1)));
						} else {
							// We failed wrapping it, then remove or unwrap it
							if (specialElements[node.name]) {
								node.empty().remove();
							} else {
								node.unwrap();
							}
						}
					}
				}
			}
	
			/**
			 * Runs the specified node though the element and attributes filters.
			 *
			 * @method filterNode
			 * @param {tinymce.html.Node} Node the node to run filters on.
			 * @return {tinymce.html.Node} The passed in node.
			 */
			self.filterNode = function(node) {
				var i, name, list;
	
				// Run element filters
				if (name in nodeFilters) {
					list = matchedNodes[name];
	
					if (list) {
						list.push(node);
					} else {
						matchedNodes[name] = [node];
					}
				}
	
				// Run attribute filters
				i = attributeFilters.length;
				while (i--) {
					name = attributeFilters[i].name;
	
					if (name in node.attributes.map) {
						list = matchedAttributes[name];
	
						if (list) {
							list.push(node);
						} else {
							matchedAttributes[name] = [node];
						}
					}
				}
	
				return node;
			};
	
			/**
			 * Adds a node filter function to the parser, the parser will collect the specified nodes by name
			 * and then execute the callback ones it has finished parsing the document.
			 *
			 * @example
			 * parser.addNodeFilter('p,h1', function(nodes, name) {
			 *		for (var i = 0; i < nodes.length; i++) {
			 *			console.log(nodes[i].name);
			 *		}
			 * });
			 * @method addNodeFilter
			 * @method {String} name Comma separated list of nodes to collect.
			 * @param {function} callback Callback function to execute once it has collected nodes.
			 */
			self.addNodeFilter = function(name, callback) {
				each(explode(name), function(name) {
					var list = nodeFilters[name];
	
					if (!list) {
						nodeFilters[name] = list = [];
					}
	
					list.push(callback);
				});
			};
	
			/**
			 * Adds a attribute filter function to the parser, the parser will collect nodes that has the specified attributes
			 * and then execute the callback ones it has finished parsing the document.
			 *
			 * @example
			 * parser.addAttributeFilter('src,href', function(nodes, name) {
			 *		for (var i = 0; i < nodes.length; i++) {
			 *			console.log(nodes[i].name);
			 *		}
			 * });
			 * @method addAttributeFilter
			 * @method {String} name Comma separated list of nodes to collect.
			 * @param {function} callback Callback function to execute once it has collected nodes.
			 */
			self.addAttributeFilter = function(name, callback) {
				each(explode(name), function(name) {
					var i;
	
					for (i = 0; i < attributeFilters.length; i++) {
						if (attributeFilters[i].name === name) {
							attributeFilters[i].callbacks.push(callback);
							return;
						}
					}
	
					attributeFilters.push({name: name, callbacks: [callback]});
				});
			};
	
			/**
			 * Parses the specified HTML string into a DOM like node tree and returns the result.
			 *
			 * @example
			 * var rootNode = new DomParser({...}).parse('<b>text</b>');
			 * @method parse
			 * @param {String} html Html string to sax parse.
			 * @param {Object} args Optional args object that gets passed to all filter functions.
			 * @return {tinymce.html.Node} Root node containing the tree.
			 */
			self.parse = function(html, args) {
				var parser, rootNode, node, nodes, i, l, fi, fl, list, name, validate;
				var blockElements, startWhiteSpaceRegExp, invalidChildren = [], isInWhiteSpacePreservedElement;
				var endWhiteSpaceRegExp, allWhiteSpaceRegExp, isAllWhiteSpaceRegExp, whiteSpaceElements;
				var children, nonEmptyElements, rootBlockName;
	
				args = args || {};
				matchedNodes = {};
				matchedAttributes = {};
				blockElements = extend(makeMap('script,style,head,html,body,title,meta,param'), schema.getBlockElements());
				nonEmptyElements = schema.getNonEmptyElements();
				children = schema.children;
				validate = settings.validate;
				rootBlockName = "forced_root_block" in args ? args.forced_root_block : settings.forced_root_block;
	
				whiteSpaceElements = schema.getWhiteSpaceElements();
				startWhiteSpaceRegExp = /^[ \t\r\n]+/;
				endWhiteSpaceRegExp = /[ \t\r\n]+$/;
				allWhiteSpaceRegExp = /[ \t\r\n]+/g;
				isAllWhiteSpaceRegExp = /^[ \t\r\n]+$/;
	
				function addRootBlocks() {
					var node = rootNode.firstChild, next, rootBlockNode;
	
					// Removes whitespace at beginning and end of block so:
					// <p> x </p> -> <p>x</p>
					function trim(rootBlockNode) {
						if (rootBlockNode) {
							node = rootBlockNode.firstChild;
							if (node && node.type == 3) {
								node.value = node.value.replace(startWhiteSpaceRegExp, '');
							}
	
							node = rootBlockNode.lastChild;
							if (node && node.type == 3) {
								node.value = node.value.replace(endWhiteSpaceRegExp, '');
							}
						}
					}
	
					// Check if rootBlock is valid within rootNode for example if P is valid in H1 if H1 is the contentEditabe root
					if (!schema.isValidChild(rootNode.name, rootBlockName.toLowerCase())) {
						return;
					}
	
					while (node) {
						next = node.next;
	
						if (node.type == 3 || (node.type == 1 && node.name !== 'p' &&
							!blockElements[node.name] && !node.attr('data-mce-type'))) {
							if (!rootBlockNode) {
								// Create a new root block element
								rootBlockNode = createNode(rootBlockName, 1);
								rootBlockNode.attr(settings.forced_root_block_attrs);
								rootNode.insert(rootBlockNode, node);
								rootBlockNode.append(node);
							} else {
								rootBlockNode.append(node);
							}
						} else {
							trim(rootBlockNode);
							rootBlockNode = null;
						}
	
						node = next;
					}
	
					trim(rootBlockNode);
				}
	
				function createNode(name, type) {
					var node = new Node(name, type), list;
	
					if (name in nodeFilters) {
						list = matchedNodes[name];
	
						if (list) {
							list.push(node);
						} else {
							matchedNodes[name] = [node];
						}
					}
	
					return node;
				}
	
				function removeWhitespaceBefore(node) {
					var textNode, textNodeNext, textVal, sibling, blockElements = schema.getBlockElements();
	
					for (textNode = node.prev; textNode && textNode.type === 3;) {
						textVal = textNode.value.replace(endWhiteSpaceRegExp, '');
	
						// Found a text node with non whitespace then trim that and break
						if (textVal.length > 0) {
							textNode.value = textVal;
							return;
						}
	
						textNodeNext = textNode.next;
	
						// Fix for bug #7543 where bogus nodes would produce empty
						// text nodes and these would be removed if a nested list was before it
						if (textNodeNext) {
							if (textNodeNext.type == 3 && textNodeNext.value.length) {
								textNode = textNode.prev;
								continue;
							}
	
							if (!blockElements[textNodeNext.name] && textNodeNext.name != 'script' && textNodeNext.name != 'style') {
								textNode = textNode.prev;
								continue;
							}
						}
	
						sibling = textNode.prev;
						textNode.remove();
						textNode = sibling;
					}
				}
	
				function cloneAndExcludeBlocks(input) {
					var name, output = {};
	
					for (name in input) {
						if (name !== 'li' && name != 'p') {
							output[name] = input[name];
						}
					}
	
					return output;
				}
	
				parser = new SaxParser({
					validate: validate,
					allow_script_urls: settings.allow_script_urls,
					allow_conditional_comments: settings.allow_conditional_comments,
	
					// Exclude P and LI from DOM parsing since it's treated better by the DOM parser
					self_closing_elements: cloneAndExcludeBlocks(schema.getSelfClosingElements()),
	
					cdata: function(text) {
						node.append(createNode('#cdata', 4)).value = text;
					},
	
					text: function(text, raw) {
						var textNode;
	
						// Trim all redundant whitespace on non white space elements
						if (!isInWhiteSpacePreservedElement) {
							text = text.replace(allWhiteSpaceRegExp, ' ');
	
							if (node.lastChild && blockElements[node.lastChild.name]) {
								text = text.replace(startWhiteSpaceRegExp, '');
							}
						}
	
						// Do we need to create the node
						if (text.length !== 0) {
							textNode = createNode('#text', 3);
							textNode.raw = !!raw;
							node.append(textNode).value = text;
						}
					},
	
					comment: function(text) {
						node.append(createNode('#comment', 8)).value = text;
					},
	
					pi: function(name, text) {
						node.append(createNode(name, 7)).value = text;
						removeWhitespaceBefore(node);
					},
	
					doctype: function(text) {
						var newNode;
	
						newNode = node.append(createNode('#doctype', 10));
						newNode.value = text;
						removeWhitespaceBefore(node);
					},
	
					start: function(name, attrs, empty) {
						var newNode, attrFiltersLen, elementRule, attrName, parent;
	
						elementRule = validate ? schema.getElementRule(name) : {};
						if (elementRule) {
							newNode = createNode(elementRule.outputName || name, 1);
							newNode.attributes = attrs;
							newNode.shortEnded = empty;
	
							node.append(newNode);
	
							// Check if node is valid child of the parent node is the child is
							// unknown we don't collect it since it's probably a custom element
							parent = children[node.name];
							if (parent && children[newNode.name] && !parent[newNode.name]) {
								invalidChildren.push(newNode);
							}
	
							attrFiltersLen = attributeFilters.length;
							while (attrFiltersLen--) {
								attrName = attributeFilters[attrFiltersLen].name;
	
								if (attrName in attrs.map) {
									list = matchedAttributes[attrName];
	
									if (list) {
										list.push(newNode);
									} else {
										matchedAttributes[attrName] = [newNode];
									}
								}
							}
	
							// Trim whitespace before block
							if (blockElements[name]) {
								removeWhitespaceBefore(newNode);
							}
	
							// Change current node if the element wasn't empty i.e not <br /> or <img />
							if (!empty) {
								node = newNode;
							}
	
							// Check if we are inside a whitespace preserved element
							if (!isInWhiteSpacePreservedElement && whiteSpaceElements[name]) {
								isInWhiteSpacePreservedElement = true;
							}
						}
					},
	
					end: function(name) {
						var textNode, elementRule, text, sibling, tempNode;
	
						elementRule = validate ? schema.getElementRule(name) : {};
						if (elementRule) {
							if (blockElements[name]) {
								if (!isInWhiteSpacePreservedElement) {
									// Trim whitespace of the first node in a block
									textNode = node.firstChild;
									if (textNode && textNode.type === 3) {
										text = textNode.value.replace(startWhiteSpaceRegExp, '');
	
										// Any characters left after trim or should we remove it
										if (text.length > 0) {
											textNode.value = text;
											textNode = textNode.next;
										} else {
											sibling = textNode.next;
											textNode.remove();
											textNode = sibling;
	
											// Remove any pure whitespace siblings
											while (textNode && textNode.type === 3) {
												text = textNode.value;
												sibling = textNode.next;
	
												if (text.length === 0 || isAllWhiteSpaceRegExp.test(text)) {
													textNode.remove();
													textNode = sibling;
												}
	
												textNode = sibling;
											}
										}
									}
	
									// Trim whitespace of the last node in a block
									textNode = node.lastChild;
									if (textNode && textNode.type === 3) {
										text = textNode.value.replace(endWhiteSpaceRegExp, '');
	
										// Any characters left after trim or should we remove it
										if (text.length > 0) {
											textNode.value = text;
											textNode = textNode.prev;
										} else {
											sibling = textNode.prev;
											textNode.remove();
											textNode = sibling;
	
											// Remove any pure whitespace siblings
											while (textNode && textNode.type === 3) {
												text = textNode.value;
												sibling = textNode.prev;
	
												if (text.length === 0 || isAllWhiteSpaceRegExp.test(text)) {
													textNode.remove();
													textNode = sibling;
												}
	
												textNode = sibling;
											}
										}
									}
								}
	
								// Trim start white space
								// Removed due to: #5424
								/*textNode = node.prev;
								if (textNode && textNode.type === 3) {
									text = textNode.value.replace(startWhiteSpaceRegExp, '');
	
									if (text.length > 0)
										textNode.value = text;
									else
										textNode.remove();
								}*/
							}
	
							// Check if we exited a whitespace preserved element
							if (isInWhiteSpacePreservedElement && whiteSpaceElements[name]) {
								isInWhiteSpacePreservedElement = false;
							}
	
							// Handle empty nodes
							if (elementRule.removeEmpty || elementRule.paddEmpty) {
								if (node.isEmpty(nonEmptyElements)) {
									if (elementRule.paddEmpty) {
										node.empty().append(new Node('#text', '3')).value = '\u00a0';
									} else {
										// Leave nodes that have a name like <a name="name">
										if (!node.attributes.map.name && !node.attributes.map.id) {
											tempNode = node.parent;
	
											if (blockElements[node.name]) {
												node.empty().remove();
											} else {
												node.unwrap();
											}
	
											node = tempNode;
											return;
										}
									}
								}
							}
	
							node = node.parent;
						}
					}
				}, schema);
	
				rootNode = node = new Node(args.context || settings.root_name, 11);
	
				parser.parse(html);
	
				// Fix invalid children or report invalid children in a contextual parsing
				if (validate && invalidChildren.length) {
					if (!args.context) {
						fixInvalidChildren(invalidChildren);
					} else {
						args.invalid = true;
					}
				}
	
				// Wrap nodes in the root into block elements if the root is body
				if (rootBlockName && (rootNode.name == 'body' || args.isRootContent)) {
					addRootBlocks();
				}
	
				// Run filters only when the contents is valid
				if (!args.invalid) {
					// Run node filters
					for (name in matchedNodes) {
						list = nodeFilters[name];
						nodes = matchedNodes[name];
	
						// Remove already removed children
						fi = nodes.length;
						while (fi--) {
							if (!nodes[fi].parent) {
								nodes.splice(fi, 1);
							}
						}
	
						for (i = 0, l = list.length; i < l; i++) {
							list[i](nodes, name, args);
						}
					}
	
					// Run attribute filters
					for (i = 0, l = attributeFilters.length; i < l; i++) {
						list = attributeFilters[i];
	
						if (list.name in matchedAttributes) {
							nodes = matchedAttributes[list.name];
	
							// Remove already removed children
							fi = nodes.length;
							while (fi--) {
								if (!nodes[fi].parent) {
									nodes.splice(fi, 1);
								}
							}
	
							for (fi = 0, fl = list.callbacks.length; fi < fl; fi++) {
								list.callbacks[fi](nodes, list.name, args);
							}
						}
					}
				}
	
				return rootNode;
			};
	
			// Remove <br> at end of block elements Gecko and WebKit injects BR elements to
			// make it possible to place the caret inside empty blocks. This logic tries to remove
			// these elements and keep br elements that where intended to be there intact
			if (settings.remove_trailing_brs) {
				self.addNodeFilter('br', function(nodes) {
					var i, l = nodes.length, node, blockElements = extend({}, schema.getBlockElements());
					var nonEmptyElements = schema.getNonEmptyElements(), parent, lastParent, prev, prevName;
					var elementRule, textNode;
	
					// Remove brs from body element as well
					blockElements.body = 1;
	
					// Must loop forwards since it will otherwise remove all brs in <p>a<br><br><br></p>
					for (i = 0; i < l; i++) {
						node = nodes[i];
						parent = node.parent;
	
						if (blockElements[node.parent.name] && node === parent.lastChild) {
							// Loop all nodes to the left of the current node and check for other BR elements
							// excluding bookmarks since they are invisible
							prev = node.prev;
							while (prev) {
								prevName = prev.name;
	
								// Ignore bookmarks
								if (prevName !== "span" || prev.attr('data-mce-type') !== 'bookmark') {
									// Found a non BR element
									if (prevName !== "br") {
										break;
									}
	
									// Found another br it's a <br><br> structure then don't remove anything
									if (prevName === 'br') {
										node = null;
										break;
									}
								}
	
								prev = prev.prev;
							}
	
							if (node) {
								node.remove();
	
								// Is the parent to be considered empty after we removed the BR
								if (parent.isEmpty(nonEmptyElements)) {
									elementRule = schema.getElementRule(parent.name);
	
									// Remove or padd the element depending on schema rule
									if (elementRule) {
										if (elementRule.removeEmpty) {
											parent.remove();
										} else if (elementRule.paddEmpty) {
											parent.empty().append(new Node('#text', 3)).value = '\u00a0';
										}
									}
								}
							}
						} else {
							// Replaces BR elements inside inline elements like <p><b><i><br></i></b></p>
							// so they become <p><b><i>&nbsp;</i></b></p>
							lastParent = node;
							while (parent && parent.firstChild === lastParent && parent.lastChild === lastParent) {
								lastParent = parent;
	
								if (blockElements[parent.name]) {
									break;
								}
	
								parent = parent.parent;
							}
	
							if (lastParent === parent) {
								textNode = new Node('#text', 3);
								textNode.value = '\u00a0';
								node.replace(textNode);
							}
						}
					}
				});
			}
	
			// Force anchor names closed, unless the setting "allow_html_in_named_anchor" is explicitly included.
			if (!settings.allow_html_in_named_anchor) {
				self.addAttributeFilter('id,name', function(nodes) {
					var i = nodes.length, sibling, prevSibling, parent, node;
	
					while (i--) {
						node = nodes[i];
						if (node.name === 'a' && node.firstChild && !node.attr('href')) {
							parent = node.parent;
	
							// Move children after current node
							sibling = node.lastChild;
							do {
								prevSibling = sibling.prev;
								parent.insert(sibling, node);
								sibling = prevSibling;
							} while (sibling);
						}
					}
				});
			}
	
			if (settings.validate && schema.getValidClasses()) {
				self.addAttributeFilter('class', function(nodes) {
					var i = nodes.length, node, classList, ci, className, classValue;
					var validClasses = schema.getValidClasses(), validClassesMap, valid;
	
					while (i--) {
						node = nodes[i];
						classList = node.attr('class').split(' ');
						classValue = '';
	
						for (ci = 0; ci < classList.length; ci++) {
							className = classList[ci];
							valid = false;
	
							validClassesMap = validClasses['*'];
							if (validClassesMap && validClassesMap[className]) {
								valid = true;
							}
	
							validClassesMap = validClasses[node.name];
							if (!valid && validClassesMap && validClassesMap[className]) {
								valid = true;
							}
	
							if (valid) {
								if (classValue) {
									classValue += ' ';
								}
	
								classValue += className;
							}
						}
	
						if (!classValue.length) {
							classValue = null;
						}
	
						node.attr('class', classValue);
					}
				});
			}
		};
	});
	
	// Included from: js/tinymce/classes/html/Writer.js
	
	/**
	 * Writer.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * This class is used to write HTML tags out it can be used with the Serializer or the SaxParser.
	 *
	 * @class tinymce.html.Writer
	 * @example
	 * var writer = new tinymce.html.Writer({indent: true});
	 * var parser = new tinymce.html.SaxParser(writer).parse('<p><br></p>');
	 * console.log(writer.getContent());
	 *
	 * @class tinymce.html.Writer
	 * @version 3.4
	 */
	define("tinymce/html/Writer", [
		"tinymce/html/Entities",
		"tinymce/util/Tools"
	], function(Entities, Tools) {
		var makeMap = Tools.makeMap;
	
		/**
		 * Constructs a new Writer instance.
		 *
		 * @constructor
		 * @method Writer
		 * @param {Object} settings Name/value settings object.
		 */
		return function(settings) {
			var html = [], indent, indentBefore, indentAfter, encode, htmlOutput;
	
			settings = settings || {};
			indent = settings.indent;
			indentBefore = makeMap(settings.indent_before || '');
			indentAfter = makeMap(settings.indent_after || '');
			encode = Entities.getEncodeFunc(settings.entity_encoding || 'raw', settings.entities);
			htmlOutput = settings.element_format == "html";
	
			return {
				/**
				 * Writes the a start element such as <p id="a">.
				 *
				 * @method start
				 * @param {String} name Name of the element.
				 * @param {Array} attrs Optional attribute array or undefined if it hasn't any.
				 * @param {Boolean} empty Optional empty state if the tag should end like <br />.
				 */
				start: function(name, attrs, empty) {
					var i, l, attr, value;
	
					if (indent && indentBefore[name] && html.length > 0) {
						value = html[html.length - 1];
	
						if (value.length > 0 && value !== '\n') {
							html.push('\n');
						}
					}
	
					html.push('<', name);
	
					if (attrs) {
						for (i = 0, l = attrs.length; i < l; i++) {
							attr = attrs[i];
							html.push(' ', attr.name, '="', encode(attr.value, true), '"');
						}
					}
	
					if (!empty || htmlOutput) {
						html[html.length] = '>';
					} else {
						html[html.length] = ' />';
					}
	
					if (empty && indent && indentAfter[name] && html.length > 0) {
						value = html[html.length - 1];
	
						if (value.length > 0 && value !== '\n') {
							html.push('\n');
						}
					}
				},
	
				/**
				 * Writes the a end element such as </p>.
				 *
				 * @method end
				 * @param {String} name Name of the element.
				 */
				end: function(name) {
					var value;
	
					/*if (indent && indentBefore[name] && html.length > 0) {
						value = html[html.length - 1];
	
						if (value.length > 0 && value !== '\n')
							html.push('\n');
					}*/
	
					html.push('</', name, '>');
	
					if (indent && indentAfter[name] && html.length > 0) {
						value = html[html.length - 1];
	
						if (value.length > 0 && value !== '\n') {
							html.push('\n');
						}
					}
				},
	
				/**
				 * Writes a text node.
				 *
				 * @method text
				 * @param {String} text String to write out.
				 * @param {Boolean} raw Optional raw state if true the contents wont get encoded.
				 */
				text: function(text, raw) {
					if (text.length > 0) {
						html[html.length] = raw ? text : encode(text);
					}
				},
	
				/**
				 * Writes a cdata node such as <![CDATA[data]]>.
				 *
				 * @method cdata
				 * @param {String} text String to write out inside the cdata.
				 */
				cdata: function(text) {
					html.push('<![CDATA[', text, ']]>');
				},
	
				/**
				 * Writes a comment node such as <!-- Comment -->.
				 *
				 * @method cdata
				 * @param {String} text String to write out inside the comment.
				 */
				comment: function(text) {
					html.push('<!--', text, '-->');
				},
	
				/**
				 * Writes a PI node such as <?xml attr="value" ?>.
				 *
				 * @method pi
				 * @param {String} name Name of the pi.
				 * @param {String} text String to write out inside the pi.
				 */
				pi: function(name, text) {
					if (text) {
						html.push('<?', name, ' ', encode(text), '?>');
					} else {
						html.push('<?', name, '?>');
					}
	
					if (indent) {
						html.push('\n');
					}
				},
	
				/**
				 * Writes a doctype node such as <!DOCTYPE data>.
				 *
				 * @method doctype
				 * @param {String} text String to write out inside the doctype.
				 */
				doctype: function(text) {
					html.push('<!DOCTYPE', text, '>', indent ? '\n' : '');
				},
	
				/**
				 * Resets the internal buffer if one wants to reuse the writer.
				 *
				 * @method reset
				 */
				reset: function() {
					html.length = 0;
				},
	
				/**
				 * Returns the contents that got serialized.
				 *
				 * @method getContent
				 * @return {String} HTML contents that got written down.
				 */
				getContent: function() {
					return html.join('').replace(/\n$/, '');
				}
			};
		};
	});
	
	// Included from: js/tinymce/classes/html/Serializer.js
	
	/**
	 * Serializer.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * This class is used to serialize down the DOM tree into a string using a Writer instance.
	 *
	 *
	 * @example
	 * new tinymce.html.Serializer().serialize(new tinymce.html.DomParser().parse('<p>text</p>'));
	 * @class tinymce.html.Serializer
	 * @version 3.4
	 */
	define("tinymce/html/Serializer", [
		"tinymce/html/Writer",
		"tinymce/html/Schema"
	], function(Writer, Schema) {
		/**
		 * Constructs a new Serializer instance.
		 *
		 * @constructor
		 * @method Serializer
		 * @param {Object} settings Name/value settings object.
		 * @param {tinymce.html.Schema} schema Schema instance to use.
		 */
		return function(settings, schema) {
			var self = this, writer = new Writer(settings);
	
			settings = settings || {};
			settings.validate = "validate" in settings ? settings.validate : true;
	
			self.schema = schema = schema || new Schema();
			self.writer = writer;
	
			/**
			 * Serializes the specified node into a string.
			 *
			 * @example
			 * new tinymce.html.Serializer().serialize(new tinymce.html.DomParser().parse('<p>text</p>'));
			 * @method serialize
			 * @param {tinymce.html.Node} node Node instance to serialize.
			 * @return {String} String with HTML based on DOM tree.
			 */
			self.serialize = function(node) {
				var handlers, validate;
	
				validate = settings.validate;
	
				handlers = {
					// #text
					3: function(node) {
						writer.text(node.value, node.raw);
					},
	
					// #comment
					8: function(node) {
						writer.comment(node.value);
					},
	
					// Processing instruction
					7: function(node) {
						writer.pi(node.name, node.value);
					},
	
					// Doctype
					10: function(node) {
						writer.doctype(node.value);
					},
	
					// CDATA
					4: function(node) {
						writer.cdata(node.value);
					},
	
					// Document fragment
					11: function(node) {
						if ((node = node.firstChild)) {
							do {
								walk(node);
							} while ((node = node.next));
						}
					}
				};
	
				writer.reset();
	
				function walk(node) {
					var handler = handlers[node.type], name, isEmpty, attrs, attrName, attrValue, sortedAttrs, i, l, elementRule;
	
					if (!handler) {
						name = node.name;
						isEmpty = node.shortEnded;
						attrs = node.attributes;
	
						// Sort attributes
						if (validate && attrs && attrs.length > 1) {
							sortedAttrs = [];
							sortedAttrs.map = {};
	
							elementRule = schema.getElementRule(node.name);
							if (elementRule) {
								for (i = 0, l = elementRule.attributesOrder.length; i < l; i++) {
									attrName = elementRule.attributesOrder[i];
	
									if (attrName in attrs.map) {
										attrValue = attrs.map[attrName];
										sortedAttrs.map[attrName] = attrValue;
										sortedAttrs.push({name: attrName, value: attrValue});
									}
								}
	
								for (i = 0, l = attrs.length; i < l; i++) {
									attrName = attrs[i].name;
	
									if (!(attrName in sortedAttrs.map)) {
										attrValue = attrs.map[attrName];
										sortedAttrs.map[attrName] = attrValue;
										sortedAttrs.push({name: attrName, value: attrValue});
									}
								}
	
								attrs = sortedAttrs;
							}
						}
	
						writer.start(node.name, attrs, isEmpty);
	
						if (!isEmpty) {
							if ((node = node.firstChild)) {
								do {
									walk(node);
								} while ((node = node.next));
							}
	
							writer.end(name);
						}
					} else {
						handler(node);
					}
				}
	
				// Serialize element and treat all non elements as fragments
				if (node.type == 1 && !settings.inner) {
					walk(node);
				} else {
					handlers[11](node);
				}
	
				return writer.getContent();
			};
		};
	});
	
	// Included from: js/tinymce/classes/dom/Serializer.js
	
	/**
	 * Serializer.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * This class is used to serialize DOM trees into a string. Consult the TinyMCE Wiki API for
	 * more details and examples on how to use this class.
	 *
	 * @class tinymce.dom.Serializer
	 */
	define("tinymce/dom/Serializer", [
		"tinymce/dom/DOMUtils",
		"tinymce/html/DomParser",
		"tinymce/html/SaxParser",
		"tinymce/html/Entities",
		"tinymce/html/Serializer",
		"tinymce/html/Node",
		"tinymce/html/Schema",
		"tinymce/Env",
		"tinymce/util/Tools",
		"tinymce/text/Zwsp"
	], function(DOMUtils, DomParser, SaxParser, Entities, Serializer, Node, Schema, Env, Tools, Zwsp) {
		var each = Tools.each, trim = Tools.trim;
		var DOM = DOMUtils.DOM, tempAttrs = ["data-mce-selected"];
	
		/**
		 * IE 11 has a fantastic bug where it will produce two trailing BR elements to iframe bodies when
		 * the iframe is hidden by display: none on a parent container. The DOM is actually out of sync
		 * with innerHTML in this case. It's like IE adds shadow DOM BR elements that appears on innerHTML
		 * but not as the lastChild of the body. So this fix simply removes the last two
		 * BR elements at the end of the document.
		 *
		 * Example of what happens: <body>text</body> becomes <body>text<br><br></body>
		 */
		function trimTrailingBr(rootNode) {
			var brNode1, brNode2;
	
			function isBr(node) {
				return node && node.name === 'br';
			}
	
			brNode1 = rootNode.lastChild;
			if (isBr(brNode1)) {
				brNode2 = brNode1.prev;
	
				if (isBr(brNode2)) {
					brNode1.remove();
					brNode2.remove();
				}
			}
		}
	
		/**
		 * Constructs a new DOM serializer class.
		 *
		 * @constructor
		 * @method Serializer
		 * @param {Object} settings Serializer settings object.
		 * @param {tinymce.Editor} editor Optional editor to bind events to and get schema/dom from.
		 */
		return function(settings, editor) {
			var dom, schema, htmlParser;
	
			if (editor) {
				dom = editor.dom;
				schema = editor.schema;
			}
	
			function trimHtml(html) {
				var trimContentRegExp = new RegExp([
					'<span[^>]+data-mce-bogus[^>]+>[\u200B\uFEFF]+<\\/span>', // Trim bogus spans like caret containers
					'\\s?(' + tempAttrs.join('|') + ')="[^"]+"' // Trim temporaty data-mce prefixed attributes like data-mce-selected
				].join('|'), 'gi');
	
				html = Zwsp.trim(html.replace(trimContentRegExp, ''));
	
				return html;
			}
	
			/**
			 * Returns a trimmed version of the editor contents to be used for the undo level. This
			 * will remove any data-mce-bogus="all" marked elements since these are used for UI it will also
			 * remove the data-mce-selected attributes used for selection of objects and caret containers.
			 * It will keep all data-mce-bogus="1" elements since these can be used to place the caret etc and will
			 * be removed by the serialization logic when you save.
			 *
			 * @private
			 * @return {String} HTML contents of the editor excluding some internal bogus elements.
			 */
			function getTrimmedContent() {
				var content = editor.getBody().innerHTML;
				var bogusAllRegExp = /<(\w+) [^>]*data-mce-bogus="all"[^>]*>/g;
				var endTagIndex, index, matchLength, matches, shortEndedElements, schema = editor.schema;
	
				content = trimHtml(content);
				shortEndedElements = schema.getShortEndedElements();
	
				// Remove all bogus elements marked with "all"
				while ((matches = bogusAllRegExp.exec(content))) {
					index = bogusAllRegExp.lastIndex;
					matchLength = matches[0].length;
	
					if (shortEndedElements[matches[1]]) {
						endTagIndex = index;
					} else {
						endTagIndex = SaxParser.findEndTag(schema, content, index);
					}
	
					content = content.substring(0, index - matchLength) + content.substring(endTagIndex);
					bogusAllRegExp.lastIndex = index - matchLength;
				}
	
				return trim(content);
			}
	
			function addTempAttr(name) {
				if (Tools.inArray(tempAttrs, name) === -1) {
					htmlParser.addAttributeFilter(name, function(nodes, name) {
						var i = nodes.length;
	
						while (i--) {
							nodes[i].attr(name, null);
						}
					});
	
					tempAttrs.push(name);
				}
			}
	
			// Default DOM and Schema if they are undefined
			dom = dom || DOM;
			schema = schema || new Schema(settings);
			settings.entity_encoding = settings.entity_encoding || 'named';
			settings.remove_trailing_brs = "remove_trailing_brs" in settings ? settings.remove_trailing_brs : true;
	
			htmlParser = new DomParser(settings, schema);
	
			// Convert tabindex back to elements when serializing contents
			htmlParser.addAttributeFilter('data-mce-tabindex', function(nodes, name) {
				var i = nodes.length, node;
	
				while (i--) {
					node = nodes[i];
					node.attr('tabindex', node.attributes.map['data-mce-tabindex']);
					node.attr(name, null);
				}
			});
	
			// Convert move data-mce-src, data-mce-href and data-mce-style into nodes or process them if needed
			htmlParser.addAttributeFilter('src,href,style', function(nodes, name) {
				var i = nodes.length, node, value, internalName = 'data-mce-' + name;
				var urlConverter = settings.url_converter, urlConverterScope = settings.url_converter_scope, undef;
	
				while (i--) {
					node = nodes[i];
	
					value = node.attributes.map[internalName];
					if (value !== undef) {
						// Set external name to internal value and remove internal
						node.attr(name, value.length > 0 ? value : null);
						node.attr(internalName, null);
					} else {
						// No internal attribute found then convert the value we have in the DOM
						value = node.attributes.map[name];
	
						if (name === "style") {
							value = dom.serializeStyle(dom.parseStyle(value), node.name);
						} else if (urlConverter) {
							value = urlConverter.call(urlConverterScope, value, name, node.name);
						}
	
						node.attr(name, value.length > 0 ? value : null);
					}
				}
			});
	
			// Remove internal classes mceItem<..> or mceSelected
			htmlParser.addAttributeFilter('class', function(nodes) {
				var i = nodes.length, node, value;
	
				while (i--) {
					node = nodes[i];
					value = node.attr('class');
	
					if (value) {
						value = node.attr('class').replace(/(?:^|\s)mce-item-\w+(?!\S)/g, '');
						node.attr('class', value.length > 0 ? value : null);
					}
				}
			});
	
			// Remove bookmark elements
			htmlParser.addAttributeFilter('data-mce-type', function(nodes, name, args) {
				var i = nodes.length, node;
	
				while (i--) {
					node = nodes[i];
	
					if (node.attributes.map['data-mce-type'] === 'bookmark' && !args.cleanup) {
						node.remove();
					}
				}
			});
	
			htmlParser.addNodeFilter('noscript', function(nodes) {
				var i = nodes.length, node;
	
				while (i--) {
					node = nodes[i].firstChild;
	
					if (node) {
						node.value = Entities.decode(node.value);
					}
				}
			});
	
			// Force script into CDATA sections and remove the mce- prefix also add comments around styles
			htmlParser.addNodeFilter('script,style', function(nodes, name) {
				var i = nodes.length, node, value, type;
	
				function trim(value) {
					/*jshint maxlen:255 */
					/*eslint max-len:0 */
					return value.replace(/(<!--\[CDATA\[|\]\]-->)/g, '\n')
							.replace(/^[\r\n]*|[\r\n]*$/g, '')
							.replace(/^\s*((<!--)?(\s*\/\/)?\s*<!\[CDATA\[|(<!--\s*)?\/\*\s*<!\[CDATA\[\s*\*\/|(\/\/)?\s*<!--|\/\*\s*<!--\s*\*\/)\s*[\r\n]*/gi, '')
							.replace(/\s*(\/\*\s*\]\]>\s*\*\/(-->)?|\s*\/\/\s*\]\]>(-->)?|\/\/\s*(-->)?|\]\]>|\/\*\s*-->\s*\*\/|\s*-->\s*)\s*$/g, '');
				}
	
				while (i--) {
					node = nodes[i];
					value = node.firstChild ? node.firstChild.value : '';
	
					if (name === "script") {
						// Remove mce- prefix from script elements and remove default type since the user specified
						// a script element without type attribute
						type = node.attr('type');
						if (type) {
							node.attr('type', type == 'mce-no/type' ? null : type.replace(/^mce\-/, ''));
						}
	
						if (value.length > 0) {
							node.firstChild.value = '// <![CDATA[\n' + trim(value) + '\n// ]]>';
						}
					} else {
						if (value.length > 0) {
							node.firstChild.value = '<!--\n' + trim(value) + '\n-->';
						}
					}
				}
			});
	
			// Convert comments to cdata and handle protected comments
			htmlParser.addNodeFilter('#comment', function(nodes) {
				var i = nodes.length, node;
	
				while (i--) {
					node = nodes[i];
	
					if (node.value.indexOf('[CDATA[') === 0) {
						node.name = '#cdata';
						node.type = 4;
						node.value = node.value.replace(/^\[CDATA\[|\]\]$/g, '');
					} else if (node.value.indexOf('mce:protected ') === 0) {
						node.name = "#text";
						node.type = 3;
						node.raw = true;
						node.value = unescape(node.value).substr(14);
					}
				}
			});
	
			htmlParser.addNodeFilter('xml:namespace,input', function(nodes, name) {
				var i = nodes.length, node;
	
				while (i--) {
					node = nodes[i];
					if (node.type === 7) {
						node.remove();
					} else if (node.type === 1) {
						if (name === "input" && !("type" in node.attributes.map)) {
							node.attr('type', 'text');
						}
					}
				}
			});
	
			// Fix list elements, TODO: Replace this later
			if (settings.fix_list_elements) {
				htmlParser.addNodeFilter('ul,ol', function(nodes) {
					var i = nodes.length, node, parentNode;
	
					while (i--) {
						node = nodes[i];
						parentNode = node.parent;
	
						if (parentNode.name === 'ul' || parentNode.name === 'ol') {
							if (node.prev && node.prev.name === 'li') {
								node.prev.append(node);
							}
						}
					}
				});
			}
	
			// Remove internal data attributes
			htmlParser.addAttributeFilter(
				'data-mce-src,data-mce-href,data-mce-style,' +
				'data-mce-selected,data-mce-expando,' +
				'data-mce-type,data-mce-resize',
	
				function(nodes, name) {
					var i = nodes.length;
	
					while (i--) {
						nodes[i].attr(name, null);
					}
				}
			);
	
			// Return public methods
			return {
				/**
				 * Schema instance that was used to when the Serializer was constructed.
				 *
				 * @field {tinymce.html.Schema} schema
				 */
				schema: schema,
	
				/**
				 * Adds a node filter function to the parser used by the serializer, the parser will collect the specified nodes by name
				 * and then execute the callback ones it has finished parsing the document.
				 *
				 * @example
				 * parser.addNodeFilter('p,h1', function(nodes, name) {
				 *		for (var i = 0; i < nodes.length; i++) {
				 *			console.log(nodes[i].name);
				 *		}
				 * });
				 * @method addNodeFilter
				 * @method {String} name Comma separated list of nodes to collect.
				 * @param {function} callback Callback function to execute once it has collected nodes.
				 */
				addNodeFilter: htmlParser.addNodeFilter,
	
				/**
				 * Adds a attribute filter function to the parser used by the serializer, the parser will
				 * collect nodes that has the specified attributes
				 * and then execute the callback ones it has finished parsing the document.
				 *
				 * @example
				 * parser.addAttributeFilter('src,href', function(nodes, name) {
				 *		for (var i = 0; i < nodes.length; i++) {
				 *			console.log(nodes[i].name);
				 *		}
				 * });
				 * @method addAttributeFilter
				 * @method {String} name Comma separated list of nodes to collect.
				 * @param {function} callback Callback function to execute once it has collected nodes.
				 */
				addAttributeFilter: htmlParser.addAttributeFilter,
	
				/**
				 * Serializes the specified browser DOM node into a HTML string.
				 *
				 * @method serialize
				 * @param {DOMNode} node DOM node to serialize.
				 * @param {Object} args Arguments option that gets passed to event handlers.
				 */
				serialize: function(node, args) {
					var self = this, impl, doc, oldDoc, htmlSerializer, content, rootNode;
	
					// Explorer won't clone contents of script and style and the
					// selected index of select elements are cleared on a clone operation.
					if (Env.ie && dom.select('script,style,select,map').length > 0) {
						content = node.innerHTML;
						node = node.cloneNode(false);
						dom.setHTML(node, content);
					} else {
						node = node.cloneNode(true);
					}
	
					// Nodes needs to be attached to something in WebKit/Opera
					// This fix will make DOM ranges and make Sizzle happy!
					impl = node.ownerDocument.implementation;
					if (impl.createHTMLDocument) {
						// Create an empty HTML document
						doc = impl.createHTMLDocument("");
	
						// Add the element or it's children if it's a body element to the new document
						each(node.nodeName == 'BODY' ? node.childNodes : [node], function(node) {
							doc.body.appendChild(doc.importNode(node, true));
						});
	
						// Grab first child or body element for serialization
						if (node.nodeName != 'BODY') {
							node = doc.body.firstChild;
						} else {
							node = doc.body;
						}
	
						// set the new document in DOMUtils so createElement etc works
						oldDoc = dom.doc;
						dom.doc = doc;
					}
	
					args = args || {};
					args.format = args.format || 'html';
	
					// Don't wrap content if we want selected html
					if (args.selection) {
						args.forced_root_block = '';
					}
	
					// Pre process
					if (!args.no_events) {
						args.node = node;
						self.onPreProcess(args);
					}
	
					// Parse HTML
					rootNode = htmlParser.parse(trim(args.getInner ? node.innerHTML : dom.getOuterHTML(node)), args);
					trimTrailingBr(rootNode);
	
					// Serialize HTML
					htmlSerializer = new Serializer(settings, schema);
					args.content = htmlSerializer.serialize(rootNode);
	
					// Replace all BOM characters for now until we can find a better solution
					if (!args.cleanup) {
						args.content = Zwsp.trim(args.content);
						args.content = args.content.replace(/\uFEFF/g, '');
					}
	
					// Post process
					if (!args.no_events) {
						self.onPostProcess(args);
					}
	
					// Restore the old document if it was changed
					if (oldDoc) {
						dom.doc = oldDoc;
					}
	
					args.node = null;
	
					return args.content;
				},
	
				/**
				 * Adds valid elements rules to the serializers schema instance this enables you to specify things
				 * like what elements should be outputted and what attributes specific elements might have.
				 * Consult the Wiki for more details on this format.
				 *
				 * @method addRules
				 * @param {String} rules Valid elements rules string to add to schema.
				 */
				addRules: function(rules) {
					schema.addValidElements(rules);
				},
	
				/**
				 * Sets the valid elements rules to the serializers schema instance this enables you to specify things
				 * like what elements should be outputted and what attributes specific elements might have.
				 * Consult the Wiki for more details on this format.
				 *
				 * @method setRules
				 * @param {String} rules Valid elements rules string.
				 */
				setRules: function(rules) {
					schema.setValidElements(rules);
				},
	
				onPreProcess: function(args) {
					if (editor) {
						editor.fire('PreProcess', args);
					}
				},
	
				onPostProcess: function(args) {
					if (editor) {
						editor.fire('PostProcess', args);
					}
				},
	
				/**
				 * Adds a temporary internal attribute these attributes will get removed on undo and
				 * when getting contents out of the editor.
				 *
				 * @method addTempAttr
				 * @param {String} name string
				 */
				addTempAttr: addTempAttr,
	
				// Internal
				trimHtml: trimHtml,
				getTrimmedContent: getTrimmedContent
			};
		};
	});
	
	// Included from: js/tinymce/classes/dom/TridentSelection.js
	
	/**
	 * TridentSelection.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * Selection class for old explorer versions. This one fakes the
	 * native selection object available on modern browsers.
	 *
	 * @private
	 * @class tinymce.dom.TridentSelection
	 */
	define("tinymce/dom/TridentSelection", [], function() {
		function Selection(selection) {
			var self = this, dom = selection.dom, FALSE = false;
	
			function getPosition(rng, start) {
				var checkRng, startIndex = 0, endIndex, inside,
					children, child, offset, index, position = -1, parent;
	
				// Setup test range, collapse it and get the parent
				checkRng = rng.duplicate();
				checkRng.collapse(start);
				parent = checkRng.parentElement();
	
				// Check if the selection is within the right document
				if (parent.ownerDocument !== selection.dom.doc) {
					return;
				}
	
				// IE will report non editable elements as it's parent so look for an editable one
				while (parent.contentEditable === "false") {
					parent = parent.parentNode;
				}
	
				// If parent doesn't have any children then return that we are inside the element
				if (!parent.hasChildNodes()) {
					return {node: parent, inside: 1};
				}
	
				// Setup node list and endIndex
				children = parent.children;
				endIndex = children.length - 1;
	
				// Perform a binary search for the position
				while (startIndex <= endIndex) {
					index = Math.floor((startIndex + endIndex) / 2);
	
					// Move selection to node and compare the ranges
					child = children[index];
					checkRng.moveToElementText(child);
					position = checkRng.compareEndPoints(start ? 'StartToStart' : 'EndToEnd', rng);
	
					// Before/after or an exact match
					if (position > 0) {
						endIndex = index - 1;
					} else if (position < 0) {
						startIndex = index + 1;
					} else {
						return {node: child};
					}
				}
	
				// Check if child position is before or we didn't find a position
				if (position < 0) {
					// No element child was found use the parent element and the offset inside that
					if (!child) {
						checkRng.moveToElementText(parent);
						checkRng.collapse(true);
						child = parent;
						inside = true;
					} else {
						checkRng.collapse(false);
					}
	
					// Walk character by character in text node until we hit the selected range endpoint,
					// hit the end of document or parent isn't the right one
					// We need to walk char by char since rng.text or rng.htmlText will trim line endings
					offset = 0;
					while (checkRng.compareEndPoints(start ? 'StartToStart' : 'StartToEnd', rng) !== 0) {
						if (checkRng.move('character', 1) === 0 || parent != checkRng.parentElement()) {
							break;
						}
	
						offset++;
					}
				} else {
					// Child position is after the selection endpoint
					checkRng.collapse(true);
	
					// Walk character by character in text node until we hit the selected range endpoint, hit
					// the end of document or parent isn't the right one
					offset = 0;
					while (checkRng.compareEndPoints(start ? 'StartToStart' : 'StartToEnd', rng) !== 0) {
						if (checkRng.move('character', -1) === 0 || parent != checkRng.parentElement()) {
							break;
						}
	
						offset++;
					}
				}
	
				return {node: child, position: position, offset: offset, inside: inside};
			}
	
			// Returns a W3C DOM compatible range object by using the IE Range API
			function getRange() {
				var ieRange = selection.getRng(), domRange = dom.createRng(), element, collapsed, tmpRange, element2, bookmark;
	
				// If selection is outside the current document just return an empty range
				element = ieRange.item ? ieRange.item(0) : ieRange.parentElement();
				if (element.ownerDocument != dom.doc) {
					return domRange;
				}
	
				collapsed = selection.isCollapsed();
	
				// Handle control selection
				if (ieRange.item) {
					domRange.setStart(element.parentNode, dom.nodeIndex(element));
					domRange.setEnd(domRange.startContainer, domRange.startOffset + 1);
	
					return domRange;
				}
	
				function findEndPoint(start) {
					var endPoint = getPosition(ieRange, start), container, offset, textNodeOffset = 0, sibling, undef, nodeValue;
	
					container = endPoint.node;
					offset = endPoint.offset;
	
					if (endPoint.inside && !container.hasChildNodes()) {
						domRange[start ? 'setStart' : 'setEnd'](container, 0);
						return;
					}
	
					if (offset === undef) {
						domRange[start ? 'setStartBefore' : 'setEndAfter'](container);
						return;
					}
	
					if (endPoint.position < 0) {
						sibling = endPoint.inside ? container.firstChild : container.nextSibling;
	
						if (!sibling) {
							domRange[start ? 'setStartAfter' : 'setEndAfter'](container);
							return;
						}
	
						if (!offset) {
							if (sibling.nodeType == 3) {
								domRange[start ? 'setStart' : 'setEnd'](sibling, 0);
							} else {
								domRange[start ? 'setStartBefore' : 'setEndBefore'](sibling);
							}
	
							return;
						}
	
						// Find the text node and offset
						while (sibling) {
							if (sibling.nodeType == 3) {
								nodeValue = sibling.nodeValue;
								textNodeOffset += nodeValue.length;
	
								// We are at or passed the position we where looking for
								if (textNodeOffset >= offset) {
									container = sibling;
									textNodeOffset -= offset;
									textNodeOffset = nodeValue.length - textNodeOffset;
									break;
								}
							}
	
							sibling = sibling.nextSibling;
						}
					} else {
						// Find the text node and offset
						sibling = container.previousSibling;
	
						if (!sibling) {
							return domRange[start ? 'setStartBefore' : 'setEndBefore'](container);
						}
	
						// If there isn't any text to loop then use the first position
						if (!offset) {
							if (container.nodeType == 3) {
								domRange[start ? 'setStart' : 'setEnd'](sibling, container.nodeValue.length);
							} else {
								domRange[start ? 'setStartAfter' : 'setEndAfter'](sibling);
							}
	
							return;
						}
	
						while (sibling) {
							if (sibling.nodeType == 3) {
								textNodeOffset += sibling.nodeValue.length;
	
								// We are at or passed the position we where looking for
								if (textNodeOffset >= offset) {
									container = sibling;
									textNodeOffset -= offset;
									break;
								}
							}
	
							sibling = sibling.previousSibling;
						}
					}
	
					domRange[start ? 'setStart' : 'setEnd'](container, textNodeOffset);
				}
	
				try {
					// Find start point
					findEndPoint(true);
	
					// Find end point if needed
					if (!collapsed) {
						findEndPoint();
					}
				} catch (ex) {
					// IE has a nasty bug where text nodes might throw "invalid argument" when you
					// access the nodeValue or other properties of text nodes. This seems to happen when
					// text nodes are split into two nodes by a delete/backspace call.
					// So let us detect and try to fix it.
					if (ex.number == -2147024809) {
						// Get the current selection
						bookmark = self.getBookmark(2);
	
						// Get start element
						tmpRange = ieRange.duplicate();
						tmpRange.collapse(true);
						element = tmpRange.parentElement();
	
						// Get end element
						if (!collapsed) {
							tmpRange = ieRange.duplicate();
							tmpRange.collapse(false);
							element2 = tmpRange.parentElement();
							element2.innerHTML = element2.innerHTML;
						}
	
						// Remove the broken elements
						element.innerHTML = element.innerHTML;
	
						// Restore the selection
						self.moveToBookmark(bookmark);
	
						// Since the range has moved we need to re-get it
						ieRange = selection.getRng();
	
						// Find start point
						findEndPoint(true);
	
						// Find end point if needed
						if (!collapsed) {
							findEndPoint();
						}
					} else {
						throw ex; // Throw other errors
					}
				}
	
				return domRange;
			}
	
			this.getBookmark = function(type) {
				var rng = selection.getRng(), bookmark = {};
	
				function getIndexes(node) {
					var parent, root, children, i, indexes = [];
	
					parent = node.parentNode;
					root = dom.getRoot().parentNode;
	
					while (parent != root && parent.nodeType !== 9) {
						children = parent.children;
	
						i = children.length;
						while (i--) {
							if (node === children[i]) {
								indexes.push(i);
								break;
							}
						}
	
						node = parent;
						parent = parent.parentNode;
					}
	
					return indexes;
				}
	
				function getBookmarkEndPoint(start) {
					var position;
	
					position = getPosition(rng, start);
					if (position) {
						return {
							position: position.position,
							offset: position.offset,
							indexes: getIndexes(position.node),
							inside: position.inside
						};
					}
				}
	
				// Non ubstructive bookmark
				if (type === 2) {
					// Handle text selection
					if (!rng.item) {
						bookmark.start = getBookmarkEndPoint(true);
	
						if (!selection.isCollapsed()) {
							bookmark.end = getBookmarkEndPoint();
						}
					} else {
						bookmark.start = {ctrl: true, indexes: getIndexes(rng.item(0))};
					}
				}
	
				return bookmark;
			};
	
			this.moveToBookmark = function(bookmark) {
				var rng, body = dom.doc.body;
	
				function resolveIndexes(indexes) {
					var node, i, idx, children;
	
					node = dom.getRoot();
					for (i = indexes.length - 1; i >= 0; i--) {
						children = node.children;
						idx = indexes[i];
	
						if (idx <= children.length - 1) {
							node = children[idx];
						}
					}
	
					return node;
				}
	
				function setBookmarkEndPoint(start) {
					var endPoint = bookmark[start ? 'start' : 'end'], moveLeft, moveRng, undef, offset;
	
					if (endPoint) {
						moveLeft = endPoint.position > 0;
	
						moveRng = body.createTextRange();
						moveRng.moveToElementText(resolveIndexes(endPoint.indexes));
	
						offset = endPoint.offset;
						if (offset !== undef) {
							moveRng.collapse(endPoint.inside || moveLeft);
							moveRng.moveStart('character', moveLeft ? -offset : offset);
						} else {
							moveRng.collapse(start);
						}
	
						rng.setEndPoint(start ? 'StartToStart' : 'EndToStart', moveRng);
	
						if (start) {
							rng.collapse(true);
						}
					}
				}
	
				if (bookmark.start) {
					if (bookmark.start.ctrl) {
						rng = body.createControlRange();
						rng.addElement(resolveIndexes(bookmark.start.indexes));
						rng.select();
					} else {
						rng = body.createTextRange();
						setBookmarkEndPoint(true);
						setBookmarkEndPoint();
						rng.select();
					}
				}
			};
	
			this.addRange = function(rng) {
				var ieRng, ctrlRng, startContainer, startOffset, endContainer, endOffset, sibling,
					doc = selection.dom.doc, body = doc.body, nativeRng, ctrlElm;
	
				function setEndPoint(start) {
					var container, offset, marker, tmpRng, nodes;
	
					marker = dom.create('a');
					container = start ? startContainer : endContainer;
					offset = start ? startOffset : endOffset;
					tmpRng = ieRng.duplicate();
	
					if (container == doc || container == doc.documentElement) {
						container = body;
						offset = 0;
					}
	
					if (container.nodeType == 3) {
						container.parentNode.insertBefore(marker, container);
						tmpRng.moveToElementText(marker);
						tmpRng.moveStart('character', offset);
						dom.remove(marker);
						ieRng.setEndPoint(start ? 'StartToStart' : 'EndToEnd', tmpRng);
					} else {
						nodes = container.childNodes;
	
						if (nodes.length) {
							if (offset >= nodes.length) {
								dom.insertAfter(marker, nodes[nodes.length - 1]);
							} else {
								container.insertBefore(marker, nodes[offset]);
							}
	
							tmpRng.moveToElementText(marker);
						} else if (container.canHaveHTML) {
							// Empty node selection for example <div>|</div>
							// Setting innerHTML with a span marker then remove that marker seems to keep empty block elements open
							container.innerHTML = '<span>&#xFEFF;</span>';
							marker = container.firstChild;
							tmpRng.moveToElementText(marker);
							tmpRng.collapse(FALSE); // Collapse false works better than true for some odd reason
						}
	
						ieRng.setEndPoint(start ? 'StartToStart' : 'EndToEnd', tmpRng);
						dom.remove(marker);
					}
				}
	
				// Setup some shorter versions
				startContainer = rng.startContainer;
				startOffset = rng.startOffset;
				endContainer = rng.endContainer;
				endOffset = rng.endOffset;
				ieRng = body.createTextRange();
	
				// If single element selection then try making a control selection out of it
				if (startContainer == endContainer && startContainer.nodeType == 1) {
					// Trick to place the caret inside an empty block element like <p></p>
					if (startOffset == endOffset && !startContainer.hasChildNodes()) {
						if (startContainer.canHaveHTML) {
							// Check if previous sibling is an empty block if it is then we need to render it
							// IE would otherwise move the caret into the sibling instead of the empty startContainer see: #5236
							// Example this: <p></p><p>|</p> would become this: <p>|</p><p></p>
							sibling = startContainer.previousSibling;
							if (sibling && !sibling.hasChildNodes() && dom.isBlock(sibling)) {
								sibling.innerHTML = '&#xFEFF;';
							} else {
								sibling = null;
							}
	
							startContainer.innerHTML = '<span>&#xFEFF;</span><span>&#xFEFF;</span>';
							ieRng.moveToElementText(startContainer.lastChild);
							ieRng.select();
							dom.doc.selection.clear();
							startContainer.innerHTML = '';
	
							if (sibling) {
								sibling.innerHTML = '';
							}
							return;
						}
	
						startOffset = dom.nodeIndex(startContainer);
						startContainer = startContainer.parentNode;
					}
	
					if (startOffset == endOffset - 1) {
						try {
							ctrlElm = startContainer.childNodes[startOffset];
							ctrlRng = body.createControlRange();
							ctrlRng.addElement(ctrlElm);
							ctrlRng.select();
	
							// Check if the range produced is on the correct element and is a control range
							// On IE 8 it will select the parent contentEditable container if you select an inner element see: #5398
							nativeRng = selection.getRng();
							if (nativeRng.item && ctrlElm === nativeRng.item(0)) {
								return;
							}
						} catch (ex) {
							// Ignore
						}
					}
				}
	
				// Set start/end point of selection
				setEndPoint(true);
				setEndPoint();
	
				// Select the new range and scroll it into view
				ieRng.select();
			};
	
			// Expose range method
			this.getRangeAt = getRange;
		}
	
		return Selection;
	});
	
	// Included from: js/tinymce/classes/util/VK.js
	
	/**
	 * VK.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * This file exposes a set of the common KeyCodes for use. Please grow it as needed.
	 */
	define("tinymce/util/VK", [
		"tinymce/Env"
	], function(Env) {
		return {
			BACKSPACE: 8,
			DELETE: 46,
			DOWN: 40,
			ENTER: 13,
			LEFT: 37,
			RIGHT: 39,
			SPACEBAR: 32,
			TAB: 9,
			UP: 38,
	
			modifierPressed: function(e) {
				return e.shiftKey || e.ctrlKey || e.altKey || this.metaKeyPressed(e);
			},
	
			metaKeyPressed: function(e) {
				// Check if ctrl or meta key is pressed. Edge case for AltGr on Windows where it produces ctrlKey+altKey states
				return (Env.mac ? e.metaKey : e.ctrlKey && !e.altKey);
			}
		};
	});
	
	// Included from: js/tinymce/classes/dom/ControlSelection.js
	
	/**
	 * ControlSelection.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * This class handles control selection of elements. Controls are elements
	 * that can be resized and needs to be selected as a whole. It adds custom resize handles
	 * to all browser engines that support properly disabling the built in resize logic.
	 *
	 * @class tinymce.dom.ControlSelection
	 */
	define("tinymce/dom/ControlSelection", [
		"tinymce/util/VK",
		"tinymce/util/Tools",
		"tinymce/util/Delay",
		"tinymce/Env",
		"tinymce/dom/NodeType"
	], function(VK, Tools, Delay, Env, NodeType) {
		var isContentEditableFalse = NodeType.isContentEditableFalse;
	
		return function(selection, editor) {
			var dom = editor.dom, each = Tools.each;
			var selectedElm, selectedElmGhost, resizeHelper, resizeHandles, selectedHandle, lastMouseDownEvent;
			var startX, startY, selectedElmX, selectedElmY, startW, startH, ratio, resizeStarted;
			var width, height, editableDoc = editor.getDoc(), rootDocument = document, isIE = Env.ie && Env.ie < 11;
			var abs = Math.abs, round = Math.round, rootElement = editor.getBody(), startScrollWidth, startScrollHeight;
	
			// Details about each resize handle how to scale etc
			resizeHandles = {
				// Name: x multiplier, y multiplier, delta size x, delta size y
				/*n: [0.5, 0, 0, -1],
				e: [1, 0.5, 1, 0],
				s: [0.5, 1, 0, 1],
				w: [0, 0.5, -1, 0],*/
				nw: [0, 0, -1, -1],
				ne: [1, 0, 1, -1],
				se: [1, 1, 1, 1],
				sw: [0, 1, -1, 1]
			};
	
			// Add CSS for resize handles, cloned element and selected
			var rootClass = '.mce-content-body';
			editor.contentStyles.push(
				rootClass + ' div.mce-resizehandle {' +
					'position: absolute;' +
					'border: 1px solid black;' +
					'box-sizing: box-sizing;' +
					'background: #FFF;' +
					'width: 7px;' +
					'height: 7px;' +
					'z-index: 10000' +
				'}' +
				rootClass + ' .mce-resizehandle:hover {' +
					'background: #000' +
				'}' +
				rootClass + ' img[data-mce-selected],' + rootClass + ' hr[data-mce-selected] {' +
					'outline: 1px solid black;' +
					'resize: none' + // Have been talks about implementing this in browsers
				'}' +
				rootClass + ' .mce-clonedresizable {' +
					'position: absolute;' +
					(Env.gecko ? '' : 'outline: 1px dashed black;') + // Gecko produces trails while resizing
					'opacity: .5;' +
					'filter: alpha(opacity=50);' +
					'z-index: 10000' +
				'}' +
				rootClass + ' .mce-resize-helper {' +
					'background: #555;' +
					'background: rgba(0,0,0,0.75);' +
					'border-radius: 3px;' +
					'border: 1px;' +
					'color: white;' +
					'display: none;' +
					'font-family: sans-serif;' +
					'font-size: 12px;' +
					'white-space: nowrap;' +
					'line-height: 14px;' +
					'margin: 5px 10px;' +
					'padding: 5px;' +
					'position: absolute;' +
					'z-index: 10001' +
				'}'
			);
	
			function isResizable(elm) {
				var selector = editor.settings.object_resizing;
	
				if (selector === false || Env.iOS) {
					return false;
				}
	
				if (typeof selector != 'string') {
					selector = 'table,img,div';
				}
	
				if (elm.getAttribute('data-mce-resize') === 'false') {
					return false;
				}
	
				if (elm == editor.getBody()) {
					return false;
				}
	
				return editor.dom.is(elm, selector);
			}
	
			function resizeGhostElement(e) {
				var deltaX, deltaY, proportional;
				var resizeHelperX, resizeHelperY;
	
				// Calc new width/height
				deltaX = e.screenX - startX;
				deltaY = e.screenY - startY;
	
				// Calc new size
				width = deltaX * selectedHandle[2] + startW;
				height = deltaY * selectedHandle[3] + startH;
	
				// Never scale down lower than 5 pixels
				width = width < 5 ? 5 : width;
				height = height < 5 ? 5 : height;
	
				if (selectedElm.nodeName == "IMG" && editor.settings.resize_img_proportional !== false) {
					proportional = !VK.modifierPressed(e);
				} else {
					proportional = VK.modifierPressed(e) || (selectedElm.nodeName == "IMG" && selectedHandle[2] * selectedHandle[3] !== 0);
				}
	
				// Constrain proportions
				if (proportional) {
					if (abs(deltaX) > abs(deltaY)) {
						height = round(width * ratio);
						width = round(height / ratio);
					} else {
						width = round(height / ratio);
						height = round(width * ratio);
					}
				}
	
				// Update ghost size
				dom.setStyles(selectedElmGhost, {
					width: width,
					height: height
				});
	
				// Update resize helper position
				resizeHelperX = selectedHandle.startPos.x + deltaX;
				resizeHelperY = selectedHandle.startPos.y + deltaY;
				resizeHelperX = resizeHelperX > 0 ? resizeHelperX : 0;
				resizeHelperY = resizeHelperY > 0 ? resizeHelperY : 0;
	
				dom.setStyles(resizeHelper, {
					left: resizeHelperX,
					top: resizeHelperY,
					display: 'block'
				});
	
				resizeHelper.innerHTML = width + ' &times; ' + height;
	
				// Update ghost X position if needed
				if (selectedHandle[2] < 0 && selectedElmGhost.clientWidth <= width) {
					dom.setStyle(selectedElmGhost, 'left', selectedElmX + (startW - width));
				}
	
				// Update ghost Y position if needed
				if (selectedHandle[3] < 0 && selectedElmGhost.clientHeight <= height) {
					dom.setStyle(selectedElmGhost, 'top', selectedElmY + (startH - height));
				}
	
				// Calculate how must overflow we got
				deltaX = rootElement.scrollWidth - startScrollWidth;
				deltaY = rootElement.scrollHeight - startScrollHeight;
	
				// Re-position the resize helper based on the overflow
				if (deltaX + deltaY !== 0) {
					dom.setStyles(resizeHelper, {
						left: resizeHelperX - deltaX,
						top: resizeHelperY - deltaY
					});
				}
	
				if (!resizeStarted) {
					editor.fire('ObjectResizeStart', {target: selectedElm, width: startW, height: startH});
					resizeStarted = true;
				}
			}
	
			function endGhostResize() {
				resizeStarted = false;
	
				function setSizeProp(name, value) {
					if (value) {
						// Resize by using style or attribute
						if (selectedElm.style[name] || !editor.schema.isValid(selectedElm.nodeName.toLowerCase(), name)) {
							dom.setStyle(selectedElm, name, value);
						} else {
							dom.setAttrib(selectedElm, name, value);
						}
					}
				}
	
				// Set width/height properties
				setSizeProp('width', width);
				setSizeProp('height', height);
	
				dom.unbind(editableDoc, 'mousemove', resizeGhostElement);
				dom.unbind(editableDoc, 'mouseup', endGhostResize);
	
				if (rootDocument != editableDoc) {
					dom.unbind(rootDocument, 'mousemove', resizeGhostElement);
					dom.unbind(rootDocument, 'mouseup', endGhostResize);
				}
	
				// Remove ghost/helper and update resize handle positions
				dom.remove(selectedElmGhost);
				dom.remove(resizeHelper);
	
				if (!isIE || selectedElm.nodeName == "TABLE") {
					showResizeRect(selectedElm);
				}
	
				editor.fire('ObjectResized', {target: selectedElm, width: width, height: height});
				dom.setAttrib(selectedElm, 'style', dom.getAttrib(selectedElm, 'style'));
				editor.nodeChanged();
			}
	
			function showResizeRect(targetElm, mouseDownHandleName, mouseDownEvent) {
				var position, targetWidth, targetHeight, e, rect;
	
				hideResizeRect();
				unbindResizeHandleEvents();
	
				// Get position and size of target
				position = dom.getPos(targetElm, rootElement);
				selectedElmX = position.x;
				selectedElmY = position.y;
				rect = targetElm.getBoundingClientRect(); // Fix for Gecko offsetHeight for table with caption
				targetWidth = rect.width || (rect.right - rect.left);
				targetHeight = rect.height || (rect.bottom - rect.top);
	
				// Reset width/height if user selects a new image/table
				if (selectedElm != targetElm) {
					detachResizeStartListener();
					selectedElm = targetElm;
					width = height = 0;
				}
	
				// Makes it possible to disable resizing
				e = editor.fire('ObjectSelected', {target: targetElm});
	
				if (isResizable(targetElm) && !e.isDefaultPrevented()) {
					each(resizeHandles, function(handle, name) {
						var handleElm;
	
						function startDrag(e) {
							startX = e.screenX;
							startY = e.screenY;
							startW = selectedElm.clientWidth;
							startH = selectedElm.clientHeight;
							ratio = startH / startW;
							selectedHandle = handle;
	
							handle.startPos = {
								x: targetWidth * handle[0] + selectedElmX,
								y: targetHeight * handle[1] + selectedElmY
							};
	
							startScrollWidth = rootElement.scrollWidth;
							startScrollHeight = rootElement.scrollHeight;
	
							selectedElmGhost = selectedElm.cloneNode(true);
							dom.addClass(selectedElmGhost, 'mce-clonedresizable');
							dom.setAttrib(selectedElmGhost, 'data-mce-bogus', 'all');
							selectedElmGhost.contentEditable = false; // Hides IE move layer cursor
							selectedElmGhost.unSelectabe = true;
							dom.setStyles(selectedElmGhost, {
								left: selectedElmX,
								top: selectedElmY,
								margin: 0
							});
	
							selectedElmGhost.removeAttribute('data-mce-selected');
							rootElement.appendChild(selectedElmGhost);
	
							dom.bind(editableDoc, 'mousemove', resizeGhostElement);
							dom.bind(editableDoc, 'mouseup', endGhostResize);
	
							if (rootDocument != editableDoc) {
								dom.bind(rootDocument, 'mousemove', resizeGhostElement);
								dom.bind(rootDocument, 'mouseup', endGhostResize);
							}
	
							resizeHelper = dom.add(rootElement, 'div', {
								'class': 'mce-resize-helper',
								'data-mce-bogus': 'all'
							}, startW + ' &times; ' + startH);
						}
	
						if (mouseDownHandleName) {
							// Drag started by IE native resizestart
							if (name == mouseDownHandleName) {
								startDrag(mouseDownEvent);
							}
	
							return;
						}
	
						// Get existing or render resize handle
						handleElm = dom.get('mceResizeHandle' + name);
						if (handleElm) {
							dom.remove(handleElm);
						}
	
						handleElm = dom.add(rootElement, 'div', {
							id: 'mceResizeHandle' + name,
							'data-mce-bogus': 'all',
							'class': 'mce-resizehandle',
							unselectable: true,
							style: 'cursor:' + name + '-resize; margin:0; padding:0'
						});
	
						// Hides IE move layer cursor
						// If we set it on Chrome we get this wounderful bug: #6725
						if (Env.ie) {
							handleElm.contentEditable = false;
						}
	
						dom.bind(handleElm, 'mousedown', function(e) {
							e.stopImmediatePropagation();
							e.preventDefault();
							startDrag(e);
						});
	
						handle.elm = handleElm;
	
						// Position element
						dom.setStyles(handleElm, {
							left: (targetWidth * handle[0] + selectedElmX) - (handleElm.offsetWidth / 2),
							top: (targetHeight * handle[1] + selectedElmY) - (handleElm.offsetHeight / 2)
						});
					});
				} else {
					hideResizeRect();
				}
	
				selectedElm.setAttribute('data-mce-selected', '1');
			}
	
			function hideResizeRect() {
				var name, handleElm;
	
				unbindResizeHandleEvents();
	
				if (selectedElm) {
					selectedElm.removeAttribute('data-mce-selected');
				}
	
				for (name in resizeHandles) {
					handleElm = dom.get('mceResizeHandle' + name);
					if (handleElm) {
						dom.unbind(handleElm);
						dom.remove(handleElm);
					}
				}
			}
	
			function updateResizeRect(e) {
				var startElm, controlElm;
	
				function isChildOrEqual(node, parent) {
					if (node) {
						do {
							if (node === parent) {
								return true;
							}
						} while ((node = node.parentNode));
					}
				}
	
				// Ignore all events while resizing or if the editor instance was removed
				if (resizeStarted || editor.removed) {
					return;
				}
	
				// Remove data-mce-selected from all elements since they might have been copied using Ctrl+c/v
				each(dom.select('img[data-mce-selected],hr[data-mce-selected]'), function(img) {
					img.removeAttribute('data-mce-selected');
				});
	
				controlElm = e.type == 'mousedown' ? e.target : selection.getNode();
				controlElm = dom.$(controlElm).closest(isIE ? 'table' : 'table,img,hr')[0];
	
				if (isChildOrEqual(controlElm, rootElement)) {
					disableGeckoResize();
					startElm = selection.getStart(true);
	
					if (isChildOrEqual(startElm, controlElm) && isChildOrEqual(selection.getEnd(true), controlElm)) {
						if (!isIE || (controlElm != startElm && startElm.nodeName !== 'IMG')) {
							showResizeRect(controlElm);
							return;
						}
					}
				}
	
				hideResizeRect();
			}
	
			function attachEvent(elm, name, func) {
				if (elm && elm.attachEvent) {
					elm.attachEvent('on' + name, func);
				}
			}
	
			function detachEvent(elm, name, func) {
				if (elm && elm.detachEvent) {
					elm.detachEvent('on' + name, func);
				}
			}
	
			function resizeNativeStart(e) {
				var target = e.srcElement, pos, name, corner, cornerX, cornerY, relativeX, relativeY;
	
				pos = target.getBoundingClientRect();
				relativeX = lastMouseDownEvent.clientX - pos.left;
				relativeY = lastMouseDownEvent.clientY - pos.top;
	
				// Figure out what corner we are draging on
				for (name in resizeHandles) {
					corner = resizeHandles[name];
	
					cornerX = target.offsetWidth * corner[0];
					cornerY = target.offsetHeight * corner[1];
	
					if (abs(cornerX - relativeX) < 8 && abs(cornerY - relativeY) < 8) {
						selectedHandle = corner;
						break;
					}
				}
	
				// Remove native selection and let the magic begin
				resizeStarted = true;
				editor.fire('ObjectResizeStart', {
					target: selectedElm,
					width: selectedElm.clientWidth,
					height: selectedElm.clientHeight
				});
				editor.getDoc().selection.empty();
				showResizeRect(target, name, lastMouseDownEvent);
			}
	
			function preventDefault(e) {
				if (e.preventDefault) {
					e.preventDefault();
				} else {
					e.returnValue = false; // IE
				}
			}
	
			function nativeControlSelect(e) {
				var target = e.srcElement;
	
				if (isContentEditableFalse(target)) {
					preventDefault(e);
					return;
				}
	
				if (target != selectedElm) {
					editor.fire('ObjectSelected', {target: target});
					detachResizeStartListener();
	
					if (target.id.indexOf('mceResizeHandle') === 0) {
						e.returnValue = false;
						return;
					}
	
					if (target.nodeName == 'IMG' || target.nodeName == 'TABLE') {
						hideResizeRect();
						selectedElm = target;
						attachEvent(target, 'resizestart', resizeNativeStart);
					}
				}
			}
	
			function detachResizeStartListener() {
				detachEvent(selectedElm, 'resizestart', resizeNativeStart);
			}
	
			function unbindResizeHandleEvents() {
				for (var name in resizeHandles) {
					var handle = resizeHandles[name];
	
					if (handle.elm) {
						dom.unbind(handle.elm);
						delete handle.elm;
					}
				}
			}
	
			function disableGeckoResize() {
				try {
					// Disable object resizing on Gecko
					editor.getDoc().execCommand('enableObjectResizing', false, false);
				} catch (ex) {
					// Ignore
				}
			}
	
			function controlSelect(elm) {
				var ctrlRng;
	
				if (!isIE) {
					return;
				}
	
				ctrlRng = editableDoc.body.createControlRange();
	
				try {
					ctrlRng.addElement(elm);
					ctrlRng.select();
					return true;
				} catch (ex) {
					// Ignore since the element can't be control selected for example a P tag
				}
			}
	
			editor.on('init', function() {
				if (isIE) {
					// Hide the resize rect on resize and reselect the image
					editor.on('ObjectResized', function(e) {
						if (e.target.nodeName != 'TABLE') {
							hideResizeRect();
							controlSelect(e.target);
						}
					});
	
					attachEvent(rootElement, 'controlselect', nativeControlSelect);
	
					editor.on('mousedown', function(e) {
						lastMouseDownEvent = e;
					});
				} else {
					disableGeckoResize();
	
					// Sniff sniff, hard to feature detect this stuff
					if (Env.ie >= 11) {
						// Needs to be mousedown for drag/drop to work on IE 11
						// Needs to be click on Edge to properly select images
						editor.on('mousedown click', function(e) {
							var nodeName = e.target.nodeName;
	
							if (!resizeStarted && /^(TABLE|IMG|HR)$/.test(nodeName)) {
								editor.selection.select(e.target, nodeName == 'TABLE');
	
								// Only fire once since nodeChange is expensive
								if (e.type == 'mousedown') {
									editor.nodeChanged();
								}
							}
						});
	
						editor.dom.bind(rootElement, 'mscontrolselect', function(e) {
							function delayedSelect(node) {
								Delay.setEditorTimeout(editor, function() {
									editor.selection.select(node);
								});
							}
	
							if (isContentEditableFalse(e.target)) {
								e.preventDefault();
								delayedSelect(e.target);
								return;
							}
	
							if (/^(TABLE|IMG|HR)$/.test(e.target.nodeName)) {
								e.preventDefault();
	
								// This moves the selection from being a control selection to a text like selection like in WebKit #6753
								// TODO: Fix this the day IE works like other browsers without this nasty native ugly control selections.
								if (e.target.tagName == 'IMG') {
									delayedSelect(e.target);
								}
							}
						});
					}
				}
	
				var throttledUpdateResizeRect = Delay.throttle(function(e) {
					if (!editor.composing) {
						updateResizeRect(e);
					}
				});
	
				editor.on('nodechange ResizeEditor ResizeWindow drop', throttledUpdateResizeRect);
	
				// Update resize rect while typing in a table
				editor.on('keyup compositionend', function(e) {
					// Don't update the resize rect while composing since it blows away the IME see: #2710
					if (selectedElm && selectedElm.nodeName == "TABLE") {
						throttledUpdateResizeRect(e);
					}
				});
	
				editor.on('hide blur', hideResizeRect);
	
				// Hide rect on focusout since it would float on top of windows otherwise
				//editor.on('focusout', hideResizeRect);
			});
	
			editor.on('remove', unbindResizeHandleEvents);
	
			function destroy() {
				selectedElm = selectedElmGhost = null;
	
				if (isIE) {
					detachResizeStartListener();
					detachEvent(rootElement, 'controlselect', nativeControlSelect);
				}
			}
	
			return {
				isResizable: isResizable,
				showResizeRect: showResizeRect,
				hideResizeRect: hideResizeRect,
				updateResizeRect: updateResizeRect,
				controlSelect: controlSelect,
				destroy: destroy
			};
		};
	});
	
	// Included from: js/tinymce/classes/util/Fun.js
	
	/**
	 * Fun.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * Functional utility class.
	 *
	 * @private
	 * @class tinymce.util.Fun
	 */
	define("tinymce/util/Fun", [], function() {
		var slice = [].slice;
	
		function constant(value) {
			return function() {
				return value;
			};
		}
	
		function negate(predicate) {
			return function(x) {
				return !predicate(x);
			};
		}
	
		function compose(f, g) {
			return function(x) {
				return f(g(x));
			};
		}
	
		function or() {
			var args = slice.call(arguments);
	
			return function(x) {
				for (var i = 0; i < args.length; i++) {
					if (args[i](x)) {
						return true;
					}
				}
	
				return false;
			};
		}
	
		function and() {
			var args = slice.call(arguments);
	
			return function(x) {
				for (var i = 0; i < args.length; i++) {
					if (!args[i](x)) {
						return false;
					}
				}
	
				return true;
			};
		}
	
		function curry(fn) {
			var args = slice.call(arguments);
	
			if (args.length - 1 >= fn.length) {
				return fn.apply(this, args.slice(1));
			}
	
			return function() {
				var tempArgs = args.concat([].slice.call(arguments));
				return curry.apply(this, tempArgs);
			};
		}
	
		return {
			constant: constant,
			negate: negate,
			and: and,
			or: or,
			curry: curry,
			compose: compose
		};
	});
	
	// Included from: js/tinymce/classes/caret/CaretCandidate.js
	
	/**
	 * CaretCandidate.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * This module contains logic for handling caret candidates. A caret candidate is
	 * for example text nodes, images, input elements, cE=false elements etc.
	 *
	 * @private
	 * @class tinymce.caret.CaretCandidate
	 */
	define("tinymce/caret/CaretCandidate", [
		"tinymce/dom/NodeType",
		"tinymce/util/Arr",
		"tinymce/caret/CaretContainer"
	], function(NodeType, Arr, CaretContainer) {
		var isContentEditableTrue = NodeType.isContentEditableTrue,
			isContentEditableFalse = NodeType.isContentEditableFalse,
			isBr = NodeType.isBr,
			isText = NodeType.isText,
			isInvalidTextElement = NodeType.matchNodeNames('script style textarea'),
			isAtomicInline = NodeType.matchNodeNames('img input textarea hr iframe video audio object'),
			isTable = NodeType.matchNodeNames('table'),
			isCaretContainer = CaretContainer.isCaretContainer;
	
		function isCaretCandidate(node) {
			if (isCaretContainer(node)) {
				return false;
			}
	
			if (isText(node)) {
				if (isInvalidTextElement(node.parentNode)) {
					return false;
				}
	
				return true;
			}
	
			return isAtomicInline(node) || isBr(node) || isTable(node) || isContentEditableFalse(node);
		}
	
		function isInEditable(node, rootNode) {
			for (node = node.parentNode; node && node != rootNode; node = node.parentNode) {
				if (isContentEditableFalse(node)) {
					return false;
				}
	
				if (isContentEditableTrue(node)) {
					return true;
				}
			}
	
			return true;
		}
	
		function isAtomicContentEditableFalse(node) {
			if (!isContentEditableFalse(node)) {
				return false;
			}
	
			return Arr.reduce(node.getElementsByTagName('*'), function(result, elm) {
				return result || isContentEditableTrue(elm);
			}, false) !== true;
		}
	
		function isAtomic(node) {
			return isAtomicInline(node) || isAtomicContentEditableFalse(node);
		}
	
		function isEditableCaretCandidate(node, rootNode) {
			return isCaretCandidate(node) && isInEditable(node, rootNode);
		}
	
		return {
			isCaretCandidate: isCaretCandidate,
			isInEditable: isInEditable,
			isAtomic: isAtomic,
			isEditableCaretCandidate: isEditableCaretCandidate
		};
	});
	
	// Included from: js/tinymce/classes/geom/ClientRect.js
	
	/**
	 * ClientRect.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * Utility functions for working with client rects.
	 *
	 * @private
	 * @class tinymce.geom.ClientRect
	 */
	define("tinymce/geom/ClientRect", [], function() {
		var round = Math.round;
	
		function clone(rect) {
			if (!rect) {
				return {left: 0, top: 0, bottom: 0, right: 0, width: 0, height: 0};
			}
	
			return {
				left: round(rect.left),
				top: round(rect.top),
				bottom: round(rect.bottom),
				right: round(rect.right),
				width: round(rect.width),
				height: round(rect.height)
			};
		}
	
		function collapse(clientRect, toStart) {
			clientRect = clone(clientRect);
	
			if (toStart) {
				clientRect.right = clientRect.left;
			} else {
				clientRect.left = clientRect.left + clientRect.width;
				clientRect.right = clientRect.left;
			}
	
			clientRect.width = 0;
	
			return clientRect;
		}
	
		function isEqual(rect1, rect2) {
			return (
				rect1.left === rect2.left &&
				rect1.top === rect2.top &&
				rect1.bottom === rect2.bottom &&
				rect1.right === rect2.right
			);
		}
	
		function isValidOverflow(overflowY, clientRect1, clientRect2) {
			return overflowY >= 0 && overflowY <= Math.min(clientRect1.height, clientRect2.height) / 2;
	
		}
	
		function isAbove(clientRect1, clientRect2) {
			if (clientRect1.bottom < clientRect2.top) {
				return true;
			}
	
			if (clientRect1.top > clientRect2.bottom) {
				return false;
			}
	
			return isValidOverflow(clientRect2.top - clientRect1.bottom, clientRect1, clientRect2);
		}
	
		function isBelow(clientRect1, clientRect2) {
			if (clientRect1.top > clientRect2.bottom) {
				return true;
			}
	
			if (clientRect1.bottom < clientRect2.top) {
				return false;
			}
	
			return isValidOverflow(clientRect2.bottom - clientRect1.top, clientRect1, clientRect2);
		}
	
		function isLeft(clientRect1, clientRect2) {
			return clientRect1.left < clientRect2.left;
		}
	
		function isRight(clientRect1, clientRect2) {
			return clientRect1.right > clientRect2.right;
		}
	
		function compare(clientRect1, clientRect2) {
			if (isAbove(clientRect1, clientRect2)) {
				return -1;
			}
	
			if (isBelow(clientRect1, clientRect2)) {
				return 1;
			}
	
			if (isLeft(clientRect1, clientRect2)) {
				return -1;
			}
	
			if (isRight(clientRect1, clientRect2)) {
				return 1;
			}
	
			return 0;
		}
	
		function containsXY(clientRect, clientX, clientY) {
			return (
				clientX >= clientRect.left &&
				clientX <= clientRect.right &&
				clientY >= clientRect.top &&
				clientY <= clientRect.bottom
			);
		}
	
		return {
			clone: clone,
			collapse: collapse,
			isEqual: isEqual,
			isAbove: isAbove,
			isBelow: isBelow,
			isLeft: isLeft,
			isRight: isRight,
			compare: compare,
			containsXY: containsXY
		};
	});
	
	// Included from: js/tinymce/classes/text/ExtendingChar.js
	
	/**
	 * ExtendingChar.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * This class contains logic for detecting extending characters.
	 *
	 * @private
	 * @class tinymce.text.ExtendingChar
	 * @example
	 * var isExtending = ExtendingChar.isExtendingChar('a');
	 */
	define("tinymce/text/ExtendingChar", [], function() {
		// Generated from: http://www.unicode.org/Public/UNIDATA/DerivedCoreProperties.txt
		// Only includes the characters in that fit into UCS-2 16 bit
		var extendingChars = new RegExp(
			"[\u0300-\u036F\u0483-\u0487\u0488-\u0489\u0591-\u05BD\u05BF\u05C1-\u05C2\u05C4-\u05C5\u05C7\u0610-\u061A" +
			"\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7-\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0" +
			"\u07EB-\u07F3\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08E3-\u0902\u093A\u093C" +
			"\u0941-\u0948\u094D\u0951-\u0957\u0962-\u0963\u0981\u09BC\u09BE\u09C1-\u09C4\u09CD\u09D7\u09E2-\u09E3" +
			"\u0A01-\u0A02\u0A3C\u0A41-\u0A42\u0A47-\u0A48\u0A4B-\u0A4D\u0A51\u0A70-\u0A71\u0A75\u0A81-\u0A82\u0ABC" +
			"\u0AC1-\u0AC5\u0AC7-\u0AC8\u0ACD\u0AE2-\u0AE3\u0B01\u0B3C\u0B3E\u0B3F\u0B41-\u0B44\u0B4D\u0B56\u0B57" +
			"\u0B62-\u0B63\u0B82\u0BBE\u0BC0\u0BCD\u0BD7\u0C00\u0C3E-\u0C40\u0C46-\u0C48\u0C4A-\u0C4D\u0C55-\u0C56" +
			"\u0C62-\u0C63\u0C81\u0CBC\u0CBF\u0CC2\u0CC6\u0CCC-\u0CCD\u0CD5-\u0CD6\u0CE2-\u0CE3\u0D01\u0D3E\u0D41-\u0D44" +
			"\u0D4D\u0D57\u0D62-\u0D63\u0DCA\u0DCF\u0DD2-\u0DD4\u0DD6\u0DDF\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EB9" +
			"\u0EBB-\u0EBC\u0EC8-\u0ECD\u0F18-\u0F19\u0F35\u0F37\u0F39\u0F71-\u0F7E\u0F80-\u0F84\u0F86-\u0F87\u0F8D-\u0F97" +
			"\u0F99-\u0FBC\u0FC6\u102D-\u1030\u1032-\u1037\u1039-\u103A\u103D-\u103E\u1058-\u1059\u105E-\u1060\u1071-\u1074" +
			"\u1082\u1085-\u1086\u108D\u109D\u135D-\u135F\u1712-\u1714\u1732-\u1734\u1752-\u1753\u1772-\u1773\u17B4-\u17B5" +
			"\u17B7-\u17BD\u17C6\u17C9-\u17D3\u17DD\u180B-\u180D\u18A9\u1920-\u1922\u1927-\u1928\u1932\u1939-\u193B\u1A17-\u1A18" +
			"\u1A1B\u1A56\u1A58-\u1A5E\u1A60\u1A62\u1A65-\u1A6C\u1A73-\u1A7C\u1A7F\u1AB0-\u1ABD\u1ABE\u1B00-\u1B03\u1B34" +
			"\u1B36-\u1B3A\u1B3C\u1B42\u1B6B-\u1B73\u1B80-\u1B81\u1BA2-\u1BA5\u1BA8-\u1BA9\u1BAB-\u1BAD\u1BE6\u1BE8-\u1BE9" +
			"\u1BED\u1BEF-\u1BF1\u1C2C-\u1C33\u1C36-\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE0\u1CE2-\u1CE8\u1CED\u1CF4\u1CF8-\u1CF9" +
			"\u1DC0-\u1DF5\u1DFC-\u1DFF\u200C-\u200D\u20D0-\u20DC\u20DD-\u20E0\u20E1\u20E2-\u20E4\u20E5-\u20F0\u2CEF-\u2CF1" +
			"\u2D7F\u2DE0-\u2DFF\u302A-\u302D\u302E-\u302F\u3099-\u309A\uA66F\uA670-\uA672\uA674-\uA67D\uA69E-\uA69F\uA6F0-\uA6F1" +
			"\uA802\uA806\uA80B\uA825-\uA826\uA8C4\uA8E0-\uA8F1\uA926-\uA92D\uA947-\uA951\uA980-\uA982\uA9B3\uA9B6-\uA9B9\uA9BC" +
			"\uA9E5\uAA29-\uAA2E\uAA31-\uAA32\uAA35-\uAA36\uAA43\uAA4C\uAA7C\uAAB0\uAAB2-\uAAB4\uAAB7-\uAAB8\uAABE-\uAABF\uAAC1" +
			"\uAAEC-\uAAED\uAAF6\uABE5\uABE8\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFF9E-\uFF9F]"
		);
	
		function isExtendingChar(ch) {
			return typeof ch == "string" && ch.charCodeAt(0) >= 768 && extendingChars.test(ch);
		}
	
		return {
			isExtendingChar: isExtendingChar
		};
	});
	
	// Included from: js/tinymce/classes/caret/CaretPosition.js
	
	/**
	 * CaretPosition.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * This module contains logic for creating caret positions within a document a caretposition
	 * is similar to a DOMRange object but it doesn't have two endpoints and is also more lightweight
	 * since it's now updated live when the DOM changes.
	 *
	 * @private
	 * @class tinymce.caret.CaretPosition
	 * @example
	 * var caretPos1 = new CaretPosition(container, offset);
	 * var caretPos2 = CaretPosition.fromRangeStart(someRange);
	 */
	define("tinymce/caret/CaretPosition", [
		"tinymce/util/Fun",
		"tinymce/dom/NodeType",
		"tinymce/dom/DOMUtils",
		"tinymce/dom/RangeUtils",
		"tinymce/caret/CaretCandidate",
		"tinymce/geom/ClientRect",
		"tinymce/text/ExtendingChar"
	], function(Fun, NodeType, DOMUtils, RangeUtils, CaretCandidate, ClientRect, ExtendingChar) {
		var isElement = NodeType.isElement,
			isCaretCandidate = CaretCandidate.isCaretCandidate,
			isBlock = NodeType.matchStyleValues('display', 'block table'),
			isFloated = NodeType.matchStyleValues('float', 'left right'),
			isValidElementCaretCandidate = Fun.and(isElement, isCaretCandidate, Fun.negate(isFloated)),
			isNotPre = Fun.negate(NodeType.matchStyleValues('white-space', 'pre pre-line pre-wrap')),
			isText = NodeType.isText,
			isBr = NodeType.isBr,
			nodeIndex = DOMUtils.nodeIndex,
			resolveIndex = RangeUtils.getNode;
	
		function isWhiteSpace(chr) {
			return chr && /[\r\n\t ]/.test(chr);
		}
	
		function isHiddenWhiteSpaceRange(range) {
			var container = range.startContainer,
				offset = range.startOffset,
				text;
	
			if (isWhiteSpace(range.toString()) && isNotPre(container.parentNode)) {
				text = container.data;
	
				if (isWhiteSpace(text[offset - 1]) || isWhiteSpace(text[offset + 1])) {
					return true;
				}
			}
	
			return false;
		}
	
		function getCaretPositionClientRects(caretPosition) {
			var clientRects = [], beforeNode, node;
	
			// Hack for older WebKit versions that doesn't
			// support getBoundingClientRect on BR elements
			function getBrClientRect(brNode) {
				var doc = brNode.ownerDocument,
					rng = doc.createRange(),
					nbsp = doc.createTextNode('\u00a0'),
					parentNode = brNode.parentNode,
					clientRect;
	
				parentNode.insertBefore(nbsp, brNode);
				rng.setStart(nbsp, 0);
				rng.setEnd(nbsp, 1);
				clientRect = ClientRect.clone(rng.getBoundingClientRect());
				parentNode.removeChild(nbsp);
	
				return clientRect;
			}
	
			function getBoundingClientRect(item) {
				var clientRect, clientRects;
	
				clientRects = item.getClientRects();
				if (clientRects.length > 0) {
					clientRect = ClientRect.clone(clientRects[0]);
				} else {
					clientRect = ClientRect.clone(item.getBoundingClientRect());
				}
	
				if (isBr(item) && clientRect.left === 0) {
					return getBrClientRect(item);
				}
	
				return clientRect;
			}
	
			function collapseAndInflateWidth(clientRect, toStart) {
				clientRect = ClientRect.collapse(clientRect, toStart);
				clientRect.width = 1;
				clientRect.right = clientRect.left + 1;
	
				return clientRect;
			}
	
			function addUniqueAndValidRect(clientRect) {
				if (clientRect.height === 0) {
					return;
				}
	
				if (clientRects.length > 0) {
					if (ClientRect.isEqual(clientRect, clientRects[clientRects.length - 1])) {
						return;
					}
				}
	
				clientRects.push(clientRect);
			}
	
			function addCharacterOffset(container, offset) {
				var range = container.ownerDocument.createRange();
	
				if (offset < container.data.length) {
					if (ExtendingChar.isExtendingChar(container.data[offset])) {
						return clientRects;
					}
	
					// WebKit returns two client rects for a position after an extending
					// character a\uxxx|b so expand on "b" and collapse to start of "b" box
					if (ExtendingChar.isExtendingChar(container.data[offset - 1])) {
						range.setStart(container, offset);
						range.setEnd(container, offset + 1);
	
						if (!isHiddenWhiteSpaceRange(range)) {
							addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect(range), false));
							return clientRects;
						}
					}
				}
	
				if (offset > 0) {
					range.setStart(container, offset - 1);
					range.setEnd(container, offset);
	
					if (!isHiddenWhiteSpaceRange(range)) {
						addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect(range), false));
					}
				}
	
				if (offset < container.data.length) {
					range.setStart(container, offset);
					range.setEnd(container, offset + 1);
	
					if (!isHiddenWhiteSpaceRange(range)) {
						addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect(range), true));
					}
				}
			}
	
			if (isText(caretPosition.container())) {
				addCharacterOffset(caretPosition.container(), caretPosition.offset());
				return clientRects;
			}
	
			if (isElement(caretPosition.container())) {
				if (caretPosition.isAtEnd()) {
					node = resolveIndex(caretPosition.container(), caretPosition.offset());
					if (isText(node)) {
						addCharacterOffset(node, node.data.length);
					}
	
					if (isValidElementCaretCandidate(node) && !isBr(node)) {
						addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect(node), false));
					}
				} else {
					node = resolveIndex(caretPosition.container(), caretPosition.offset());
					if (isText(node)) {
						addCharacterOffset(node, 0);
					}
	
					if (isValidElementCaretCandidate(node) && caretPosition.isAtEnd()) {
						addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect(node), false));
						return clientRects;
					}
	
					beforeNode = resolveIndex(caretPosition.container(), caretPosition.offset() - 1);
					if (isValidElementCaretCandidate(beforeNode) && !isBr(beforeNode)) {
						if (isBlock(beforeNode) || isBlock(node) || !isValidElementCaretCandidate(node)) {
							addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect(beforeNode), false));
						}
					}
	
					if (isValidElementCaretCandidate(node)) {
						addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect(node), true));
					}
				}
			}
	
			return clientRects;
		}
	
		/**
		 * Represents a location within the document by a container and an offset.
		 *
		 * @constructor
		 * @param {Node} container Container node.
		 * @param {Number} offset Offset within that container node.
		 * @param {Array} clientRects Optional client rects array for the position.
		 */
		function CaretPosition(container, offset, clientRects) {
			function isAtStart() {
				if (isText(container)) {
					return offset === 0;
				}
	
				return offset === 0;
			}
	
			function isAtEnd() {
				if (isText(container)) {
					return offset >= container.data.length;
				}
	
				return offset >= container.childNodes.length;
			}
	
			function toRange() {
				var range;
	
				range = container.ownerDocument.createRange();
				range.setStart(container, offset);
				range.setEnd(container, offset);
	
				return range;
			}
	
			function getClientRects() {
				if (!clientRects) {
					clientRects = getCaretPositionClientRects(new CaretPosition(container, offset));
				}
	
				return clientRects;
			}
	
			function isVisible() {
				return getClientRects().length > 0;
			}
	
			function isEqual(caretPosition) {
				return caretPosition && container === caretPosition.container() && offset === caretPosition.offset();
			}
	
			function getNode(before) {
				return resolveIndex(container, before ? offset - 1 : offset);
			}
	
			return {
				/**
				 * Returns the container node.
				 *
				 * @method container
				 * @return {Node} Container node.
				 */
				container: Fun.constant(container),
	
				/**
				 * Returns the offset within the container node.
				 *
				 * @method offset
				 * @return {Number} Offset within the container node.
				 */
				offset: Fun.constant(offset),
	
				/**
				 * Returns a range out of a the caret position.
				 *
				 * @method toRange
				 * @return {DOMRange} range for the caret position.
				 */
				toRange: toRange,
	
				/**
				 * Returns the client rects for the caret position. Might be multiple rects between
				 * block elements.
				 *
				 * @method getClientRects
				 * @return {Array} Array of client rects.
				 */
				getClientRects: getClientRects,
	
				/**
				 * Returns true if the caret location is visible/displayed on screen.
				 *
				 * @method isVisible
				 * @return {Boolean} true/false if the position is visible or not.
				 */
				isVisible: isVisible,
	
				/**
				 * Returns true if the caret location is at the beginning of text node or container.
				 *
				 * @method isVisible
				 * @return {Boolean} true/false if the position is at the beginning.
				 */
				isAtStart: isAtStart,
	
				/**
				 * Returns true if the caret location is at the end of text node or container.
				 *
				 * @method isVisible
				 * @return {Boolean} true/false if the position is at the end.
				 */
				isAtEnd: isAtEnd,
	
				/**
				 * Compares the caret position to another caret position. This will only compare the
				 * container and offset not it's visual position.
				 *
				 * @method isEqual
				 * @param {tinymce.caret.CaretPosition} caretPosition Caret position to compare with.
				 * @return {Boolean} true if the caret positions are equal.
				 */
				isEqual: isEqual,
	
				/**
				 * Returns the closest resolved node from a node index. That means if you have an offset after the
				 * last node in a container it will return that last node.
				 *
				 * @method getNode
				 * @return {Node} Node that is closest to the index.
				 */
				getNode: getNode
			};
		}
	
		/**
		 * Creates a caret position from the start of a range.
		 *
		 * @method fromRangeStart
		 * @param {DOMRange} range DOM Range to create caret position from.
		 * @return {tinymce.caret.CaretPosition} Caret position from the start of DOM range.
		 */
		CaretPosition.fromRangeStart = function(range) {
			return new CaretPosition(range.startContainer, range.startOffset);
		};
	
		/**
		 * Creates a caret position from the end of a range.
		 *
		 * @method fromRangeEnd
		 * @param {DOMRange} range DOM Range to create caret position from.
		 * @return {tinymce.caret.CaretPosition} Caret position from the end of DOM range.
		 */
		CaretPosition.fromRangeEnd = function(range) {
			return new CaretPosition(range.endContainer, range.endOffset);
		};
	
		/**
		 * Creates a caret position from a node and places the offset after it.
		 *
		 * @method after
		 * @param {Node} node Node to get caret position from.
		 * @return {tinymce.caret.CaretPosition} Caret position from the node.
		 */
		CaretPosition.after = function(node) {
			return new CaretPosition(node.parentNode, nodeIndex(node) + 1);
		};
	
		/**
		 * Creates a caret position from a node and places the offset before it.
		 *
		 * @method before
		 * @param {Node} node Node to get caret position from.
		 * @return {tinymce.caret.CaretPosition} Caret position from the node.
		 */
		CaretPosition.before = function(node) {
			return new CaretPosition(node.parentNode, nodeIndex(node));
		};
	
		return CaretPosition;
	});
	
	// Included from: js/tinymce/classes/caret/CaretBookmark.js
	
	/**
	 * CaretBookmark.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * This module creates or resolves xpath like string representation of a CaretPositions.
	 *
	 * The format is a / separated list of chunks with:
	 * <element|text()>[index|after|before]
	 *
	 * For example:
	 *  p[0]/b[0]/text()[0],1 = <p><b>a|c</b></p>
	 *  p[0]/img[0],before = <p>|<img></p>
	 *  p[0]/img[0],after = <p><img>|</p>
	 *
	 * @private
	 * @static
	 * @class tinymce.caret.CaretBookmark
	 * @example
	 * var bookmark = CaretBookmark.create(rootElm, CaretPosition.before(rootElm.firstChild));
	 * var caretPosition = CaretBookmark.resolve(bookmark);
	 */
	define('tinymce/caret/CaretBookmark', [
		'tinymce/dom/NodeType',
		'tinymce/dom/DOMUtils',
		'tinymce/util/Fun',
		'tinymce/util/Arr',
		'tinymce/caret/CaretPosition'
	], function(NodeType, DomUtils, Fun, Arr, CaretPosition) {
		var isText = NodeType.isText,
			isBogus = NodeType.isBogus,
			nodeIndex = DomUtils.nodeIndex;
	
		function normalizedParent(node) {
			var parentNode = node.parentNode;
	
			if (isBogus(parentNode)) {
				return normalizedParent(parentNode);
			}
	
			return parentNode;
		}
	
		function getChildNodes(node) {
			if (!node) {
				return [];
			}
	
			return Arr.reduce(node.childNodes, function(result, node) {
				if (isBogus(node) && node.nodeName != 'BR') {
					result = result.concat(getChildNodes(node));
				} else {
					result.push(node);
				}
	
				return result;
			}, []);
		}
	
		function normalizedTextOffset(textNode, offset) {
			while ((textNode = textNode.previousSibling)) {
				if (!isText(textNode)) {
					break;
				}
	
				offset += textNode.data.length;
			}
	
			return offset;
		}
	
		function equal(targetValue) {
			return function(value) {
				return targetValue === value;
			};
		}
	
		function normalizedNodeIndex(node) {
			var nodes, index, numTextFragments;
	
			nodes = getChildNodes(normalizedParent(node));
			index = Arr.findIndex(nodes, equal(node), node);
			nodes = nodes.slice(0, index + 1);
			numTextFragments = Arr.reduce(nodes, function(result, node, i) {
				if (isText(node) && isText(nodes[i - 1])) {
					result++;
				}
	
				return result;
			}, 0);
	
			nodes = Arr.filter(nodes, NodeType.matchNodeNames(node.nodeName));
			index = Arr.findIndex(nodes, equal(node), node);
	
			return index - numTextFragments;
		}
	
		function createPathItem(node) {
			var name;
	
			if (isText(node)) {
				name = 'text()';
			} else {
				name = node.nodeName.toLowerCase();
			}
	
			return name + '[' + normalizedNodeIndex(node) + ']';
		}
	
		function parentsUntil(rootNode, node, predicate) {
			var parents = [];
	
			for (node = node.parentNode; node != rootNode; node = node.parentNode) {
				if (predicate && predicate(node)) {
					break;
				}
	
				parents.push(node);
			}
	
			return parents;
		}
	
		function create(rootNode, caretPosition) {
			var container, offset, path = [],
				outputOffset, childNodes, parents;
	
			container = caretPosition.container();
			offset = caretPosition.offset();
	
			if (isText(container)) {
				outputOffset = normalizedTextOffset(container, offset);
			} else {
				childNodes = container.childNodes;
				if (offset >= childNodes.length) {
					outputOffset = 'after';
					offset = childNodes.length - 1;
				} else {
					outputOffset = 'before';
				}
	
				container = childNodes[offset];
			}
	
			path.push(createPathItem(container));
			parents = parentsUntil(rootNode, container);
			parents = Arr.filter(parents, Fun.negate(NodeType.isBogus));
			path = path.concat(Arr.map(parents, function(node) {
				return createPathItem(node);
			}));
	
			return path.reverse().join('/') + ',' + outputOffset;
		}
	
		function resolvePathItem(node, name, index) {
			var nodes = getChildNodes(node);
	
			nodes = Arr.filter(nodes, function(node, index) {
				return !isText(node) || !isText(nodes[index - 1]);
			});
	
			nodes = Arr.filter(nodes, NodeType.matchNodeNames(name));
			return nodes[index];
		}
	
		function findTextPosition(container, offset) {
			var node = container, targetOffset = 0, dataLen;
	
			while (isText(node)) {
				dataLen = node.data.length;
	
				if (offset >= targetOffset && offset <= targetOffset + dataLen) {
					container = node;
					offset = offset - targetOffset;
					break;
				}
	
				if (!isText(node.nextSibling)) {
					container = node;
					offset = dataLen;
					break;
				}
	
				targetOffset += dataLen;
				node = node.nextSibling;
			}
	
			if (offset > container.data.length) {
				offset = container.data.length;
			}
	
			return new CaretPosition(container, offset);
		}
	
		function resolve(rootNode, path) {
			var parts, container, offset;
	
			if (!path) {
				return null;
			}
	
			parts = path.split(',');
			path = parts[0].split('/');
			offset = parts.length > 1 ? parts[1] : 'before';
	
			container = Arr.reduce(path, function(result, value) {
				value = /([\w\-\(\)]+)\[([0-9]+)\]/.exec(value);
				if (!value) {
					return null;
				}
	
				if (value[1] === 'text()') {
					value[1] = '#text';
				}
	
				return resolvePathItem(result, value[1], parseInt(value[2], 10));
			}, rootNode);
	
			if (!container) {
				return null;
			}
	
			if (!isText(container)) {
				if (offset === 'after') {
					offset = nodeIndex(container) + 1;
				} else {
					offset = nodeIndex(container);
				}
	
				return new CaretPosition(container.parentNode, offset);
			}
	
			return findTextPosition(container, parseInt(offset, 10));
		}
	
		return {
			/**
			 * Create a xpath bookmark location for the specified caret position.
			 *
			 * @method create
			 * @param {Node} rootNode Root node to create bookmark within.
			 * @param {tinymce.caret.CaretPosition} caretPosition Caret position within the root node.
			 * @return {String} String xpath like location of caret position.
			 */
			create: create,
	
			/**
			 * Resolves a xpath like bookmark location to the a caret position.
			 *
			 * @method resolve
			 * @param {Node} rootNode Root node to resolve xpath bookmark within.
			 * @param {String} bookmark Bookmark string to resolve.
			 * @return {tinymce.caret.CaretPosition} Caret position resolved from xpath like bookmark.
			 */
			resolve: resolve
		};
	});
	
	// Included from: js/tinymce/classes/dom/BookmarkManager.js
	
	/**
	 * BookmarkManager.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * This class handles selection bookmarks.
	 *
	 * @class tinymce.dom.BookmarkManager
	 */
	define("tinymce/dom/BookmarkManager", [
		"tinymce/Env",
		"tinymce/util/Tools",
		"tinymce/caret/CaretContainer",
		"tinymce/caret/CaretBookmark",
		"tinymce/caret/CaretPosition",
		"tinymce/dom/NodeType"
	], function(Env, Tools, CaretContainer, CaretBookmark, CaretPosition, NodeType) {
		var isContentEditableFalse = NodeType.isContentEditableFalse;
	
		/**
		 * Constructs a new BookmarkManager instance for a specific selection instance.
		 *
		 * @constructor
		 * @method BookmarkManager
		 * @param {tinymce.dom.Selection} selection Selection instance to handle bookmarks for.
		 */
		function BookmarkManager(selection) {
			var dom = selection.dom;
	
			/**
			 * Returns a bookmark location for the current selection. This bookmark object
			 * can then be used to restore the selection after some content modification to the document.
			 *
			 * @method getBookmark
			 * @param {Number} type Optional state if the bookmark should be simple or not. Default is complex.
			 * @param {Boolean} normalized Optional state that enables you to get a position that it would be after normalization.
			 * @return {Object} Bookmark object, use moveToBookmark with this object to restore the selection.
			 * @example
			 * // Stores a bookmark of the current selection
			 * var bm = tinymce.activeEditor.selection.getBookmark();
			 *
			 * tinymce.activeEditor.setContent(tinymce.activeEditor.getContent() + 'Some new content');
			 *
			 * // Restore the selection bookmark
			 * tinymce.activeEditor.selection.moveToBookmark(bm);
			 */
			this.getBookmark = function(type, normalized) {
				var rng, rng2, id, collapsed, name, element, chr = '&#xFEFF;', styles;
	
				function findIndex(name, element) {
					var count = 0;
	
					Tools.each(dom.select(name), function(node) {
						if (node.getAttribute('data-mce-bogus') === 'all') {
							return;
						}
	
						if (node == element) {
							return false;
						}
	
						count++;
					});
	
					return count;
				}
	
				function normalizeTableCellSelection(rng) {
					function moveEndPoint(start) {
						var container, offset, childNodes, prefix = start ? 'start' : 'end';
	
						container = rng[prefix + 'Container'];
						offset = rng[prefix + 'Offset'];
	
						if (container.nodeType == 1 && container.nodeName == "TR") {
							childNodes = container.childNodes;
							container = childNodes[Math.min(start ? offset : offset - 1, childNodes.length - 1)];
							if (container) {
								offset = start ? 0 : container.childNodes.length;
								rng['set' + (start ? 'Start' : 'End')](container, offset);
							}
						}
					}
	
					moveEndPoint(true);
					moveEndPoint();
	
					return rng;
				}
	
				function getLocation(rng) {
					var root = dom.getRoot(), bookmark = {};
	
					function getPoint(rng, start) {
						var container = rng[start ? 'startContainer' : 'endContainer'],
							offset = rng[start ? 'startOffset' : 'endOffset'], point = [], node, childNodes, after = 0;
	
						if (container.nodeType == 3) {
							if (normalized) {
								for (node = container.previousSibling; node && node.nodeType == 3; node = node.previousSibling) {
									offset += node.nodeValue.length;
								}
							}
	
							point.push(offset);
						} else {
							childNodes = container.childNodes;
	
							if (offset >= childNodes.length && childNodes.length) {
								after = 1;
								offset = Math.max(0, childNodes.length - 1);
							}
	
							point.push(dom.nodeIndex(childNodes[offset], normalized) + after);
						}
	
						for (; container && container != root; container = container.parentNode) {
							point.push(dom.nodeIndex(container, normalized));
						}
	
						return point;
					}
	
					bookmark.start = getPoint(rng, true);
	
					if (!selection.isCollapsed()) {
						bookmark.end = getPoint(rng);
					}
	
					return bookmark;
				}
	
				function findAdjacentContentEditableFalseElm(rng) {
					function findSibling(node) {
						var sibling;
	
						if (CaretContainer.isCaretContainer(node)) {
							if (NodeType.isText(node) && CaretContainer.isCaretContainerBlock(node)) {
								node = node.parentNode;
							}
	
							sibling = node.previousSibling;
							if (isContentEditableFalse(sibling)) {
								return sibling;
							}
	
							sibling = node.nextSibling;
							if (isContentEditableFalse(sibling)) {
								return sibling;
							}
						}
					}
	
					return findSibling(rng.startContainer) || findSibling(rng.endContainer);
				}
	
				if (type == 2) {
					element = selection.getNode();
					name = element ? element.nodeName : null;
					rng = selection.getRng();
	
					if (isContentEditableFalse(element) || name == 'IMG') {
						return {name: name, index: findIndex(name, element)};
					}
	
					if (selection.tridentSel) {
						return selection.tridentSel.getBookmark(type);
					}
	
					element = findAdjacentContentEditableFalseElm(rng);
					if (element) {
						name = element.tagName;
						return {name: name, index: findIndex(name, element)};
					}
	
					return getLocation(rng);
				}
	
				if (type == 3) {
					rng = selection.getRng();
	
					return {
						start: CaretBookmark.create(dom.getRoot(), CaretPosition.fromRangeStart(rng)),
						end: CaretBookmark.create(dom.getRoot(), CaretPosition.fromRangeEnd(rng))
					};
				}
	
				// Handle simple range
				if (type) {
					return {rng: selection.getRng()};
				}
	
				rng = selection.getRng();
				id = dom.uniqueId();
				collapsed = selection.isCollapsed();
				styles = 'overflow:hidden;line-height:0px';
	
				// Explorer method
				if (rng.duplicate || rng.item) {
					// Text selection
					if (!rng.item) {
						rng2 = rng.duplicate();
	
						try {
							// Insert start marker
							rng.collapse();
							rng.pasteHTML('<span data-mce-type="bookmark" id="' + id + '_start" style="' + styles + '">' + chr + '</span>');
	
							// Insert end marker
							if (!collapsed) {
								rng2.collapse(false);
	
								// Detect the empty space after block elements in IE and move the
								// end back one character <p></p>] becomes <p>]</p>
								rng.moveToElementText(rng2.parentElement());
								if (rng.compareEndPoints('StartToEnd', rng2) === 0) {
									rng2.move('character', -1);
								}
	
								rng2.pasteHTML('<span data-mce-type="bookmark" id="' + id + '_end" style="' + styles + '">' + chr + '</span>');
							}
						} catch (ex) {
							// IE might throw unspecified error so lets ignore it
							return null;
						}
					} else {
						// Control selection
						element = rng.item(0);
						name = element.nodeName;
	
						return {name: name, index: findIndex(name, element)};
					}
				} else {
					element = selection.getNode();
					name = element.nodeName;
					if (name == 'IMG') {
						return {name: name, index: findIndex(name, element)};
					}
	
					// W3C method
					rng2 = normalizeTableCellSelection(rng.cloneRange());
	
					// Insert end marker
					if (!collapsed) {
						rng2.collapse(false);
						rng2.insertNode(dom.create('span', {'data-mce-type': "bookmark", id: id + '_end', style: styles}, chr));
					}
	
					rng = normalizeTableCellSelection(rng);
					rng.collapse(true);
					rng.insertNode(dom.create('span', {'data-mce-type': "bookmark", id: id + '_start', style: styles}, chr));
				}
	
				selection.moveToBookmark({id: id, keep: 1});
	
				return {id: id};
			};
	
			/**
			 * Restores the selection to the specified bookmark.
			 *
			 * @method moveToBookmark
			 * @param {Object} bookmark Bookmark to restore selection from.
			 * @return {Boolean} true/false if it was successful or not.
			 * @example
			 * // Stores a bookmark of the current selection
			 * var bm = tinymce.activeEditor.selection.getBookmark();
			 *
			 * tinymce.activeEditor.setContent(tinymce.activeEditor.getContent() + 'Some new content');
			 *
			 * // Restore the selection bookmark
			 * tinymce.activeEditor.selection.moveToBookmark(bm);
			 */
			this.moveToBookmark = function(bookmark) {
				var rng, root, startContainer, endContainer, startOffset, endOffset;
	
				function setEndPoint(start) {
					var point = bookmark[start ? 'start' : 'end'], i, node, offset, children;
	
					if (point) {
						offset = point[0];
	
						// Find container node
						for (node = root, i = point.length - 1; i >= 1; i--) {
							children = node.childNodes;
	
							if (point[i] > children.length - 1) {
								return;
							}
	
							node = children[point[i]];
						}
	
						// Move text offset to best suitable location
						if (node.nodeType === 3) {
							offset = Math.min(point[0], node.nodeValue.length);
						}
	
						// Move element offset to best suitable location
						if (node.nodeType === 1) {
							offset = Math.min(point[0], node.childNodes.length);
						}
	
						// Set offset within container node
						if (start) {
							rng.setStart(node, offset);
						} else {
							rng.setEnd(node, offset);
						}
					}
	
					return true;
				}
	
				function restoreEndPoint(suffix) {
					var marker = dom.get(bookmark.id + '_' + suffix), node, idx, next, prev, keep = bookmark.keep;
	
					if (marker) {
						node = marker.parentNode;
	
						if (suffix == 'start') {
							if (!keep) {
								idx = dom.nodeIndex(marker);
							} else {
								node = marker.firstChild;
								idx = 1;
							}
	
							startContainer = endContainer = node;
							startOffset = endOffset = idx;
						} else {
							if (!keep) {
								idx = dom.nodeIndex(marker);
							} else {
								node = marker.firstChild;
								idx = 1;
							}
	
							endContainer = node;
							endOffset = idx;
						}
	
						if (!keep) {
							prev = marker.previousSibling;
							next = marker.nextSibling;
	
							// Remove all marker text nodes
							Tools.each(Tools.grep(marker.childNodes), function(node) {
								if (node.nodeType == 3) {
									node.nodeValue = node.nodeValue.replace(/\uFEFF/g, '');
								}
							});
	
							// Remove marker but keep children if for example contents where inserted into the marker
							// Also remove duplicated instances of the marker for example by a
							// split operation or by WebKit auto split on paste feature
							while ((marker = dom.get(bookmark.id + '_' + suffix))) {
								dom.remove(marker, 1);
							}
	
							// If siblings are text nodes then merge them unless it's Opera since it some how removes the node
							// and we are sniffing since adding a lot of detection code for a browser with 3% of the market
							// isn't worth the effort. Sorry, Opera but it's just a fact
							if (prev && next && prev.nodeType == next.nodeType && prev.nodeType == 3 && !Env.opera) {
								idx = prev.nodeValue.length;
								prev.appendData(next.nodeValue);
								dom.remove(next);
	
								if (suffix == 'start') {
									startContainer = endContainer = prev;
									startOffset = endOffset = idx;
								} else {
									endContainer = prev;
									endOffset = idx;
								}
							}
						}
					}
				}
	
				function addBogus(node) {
					// Adds a bogus BR element for empty block elements
					if (dom.isBlock(node) && !node.innerHTML && !Env.ie) {
						node.innerHTML = '<br data-mce-bogus="1" />';
					}
	
					return node;
				}
	
				function resolveCaretPositionBookmark() {
					var rng, pos;
	
					rng = dom.createRng();
					pos = CaretBookmark.resolve(dom.getRoot(), bookmark.start);
					rng.setStart(pos.container(), pos.offset());
	
					pos = CaretBookmark.resolve(dom.getRoot(), bookmark.end);
					rng.setEnd(pos.container(), pos.offset());
	
					return rng;
				}
	
				if (bookmark) {
					if (Tools.isArray(bookmark.start)) {
						rng = dom.createRng();
						root = dom.getRoot();
	
						if (selection.tridentSel) {
							return selection.tridentSel.moveToBookmark(bookmark);
						}
	
						if (setEndPoint(true) && setEndPoint()) {
							selection.setRng(rng);
						}
					} else if (typeof bookmark.start == 'string') {
						selection.setRng(resolveCaretPositionBookmark(bookmark));
					} else if (bookmark.id) {
						// Restore start/end points
						restoreEndPoint('start');
						restoreEndPoint('end');
	
						if (startContainer) {
							rng = dom.createRng();
							rng.setStart(addBogus(startContainer), startOffset);
							rng.setEnd(addBogus(endContainer), endOffset);
							selection.setRng(rng);
						}
					} else if (bookmark.name) {
						selection.select(dom.select(bookmark.name)[bookmark.index]);
					} else if (bookmark.rng) {
						selection.setRng(bookmark.rng);
					}
				}
			};
		}
	
		/**
		 * Returns true/false if the specified node is a bookmark node or not.
		 *
		 * @static
		 * @method isBookmarkNode
		 * @param {DOMNode} node DOM Node to check if it's a bookmark node or not.
		 * @return {Boolean} true/false if the node is a bookmark node or not.
		 */
		BookmarkManager.isBookmarkNode = function(node) {
			return node && node.tagName === 'SPAN' && node.getAttribute('data-mce-type') === 'bookmark';
		};
	
		return BookmarkManager;
	});
	
	// Included from: js/tinymce/classes/dom/Selection.js
	
	/**
	 * Selection.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * This class handles text and control selection it's an crossbrowser utility class.
	 * Consult the TinyMCE Wiki API for more details and examples on how to use this class.
	 *
	 * @class tinymce.dom.Selection
	 * @example
	 * // Getting the currently selected node for the active editor
	 * alert(tinymce.activeEditor.selection.getNode().nodeName);
	 */
	define("tinymce/dom/Selection", [
		"tinymce/dom/TreeWalker",
		"tinymce/dom/TridentSelection",
		"tinymce/dom/ControlSelection",
		"tinymce/dom/RangeUtils",
		"tinymce/dom/BookmarkManager",
		"tinymce/dom/NodeType",
		"tinymce/Env",
		"tinymce/util/Tools"
	], function(TreeWalker, TridentSelection, ControlSelection, RangeUtils, BookmarkManager, NodeType, Env, Tools) {
		var each = Tools.each, trim = Tools.trim;
		var isIE = Env.ie;
	
		/**
		 * Constructs a new selection instance.
		 *
		 * @constructor
		 * @method Selection
		 * @param {tinymce.dom.DOMUtils} dom DOMUtils object reference.
		 * @param {Window} win Window to bind the selection object to.
		 * @param {tinymce.Editor} editor Editor instance of the selection.
		 * @param {tinymce.dom.Serializer} serializer DOM serialization class to use for getContent.
		 */
		function Selection(dom, win, serializer, editor) {
			var self = this;
	
			self.dom = dom;
			self.win = win;
			self.serializer = serializer;
			self.editor = editor;
			self.bookmarkManager = new BookmarkManager(self);
			self.controlSelection = new ControlSelection(self, editor);
	
			// No W3C Range support
			if (!self.win.getSelection) {
				self.tridentSel = new TridentSelection(self);
			}
		}
	
		Selection.prototype = {
			/**
			 * Move the selection cursor range to the specified node and offset.
			 * If there is no node specified it will move it to the first suitable location within the body.
			 *
			 * @method setCursorLocation
			 * @param {Node} node Optional node to put the cursor in.
			 * @param {Number} offset Optional offset from the start of the node to put the cursor at.
			 */
			setCursorLocation: function(node, offset) {
				var self = this, rng = self.dom.createRng();
	
				if (!node) {
					self._moveEndPoint(rng, self.editor.getBody(), true);
					self.setRng(rng);
				} else {
					rng.setStart(node, offset);
					rng.setEnd(node, offset);
					self.setRng(rng);
					self.collapse(false);
				}
			},
	
			/**
			 * Returns the selected contents using the DOM serializer passed in to this class.
			 *
			 * @method getContent
			 * @param {Object} args Optional settings class with for example output format text or html.
			 * @return {String} Selected contents in for example HTML format.
			 * @example
			 * // Alerts the currently selected contents
			 * alert(tinymce.activeEditor.selection.getContent());
			 *
			 * // Alerts the currently selected contents as plain text
			 * alert(tinymce.activeEditor.selection.getContent({format: 'text'}));
			 */
			getContent: function(args) {
				var self = this, rng = self.getRng(), tmpElm = self.dom.create("body");
				var se = self.getSel(), whiteSpaceBefore, whiteSpaceAfter, fragment;
	
				args = args || {};
				whiteSpaceBefore = whiteSpaceAfter = '';
				args.get = true;
				args.format = args.format || 'html';
				args.selection = true;
				self.editor.fire('BeforeGetContent', args);
	
				if (args.format == 'text') {
					return self.isCollapsed() ? '' : (rng.text || (se.toString ? se.toString() : ''));
				}
	
				if (rng.cloneContents) {
					fragment = rng.cloneContents();
	
					if (fragment) {
						tmpElm.appendChild(fragment);
					}
				} else if (rng.item !== undefined || rng.htmlText !== undefined) {
					// IE will produce invalid markup if elements are present that
					// it doesn't understand like custom elements or HTML5 elements.
					// Adding a BR in front of the contents and then remoiving it seems to fix it though.
					tmpElm.innerHTML = '<br>' + (rng.item ? rng.item(0).outerHTML : rng.htmlText);
					tmpElm.removeChild(tmpElm.firstChild);
				} else {
					tmpElm.innerHTML = rng.toString();
				}
	
				// Keep whitespace before and after
				if (/^\s/.test(tmpElm.innerHTML)) {
					whiteSpaceBefore = ' ';
				}
	
				if (/\s+$/.test(tmpElm.innerHTML)) {
					whiteSpaceAfter = ' ';
				}
	
				args.getInner = true;
	
				args.content = self.isCollapsed() ? '' : whiteSpaceBefore + self.serializer.serialize(tmpElm, args) + whiteSpaceAfter;
				self.editor.fire('GetContent', args);
	
				return args.content;
			},
	
			/**
			 * Sets the current selection to the specified content. If any contents is selected it will be replaced
			 * with the contents passed in to this function. If there is no selection the contents will be inserted
			 * where the caret is placed in the editor/page.
			 *
			 * @method setContent
			 * @param {String} content HTML contents to set could also be other formats depending on settings.
			 * @param {Object} args Optional settings object with for example data format.
			 * @example
			 * // Inserts some HTML contents at the current selection
			 * tinymce.activeEditor.selection.setContent('<strong>Some contents</strong>');
			 */
			setContent: function(content, args) {
				var self = this, rng = self.getRng(), caretNode, doc = self.win.document, frag, temp;
	
				args = args || {format: 'html'};
				args.set = true;
				args.selection = true;
				args.content = content;
	
				// Dispatch before set content event
				if (!args.no_events) {
					self.editor.fire('BeforeSetContent', args);
				}
	
				content = args.content;
	
				if (rng.insertNode) {
					// Make caret marker since insertNode places the caret in the beginning of text after insert
					content += '<span id="__caret">_</span>';
	
					// Delete and insert new node
					if (rng.startContainer == doc && rng.endContainer == doc) {
						// WebKit will fail if the body is empty since the range is then invalid and it can't insert contents
						doc.body.innerHTML = content;
					} else {
						rng.deleteContents();
	
						if (doc.body.childNodes.length === 0) {
							doc.body.innerHTML = content;
						} else {
							// createContextualFragment doesn't exists in IE 9 DOMRanges
							if (rng.createContextualFragment) {
								rng.insertNode(rng.createContextualFragment(content));
							} else {
								// Fake createContextualFragment call in IE 9
								frag = doc.createDocumentFragment();
								temp = doc.createElement('div');
	
								frag.appendChild(temp);
								temp.outerHTML = content;
	
								rng.insertNode(frag);
							}
						}
					}
	
					// Move to caret marker
					caretNode = self.dom.get('__caret');
	
					// Make sure we wrap it compleatly, Opera fails with a simple select call
					rng = doc.createRange();
					rng.setStartBefore(caretNode);
					rng.setEndBefore(caretNode);
					self.setRng(rng);
	
					// Remove the caret position
					self.dom.remove('__caret');
	
					try {
						self.setRng(rng);
					} catch (ex) {
						// Might fail on Opera for some odd reason
					}
				} else {
					if (rng.item) {
						// Delete content and get caret text selection
						doc.execCommand('Delete', false, null);
						rng = self.getRng();
					}
	
					// Explorer removes spaces from the beginning of pasted contents
					if (/^\s+/.test(content)) {
						rng.pasteHTML('<span id="__mce_tmp">_</span>' + content);
						self.dom.remove('__mce_tmp');
					} else {
						rng.pasteHTML(content);
					}
				}
	
				// Dispatch set content event
				if (!args.no_events) {
					self.editor.fire('SetContent', args);
				}
			},
	
			/**
			 * Returns the start element of a selection range. If the start is in a text
			 * node the parent element will be returned.
			 *
			 * @method getStart
			 * @param {Boolean} real Optional state to get the real parent when the selection is collapsed not the closest element.
			 * @return {Element} Start element of selection range.
			 */
			getStart: function(real) {
				var self = this, rng = self.getRng(), startElement, parentElement, checkRng, node;
	
				if (rng.duplicate || rng.item) {
					// Control selection, return first item
					if (rng.item) {
						return rng.item(0);
					}
	
					// Get start element
					checkRng = rng.duplicate();
					checkRng.collapse(1);
					startElement = checkRng.parentElement();
					if (startElement.ownerDocument !== self.dom.doc) {
						startElement = self.dom.getRoot();
					}
	
					// Check if range parent is inside the start element, then return the inner parent element
					// This will fix issues when a single element is selected, IE would otherwise return the wrong start element
					parentElement = node = rng.parentElement();
					while ((node = node.parentNode)) {
						if (node == startElement) {
							startElement = parentElement;
							break;
						}
					}
	
					return startElement;
				}
	
				startElement = rng.startContainer;
	
				if (startElement.nodeType == 1 && startElement.hasChildNodes()) {
					if (!real || !rng.collapsed) {
						startElement = startElement.childNodes[Math.min(startElement.childNodes.length - 1, rng.startOffset)];
					}
				}
	
				if (startElement && startElement.nodeType == 3) {
					return startElement.parentNode;
				}
	
				return startElement;
			},
	
			/**
			 * Returns the end element of a selection range. If the end is in a text
			 * node the parent element will be returned.
			 *
			 * @method getEnd
			 * @param {Boolean} real Optional state to get the real parent when the selection is collapsed not the closest element.
			 * @return {Element} End element of selection range.
			 */
			getEnd: function(real) {
				var self = this, rng = self.getRng(), endElement, endOffset;
	
				if (rng.duplicate || rng.item) {
					if (rng.item) {
						return rng.item(0);
					}
	
					rng = rng.duplicate();
					rng.collapse(0);
					endElement = rng.parentElement();
					if (endElement.ownerDocument !== self.dom.doc) {
						endElement = self.dom.getRoot();
					}
	
					if (endElement && endElement.nodeName == 'BODY') {
						return endElement.lastChild || endElement;
					}
	
					return endElement;
				}
	
				endElement = rng.endContainer;
				endOffset = rng.endOffset;
	
				if (endElement.nodeType == 1 && endElement.hasChildNodes()) {
					if (!real || !rng.collapsed) {
						endElement = endElement.childNodes[endOffset > 0 ? endOffset - 1 : endOffset];
					}
				}
	
				if (endElement && endElement.nodeType == 3) {
					return endElement.parentNode;
				}
	
				return endElement;
			},
	
			/**
			 * Returns a bookmark location for the current selection. This bookmark object
			 * can then be used to restore the selection after some content modification to the document.
			 *
			 * @method getBookmark
			 * @param {Number} type Optional state if the bookmark should be simple or not. Default is complex.
			 * @param {Boolean} normalized Optional state that enables you to get a position that it would be after normalization.
			 * @return {Object} Bookmark object, use moveToBookmark with this object to restore the selection.
			 * @example
			 * // Stores a bookmark of the current selection
			 * var bm = tinymce.activeEditor.selection.getBookmark();
			 *
			 * tinymce.activeEditor.setContent(tinymce.activeEditor.getContent() + 'Some new content');
			 *
			 * // Restore the selection bookmark
			 * tinymce.activeEditor.selection.moveToBookmark(bm);
			 */
			getBookmark: function(type, normalized) {
				return this.bookmarkManager.getBookmark(type, normalized);
			},
	
			/**
			 * Restores the selection to the specified bookmark.
			 *
			 * @method moveToBookmark
			 * @param {Object} bookmark Bookmark to restore selection from.
			 * @return {Boolean} true/false if it was successful or not.
			 * @example
			 * // Stores a bookmark of the current selection
			 * var bm = tinymce.activeEditor.selection.getBookmark();
			 *
			 * tinymce.activeEditor.setContent(tinymce.activeEditor.getContent() + 'Some new content');
			 *
			 * // Restore the selection bookmark
			 * tinymce.activeEditor.selection.moveToBookmark(bm);
			 */
			moveToBookmark: function(bookmark) {
				return this.bookmarkManager.moveToBookmark(bookmark);
			},
	
			/**
			 * Selects the specified element. This will place the start and end of the selection range around the element.
			 *
			 * @method select
			 * @param {Element} node HTML DOM element to select.
			 * @param {Boolean} content Optional bool state if the contents should be selected or not on non IE browser.
			 * @return {Element} Selected element the same element as the one that got passed in.
			 * @example
			 * // Select the first paragraph in the active editor
			 * tinymce.activeEditor.selection.select(tinymce.activeEditor.dom.select('p')[0]);
			 */
			select: function(node, content) {
				var self = this, dom = self.dom, rng = dom.createRng(), idx;
	
				// Clear stored range set by FocusManager
				self.lastFocusBookmark = null;
	
				if (node) {
					if (!content && self.controlSelection.controlSelect(node)) {
						return;
					}
	
					idx = dom.nodeIndex(node);
					rng.setStart(node.parentNode, idx);
					rng.setEnd(node.parentNode, idx + 1);
	
					// Find first/last text node or BR element
					if (content) {
						self._moveEndPoint(rng, node, true);
						self._moveEndPoint(rng, node);
					}
	
					self.setRng(rng);
				}
	
				return node;
			},
	
			/**
			 * Returns true/false if the selection range is collapsed or not. Collapsed means if it's a caret or a larger selection.
			 *
			 * @method isCollapsed
			 * @return {Boolean} true/false state if the selection range is collapsed or not.
			 * Collapsed means if it's a caret or a larger selection.
			 */
			isCollapsed: function() {
				var self = this, rng = self.getRng(), sel = self.getSel();
	
				if (!rng || rng.item) {
					return false;
				}
	
				if (rng.compareEndPoints) {
					return rng.compareEndPoints('StartToEnd', rng) === 0;
				}
	
				return !sel || rng.collapsed;
			},
	
			/**
			 * Collapse the selection to start or end of range.
			 *
			 * @method collapse
			 * @param {Boolean} toStart Optional boolean state if to collapse to end or not. Defaults to false.
			 */
			collapse: function(toStart) {
				var self = this, rng = self.getRng(), node;
	
				// Control range on IE
				if (rng.item) {
					node = rng.item(0);
					rng = self.win.document.body.createTextRange();
					rng.moveToElementText(node);
				}
	
				rng.collapse(!!toStart);
				self.setRng(rng);
			},
	
			/**
			 * Returns the browsers internal selection object.
			 *
			 * @method getSel
			 * @return {Selection} Internal browser selection object.
			 */
			getSel: function() {
				var win = this.win;
	
				return win.getSelection ? win.getSelection() : win.document.selection;
			},
	
			/**
			 * Returns the browsers internal range object.
			 *
			 * @method getRng
			 * @param {Boolean} w3c Forces a compatible W3C range on IE.
			 * @return {Range} Internal browser range object.
			 * @see http://www.quirksmode.org/dom/range_intro.html
			 * @see http://www.dotvoid.com/2001/03/using-the-range-object-in-mozilla/
			 */
			getRng: function(w3c) {
				var self = this, selection, rng, elm, doc, ieRng, evt;
	
				function tryCompareBoundaryPoints(how, sourceRange, destinationRange) {
					try {
						return sourceRange.compareBoundaryPoints(how, destinationRange);
					} catch (ex) {
						// Gecko throws wrong document exception if the range points
						// to nodes that where removed from the dom #6690
						// Browsers should mutate existing DOMRange instances so that they always point
						// to something in the document this is not the case in Gecko works fine in IE/WebKit/Blink
						// For performance reasons just return -1
						return -1;
					}
				}
	
				if (!self.win) {
					return null;
				}
	
				doc = self.win.document;
	
				// Use last rng passed from FocusManager if it's available this enables
				// calls to editor.selection.getStart() to work when caret focus is lost on IE
				if (!w3c && self.lastFocusBookmark) {
					var bookmark = self.lastFocusBookmark;
	
					// Convert bookmark to range IE 11 fix
					if (bookmark.startContainer) {
						rng = doc.createRange();
						rng.setStart(bookmark.startContainer, bookmark.startOffset);
						rng.setEnd(bookmark.endContainer, bookmark.endOffset);
					} else {
						rng = bookmark;
					}
	
					return rng;
				}
	
				// Found tridentSel object then we need to use that one
				if (w3c && self.tridentSel) {
					return self.tridentSel.getRangeAt(0);
				}
	
				try {
					if ((selection = self.getSel())) {
						if (selection.rangeCount > 0) {
							rng = selection.getRangeAt(0);
						} else {
							rng = selection.createRange ? selection.createRange() : doc.createRange();
						}
					}
				} catch (ex) {
					// IE throws unspecified error here if TinyMCE is placed in a frame/iframe
				}
	
				evt = self.editor.fire('GetSelectionRange', {range: rng});
				if (evt.range !== rng) {
					return evt.range;
				}
	
				// We have W3C ranges and it's IE then fake control selection since IE9 doesn't handle that correctly yet
				// IE 11 doesn't support the selection object so we check for that as well
				if (isIE && rng && rng.setStart && doc.selection) {
					try {
						// IE will sometimes throw an exception here
						ieRng = doc.selection.createRange();
					} catch (ex) {
						// Ignore
					}
	
					if (ieRng && ieRng.item) {
						elm = ieRng.item(0);
						rng = doc.createRange();
						rng.setStartBefore(elm);
						rng.setEndAfter(elm);
					}
				}
	
				// No range found then create an empty one
				// This can occur when the editor is placed in a hidden container element on Gecko
				// Or on IE when there was an exception
				if (!rng) {
					rng = doc.createRange ? doc.createRange() : doc.body.createTextRange();
				}
	
				// If range is at start of document then move it to start of body
				if (rng.setStart && rng.startContainer.nodeType === 9 && rng.collapsed) {
					elm = self.dom.getRoot();
					rng.setStart(elm, 0);
					rng.setEnd(elm, 0);
				}
	
				if (self.selectedRange && self.explicitRange) {
					if (tryCompareBoundaryPoints(rng.START_TO_START, rng, self.selectedRange) === 0 &&
						tryCompareBoundaryPoints(rng.END_TO_END, rng, self.selectedRange) === 0) {
						// Safari, Opera and Chrome only ever select text which causes the range to change.
						// This lets us use the originally set range if the selection hasn't been changed by the user.
						rng = self.explicitRange;
					} else {
						self.selectedRange = null;
						self.explicitRange = null;
					}
				}
	
				return rng;
			},
	
			/**
			 * Changes the selection to the specified DOM range.
			 *
			 * @method setRng
			 * @param {Range} rng Range to select.
			 * @param {Boolean} forward Optional boolean if the selection is forwards or backwards.
			 */
			setRng: function(rng, forward) {
				var self = this, sel, node, evt;
	
				if (!rng) {
					return;
				}
	
				// Is IE specific range
				if (rng.select) {
					self.explicitRange = null;
	
					try {
						rng.select();
					} catch (ex) {
						// Needed for some odd IE bug #1843306
					}
	
					return;
				}
	
				if (!self.tridentSel) {
					sel = self.getSel();
	
					evt = self.editor.fire('SetSelectionRange', {range: rng});
					rng = evt.range;
	
					if (sel) {
						self.explicitRange = rng;
	
						try {
							sel.removeAllRanges();
							sel.addRange(rng);
						} catch (ex) {
							// IE might throw errors here if the editor is within a hidden container and selection is changed
						}
	
						// Forward is set to false and we have an extend function
						if (forward === false && sel.extend) {
							sel.collapse(rng.endContainer, rng.endOffset);
							sel.extend(rng.startContainer, rng.startOffset);
						}
	
						// adding range isn't always successful so we need to check range count otherwise an exception can occur
						self.selectedRange = sel.rangeCount > 0 ? sel.getRangeAt(0) : null;
					}
	
					// WebKit egde case selecting images works better using setBaseAndExtent
					if (!rng.collapsed && rng.startContainer == rng.endContainer && sel.setBaseAndExtent && !Env.ie) {
						if (rng.endOffset - rng.startOffset < 2) {
							if (rng.startContainer.hasChildNodes()) {
								node = rng.startContainer.childNodes[rng.startOffset];
								if (node && node.tagName == 'IMG') {
									self.getSel().setBaseAndExtent(node, 0, node, 1);
								}
							}
						}
					}
				} else {
					// Is W3C Range fake range on IE
					if (rng.cloneRange) {
						try {
							self.tridentSel.addRange(rng);
						} catch (ex) {
							//IE9 throws an error here if called before selection is placed in the editor
						}
					}
				}
			},
	
			/**
			 * Sets the current selection to the specified DOM element.
			 *
			 * @method setNode
			 * @param {Element} elm Element to set as the contents of the selection.
			 * @return {Element} Returns the element that got passed in.
			 * @example
			 * // Inserts a DOM node at current selection/caret location
			 * tinymce.activeEditor.selection.setNode(tinymce.activeEditor.dom.create('img', {src: 'some.gif', title: 'some title'}));
			 */
			setNode: function(elm) {
				var self = this;
	
				self.setContent(self.dom.getOuterHTML(elm));
	
				return elm;
			},
	
			/**
			 * Returns the currently selected element or the common ancestor element for both start and end of the selection.
			 *
			 * @method getNode
			 * @return {Element} Currently selected element or common ancestor element.
			 * @example
			 * // Alerts the currently selected elements node name
			 * alert(tinymce.activeEditor.selection.getNode().nodeName);
			 */
			getNode: function() {
				var self = this, rng = self.getRng(), elm;
				var startContainer, endContainer, startOffset, endOffset, root = self.dom.getRoot();
	
				function skipEmptyTextNodes(node, forwards) {
					var orig = node;
	
					while (node && node.nodeType === 3 && node.length === 0) {
						node = forwards ? node.nextSibling : node.previousSibling;
					}
	
					return node || orig;
				}
	
				// Range maybe lost after the editor is made visible again
				if (!rng) {
					return root;
				}
	
				startContainer = rng.startContainer;
				endContainer = rng.endContainer;
				startOffset = rng.startOffset;
				endOffset = rng.endOffset;
	
				if (rng.setStart) {
					elm = rng.commonAncestorContainer;
	
					// Handle selection a image or other control like element such as anchors
					if (!rng.collapsed) {
						if (startContainer == endContainer) {
							if (endOffset - startOffset < 2) {
								if (startContainer.hasChildNodes()) {
									elm = startContainer.childNodes[startOffset];
								}
							}
						}
	
						// If the anchor node is a element instead of a text node then return this element
						//if (tinymce.isWebKit && sel.anchorNode && sel.anchorNode.nodeType == 1)
						//	return sel.anchorNode.childNodes[sel.anchorOffset];
	
						// Handle cases where the selection is immediately wrapped around a node and return that node instead of it's parent.
						// This happens when you double click an underlined word in FireFox.
						if (startContainer.nodeType === 3 && endContainer.nodeType === 3) {
							if (startContainer.length === startOffset) {
								startContainer = skipEmptyTextNodes(startContainer.nextSibling, true);
							} else {
								startContainer = startContainer.parentNode;
							}
	
							if (endOffset === 0) {
								endContainer = skipEmptyTextNodes(endContainer.previousSibling, false);
							} else {
								endContainer = endContainer.parentNode;
							}
	
							if (startContainer && startContainer === endContainer) {
								return startContainer;
							}
						}
					}
	
					if (elm && elm.nodeType == 3) {
						return elm.parentNode;
					}
	
					return elm;
				}
	
				elm = rng.item ? rng.item(0) : rng.parentElement();
	
				// IE 7 might return elements outside the iframe
				if (elm.ownerDocument !== self.win.document) {
					elm = root;
				}
	
				return elm;
			},
	
			getSelectedBlocks: function(startElm, endElm) {
				var self = this, dom = self.dom, node, root, selectedBlocks = [];
	
				root = dom.getRoot();
				startElm = dom.getParent(startElm || self.getStart(), dom.isBlock);
				endElm = dom.getParent(endElm || self.getEnd(), dom.isBlock);
	
				if (startElm && startElm != root) {
					selectedBlocks.push(startElm);
				}
	
				if (startElm && endElm && startElm != endElm) {
					node = startElm;
	
					var walker = new TreeWalker(startElm, root);
					while ((node = walker.next()) && node != endElm) {
						if (dom.isBlock(node)) {
							selectedBlocks.push(node);
						}
					}
				}
	
				if (endElm && startElm != endElm && endElm != root) {
					selectedBlocks.push(endElm);
				}
	
				return selectedBlocks;
			},
	
			isForward: function() {
				var dom = this.dom, sel = this.getSel(), anchorRange, focusRange;
	
				// No support for selection direction then always return true
				if (!sel || !sel.anchorNode || !sel.focusNode) {
					return true;
				}
	
				anchorRange = dom.createRng();
				anchorRange.setStart(sel.anchorNode, sel.anchorOffset);
				anchorRange.collapse(true);
	
				focusRange = dom.createRng();
				focusRange.setStart(sel.focusNode, sel.focusOffset);
				focusRange.collapse(true);
	
				return anchorRange.compareBoundaryPoints(anchorRange.START_TO_START, focusRange) <= 0;
			},
	
			normalize: function() {
				var self = this, rng = self.getRng();
	
				if (Env.range && new RangeUtils(self.dom).normalize(rng)) {
					self.setRng(rng, self.isForward());
				}
	
				return rng;
			},
	
			/**
			 * Executes callback when the current selection starts/stops matching the specified selector. The current
			 * state will be passed to the callback as it's first argument.
			 *
			 * @method selectorChanged
			 * @param {String} selector CSS selector to check for.
			 * @param {function} callback Callback with state and args when the selector is matches or not.
			 */
			selectorChanged: function(selector, callback) {
				var self = this, currentSelectors;
	
				if (!self.selectorChangedData) {
					self.selectorChangedData = {};
					currentSelectors = {};
	
					self.editor.on('NodeChange', function(e) {
						var node = e.element, dom = self.dom, parents = dom.getParents(node, null, dom.getRoot()), matchedSelectors = {};
	
						// Check for new matching selectors
						each(self.selectorChangedData, function(callbacks, selector) {
							each(parents, function(node) {
								if (dom.is(node, selector)) {
									if (!currentSelectors[selector]) {
										// Execute callbacks
										each(callbacks, function(callback) {
											callback(true, {node: node, selector: selector, parents: parents});
										});
	
										currentSelectors[selector] = callbacks;
									}
	
									matchedSelectors[selector] = callbacks;
									return false;
								}
							});
						});
	
						// Check if current selectors still match
						each(currentSelectors, function(callbacks, selector) {
							if (!matchedSelectors[selector]) {
								delete currentSelectors[selector];
	
								each(callbacks, function(callback) {
									callback(false, {node: node, selector: selector, parents: parents});
								});
							}
						});
					});
				}
	
				// Add selector listeners
				if (!self.selectorChangedData[selector]) {
					self.selectorChangedData[selector] = [];
				}
	
				self.selectorChangedData[selector].push(callback);
	
				return self;
			},
	
			getScrollContainer: function() {
				var scrollContainer, node = this.dom.getRoot();
	
				while (node && node.nodeName != 'BODY') {
					if (node.scrollHeight > node.clientHeight) {
						scrollContainer = node;
						break;
					}
	
					node = node.parentNode;
				}
	
				return scrollContainer;
			},
	
			scrollIntoView: function(elm, alignToTop) {
				var y, viewPort, self = this, dom = self.dom, root = dom.getRoot(), viewPortY, viewPortH, offsetY = 0;
	
				function getPos(elm) {
					var x = 0, y = 0;
	
					var offsetParent = elm;
					while (offsetParent && offsetParent.nodeType) {
						x += offsetParent.offsetLeft || 0;
						y += offsetParent.offsetTop || 0;
						offsetParent = offsetParent.offsetParent;
					}
	
					return {x: x, y: y};
				}
	
				if (!NodeType.isElement(elm)) {
					return;
				}
	
				if (alignToTop === false) {
					offsetY = elm.offsetHeight;
				}
	
				if (root.nodeName != 'BODY') {
					var scrollContainer = self.getScrollContainer();
					if (scrollContainer) {
						y = getPos(elm).y - getPos(scrollContainer).y + offsetY;
						viewPortH = scrollContainer.clientHeight;
						viewPortY = scrollContainer.scrollTop;
						if (y < viewPortY || y + 25 > viewPortY + viewPortH) {
							scrollContainer.scrollTop = y < viewPortY ? y : y - viewPortH + 25;
						}
	
						return;
					}
				}
	
				viewPort = dom.getViewPort(self.editor.getWin());
				y = dom.getPos(elm).y + offsetY;
				viewPortY = viewPort.y;
				viewPortH = viewPort.h;
				if (y < viewPort.y || y + 25 > viewPortY + viewPortH) {
					self.editor.getWin().scrollTo(0, y < viewPortY ? y : y - viewPortH + 25);
				}
			},
	
			placeCaretAt: function(clientX, clientY) {
				this.setRng(RangeUtils.getCaretRangeFromPoint(clientX, clientY, this.editor.getDoc()));
			},
	
			_moveEndPoint: function(rng, node, start) {
				var root = node, walker = new TreeWalker(node, root);
				var nonEmptyElementsMap = this.dom.schema.getNonEmptyElements();
	
				do {
					// Text node
					if (node.nodeType == 3 && trim(node.nodeValue).length !== 0) {
						if (start) {
							rng.setStart(node, 0);
						} else {
							rng.setEnd(node, node.nodeValue.length);
						}
	
						return;
					}
	
					// BR/IMG/INPUT elements but not table cells
					if (nonEmptyElementsMap[node.nodeName] && !/^(TD|TH)$/.test(node.nodeName)) {
						if (start) {
							rng.setStartBefore(node);
						} else {
							if (node.nodeName == 'BR') {
								rng.setEndBefore(node);
							} else {
								rng.setEndAfter(node);
							}
						}
	
						return;
					}
	
					// Found empty text block old IE can place the selection inside those
					if (Env.ie && Env.ie < 11 && this.dom.isBlock(node) && this.dom.isEmpty(node)) {
						if (start) {
							rng.setStart(node, 0);
						} else {
							rng.setEnd(node, 0);
						}
	
						return;
					}
				} while ((node = (start ? walker.next() : walker.prev())));
	
				// Failed to find any text node or other suitable location then move to the root of body
				if (root.nodeName == 'BODY') {
					if (start) {
						rng.setStart(root, 0);
					} else {
						rng.setEnd(root, root.childNodes.length);
					}
				}
			},
	
			destroy: function() {
				this.win = null;
				this.controlSelection.destroy();
			}
		};
	
		return Selection;
	});
	
	// Included from: js/tinymce/classes/dom/ElementUtils.js
	
	/**
	 * ElementUtils.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * Utility class for various element specific functions.
	 *
	 * @private
	 * @class tinymce.dom.ElementUtils
	 */
	define("tinymce/dom/ElementUtils", [
		"tinymce/dom/BookmarkManager",
		"tinymce/util/Tools"
	], function(BookmarkManager, Tools) {
		var each = Tools.each;
	
		function ElementUtils(dom) {
			/**
			 * Compares two nodes and checks if it's attributes and styles matches.
			 * This doesn't compare classes as items since their order is significant.
			 *
			 * @method compare
			 * @param {Node} node1 First node to compare with.
			 * @param {Node} node2 Second node to compare with.
			 * @return {boolean} True/false if the nodes are the same or not.
			 */
			this.compare = function(node1, node2) {
				// Not the same name
				if (node1.nodeName != node2.nodeName) {
					return false;
				}
	
				/**
				 * Returns all the nodes attributes excluding internal ones, styles and classes.
				 *
				 * @private
				 * @param {Node} node Node to get attributes from.
				 * @return {Object} Name/value object with attributes and attribute values.
				 */
				function getAttribs(node) {
					var attribs = {};
	
					each(dom.getAttribs(node), function(attr) {
						var name = attr.nodeName.toLowerCase();
	
						// Don't compare internal attributes or style
						if (name.indexOf('_') !== 0 && name !== 'style' && name !== 'data-mce-style' && name != 'data-mce-fragment') {
							attribs[name] = dom.getAttrib(node, name);
						}
					});
	
					return attribs;
				}
	
				/**
				 * Compares two objects checks if it's key + value exists in the other one.
				 *
				 * @private
				 * @param {Object} obj1 First object to compare.
				 * @param {Object} obj2 Second object to compare.
				 * @return {boolean} True/false if the objects matches or not.
				 */
				function compareObjects(obj1, obj2) {
					var value, name;
	
					for (name in obj1) {
						// Obj1 has item obj2 doesn't have
						if (obj1.hasOwnProperty(name)) {
							value = obj2[name];
	
							// Obj2 doesn't have obj1 item
							if (typeof value == "undefined") {
								return false;
							}
	
							// Obj2 item has a different value
							if (obj1[name] != value) {
								return false;
							}
	
							// Delete similar value
							delete obj2[name];
						}
					}
	
					// Check if obj 2 has something obj 1 doesn't have
					for (name in obj2) {
						// Obj2 has item obj1 doesn't have
						if (obj2.hasOwnProperty(name)) {
							return false;
						}
					}
	
					return true;
				}
	
				// Attribs are not the same
				if (!compareObjects(getAttribs(node1), getAttribs(node2))) {
					return false;
				}
	
				// Styles are not the same
				if (!compareObjects(dom.parseStyle(dom.getAttrib(node1, 'style')), dom.parseStyle(dom.getAttrib(node2, 'style')))) {
					return false;
				}
	
				return !BookmarkManager.isBookmarkNode(node1) && !BookmarkManager.isBookmarkNode(node2);
			};
		}
	
		return ElementUtils;
	});
	
	// Included from: js/tinymce/classes/fmt/Preview.js
	
	/**
	 * Preview.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * Internal class for generating previews styles for formats.
	 *
	 * Example:
	 *  Preview.getCssText(editor, 'bold');
	 *
	 * @private
	 * @class tinymce.fmt.Preview
	 */
	define("tinymce/fmt/Preview", [
		"tinymce/util/Tools"
	], function(Tools) {
		var each = Tools.each;
	
		function getCssText(editor, format) {
			var name, previewElm, dom = editor.dom;
			var previewCss = '', parentFontSize, previewStyles;
	
			previewStyles = editor.settings.preview_styles;
	
			// No preview forced
			if (previewStyles === false) {
				return '';
			}
	
			// Default preview
			if (!previewStyles) {
				previewStyles = 'font-family font-size font-weight font-style text-decoration ' +
					'text-transform color background-color border border-radius outline text-shadow';
			}
	
			// Removes any variables since these can't be previewed
			function removeVars(val) {
				return val.replace(/%(\w+)/g, '');
			}
	
			// Create block/inline element to use for preview
			if (typeof format == "string") {
				format = editor.formatter.get(format);
				if (!format) {
					return;
				}
	
				format = format[0];
			}
	
			name = format.block || format.inline || 'span';
			previewElm = dom.create(name);
	
			// Add format styles to preview element
			each(format.styles, function(value, name) {
				value = removeVars(value);
	
				if (value) {
					dom.setStyle(previewElm, name, value);
				}
			});
	
			// Add attributes to preview element
			each(format.attributes, function(value, name) {
				value = removeVars(value);
	
				if (value) {
					dom.setAttrib(previewElm, name, value);
				}
			});
	
			// Add classes to preview element
			each(format.classes, function(value) {
				value = removeVars(value);
	
				if (!dom.hasClass(previewElm, value)) {
					dom.addClass(previewElm, value);
				}
			});
	
			editor.fire('PreviewFormats');
	
			// Add the previewElm outside the visual area
			dom.setStyles(previewElm, {position: 'absolute', left: -0xFFFF});
			editor.getBody().appendChild(previewElm);
	
			// Get parent container font size so we can compute px values out of em/% for older IE:s
			parentFontSize = dom.getStyle(editor.getBody(), 'fontSize', true);
			parentFontSize = /px$/.test(parentFontSize) ? parseInt(parentFontSize, 10) : 0;
	
			each(previewStyles.split(' '), function(name) {
				var value = dom.getStyle(previewElm, name, true);
	
				// If background is transparent then check if the body has a background color we can use
				if (name == 'background-color' && /transparent|rgba\s*\([^)]+,\s*0\)/.test(value)) {
					value = dom.getStyle(editor.getBody(), name, true);
	
					// Ignore white since it's the default color, not the nicest fix
					// TODO: Fix this by detecting runtime style
					if (dom.toHex(value).toLowerCase() == '#ffffff') {
						return;
					}
				}
	
				if (name == 'color') {
					// Ignore black since it's the default color, not the nicest fix
					// TODO: Fix this by detecting runtime style
					if (dom.toHex(value).toLowerCase() == '#000000') {
						return;
					}
				}
	
				// Old IE won't calculate the font size so we need to do that manually
				if (name == 'font-size') {
					if (/em|%$/.test(value)) {
						if (parentFontSize === 0) {
							return;
						}
	
						// Convert font size from em/% to px
						value = parseFloat(value, 10) / (/%$/.test(value) ? 100 : 1);
						value = (value * parentFontSize) + 'px';
					}
				}
	
				if (name == "border" && value) {
					previewCss += 'padding:0 2px;';
				}
	
				previewCss += name + ':' + value + ';';
			});
	
			editor.fire('AfterPreviewFormats');
	
			//previewCss += 'line-height:normal';
	
			dom.remove(previewElm);
	
			return previewCss;
		}
	
		return {
			getCssText: getCssText
		};
	});
	
	// Included from: js/tinymce/classes/fmt/Hooks.js
	
	/**
	 * Hooks.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2016 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * Internal class for overriding formatting.
	 *
	 * @private
	 * @class tinymce.fmt.Hooks
	 */
	define("tinymce/fmt/Hooks", [
		"tinymce/util/Arr",
		"tinymce/dom/NodeType",
		"tinymce/dom/DomQuery"
	], function(Arr, NodeType, $) {
		var postProcessHooks = [], filter = Arr.filter, each = Arr.each;
	
		function addPostProcessHook(name, hook) {
			var hooks = postProcessHooks[name];
	
			if (!hooks) {
				postProcessHooks[name] = hooks = [];
			}
	
			postProcessHooks[name].push(hook);
		}
	
		function postProcess(name, editor) {
			each(postProcessHooks[name], function(hook) {
				hook(editor);
			});
		}
	
		addPostProcessHook("pre", function(editor) {
			var rng = editor.selection.getRng(), isPre, blocks;
	
			function hasPreSibling(pre) {
				return isPre(pre.previousSibling) && Arr.indexOf(blocks, pre.previousSibling) != -1;
			}
	
			function joinPre(pre1, pre2) {
				$(pre2).remove();
				$(pre1).append('<br><br>').append(pre2.childNodes);
			}
	
			isPre = NodeType.matchNodeNames('pre');
	
			if (!rng.collapsed) {
				blocks = editor.selection.getSelectedBlocks();
	
				each(filter(filter(blocks, isPre), hasPreSibling), function(pre) {
					joinPre(pre.previousSibling, pre);
				});
			}
		});
	
		return {
			postProcess: postProcess
		};
	});
	
	// Included from: js/tinymce/classes/Formatter.js
	
	/**
	 * Formatter.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * Text formatter engine class. This class is used to apply formats like bold, italic, font size
	 * etc to the current selection or specific nodes. This engine was built to replace the browser's
	 * default formatting logic for execCommand due to its inconsistent and buggy behavior.
	 *
	 * @class tinymce.Formatter
	 * @example
	 *  tinymce.activeEditor.formatter.register('mycustomformat', {
	 *    inline: 'span',
	 *    styles: {color: '#ff0000'}
	 *  });
	 *
	 *  tinymce.activeEditor.formatter.apply('mycustomformat');
	 */
	define("tinymce/Formatter", [
		"tinymce/dom/TreeWalker",
		"tinymce/dom/RangeUtils",
		"tinymce/dom/BookmarkManager",
		"tinymce/dom/ElementUtils",
		"tinymce/util/Tools",
		"tinymce/fmt/Preview",
		"tinymce/fmt/Hooks"
	], function(TreeWalker, RangeUtils, BookmarkManager, ElementUtils, Tools, Preview, Hooks) {
		/**
		 * Constructs a new formatter instance.
		 *
		 * @constructor Formatter
		 * @param {tinymce.Editor} ed Editor instance to construct the formatter engine to.
		 */
		return function(ed) {
			var formats = {},
				dom = ed.dom,
				selection = ed.selection,
				rangeUtils = new RangeUtils(dom),
				isValid = ed.schema.isValidChild,
				isBlock = dom.isBlock,
				forcedRootBlock = ed.settings.forced_root_block,
				nodeIndex = dom.nodeIndex,
				INVISIBLE_CHAR = '\uFEFF',
				MCE_ATTR_RE = /^(src|href|style)$/,
				FALSE = false,
				TRUE = true,
				formatChangeData,
				undef,
				getContentEditable = dom.getContentEditable,
				disableCaretContainer,
				markCaretContainersBogus,
				isBookmarkNode = BookmarkManager.isBookmarkNode;
	
			var each = Tools.each,
				grep = Tools.grep,
				walk = Tools.walk,
				extend = Tools.extend;
	
			function isTextBlock(name) {
				if (name.nodeType) {
					name = name.nodeName;
				}
	
				return !!ed.schema.getTextBlockElements()[name.toLowerCase()];
			}
	
			function isTableCell(node) {
				return /^(TH|TD)$/.test(node.nodeName);
			}
	
			function isInlineBlock(node) {
				return node && /^(IMG)$/.test(node.nodeName);
			}
	
			function getParents(node, selector) {
				return dom.getParents(node, selector, dom.getRoot());
			}
	
			function isCaretNode(node) {
				return node.nodeType === 1 && node.id === '_mce_caret';
			}
	
			function defaultFormats() {
				register({
					valigntop: [
						{selector: 'td,th', styles: {'verticalAlign': 'top'}}
					],
	
					valignmiddle: [
						{selector: 'td,th', styles: {'verticalAlign': 'middle'}}
					],
	
					valignbottom: [
						{selector: 'td,th', styles: {'verticalAlign': 'bottom'}}
					],
	
					alignleft: [
						{selector: 'figure.image', collapsed: false, classes: 'align-left', ceFalseOverride: true},
						{
							selector: 'figure,p,h1,h2,h3,h4,h5,h6,td,th,tr,div,ul,ol,li',
							styles: {
								textAlign: 'left'
							},
							inherit: false,
							defaultBlock: 'div'
						},
						{selector: 'img,table', collapsed: false, styles: {'float': 'left'}}
					],
	
					aligncenter: [
						{
							selector: 'figure,p,h1,h2,h3,h4,h5,h6,td,th,tr,div,ul,ol,li',
							styles: {
								textAlign: 'center'
							},
							inherit: false,
							defaultBlock: 'div'
						},
						{selector: 'figure.image', collapsed: false, classes: 'align-center', ceFalseOverride: true},
						{selector: 'img', collapsed: false, styles: {display: 'block', marginLeft: 'auto', marginRight: 'auto'}},
						{selector: 'table', collapsed: false, styles: {marginLeft: 'auto', marginRight: 'auto'}}
					],
	
					alignright: [
						{selector: 'figure.image', collapsed: false, classes: 'align-right', ceFalseOverride: true},
						{
							selector: 'figure,p,h1,h2,h3,h4,h5,h6,td,th,tr,div,ul,ol,li',
							styles: {
								textAlign: 'right'
							},
							inherit: false,
							defaultBlock: 'div'
						},
						{selector: 'img,table', collapsed: false, styles: {'float': 'right'}}
					],
	
					alignjustify: [
						{
							selector: 'figure,p,h1,h2,h3,h4,h5,h6,td,th,tr,div,ul,ol,li',
							styles: {
								textAlign: 'justify'
							},
							inherit: false,
							defaultBlock: 'div'
						}
					],
	
					bold: [
						{inline: 'strong', remove: 'all'},
						{inline: 'span', styles: {fontWeight: 'bold'}},
						{inline: 'b', remove: 'all'}
					],
	
					italic: [
						{inline: 'em', remove: 'all'},
						{inline: 'span', styles: {fontStyle: 'italic'}},
						{inline: 'i', remove: 'all'}
					],
	
					underline: [
						{inline: 'span', styles: {textDecoration: 'underline'}, exact: true},
						{inline: 'u', remove: 'all'}
					],
	
					strikethrough: [
						{inline: 'span', styles: {textDecoration: 'line-through'}, exact: true},
						{inline: 'strike', remove: 'all'}
					],
	
					forecolor: {inline: 'span', styles: {color: '%value'}, links: true, remove_similar: true},
					hilitecolor: {inline: 'span', styles: {backgroundColor: '%value'}, links: true, remove_similar: true},
					fontname: {inline: 'span', styles: {fontFamily: '%value'}},
					fontsize: {inline: 'span', styles: {fontSize: '%value'}},
					fontsize_class: {inline: 'span', attributes: {'class': '%value'}},
					blockquote: {block: 'blockquote', wrapper: 1, remove: 'all'},
					subscript: {inline: 'sub'},
					superscript: {inline: 'sup'},
					code: {inline: 'code'},
	
					link: {inline: 'a', selector: 'a', remove: 'all', split: true, deep: true,
						onmatch: function() {
							return true;
						},
	
						onformat: function(elm, fmt, vars) {
							each(vars, function(value, key) {
								dom.setAttrib(elm, key, value);
							});
						}
					},
	
					removeformat: [
						{
							selector: 'b,strong,em,i,font,u,strike,sub,sup,dfn,code,samp,kbd,var,cite,mark,q,del,ins',
							remove: 'all',
							split: true,
							expand: false,
							block_expand: true,
							deep: true
						},
						{selector: 'span', attributes: ['style', 'class'], remove: 'empty', split: true, expand: false, deep: true},
						{selector: '*', attributes: ['style', 'class'], split: false, expand: false, deep: true}
					]
				});
	
				// Register default block formats
				each('p h1 h2 h3 h4 h5 h6 div address pre div dt dd samp'.split(/\s/), function(name) {
					register(name, {block: name, remove: 'all'});
				});
	
				// Register user defined formats
				register(ed.settings.formats);
			}
	
			function addKeyboardShortcuts() {
				// Add some inline shortcuts
				ed.addShortcut('meta+b', 'bold_desc', 'Bold');
				ed.addShortcut('meta+i', 'italic_desc', 'Italic');
				ed.addShortcut('meta+u', 'underline_desc', 'Underline');
	
				// BlockFormat shortcuts keys
				for (var i = 1; i <= 6; i++) {
					ed.addShortcut('access+' + i, '', ['FormatBlock', false, 'h' + i]);
				}
	
				ed.addShortcut('access+7', '', ['FormatBlock', false, 'p']);
				ed.addShortcut('access+8', '', ['FormatBlock', false, 'div']);
				ed.addShortcut('access+9', '', ['FormatBlock', false, 'address']);
			}
	
			// Public functions
	
			/**
			 * Returns the format by name or all formats if no name is specified.
			 *
			 * @method get
			 * @param {String} name Optional name to retrieve by.
			 * @return {Array/Object} Array/Object with all registered formats or a specific format.
			 */
			function get(name) {
				return name ? formats[name] : formats;
			}
	
			/**
			 * Registers a specific format by name.
			 *
			 * @method register
			 * @param {Object/String} name Name of the format for example "bold".
			 * @param {Object/Array} format Optional format object or array of format variants
			 * can only be omitted if the first arg is an object.
			 */
			function register(name, format) {
				if (name) {
					if (typeof name !== 'string') {
						each(name, function(format, name) {
							register(name, format);
						});
					} else {
						// Force format into array and add it to internal collection
						format = format.length ? format : [format];
	
						each(format, function(format) {
							// Set deep to false by default on selector formats this to avoid removing
							// alignment on images inside paragraphs when alignment is changed on paragraphs
							if (format.deep === undef) {
								format.deep = !format.selector;
							}
	
							// Default to true
							if (format.split === undef) {
								format.split = !format.selector || format.inline;
							}
	
							// Default to true
							if (format.remove === undef && format.selector && !format.inline) {
								format.remove = 'none';
							}
	
							// Mark format as a mixed format inline + block level
							if (format.selector && format.inline) {
								format.mixed = true;
								format.block_expand = true;
							}
	
							// Split classes if needed
							if (typeof format.classes === 'string') {
								format.classes = format.classes.split(/\s+/);
							}
						});
	
						formats[name] = format;
					}
				}
			}
	
			/**
			 * Unregister a specific format by name.
			 *
			 * @method unregister
			 * @param {String} name Name of the format for example "bold".
			 */
			function unregister(name) {
				if (name && formats[name]) {
					delete formats[name];
				}
	
				return formats;
			}
	
			function matchesUnInheritedFormatSelector(node, name) {
				var formatList = get(name);
	
				if (formatList) {
					for (var i = 0; i < formatList.length; i++) {
						if (formatList[i].inherit === false && dom.is(node, formatList[i].selector)) {
							return true;
						}
					}
				}
	
				return false;
			}
	
			function getTextDecoration(node) {
				var decoration;
	
				ed.dom.getParent(node, function(n) {
					decoration = ed.dom.getStyle(n, 'text-decoration');
					return decoration && decoration !== 'none';
				});
	
				return decoration;
			}
	
			function processUnderlineAndColor(node) {
				var textDecoration;
				if (node.nodeType === 1 && node.parentNode && node.parentNode.nodeType === 1) {
					textDecoration = getTextDecoration(node.parentNode);
					if (ed.dom.getStyle(node, 'color') && textDecoration) {
						ed.dom.setStyle(node, 'text-decoration', textDecoration);
					} else if (ed.dom.getStyle(node, 'text-decoration') === textDecoration) {
						ed.dom.setStyle(node, 'text-decoration', null);
					}
				}
			}
	
			/**
			 * Applies the specified format to the current selection or specified node.
			 *
			 * @method apply
			 * @param {String} name Name of format to apply.
			 * @param {Object} vars Optional list of variables to replace within format before applying it.
			 * @param {Node} node Optional node to apply the format to defaults to current selection.
			 */
			function apply(name, vars, node) {
				var formatList = get(name), format = formatList[0], bookmark, rng, isCollapsed = !node && selection.isCollapsed();
	
				function setElementFormat(elm, fmt) {
					fmt = fmt || format;
	
					if (elm) {
						if (fmt.onformat) {
							fmt.onformat(elm, fmt, vars, node);
						}
	
						each(fmt.styles, function(value, name) {
							dom.setStyle(elm, name, replaceVars(value, vars));
						});
	
						// Needed for the WebKit span spam bug
						// TODO: Remove this once WebKit/Blink fixes this
						if (fmt.styles) {
							var styleVal = dom.getAttrib(elm, 'style');
	
							if (styleVal) {
								elm.setAttribute('data-mce-style', styleVal);
							}
						}
	
						each(fmt.attributes, function(value, name) {
							dom.setAttrib(elm, name, replaceVars(value, vars));
						});
	
						each(fmt.classes, function(value) {
							value = replaceVars(value, vars);
	
							if (!dom.hasClass(elm, value)) {
								dom.addClass(elm, value);
							}
						});
					}
				}
	
				// This converts: <p>[a</p><p>]b</p> -> <p>[a]</p><p>b</p>
				function adjustSelectionToVisibleSelection() {
					function findSelectionEnd(start, end) {
						var walker = new TreeWalker(end);
						for (node = walker.prev2(); node; node = walker.prev2()) {
							if (node.nodeType == 3 && node.data.length > 0) {
								return node;
							}
	
							if (node.childNodes.length > 1 || node == start || node.tagName == 'BR') {
								return node;
							}
						}
					}
	
					// Adjust selection so that a end container with a end offset of zero is not included in the selection
					// as this isn't visible to the user.
					var rng = ed.selection.getRng();
					var start = rng.startContainer;
					var end = rng.endContainer;
	
					if (start != end && rng.endOffset === 0) {
						var newEnd = findSelectionEnd(start, end);
						var endOffset = newEnd.nodeType == 3 ? newEnd.data.length : newEnd.childNodes.length;
	
						rng.setEnd(newEnd, endOffset);
					}
	
					return rng;
				}
	
				function applyRngStyle(rng, bookmark, node_specific) {
					var newWrappers = [], wrapName, wrapElm, contentEditable = true;
	
					// Setup wrapper element
					wrapName = format.inline || format.block;
					wrapElm = dom.create(wrapName);
					setElementFormat(wrapElm);
	
					rangeUtils.walk(rng, function(nodes) {
						var currentWrapElm;
	
						/**
						 * Process a list of nodes wrap them.
						 */
						function process(node) {
							var nodeName, parentName, found, hasContentEditableState, lastContentEditable;
	
							lastContentEditable = contentEditable;
							nodeName = node.nodeName.toLowerCase();
							parentName = node.parentNode.nodeName.toLowerCase();
	
							// Node has a contentEditable value
							if (node.nodeType === 1 && getContentEditable(node)) {
								lastContentEditable = contentEditable;
								contentEditable = getContentEditable(node) === "true";
								hasContentEditableState = true; // We don't want to wrap the container only it's children
							}
	
							// Stop wrapping on br elements
							if (isEq(nodeName, 'br')) {
								currentWrapElm = 0;
	
								// Remove any br elements when we wrap things
								if (format.block) {
									dom.remove(node);
								}
	
								return;
							}
	
							// If node is wrapper type
							if (format.wrapper && matchNode(node, name, vars)) {
								currentWrapElm = 0;
								return;
							}
	
							// Can we rename the block
							// TODO: Break this if up, too complex
							if (contentEditable && !hasContentEditableState && format.block &&
								!format.wrapper && isTextBlock(nodeName) && isValid(parentName, wrapName)) {
								node = dom.rename(node, wrapName);
								setElementFormat(node);
								newWrappers.push(node);
								currentWrapElm = 0;
								return;
							}
	
							// Handle selector patterns
							if (format.selector) {
								// Look for matching formats
								each(formatList, function(format) {
									// Check collapsed state if it exists
									if ('collapsed' in format && format.collapsed !== isCollapsed) {
										return;
									}
	
									if (dom.is(node, format.selector) && !isCaretNode(node)) {
										setElementFormat(node, format);
										found = true;
										return false;
									}
								});
	
								// Continue processing if a selector match wasn't found and a inline element is defined
								if (!format.inline || found) {
									currentWrapElm = 0;
									return;
								}
							}
	
							// Is it valid to wrap this item
							// TODO: Break this if up, too complex
							if (contentEditable && !hasContentEditableState && isValid(wrapName, nodeName) && isValid(parentName, wrapName) &&
									!(!node_specific && node.nodeType === 3 &&
									node.nodeValue.length === 1 &&
									node.nodeValue.charCodeAt(0) === 65279) &&
									!isCaretNode(node) &&
									(!format.inline || !isBlock(node))) {
								// Start wrapping
								if (!currentWrapElm) {
									// Wrap the node
									currentWrapElm = dom.clone(wrapElm, FALSE);
									node.parentNode.insertBefore(currentWrapElm, node);
									newWrappers.push(currentWrapElm);
								}
	
								currentWrapElm.appendChild(node);
							} else {
								// Start a new wrapper for possible children
								currentWrapElm = 0;
	
								each(grep(node.childNodes), process);
	
								if (hasContentEditableState) {
									contentEditable = lastContentEditable; // Restore last contentEditable state from stack
								}
	
								// End the last wrapper
								currentWrapElm = 0;
							}
						}
	
						// Process siblings from range
						each(nodes, process);
					});
	
					// Apply formats to links as well to get the color of the underline to change as well
					if (format.links === true) {
						each(newWrappers, function(node) {
							function process(node) {
								if (node.nodeName === 'A') {
									setElementFormat(node, format);
								}
	
								each(grep(node.childNodes), process);
							}
	
							process(node);
						});
					}
	
					// Cleanup
					each(newWrappers, function(node) {
						var childCount;
	
						function getChildCount(node) {
							var count = 0;
	
							each(node.childNodes, function(node) {
								if (!isWhiteSpaceNode(node) && !isBookmarkNode(node)) {
									count++;
								}
							});
	
							return count;
						}
	
						function mergeStyles(node) {
							var child, clone;
	
							each(node.childNodes, function(node) {
								if (node.nodeType == 1 && !isBookmarkNode(node) && !isCaretNode(node)) {
									child = node;
									return FALSE; // break loop
								}
							});
	
							// If child was found and of the same type as the current node
							if (child && !isBookmarkNode(child) && matchName(child, format)) {
								clone = dom.clone(child, FALSE);
								setElementFormat(clone);
	
								dom.replace(clone, node, TRUE);
								dom.remove(child, 1);
							}
	
							return clone || node;
						}
	
						childCount = getChildCount(node);
	
						// Remove empty nodes but only if there is multiple wrappers and they are not block
						// elements so never remove single <h1></h1> since that would remove the
						// current empty block element where the caret is at
						if ((newWrappers.length > 1 || !isBlock(node)) && childCount === 0) {
							dom.remove(node, 1);
							return;
						}
	
						if (format.inline || format.wrapper) {
							// Merges the current node with it's children of similar type to reduce the number of elements
							if (!format.exact && childCount === 1) {
								node = mergeStyles(node);
							}
	
							// Remove/merge children
							each(formatList, function(format) {
								// Merge all children of similar type will move styles from child to parent
								// this: <span style="color:red"><b><span style="color:red; font-size:10px">text</span></b></span>
								// will become: <span style="color:red"><b><span style="font-size:10px">text</span></b></span>
								each(dom.select(format.inline, node), function(child) {
									if (isBookmarkNode(child)) {
										return;
									}
	
									removeFormat(format, vars, child, format.exact ? child : null);
								});
							});
	
							// Remove child if direct parent is of same type
							if (matchNode(node.parentNode, name, vars)) {
								dom.remove(node, 1);
								node = 0;
								return TRUE;
							}
	
							// Look for parent with similar style format
							if (format.merge_with_parents) {
								dom.getParent(node.parentNode, function(parent) {
									if (matchNode(parent, name, vars)) {
										dom.remove(node, 1);
										node = 0;
										return TRUE;
									}
								});
							}
	
							// Merge next and previous siblings if they are similar <b>text</b><b>text</b> becomes <b>texttext</b>
							if (node && format.merge_siblings !== false) {
								node = mergeSiblings(getNonWhiteSpaceSibling(node), node);
								node = mergeSiblings(node, getNonWhiteSpaceSibling(node, TRUE));
							}
						}
					});
				}
	
				if (getContentEditable(selection.getNode()) === "false") {
					node = selection.getNode();
					for (var i = 0, l = formatList.length; i < l; i++) {
						if (formatList[i].ceFalseOverride && dom.is(node, formatList[i].selector)) {
							setElementFormat(node, formatList[i]);
							return;
						}
					}
	
					return;
				}
	
				if (format) {
					if (node) {
						if (node.nodeType) {
							rng = dom.createRng();
							rng.setStartBefore(node);
							rng.setEndAfter(node);
							applyRngStyle(expandRng(rng, formatList), null, true);
						} else {
							applyRngStyle(node, null, true);
						}
					} else {
						if (!isCollapsed || !format.inline || dom.select('td[data-mce-selected],th[data-mce-selected]').length) {
							// Obtain selection node before selection is unselected by applyRngStyle()
							var curSelNode = ed.selection.getNode();
	
							// If the formats have a default block and we can't find a parent block then
							// start wrapping it with a DIV this is for forced_root_blocks: false
							// It's kind of a hack but people should be using the default block type P since all desktop editors work that way
							if (!forcedRootBlock && formatList[0].defaultBlock && !dom.getParent(curSelNode, dom.isBlock)) {
								apply(formatList[0].defaultBlock);
							}
	
							// Apply formatting to selection
							ed.selection.setRng(adjustSelectionToVisibleSelection());
							bookmark = selection.getBookmark();
							applyRngStyle(expandRng(selection.getRng(TRUE), formatList), bookmark);
	
							// Colored nodes should be underlined so that the color of the underline matches the text color.
							if (format.styles && (format.styles.color || format.styles.textDecoration)) {
								walk(curSelNode, processUnderlineAndColor, 'childNodes');
								processUnderlineAndColor(curSelNode);
							}
	
							selection.moveToBookmark(bookmark);
							moveStart(selection.getRng(TRUE));
							ed.nodeChanged();
						} else {
							performCaretAction('apply', name, vars);
						}
					}
	
					Hooks.postProcess(name, ed);
				}
			}
	
			/**
			 * Removes the specified format from the current selection or specified node.
			 *
			 * @method remove
			 * @param {String} name Name of format to remove.
			 * @param {Object} vars Optional list of variables to replace within format before removing it.
			 * @param {Node/Range} node Optional node or DOM range to remove the format from defaults to current selection.
			 */
			function remove(name, vars, node, similar) {
				var formatList = get(name), format = formatList[0], bookmark, rng, contentEditable = true;
	
				// Merges the styles for each node
				function process(node) {
					var children, i, l, lastContentEditable, hasContentEditableState;
	
					// Node has a contentEditable value
					if (node.nodeType === 1 && getContentEditable(node)) {
						lastContentEditable = contentEditable;
						contentEditable = getContentEditable(node) === "true";
						hasContentEditableState = true; // We don't want to wrap the container only it's children
					}
	
					// Grab the children first since the nodelist might be changed
					children = grep(node.childNodes);
	
					// Process current node
					if (contentEditable && !hasContentEditableState) {
						for (i = 0, l = formatList.length; i < l; i++) {
							if (removeFormat(formatList[i], vars, node, node)) {
								break;
							}
						}
					}
	
					// Process the children
					if (format.deep) {
						if (children.length) {
							for (i = 0, l = children.length; i < l; i++) {
								process(children[i]);
							}
	
							if (hasContentEditableState) {
								contentEditable = lastContentEditable; // Restore last contentEditable state from stack
							}
						}
					}
				}
	
				function findFormatRoot(container) {
					var formatRoot;
	
					// Find format root
					each(getParents(container.parentNode).reverse(), function(parent) {
						var format;
	
						// Find format root element
						if (!formatRoot && parent.id != '_start' && parent.id != '_end') {
							// Is the node matching the format we are looking for
							format = matchNode(parent, name, vars, similar);
							if (format && format.split !== false) {
								formatRoot = parent;
							}
						}
					});
	
					return formatRoot;
				}
	
				function wrapAndSplit(formatRoot, container, target, split) {
					var parent, clone, lastClone, firstClone, i, formatRootParent;
	
					// Format root found then clone formats and split it
					if (formatRoot) {
						formatRootParent = formatRoot.parentNode;
	
						for (parent = container.parentNode; parent && parent != formatRootParent; parent = parent.parentNode) {
							clone = dom.clone(parent, FALSE);
	
							for (i = 0; i < formatList.length; i++) {
								if (removeFormat(formatList[i], vars, clone, clone)) {
									clone = 0;
									break;
								}
							}
	
							// Build wrapper node
							if (clone) {
								if (lastClone) {
									clone.appendChild(lastClone);
								}
	
								if (!firstClone) {
									firstClone = clone;
								}
	
								lastClone = clone;
							}
						}
	
						// Never split block elements if the format is mixed
						if (split && (!format.mixed || !isBlock(formatRoot))) {
							container = dom.split(formatRoot, container);
						}
	
						// Wrap container in cloned formats
						if (lastClone) {
							target.parentNode.insertBefore(lastClone, target);
							firstClone.appendChild(target);
						}
					}
	
					return container;
				}
	
				function splitToFormatRoot(container) {
					return wrapAndSplit(findFormatRoot(container), container, container, true);
				}
	
				function unwrap(start) {
					var node = dom.get(start ? '_start' : '_end'),
						out = node[start ? 'firstChild' : 'lastChild'];
	
					// If the end is placed within the start the result will be removed
					// So this checks if the out node is a bookmark node if it is it
					// checks for another more suitable node
					if (isBookmarkNode(out)) {
						out = out[start ? 'firstChild' : 'lastChild'];
					}
	
					// Since dom.remove removes empty text nodes then we need to try to find a better node
					if (out.nodeType == 3 && out.data.length === 0) {
						out = start ? node.previousSibling || node.nextSibling : node.nextSibling || node.previousSibling;
					}
	
					dom.remove(node, true);
	
					return out;
				}
	
				function removeRngStyle(rng) {
					var startContainer, endContainer;
					var commonAncestorContainer = rng.commonAncestorContainer;
	
					rng = expandRng(rng, formatList, TRUE);
	
					if (format.split) {
						startContainer = getContainer(rng, TRUE);
						endContainer = getContainer(rng);
	
						if (startContainer != endContainer) {
							// WebKit will render the table incorrectly if we wrap a TH or TD in a SPAN
							// so let's see if we can use the first child instead
							// This will happen if you triple click a table cell and use remove formatting
							if (/^(TR|TH|TD)$/.test(startContainer.nodeName) && startContainer.firstChild) {
								if (startContainer.nodeName == "TR") {
									startContainer = startContainer.firstChild.firstChild || startContainer;
								} else {
									startContainer = startContainer.firstChild || startContainer;
								}
							}
	
							// Try to adjust endContainer as well if cells on the same row were selected - bug #6410
							if (commonAncestorContainer &&
								/^T(HEAD|BODY|FOOT|R)$/.test(commonAncestorContainer.nodeName) &&
								isTableCell(endContainer) && endContainer.firstChild) {
								endContainer = endContainer.firstChild || endContainer;
							}
	
							if (dom.isChildOf(startContainer, endContainer) && !isBlock(endContainer) &&
								!isTableCell(startContainer) && !isTableCell(endContainer)) {
								startContainer = wrap(startContainer, 'span', {id: '_start', 'data-mce-type': 'bookmark'});
								splitToFormatRoot(startContainer);
								startContainer = unwrap(TRUE);
								return;
							}
	
							// Wrap start/end nodes in span element since these might be cloned/moved
							startContainer = wrap(startContainer, 'span', {id: '_start', 'data-mce-type': 'bookmark'});
							endContainer = wrap(endContainer, 'span', {id: '_end', 'data-mce-type': 'bookmark'});
	
							// Split start/end
							splitToFormatRoot(startContainer);
							splitToFormatRoot(endContainer);
	
							// Unwrap start/end to get real elements again
							startContainer = unwrap(TRUE);
							endContainer = unwrap();
						} else {
							startContainer = endContainer = splitToFormatRoot(startContainer);
						}
	
						// Update range positions since they might have changed after the split operations
						rng.startContainer = startContainer.parentNode ? startContainer.parentNode : startContainer;
						rng.startOffset = nodeIndex(startContainer);
						rng.endContainer = endContainer.parentNode ? endContainer.parentNode : endContainer;
						rng.endOffset = nodeIndex(endContainer) + 1;
					}
	
					// Remove items between start/end
					rangeUtils.walk(rng, function(nodes) {
						each(nodes, function(node) {
							process(node);
	
							// Remove parent span if it only contains text-decoration: underline, yet a parent node is also underlined.
							if (node.nodeType === 1 && ed.dom.getStyle(node, 'text-decoration') === 'underline' &&
								node.parentNode && getTextDecoration(node.parentNode) === 'underline') {
								removeFormat({
									'deep': false,
									'exact': true,
									'inline': 'span',
									'styles': {
										'textDecoration': 'underline'
									}
								}, null, node);
							}
						});
					});
				}
	
				// Handle node
				if (node) {
					if (node.nodeType) {
						rng = dom.createRng();
						rng.setStartBefore(node);
						rng.setEndAfter(node);
						removeRngStyle(rng);
					} else {
						removeRngStyle(node);
					}
	
					return;
				}
	
				if (getContentEditable(selection.getNode()) === "false") {
					node = selection.getNode();
					for (var i = 0, l = formatList.length; i < l; i++) {
						if (formatList[i].ceFalseOverride) {
							if (removeFormat(formatList[i], vars, node, node)) {
								break;
							}
						}
					}
	
					return;
				}
	
				if (!selection.isCollapsed() || !format.inline || dom.select('td[data-mce-selected],th[data-mce-selected]').length) {
					bookmark = selection.getBookmark();
					removeRngStyle(selection.getRng(TRUE));
					selection.moveToBookmark(bookmark);
	
					// Check if start element still has formatting then we are at: "<b>text|</b>text"
					// and need to move the start into the next text node
					if (format.inline && match(name, vars, selection.getStart())) {
						moveStart(selection.getRng(true));
					}
	
					ed.nodeChanged();
				} else {
					performCaretAction('remove', name, vars, similar);
				}
			}
	
			/**
			 * Toggles the specified format on/off.
			 *
			 * @method toggle
			 * @param {String} name Name of format to apply/remove.
			 * @param {Object} vars Optional list of variables to replace within format before applying/removing it.
			 * @param {Node} node Optional node to apply the format to or remove from. Defaults to current selection.
			 */
			function toggle(name, vars, node) {
				var fmt = get(name);
	
				if (match(name, vars, node) && (!('toggle' in fmt[0]) || fmt[0].toggle)) {
					remove(name, vars, node);
				} else {
					apply(name, vars, node);
				}
			}
	
			/**
			 * Return true/false if the specified node has the specified format.
			 *
			 * @method matchNode
			 * @param {Node} node Node to check the format on.
			 * @param {String} name Format name to check.
			 * @param {Object} vars Optional list of variables to replace before checking it.
			 * @param {Boolean} similar Match format that has similar properties.
			 * @return {Object} Returns the format object it matches or undefined if it doesn't match.
			 */
			function matchNode(node, name, vars, similar) {
				var formatList = get(name), format, i, classes;
	
				function matchItems(node, format, item_name) {
					var key, value, items = format[item_name], i;
	
					// Custom match
					if (format.onmatch) {
						return format.onmatch(node, format, item_name);
					}
	
					// Check all items
					if (items) {
						// Non indexed object
						if (items.length === undef) {
							for (key in items) {
								if (items.hasOwnProperty(key)) {
									if (item_name === 'attributes') {
										value = dom.getAttrib(node, key);
									} else {
										value = getStyle(node, key);
									}
	
									if (similar && !value && !format.exact) {
										return;
									}
	
									if ((!similar || format.exact) && !isEq(value, normalizeStyleValue(replaceVars(items[key], vars), key))) {
										return;
									}
								}
							}
						} else {
							// Only one match needed for indexed arrays
							for (i = 0; i < items.length; i++) {
								if (item_name === 'attributes' ? dom.getAttrib(node, items[i]) : getStyle(node, items[i])) {
									return format;
								}
							}
						}
					}
	
					return format;
				}
	
				if (formatList && node) {
					// Check each format in list
					for (i = 0; i < formatList.length; i++) {
						format = formatList[i];
	
						// Name name, attributes, styles and classes
						if (matchName(node, format) && matchItems(node, format, 'attributes') && matchItems(node, format, 'styles')) {
							// Match classes
							if ((classes = format.classes)) {
								for (i = 0; i < classes.length; i++) {
									if (!dom.hasClass(node, classes[i])) {
										return;
									}
								}
							}
	
							return format;
						}
					}
				}
			}
	
			/**
			 * Matches the current selection or specified node against the specified format name.
			 *
			 * @method match
			 * @param {String} name Name of format to match.
			 * @param {Object} vars Optional list of variables to replace before checking it.
			 * @param {Node} node Optional node to check.
			 * @return {boolean} true/false if the specified selection/node matches the format.
			 */
			function match(name, vars, node) {
				var startNode;
	
				function matchParents(node) {
					var root = dom.getRoot();
	
					if (node === root) {
						return false;
					}
	
					// Find first node with similar format settings
					node = dom.getParent(node, function(node) {
						if (matchesUnInheritedFormatSelector(node, name)) {
							return true;
						}
	
						return node.parentNode === root || !!matchNode(node, name, vars, true);
					});
	
					// Do an exact check on the similar format element
					return matchNode(node, name, vars);
				}
	
				// Check specified node
				if (node) {
					return matchParents(node);
				}
	
				// Check selected node
				node = selection.getNode();
				if (matchParents(node)) {
					return TRUE;
				}
	
				// Check start node if it's different
				startNode = selection.getStart();
				if (startNode != node) {
					if (matchParents(startNode)) {
						return TRUE;
					}
				}
	
				return FALSE;
			}
	
			/**
			 * Matches the current selection against the array of formats and returns a new array with matching formats.
			 *
			 * @method matchAll
			 * @param {Array} names Name of format to match.
			 * @param {Object} vars Optional list of variables to replace before checking it.
			 * @return {Array} Array with matched formats.
			 */
			function matchAll(names, vars) {
				var startElement, matchedFormatNames = [], checkedMap = {};
	
				// Check start of selection for formats
				startElement = selection.getStart();
				dom.getParent(startElement, function(node) {
					var i, name;
	
					for (i = 0; i < names.length; i++) {
						name = names[i];
	
						if (!checkedMap[name] && matchNode(node, name, vars)) {
							checkedMap[name] = true;
							matchedFormatNames.push(name);
						}
					}
				}, dom.getRoot());
	
				return matchedFormatNames;
			}
	
			/**
			 * Returns true/false if the specified format can be applied to the current selection or not. It
			 * will currently only check the state for selector formats, it returns true on all other format types.
			 *
			 * @method canApply
			 * @param {String} name Name of format to check.
			 * @return {boolean} true/false if the specified format can be applied to the current selection/node.
			 */
			function canApply(name) {
				var formatList = get(name), startNode, parents, i, x, selector;
	
				if (formatList) {
					startNode = selection.getStart();
					parents = getParents(startNode);
	
					for (x = formatList.length - 1; x >= 0; x--) {
						selector = formatList[x].selector;
	
						// Format is not selector based then always return TRUE
						// Is it has a defaultBlock then it's likely it can be applied for example align on a non block element line
						if (!selector || formatList[x].defaultBlock) {
							return TRUE;
						}
	
						for (i = parents.length - 1; i >= 0; i--) {
							if (dom.is(parents[i], selector)) {
								return TRUE;
							}
						}
					}
				}
	
				return FALSE;
			}
	
			/**
			 * Executes the specified callback when the current selection matches the formats or not.
			 *
			 * @method formatChanged
			 * @param {String} formats Comma separated list of formats to check for.
			 * @param {function} callback Callback with state and args when the format is changed/toggled on/off.
			 * @param {Boolean} similar True/false state if the match should handle similar or exact formats.
			 */
			function formatChanged(formats, callback, similar) {
				var currentFormats;
	
				// Setup format node change logic
				if (!formatChangeData) {
					formatChangeData = {};
					currentFormats = {};
	
					ed.on('NodeChange', function(e) {
						var parents = getParents(e.element), matchedFormats = {};
	
						// Ignore bogus nodes like the <a> tag created by moveStart()
						parents = Tools.grep(parents, function(node) {
							return node.nodeType == 1 && !node.getAttribute('data-mce-bogus');
						});
	
						// Check for new formats
						each(formatChangeData, function(callbacks, format) {
							each(parents, function(node) {
								if (matchNode(node, format, {}, callbacks.similar)) {
									if (!currentFormats[format]) {
										// Execute callbacks
										each(callbacks, function(callback) {
											callback(true, {node: node, format: format, parents: parents});
										});
	
										currentFormats[format] = callbacks;
									}
	
									matchedFormats[format] = callbacks;
									return false;
								}
	
								if (matchesUnInheritedFormatSelector(node, format)) {
									return false;
								}
							});
						});
	
						// Check if current formats still match
						each(currentFormats, function(callbacks, format) {
							if (!matchedFormats[format]) {
								delete currentFormats[format];
	
								each(callbacks, function(callback) {
									callback(false, {node: e.element, format: format, parents: parents});
								});
							}
						});
					});
				}
	
				// Add format listeners
				each(formats.split(','), function(format) {
					if (!formatChangeData[format]) {
						formatChangeData[format] = [];
						formatChangeData[format].similar = similar;
					}
	
					formatChangeData[format].push(callback);
				});
	
				return this;
			}
	
			/**
			 * Returns a preview css text for the specified format.
			 *
			 * @method getCssText
			 * @param {String/Object} format Format to generate preview css text for.
			 * @return {String} Css text for the specified format.
			 * @example
			 * var cssText1 = editor.formatter.getCssText('bold');
			 * var cssText2 = editor.formatter.getCssText({inline: 'b'});
			 */
			function getCssText(format) {
				return Preview.getCssText(ed, format);
			}
	
			// Expose to public
			extend(this, {
				get: get,
				register: register,
				unregister: unregister,
				apply: apply,
				remove: remove,
				toggle: toggle,
				match: match,
				matchAll: matchAll,
				matchNode: matchNode,
				canApply: canApply,
				formatChanged: formatChanged,
				getCssText: getCssText
			});
	
			// Initialize
			defaultFormats();
			addKeyboardShortcuts();
			ed.on('BeforeGetContent', function(e) {
				if (markCaretContainersBogus && e.format != 'raw') {
					markCaretContainersBogus();
				}
			});
			ed.on('mouseup keydown', function(e) {
				if (disableCaretContainer) {
					disableCaretContainer(e);
				}
			});
	
			// Private functions
	
			/**
			 * Checks if the specified nodes name matches the format inline/block or selector.
			 *
			 * @private
			 * @param {Node} node Node to match against the specified format.
			 * @param {Object} format Format object o match with.
			 * @return {boolean} true/false if the format matches.
			 */
			function matchName(node, format) {
				// Check for inline match
				if (isEq(node, format.inline)) {
					return TRUE;
				}
	
				// Check for block match
				if (isEq(node, format.block)) {
					return TRUE;
				}
	
				// Check for selector match
				if (format.selector) {
					return node.nodeType == 1 && dom.is(node, format.selector);
				}
			}
	
			/**
			 * Compares two string/nodes regardless of their case.
			 *
			 * @private
			 * @param {String/Node} str1 Node or string to compare.
			 * @param {String/Node} str2 Node or string to compare.
			 * @return {boolean} True/false if they match.
			 */
			function isEq(str1, str2) {
				str1 = str1 || '';
				str2 = str2 || '';
	
				str1 = '' + (str1.nodeName || str1);
				str2 = '' + (str2.nodeName || str2);
	
				return str1.toLowerCase() == str2.toLowerCase();
			}
	
			/**
			 * Returns the style by name on the specified node. This method modifies the style
			 * contents to make it more easy to match. This will resolve a few browser issues.
			 *
			 * @private
			 * @param {Node} node to get style from.
			 * @param {String} name Style name to get.
			 * @return {String} Style item value.
			 */
			function getStyle(node, name) {
				return normalizeStyleValue(dom.getStyle(node, name), name);
			}
	
			/**
			 * Normalize style value by name. This method modifies the style contents
			 * to make it more easy to match. This will resolve a few browser issues.
			 *
			 * @private
			 * @param {String} value Value to get style from.
			 * @param {String} name Style name to get.
			 * @return {String} Style item value.
			 */
			function normalizeStyleValue(value, name) {
				// Force the format to hex
				if (name == 'color' || name == 'backgroundColor') {
					value = dom.toHex(value);
				}
	
				// Opera will return bold as 700
				if (name == 'fontWeight' && value == 700) {
					value = 'bold';
				}
	
				// Normalize fontFamily so "'Font name', Font" becomes: "Font name,Font"
				if (name == 'fontFamily') {
					value = value.replace(/[\'\"]/g, '').replace(/,\s+/g, ',');
				}
	
				return '' + value;
			}
	
			/**
			 * Replaces variables in the value. The variable format is %var.
			 *
			 * @private
			 * @param {String} value Value to replace variables in.
			 * @param {Object} vars Name/value array with variables to replace.
			 * @return {String} New value with replaced variables.
			 */
			function replaceVars(value, vars) {
				if (typeof value != "string") {
					value = value(vars);
				} else if (vars) {
					value = value.replace(/%(\w+)/g, function(str, name) {
						return vars[name] || str;
					});
				}
	
				return value;
			}
	
			function isWhiteSpaceNode(node) {
				return node && node.nodeType === 3 && /^([\t \r\n]+|)$/.test(node.nodeValue);
			}
	
			function wrap(node, name, attrs) {
				var wrapper = dom.create(name, attrs);
	
				node.parentNode.insertBefore(wrapper, node);
				wrapper.appendChild(node);
	
				return wrapper;
			}
	
			/**
			 * Expands the specified range like object to depending on format.
			 *
			 * For example on block formats it will move the start/end position
			 * to the beginning of the current block.
			 *
			 * @private
			 * @param {Object} rng Range like object.
			 * @param {Array} format Array with formats to expand by.
			 * @param {Boolean} remove
			 * @return {Object} Expanded range like object.
			 */
			function expandRng(rng, format, remove) {
				var lastIdx, leaf, endPoint,
					startContainer = rng.startContainer,
					startOffset = rng.startOffset,
					endContainer = rng.endContainer,
					endOffset = rng.endOffset;
	
				// This function walks up the tree if there is no siblings before/after the node
				function findParentContainer(start) {
					var container, parent, sibling, siblingName, root;
	
					container = parent = start ? startContainer : endContainer;
					siblingName = start ? 'previousSibling' : 'nextSibling';
					root = dom.getRoot();
	
					function isBogusBr(node) {
						return node.nodeName == "BR" && node.getAttribute('data-mce-bogus') && !node.nextSibling;
					}
	
					// If it's a text node and the offset is inside the text
					if (container.nodeType == 3 && !isWhiteSpaceNode(container)) {
						if (start ? startOffset > 0 : endOffset < container.nodeValue.length) {
							return container;
						}
					}
	
					/*eslint no-constant-condition:0 */
					while (true) {
						// Stop expanding on block elements
						if (!format[0].block_expand && isBlock(parent)) {
							return parent;
						}
	
						// Walk left/right
						for (sibling = parent[siblingName]; sibling; sibling = sibling[siblingName]) {
							if (!isBookmarkNode(sibling) && !isWhiteSpaceNode(sibling) && !isBogusBr(sibling)) {
								return parent;
							}
						}
	
						// Check if we can move up are we at root level or body level
						if (parent == root || parent.parentNode == root) {
							container = parent;
							break;
						}
	
						parent = parent.parentNode;
					}
	
					return container;
				}
	
				// This function walks down the tree to find the leaf at the selection.
				// The offset is also returned as if node initially a leaf, the offset may be in the middle of the text node.
				function findLeaf(node, offset) {
					if (offset === undef) {
						offset = node.nodeType === 3 ? node.length : node.childNodes.length;
					}
	
					while (node && node.hasChildNodes()) {
						node = node.childNodes[offset];
						if (node) {
							offset = node.nodeType === 3 ? node.length : node.childNodes.length;
						}
					}
					return {node: node, offset: offset};
				}
	
				// If index based start position then resolve it
				if (startContainer.nodeType == 1 && startContainer.hasChildNodes()) {
					lastIdx = startContainer.childNodes.length - 1;
					startContainer = startContainer.childNodes[startOffset > lastIdx ? lastIdx : startOffset];
	
					if (startContainer.nodeType == 3) {
						startOffset = 0;
					}
				}
	
				// If index based end position then resolve it
				if (endContainer.nodeType == 1 && endContainer.hasChildNodes()) {
					lastIdx = endContainer.childNodes.length - 1;
					endContainer = endContainer.childNodes[endOffset > lastIdx ? lastIdx : endOffset - 1];
	
					if (endContainer.nodeType == 3) {
						endOffset = endContainer.nodeValue.length;
					}
				}
	
				// Expands the node to the closes contentEditable false element if it exists
				function findParentContentEditable(node) {
					var parent = node;
	
					while (parent) {
						if (parent.nodeType === 1 && getContentEditable(parent)) {
							return getContentEditable(parent) === "false" ? parent : node;
						}
	
						parent = parent.parentNode;
					}
	
					return node;
				}
	
				function findWordEndPoint(container, offset, start) {
					var walker, node, pos, lastTextNode;
	
					function findSpace(node, offset) {
						var pos, pos2, str = node.nodeValue;
	
						if (typeof offset == "undefined") {
							offset = start ? str.length : 0;
						}
	
						if (start) {
							pos = str.lastIndexOf(' ', offset);
							pos2 = str.lastIndexOf('\u00a0', offset);
							pos = pos > pos2 ? pos : pos2;
	
							// Include the space on remove to avoid tag soup
							if (pos !== -1 && !remove) {
								pos++;
							}
						} else {
							pos = str.indexOf(' ', offset);
							pos2 = str.indexOf('\u00a0', offset);
							pos = pos !== -1 && (pos2 === -1 || pos < pos2) ? pos : pos2;
						}
	
						return pos;
					}
	
					if (container.nodeType === 3) {
						pos = findSpace(container, offset);
	
						if (pos !== -1) {
							return {container: container, offset: pos};
						}
	
						lastTextNode = container;
					}
	
					// Walk the nodes inside the block
					walker = new TreeWalker(container, dom.getParent(container, isBlock) || ed.getBody());
					while ((node = walker[start ? 'prev' : 'next']())) {
						if (node.nodeType === 3) {
							lastTextNode = node;
							pos = findSpace(node);
	
							if (pos !== -1) {
								return {container: node, offset: pos};
							}
						} else if (isBlock(node)) {
							break;
						}
					}
	
					if (lastTextNode) {
						if (start) {
							offset = 0;
						} else {
							offset = lastTextNode.length;
						}
	
						return {container: lastTextNode, offset: offset};
					}
				}
	
				function findSelectorEndPoint(container, sibling_name) {
					var parents, i, y, curFormat;
	
					if (container.nodeType == 3 && container.nodeValue.length === 0 && container[sibling_name]) {
						container = container[sibling_name];
					}
	
					parents = getParents(container);
					for (i = 0; i < parents.length; i++) {
						for (y = 0; y < format.length; y++) {
							curFormat = format[y];
	
							// If collapsed state is set then skip formats that doesn't match that
							if ("collapsed" in curFormat && curFormat.collapsed !== rng.collapsed) {
								continue;
							}
	
							if (dom.is(parents[i], curFormat.selector)) {
								return parents[i];
							}
						}
					}
	
					return container;
				}
	
				function findBlockEndPoint(container, sibling_name) {
					var node, root = dom.getRoot();
	
					// Expand to block of similar type
					if (!format[0].wrapper) {
						node = dom.getParent(container, format[0].block, root);
					}
	
					// Expand to first wrappable block element or any block element
					if (!node) {
						node = dom.getParent(container.nodeType == 3 ? container.parentNode : container, function(node) {
							// Fixes #6183 where it would expand to editable parent element in inline mode
							return node != root && isTextBlock(node);
						});
					}
	
					// Exclude inner lists from wrapping
					if (node && format[0].wrapper) {
						node = getParents(node, 'ul,ol').reverse()[0] || node;
					}
	
					// Didn't find a block element look for first/last wrappable element
					if (!node) {
						node = container;
	
						while (node[sibling_name] && !isBlock(node[sibling_name])) {
							node = node[sibling_name];
	
							// Break on BR but include it will be removed later on
							// we can't remove it now since we need to check if it can be wrapped
							if (isEq(node, 'br')) {
								break;
							}
						}
					}
	
					return node || container;
				}
	
				// Expand to closest contentEditable element
				startContainer = findParentContentEditable(startContainer);
				endContainer = findParentContentEditable(endContainer);
	
				// Exclude bookmark nodes if possible
				if (isBookmarkNode(startContainer.parentNode) || isBookmarkNode(startContainer)) {
					startContainer = isBookmarkNode(startContainer) ? startContainer : startContainer.parentNode;
					startContainer = startContainer.nextSibling || startContainer;
	
					if (startContainer.nodeType == 3) {
						startOffset = 0;
					}
				}
	
				if (isBookmarkNode(endContainer.parentNode) || isBookmarkNode(endContainer)) {
					endContainer = isBookmarkNode(endContainer) ? endContainer : endContainer.parentNode;
					endContainer = endContainer.previousSibling || endContainer;
	
					if (endContainer.nodeType == 3) {
						endOffset = endContainer.length;
					}
				}
	
				if (format[0].inline) {
					if (rng.collapsed) {
						// Expand left to closest word boundary
						endPoint = findWordEndPoint(startContainer, startOffset, true);
						if (endPoint) {
							startContainer = endPoint.container;
							startOffset = endPoint.offset;
						}
	
						// Expand right to closest word boundary
						endPoint = findWordEndPoint(endContainer, endOffset);
						if (endPoint) {
							endContainer = endPoint.container;
							endOffset = endPoint.offset;
						}
					}
	
					// Avoid applying formatting to a trailing space.
					leaf = findLeaf(endContainer, endOffset);
					if (leaf.node) {
						while (leaf.node && leaf.offset === 0 && leaf.node.previousSibling) {
							leaf = findLeaf(leaf.node.previousSibling);
						}
	
						if (leaf.node && leaf.offset > 0 && leaf.node.nodeType === 3 &&
								leaf.node.nodeValue.charAt(leaf.offset - 1) === ' ') {
	
							if (leaf.offset > 1) {
								endContainer = leaf.node;
								endContainer.splitText(leaf.offset - 1);
							}
						}
					}
				}
	
				// Move start/end point up the tree if the leaves are sharp and if we are in different containers
				// Example * becomes !: !<p><b><i>*text</i><i>text*</i></b></p>!
				// This will reduce the number of wrapper elements that needs to be created
				// Move start point up the tree
				if (format[0].inline || format[0].block_expand) {
					if (!format[0].inline || (startContainer.nodeType != 3 || startOffset === 0)) {
						startContainer = findParentContainer(true);
					}
	
					if (!format[0].inline || (endContainer.nodeType != 3 || endOffset === endContainer.nodeValue.length)) {
						endContainer = findParentContainer();
					}
				}
	
				// Expand start/end container to matching selector
				if (format[0].selector && format[0].expand !== FALSE && !format[0].inline) {
					// Find new startContainer/endContainer if there is better one
					startContainer = findSelectorEndPoint(startContainer, 'previousSibling');
					endContainer = findSelectorEndPoint(endContainer, 'nextSibling');
				}
	
				// Expand start/end container to matching block element or text node
				if (format[0].block || format[0].selector) {
					// Find new startContainer/endContainer if there is better one
					startContainer = findBlockEndPoint(startContainer, 'previousSibling');
					endContainer = findBlockEndPoint(endContainer, 'nextSibling');
	
					// Non block element then try to expand up the leaf
					if (format[0].block) {
						if (!isBlock(startContainer)) {
							startContainer = findParentContainer(true);
						}
	
						if (!isBlock(endContainer)) {
							endContainer = findParentContainer();
						}
					}
				}
	
				// Setup index for startContainer
				if (startContainer.nodeType == 1) {
					startOffset = nodeIndex(startContainer);
					startContainer = startContainer.parentNode;
				}
	
				// Setup index for endContainer
				if (endContainer.nodeType == 1) {
					endOffset = nodeIndex(endContainer) + 1;
					endContainer = endContainer.parentNode;
				}
	
				// Return new range like object
				return {
					startContainer: startContainer,
					startOffset: startOffset,
					endContainer: endContainer,
					endOffset: endOffset
				};
			}
	
			function isColorFormatAndAnchor(node, format) {
				return format.links && node.tagName == 'A';
			}
	
			/**
			 * Removes the specified format for the specified node. It will also remove the node if it doesn't have
			 * any attributes if the format specifies it to do so.
			 *
			 * @private
			 * @param {Object} format Format object with items to remove from node.
			 * @param {Object} vars Name/value object with variables to apply to format.
			 * @param {Node} node Node to remove the format styles on.
			 * @param {Node} compare_node Optional compare node, if specified the styles will be compared to that node.
			 * @return {Boolean} True/false if the node was removed or not.
			 */
			function removeFormat(format, vars, node, compare_node) {
				var i, attrs, stylesModified;
	
				// Check if node matches format
				if (!matchName(node, format) && !isColorFormatAndAnchor(node, format)) {
					return FALSE;
				}
	
				// Should we compare with format attribs and styles
				if (format.remove != 'all') {
					// Remove styles
					each(format.styles, function(value, name) {
						value = normalizeStyleValue(replaceVars(value, vars), name);
	
						// Indexed array
						if (typeof name === 'number') {
							name = value;
							compare_node = 0;
						}
	
						if (format.remove_similar || (!compare_node || isEq(getStyle(compare_node, name), value))) {
							dom.setStyle(node, name, '');
						}
	
						stylesModified = 1;
					});
	
					// Remove style attribute if it's empty
					if (stylesModified && dom.getAttrib(node, 'style') === '') {
						node.removeAttribute('style');
						node.removeAttribute('data-mce-style');
					}
	
					// Remove attributes
					each(format.attributes, function(value, name) {
						var valueOut;
	
						value = replaceVars(value, vars);
	
						// Indexed array
						if (typeof name === 'number') {
							name = value;
							compare_node = 0;
						}
	
						if (!compare_node || isEq(dom.getAttrib(compare_node, name), value)) {
							// Keep internal classes
							if (name == 'class') {
								value = dom.getAttrib(node, name);
								if (value) {
									// Build new class value where everything is removed except the internal prefixed classes
									valueOut = '';
									each(value.split(/\s+/), function(cls) {
										if (/mce\-\w+/.test(cls)) {
											valueOut += (valueOut ? ' ' : '') + cls;
										}
									});
	
									// We got some internal classes left
									if (valueOut) {
										dom.setAttrib(node, name, valueOut);
										return;
									}
								}
							}
	
							// IE6 has a bug where the attribute doesn't get removed correctly
							if (name == "class") {
								node.removeAttribute('className');
							}
	
							// Remove mce prefixed attributes
							if (MCE_ATTR_RE.test(name)) {
								node.removeAttribute('data-mce-' + name);
							}
	
							node.removeAttribute(name);
						}
					});
	
					// Remove classes
					each(format.classes, function(value) {
						value = replaceVars(value, vars);
	
						if (!compare_node || dom.hasClass(compare_node, value)) {
							dom.removeClass(node, value);
						}
					});
	
					// Check for non internal attributes
					attrs = dom.getAttribs(node);
					for (i = 0; i < attrs.length; i++) {
						if (attrs[i].nodeName.indexOf('_') !== 0) {
							return FALSE;
						}
					}
				}
	
				// Remove the inline child if it's empty for example <b> or <span>
				if (format.remove != 'none') {
					removeNode(node, format);
					return TRUE;
				}
			}
	
			/**
			 * Removes the node and wrap it's children in paragraphs before doing so or
			 * appends BR elements to the beginning/end of the block element if forcedRootBlocks is disabled.
			 *
			 * If the div in the node below gets removed:
			 *  text<div>text</div>text
			 *
			 * Output becomes:
			 *  text<div><br />text<br /></div>text
			 *
			 * So when the div is removed the result is:
			 *  text<br />text<br />text
			 *
			 * @private
			 * @param {Node} node Node to remove + apply BR/P elements to.
			 * @param {Object} format Format rule.
			 * @return {Node} Input node.
			 */
			function removeNode(node, format) {
				var parentNode = node.parentNode, rootBlockElm;
	
				function find(node, next, inc) {
					node = getNonWhiteSpaceSibling(node, next, inc);
	
					return !node || (node.nodeName == 'BR' || isBlock(node));
				}
	
				if (format.block) {
					if (!forcedRootBlock) {
						// Append BR elements if needed before we remove the block
						if (isBlock(node) && !isBlock(parentNode)) {
							if (!find(node, FALSE) && !find(node.firstChild, TRUE, 1)) {
								node.insertBefore(dom.create('br'), node.firstChild);
							}
	
							if (!find(node, TRUE) && !find(node.lastChild, FALSE, 1)) {
								node.appendChild(dom.create('br'));
							}
						}
					} else {
						// Wrap the block in a forcedRootBlock if we are at the root of document
						if (parentNode == dom.getRoot()) {
							if (!format.list_block || !isEq(node, format.list_block)) {
								each(grep(node.childNodes), function(node) {
									if (isValid(forcedRootBlock, node.nodeName.toLowerCase())) {
										if (!rootBlockElm) {
											rootBlockElm = wrap(node, forcedRootBlock);
											dom.setAttribs(rootBlockElm, ed.settings.forced_root_block_attrs);
										} else {
											rootBlockElm.appendChild(node);
										}
									} else {
										rootBlockElm = 0;
									}
								});
							}
						}
					}
				}
	
				// Never remove nodes that isn't the specified inline element if a selector is specified too
				if (format.selector && format.inline && !isEq(format.inline, node)) {
					return;
				}
	
				dom.remove(node, 1);
			}
	
			/**
			 * Returns the next/previous non whitespace node.
			 *
			 * @private
			 * @param {Node} node Node to start at.
			 * @param {boolean} next (Optional) Include next or previous node defaults to previous.
			 * @param {boolean} inc (Optional) Include the current node in checking. Defaults to false.
			 * @return {Node} Next or previous node or undefined if it wasn't found.
			 */
			function getNonWhiteSpaceSibling(node, next, inc) {
				if (node) {
					next = next ? 'nextSibling' : 'previousSibling';
	
					for (node = inc ? node : node[next]; node; node = node[next]) {
						if (node.nodeType == 1 || !isWhiteSpaceNode(node)) {
							return node;
						}
					}
				}
			}
	
			/**
			 * Merges the next/previous sibling element if they match.
			 *
			 * @private
			 * @param {Node} prev Previous node to compare/merge.
			 * @param {Node} next Next node to compare/merge.
			 * @return {Node} Next node if we didn't merge and prev node if we did.
			 */
			function mergeSiblings(prev, next) {
				var sibling, tmpSibling, elementUtils = new ElementUtils(dom);
	
				function findElementSibling(node, sibling_name) {
					for (sibling = node; sibling; sibling = sibling[sibling_name]) {
						if (sibling.nodeType == 3 && sibling.nodeValue.length !== 0) {
							return node;
						}
	
						if (sibling.nodeType == 1 && !isBookmarkNode(sibling)) {
							return sibling;
						}
					}
	
					return node;
				}
	
				// Check if next/prev exists and that they are elements
				if (prev && next) {
					// If previous sibling is empty then jump over it
					prev = findElementSibling(prev, 'previousSibling');
					next = findElementSibling(next, 'nextSibling');
	
					// Compare next and previous nodes
					if (elementUtils.compare(prev, next)) {
						// Append nodes between
						for (sibling = prev.nextSibling; sibling && sibling != next;) {
							tmpSibling = sibling;
							sibling = sibling.nextSibling;
							prev.appendChild(tmpSibling);
						}
	
						// Remove next node
						dom.remove(next);
	
						// Move children into prev node
						each(grep(next.childNodes), function(node) {
							prev.appendChild(node);
						});
	
						return prev;
					}
				}
	
				return next;
			}
	
			function getContainer(rng, start) {
				var container, offset, lastIdx;
	
				container = rng[start ? 'startContainer' : 'endContainer'];
				offset = rng[start ? 'startOffset' : 'endOffset'];
	
				if (container.nodeType == 1) {
					lastIdx = container.childNodes.length - 1;
	
					if (!start && offset) {
						offset--;
					}
	
					container = container.childNodes[offset > lastIdx ? lastIdx : offset];
				}
	
				// If start text node is excluded then walk to the next node
				if (container.nodeType === 3 && start && offset >= container.nodeValue.length) {
					container = new TreeWalker(container, ed.getBody()).next() || container;
				}
	
				// If end text node is excluded then walk to the previous node
				if (container.nodeType === 3 && !start && offset === 0) {
					container = new TreeWalker(container, ed.getBody()).prev() || container;
				}
	
				return container;
			}
	
			function performCaretAction(type, name, vars, similar) {
				var caretContainerId = '_mce_caret', debug = ed.settings.caret_debug;
	
				// Creates a caret container bogus element
				function createCaretContainer(fill) {
					var caretContainer = dom.create('span', {id: caretContainerId, 'data-mce-bogus': true, style: debug ? 'color:red' : ''});
	
					if (fill) {
						caretContainer.appendChild(ed.getDoc().createTextNode(INVISIBLE_CHAR));
					}
	
					return caretContainer;
				}
	
				function isCaretContainerEmpty(node, nodes) {
					while (node) {
						if ((node.nodeType === 3 && node.nodeValue !== INVISIBLE_CHAR) || node.childNodes.length > 1) {
							return false;
						}
	
						// Collect nodes
						if (nodes && node.nodeType === 1) {
							nodes.push(node);
						}
	
						node = node.firstChild;
					}
	
					return true;
				}
	
				// Returns any parent caret container element
				function getParentCaretContainer(node) {
					while (node) {
						if (node.id === caretContainerId) {
							return node;
						}
	
						node = node.parentNode;
					}
				}
	
				// Finds the first text node in the specified node
				function findFirstTextNode(node) {
					var walker;
	
					if (node) {
						walker = new TreeWalker(node, node);
	
						for (node = walker.current(); node; node = walker.next()) {
							if (node.nodeType === 3) {
								return node;
							}
						}
					}
				}
	
				// Removes the caret container for the specified node or all on the current document
				function removeCaretContainer(node, move_caret) {
					var child, rng;
	
					if (!node) {
						node = getParentCaretContainer(selection.getStart());
	
						if (!node) {
							while ((node = dom.get(caretContainerId))) {
								removeCaretContainer(node, false);
							}
						}
					} else {
						rng = selection.getRng(true);
	
						if (isCaretContainerEmpty(node)) {
							if (move_caret !== false) {
								rng.setStartBefore(node);
								rng.setEndBefore(node);
							}
	
							dom.remove(node);
						} else {
							child = findFirstTextNode(node);
	
							if (child.nodeValue.charAt(0) === INVISIBLE_CHAR) {
								child.deleteData(0, 1);
	
								// Fix for bug #6976
								if (rng.startContainer == child && rng.startOffset > 0) {
									rng.setStart(child, rng.startOffset - 1);
								}
	
								if (rng.endContainer == child && rng.endOffset > 0) {
									rng.setEnd(child, rng.endOffset - 1);
								}
							}
	
							dom.remove(node, 1);
						}
	
						selection.setRng(rng);
					}
				}
	
				// Applies formatting to the caret position
				function applyCaretFormat() {
					var rng, caretContainer, textNode, offset, bookmark, container, text;
	
					rng = selection.getRng(true);
					offset = rng.startOffset;
					container = rng.startContainer;
					text = container.nodeValue;
	
					caretContainer = getParentCaretContainer(selection.getStart());
					if (caretContainer) {
						textNode = findFirstTextNode(caretContainer);
					}
	
					// Expand to word is caret is in the middle of a text node and the char before/after is a alpha numeric character
					if (text && offset > 0 && offset < text.length && /\w/.test(text.charAt(offset)) && /\w/.test(text.charAt(offset - 1))) {
						// Get bookmark of caret position
						bookmark = selection.getBookmark();
	
						// Collapse bookmark range (WebKit)
						rng.collapse(true);
	
						// Expand the range to the closest word and split it at those points
						rng = expandRng(rng, get(name));
						rng = rangeUtils.split(rng);
	
						// Apply the format to the range
						apply(name, vars, rng);
	
						// Move selection back to caret position
						selection.moveToBookmark(bookmark);
					} else {
						if (!caretContainer || textNode.nodeValue !== INVISIBLE_CHAR) {
							caretContainer = createCaretContainer(true);
							textNode = caretContainer.firstChild;
	
							rng.insertNode(caretContainer);
							offset = 1;
	
							apply(name, vars, caretContainer);
						} else {
							apply(name, vars, caretContainer);
						}
	
						// Move selection to text node
						selection.setCursorLocation(textNode, offset);
					}
				}
	
				function removeCaretFormat() {
					var rng = selection.getRng(true), container, offset, bookmark,
						hasContentAfter, node, formatNode, parents = [], i, caretContainer;
	
					container = rng.startContainer;
					offset = rng.startOffset;
					node = container;
	
					if (container.nodeType == 3) {
						if (offset != container.nodeValue.length) {
							hasContentAfter = true;
						}
	
						node = node.parentNode;
					}
	
					while (node) {
						if (matchNode(node, name, vars, similar)) {
							formatNode = node;
							break;
						}
	
						if (node.nextSibling) {
							hasContentAfter = true;
						}
	
						parents.push(node);
						node = node.parentNode;
					}
	
					// Node doesn't have the specified format
					if (!formatNode) {
						return;
					}
	
					// Is there contents after the caret then remove the format on the element
					if (hasContentAfter) {
						// Get bookmark of caret position
						bookmark = selection.getBookmark();
	
						// Collapse bookmark range (WebKit)
						rng.collapse(true);
	
						// Expand the range to the closest word and split it at those points
						rng = expandRng(rng, get(name), true);
						rng = rangeUtils.split(rng);
	
						// Remove the format from the range
						remove(name, vars, rng);
	
						// Move selection back to caret position
						selection.moveToBookmark(bookmark);
					} else {
						caretContainer = createCaretContainer();
	
						node = caretContainer;
						for (i = parents.length - 1; i >= 0; i--) {
							node.appendChild(dom.clone(parents[i], false));
							node = node.firstChild;
						}
	
						// Insert invisible character into inner most format element
						node.appendChild(dom.doc.createTextNode(INVISIBLE_CHAR));
						node = node.firstChild;
	
						var block = dom.getParent(formatNode, isTextBlock);
	
						if (block && dom.isEmpty(block)) {
							// Replace formatNode with caretContainer when removing format from empty block like <p><b>|</b></p>
							formatNode.parentNode.replaceChild(caretContainer, formatNode);
						} else {
							// Insert caret container after the formatted node
							dom.insertAfter(caretContainer, formatNode);
						}
	
						// Move selection to text node
						selection.setCursorLocation(node, 1);
	
						// If the formatNode is empty, we can remove it safely.
						if (dom.isEmpty(formatNode)) {
							dom.remove(formatNode);
						}
					}
				}
	
				// Checks if the parent caret container node isn't empty if that is the case it
				// will remove the bogus state on all children that isn't empty
				function unmarkBogusCaretParents() {
					var caretContainer;
	
					caretContainer = getParentCaretContainer(selection.getStart());
					if (caretContainer && !dom.isEmpty(caretContainer)) {
						walk(caretContainer, function(node) {
							if (node.nodeType == 1 && node.id !== caretContainerId && !dom.isEmpty(node)) {
								dom.setAttrib(node, 'data-mce-bogus', null);
							}
						}, 'childNodes');
					}
				}
	
				// Only bind the caret events once
				if (!ed._hasCaretEvents) {
					// Mark current caret container elements as bogus when getting the contents so we don't end up with empty elements
					markCaretContainersBogus = function() {
						var nodes = [], i;
	
						if (isCaretContainerEmpty(getParentCaretContainer(selection.getStart()), nodes)) {
							// Mark children
							i = nodes.length;
							while (i--) {
								dom.setAttrib(nodes[i], 'data-mce-bogus', '1');
							}
						}
					};
	
					disableCaretContainer = function(e) {
						var keyCode = e.keyCode;
	
						removeCaretContainer();
	
						// Remove caret container if it's empty
						if (keyCode == 8 && selection.isCollapsed() && selection.getStart().innerHTML == INVISIBLE_CHAR) {
							removeCaretContainer(getParentCaretContainer(selection.getStart()));
						}
	
						// Remove caret container on keydown and it's left/right arrow keys
						if (keyCode == 37 || keyCode == 39) {
							removeCaretContainer(getParentCaretContainer(selection.getStart()));
						}
	
						unmarkBogusCaretParents();
					};
	
					// Remove bogus state if they got filled by contents using editor.selection.setContent
					ed.on('SetContent', function(e) {
						if (e.selection) {
							unmarkBogusCaretParents();
						}
					});
					ed._hasCaretEvents = true;
				}
	
				// Do apply or remove caret format
				if (type == "apply") {
					applyCaretFormat();
				} else {
					removeCaretFormat();
				}
			}
	
			/**
			 * Moves the start to the first suitable text node.
			 */
			function moveStart(rng) {
				var container = rng.startContainer,
						offset = rng.startOffset, isAtEndOfText,
						walker, node, nodes, tmpNode;
	
				if (rng.startContainer == rng.endContainer) {
					if (isInlineBlock(rng.startContainer.childNodes[rng.startOffset])) {
						return;
					}
				}
	
				// Convert text node into index if possible
				if (container.nodeType == 3 && offset >= container.nodeValue.length) {
					// Get the parent container location and walk from there
					offset = nodeIndex(container);
					container = container.parentNode;
					isAtEndOfText = true;
				}
	
				// Move startContainer/startOffset in to a suitable node
				if (container.nodeType == 1) {
					nodes = container.childNodes;
					container = nodes[Math.min(offset, nodes.length - 1)];
					walker = new TreeWalker(container, dom.getParent(container, dom.isBlock));
	
					// If offset is at end of the parent node walk to the next one
					if (offset > nodes.length - 1 || isAtEndOfText) {
						walker.next();
					}
	
					for (node = walker.current(); node; node = walker.next()) {
						if (node.nodeType == 3 && !isWhiteSpaceNode(node)) {
							// IE has a "neat" feature where it moves the start node into the closest element
							// we can avoid this by inserting an element before it and then remove it after we set the selection
							tmpNode = dom.create('a', {'data-mce-bogus': 'all'}, INVISIBLE_CHAR);
							node.parentNode.insertBefore(tmpNode, node);
	
							// Set selection and remove tmpNode
							rng.setStart(node, 0);
							selection.setRng(rng);
							dom.remove(tmpNode);
	
							return;
						}
					}
				}
			}
		};
	});
	
	// Included from: js/tinymce/classes/UndoManager.js
	
	/**
	 * UndoManager.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * This class handles the undo/redo history levels for the editor. Since the built-in undo/redo has major drawbacks a custom one was needed.
	 *
	 * @class tinymce.UndoManager
	 */
	define("tinymce/UndoManager", [
		"tinymce/util/VK",
		"tinymce/Env"
	], function(VK, Env) {
		return function(editor) {
			var self = this, index = 0, data = [], beforeBookmark, isFirstTypedCharacter, locks = 0;
	
			function getContent() {
				return editor.serializer.getTrimmedContent();
			}
	
			function setDirty(state) {
				editor.setDirty(state);
			}
	
			function addNonTypingUndoLevel(e) {
				self.typing = false;
				self.add({}, e);
			}
	
			// Add initial undo level when the editor is initialized
			editor.on('init', function() {
				self.add();
			});
	
			// Get position before an execCommand is processed
			editor.on('BeforeExecCommand', function(e) {
				var cmd = e.command;
	
				if (cmd != 'Undo' && cmd != 'Redo' && cmd != 'mceRepaint') {
					self.beforeChange();
				}
			});
	
			// Add undo level after an execCommand call was made
			editor.on('ExecCommand', function(e) {
				var cmd = e.command;
	
				if (cmd != 'Undo' && cmd != 'Redo' && cmd != 'mceRepaint') {
					addNonTypingUndoLevel(e);
				}
			});
	
			editor.on('ObjectResizeStart Cut', function() {
				self.beforeChange();
			});
	
			editor.on('SaveContent ObjectResized blur', addNonTypingUndoLevel);
			editor.on('DragEnd', addNonTypingUndoLevel);
	
			editor.on('KeyUp', function(e) {
				var keyCode = e.keyCode;
	
				// If key is prevented then don't add undo level
				// This would happen on keyboard shortcuts for example
				if (e.isDefaultPrevented()) {
					return;
				}
	
				if ((keyCode >= 33 && keyCode <= 36) || (keyCode >= 37 && keyCode <= 40) || keyCode == 45 || keyCode == 13 || e.ctrlKey) {
					addNonTypingUndoLevel();
					editor.nodeChanged();
				}
	
				if (keyCode == 46 || keyCode == 8 || (Env.mac && (keyCode == 91 || keyCode == 93))) {
					editor.nodeChanged();
				}
	
				// Fire a TypingUndo event on the first character entered
				if (isFirstTypedCharacter && self.typing) {
					// Make it dirty if the content was changed after typing the first character
					if (!editor.isDirty()) {
						setDirty(data[0] && getContent() != data[0].content);
	
						// Fire initial change event
						if (editor.isDirty()) {
							editor.fire('change', {level: data[0], lastLevel: null});
						}
					}
	
					editor.fire('TypingUndo');
					isFirstTypedCharacter = false;
					editor.nodeChanged();
				}
			});
	
			editor.on('KeyDown', function(e) {
				var keyCode = e.keyCode;
	
				// If key is prevented then don't add undo level
				// This would happen on keyboard shortcuts for example
				if (e.isDefaultPrevented()) {
					return;
				}
	
				// Is character position keys left,right,up,down,home,end,pgdown,pgup,enter
				if ((keyCode >= 33 && keyCode <= 36) || (keyCode >= 37 && keyCode <= 40) || keyCode == 45) {
					if (self.typing) {
						addNonTypingUndoLevel(e);
					}
	
					return;
				}
	
				// If key isn't Ctrl+Alt/AltGr
				var modKey = (e.ctrlKey && !e.altKey) || e.metaKey;
				if ((keyCode < 16 || keyCode > 20) && keyCode != 224 && keyCode != 91 && !self.typing && !modKey) {
					self.beforeChange();
					self.typing = true;
					self.add({}, e);
					isFirstTypedCharacter = true;
				}
			});
	
			editor.on('MouseDown', function(e) {
				if (self.typing) {
					addNonTypingUndoLevel(e);
				}
			});
	
			// Add keyboard shortcuts for undo/redo keys
			editor.addShortcut('meta+z', '', 'Undo');
			editor.addShortcut('meta+y,meta+shift+z', '', 'Redo');
	
			editor.on('AddUndo Undo Redo ClearUndos', function(e) {
				if (!e.isDefaultPrevented()) {
					editor.nodeChanged();
				}
			});
	
			/*eslint consistent-this:0 */
			self = {
				// Explode for debugging reasons
				data: data,
	
				/**
				 * State if the user is currently typing or not. This will add a typing operation into one undo
				 * level instead of one new level for each keystroke.
				 *
				 * @field {Boolean} typing
				 */
				typing: false,
	
				/**
				 * Stores away a bookmark to be used when performing an undo action so that the selection is before
				 * the change has been made.
				 *
				 * @method beforeChange
				 */
				beforeChange: function() {
					if (!locks) {
						beforeBookmark = editor.selection.getBookmark(2, true);
					}
				},
	
				/**
				 * Adds a new undo level/snapshot to the undo list.
				 *
				 * @method add
				 * @param {Object} level Optional undo level object to add.
				 * @param {DOMEvent} event Optional event responsible for the creation of the undo level.
				 * @return {Object} Undo level that got added or null it a level wasn't needed.
				 */
				add: function(level, event) {
					var i, settings = editor.settings, lastLevel;
	
					level = level || {};
					level.content = getContent();
	
					if (locks || editor.removed) {
						return null;
					}
	
					lastLevel = data[index];
					if (editor.fire('BeforeAddUndo', {level: level, lastLevel: lastLevel, originalEvent: event}).isDefaultPrevented()) {
						return null;
					}
	
					// Add undo level if needed
					if (lastLevel && lastLevel.content == level.content) {
						return null;
					}
	
					// Set before bookmark on previous level
					if (data[index]) {
						data[index].beforeBookmark = beforeBookmark;
					}
	
					// Time to compress
					if (settings.custom_undo_redo_levels) {
						if (data.length > settings.custom_undo_redo_levels) {
							for (i = 0; i < data.length - 1; i++) {
								data[i] = data[i + 1];
							}
	
							data.length--;
							index = data.length;
						}
					}
	
					// Get a non intrusive normalized bookmark
					level.bookmark = editor.selection.getBookmark(2, true);
	
					// Crop array if needed
					if (index < data.length - 1) {
						data.length = index + 1;
					}
	
					data.push(level);
					index = data.length - 1;
	
					var args = {level: level, lastLevel: lastLevel, originalEvent: event};
	
					editor.fire('AddUndo', args);
	
					if (index > 0) {
						setDirty(true);
						editor.fire('change', args);
					}
	
					return level;
				},
	
				/**
				 * Undoes the last action.
				 *
				 * @method undo
				 * @return {Object} Undo level or null if no undo was performed.
				 */
				undo: function() {
					var level;
	
					if (self.typing) {
						self.add();
						self.typing = false;
					}
	
					if (index > 0) {
						level = data[--index];
	
						editor.setContent(level.content, {format: 'raw'});
						editor.selection.moveToBookmark(level.beforeBookmark);
						setDirty(true);
	
						editor.fire('undo', {level: level});
					}
	
					return level;
				},
	
				/**
				 * Redoes the last action.
				 *
				 * @method redo
				 * @return {Object} Redo level or null if no redo was performed.
				 */
				redo: function() {
					var level;
	
					if (index < data.length - 1) {
						level = data[++index];
	
						editor.setContent(level.content, {format: 'raw'});
						editor.selection.moveToBookmark(level.bookmark);
						setDirty(true);
	
						editor.fire('redo', {level: level});
					}
	
					return level;
				},
	
				/**
				 * Removes all undo levels.
				 *
				 * @method clear
				 */
				clear: function() {
					data = [];
					index = 0;
					self.typing = false;
					editor.fire('ClearUndos');
				},
	
				/**
				 * Returns true/false if the undo manager has any undo levels.
				 *
				 * @method hasUndo
				 * @return {Boolean} true/false if the undo manager has any undo levels.
				 */
				hasUndo: function() {
					// Has undo levels or typing and content isn't the same as the initial level
					return index > 0 || (self.typing && data[0] && getContent() != data[0].content);
				},
	
				/**
				 * Returns true/false if the undo manager has any redo levels.
				 *
				 * @method hasRedo
				 * @return {Boolean} true/false if the undo manager has any redo levels.
				 */
				hasRedo: function() {
					return index < data.length - 1 && !this.typing;
				},
	
				/**
				 * Executes the specified function in an undo translation. The selection
				 * before the modification will be stored to the undo stack and if the DOM changes
				 * it will add a new undo level. Any methods within the translation that adds undo levels will
				 * be ignored. So a translation can include calls to execCommand or editor.insertContent.
				 *
				 * @method transact
				 * @param {function} callback Function to execute dom manipulation logic in.
				 */
				transact: function(callback) {
					self.beforeChange();
	
					try {
						locks++;
						callback();
					} finally {
						locks--;
					}
	
					self.add();
				}
			};
	
			return self;
		};
	});
	
	// Included from: js/tinymce/classes/EnterKey.js
	
	/**
	 * EnterKey.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * Contains logic for handling the enter key to split/generate block elements.
	 *
	 * @private
	 * @class tinymce.EnterKey
	 */
	define("tinymce/EnterKey", [
		"tinymce/dom/TreeWalker",
		"tinymce/dom/RangeUtils",
		"tinymce/Env"
	], function(TreeWalker, RangeUtils, Env) {
		var isIE = Env.ie && Env.ie < 11;
	
		return function(editor) {
			var dom = editor.dom, selection = editor.selection, settings = editor.settings;
			var undoManager = editor.undoManager, schema = editor.schema, nonEmptyElementsMap = schema.getNonEmptyElements(),
				moveCaretBeforeOnEnterElementsMap = schema.getMoveCaretBeforeOnEnterElements();
	
			function handleEnterKey(evt) {
				var rng, tmpRng, editableRoot, container, offset, parentBlock, documentMode, shiftKey,
					newBlock, fragment, containerBlock, parentBlockName, containerBlockName, newBlockName, isAfterLastNodeInContainer;
	
				// Returns true if the block can be split into two blocks or not
				function canSplitBlock(node) {
					return node &&
						dom.isBlock(node) &&
						!/^(TD|TH|CAPTION|FORM)$/.test(node.nodeName) &&
						!/^(fixed|absolute)/i.test(node.style.position) &&
						dom.getContentEditable(node) !== "true";
				}
	
				function isTableCell(node) {
					return node && /^(TD|TH|CAPTION)$/.test(node.nodeName);
				}
	
				// Renders empty block on IE
				function renderBlockOnIE(block) {
					var oldRng;
	
					if (dom.isBlock(block)) {
						oldRng = selection.getRng();
						block.appendChild(dom.create('span', null, '\u00a0'));
						selection.select(block);
						block.lastChild.outerHTML = '';
						selection.setRng(oldRng);
					}
				}
	
				// Remove the first empty inline element of the block so this: <p><b><em></em></b>x</p> becomes this: <p>x</p>
				function trimInlineElementsOnLeftSideOfBlock(block) {
					var node = block, firstChilds = [], i;
	
					if (!node) {
						return;
					}
	
					// Find inner most first child ex: <p><i><b>*</b></i></p>
					while ((node = node.firstChild)) {
						if (dom.isBlock(node)) {
							return;
						}
	
						if (node.nodeType == 1 && !nonEmptyElementsMap[node.nodeName.toLowerCase()]) {
							firstChilds.push(node);
						}
					}
	
					i = firstChilds.length;
					while (i--) {
						node = firstChilds[i];
						if (!node.hasChildNodes() || (node.firstChild == node.lastChild && node.firstChild.nodeValue === '')) {
							dom.remove(node);
						} else {
							// Remove <a> </a> see #5381
							if (node.nodeName == "A" && (node.innerText || node.textContent) === ' ') {
								dom.remove(node);
							}
						}
					}
				}
	
				// Moves the caret to a suitable position within the root for example in the first non
				// pure whitespace text node or before an image
				function moveToCaretPosition(root) {
					var walker, node, rng, lastNode = root, tempElm;
					function firstNonWhiteSpaceNodeSibling(node) {
						while (node) {
							if (node.nodeType == 1 || (node.nodeType == 3 && node.data && /[\r\n\s]/.test(node.data))) {
								return node;
							}
	
							node = node.nextSibling;
						}
					}
	
					if (!root) {
						return;
					}
	
					// Old IE versions doesn't properly render blocks with br elements in them
					// For example <p><br></p> wont be rendered correctly in a contentEditable area
					// until you remove the br producing <p></p>
					if (Env.ie && Env.ie < 9 && parentBlock && parentBlock.firstChild) {
						if (parentBlock.firstChild == parentBlock.lastChild && parentBlock.firstChild.tagName == 'BR') {
							dom.remove(parentBlock.firstChild);
						}
					}
	
					if (/^(LI|DT|DD)$/.test(root.nodeName)) {
						var firstChild = firstNonWhiteSpaceNodeSibling(root.firstChild);
	
						if (firstChild && /^(UL|OL|DL)$/.test(firstChild.nodeName)) {
							root.insertBefore(dom.doc.createTextNode('\u00a0'), root.firstChild);
						}
					}
	
					rng = dom.createRng();
	
					// Normalize whitespace to remove empty text nodes. Fix for: #6904
					// Gecko will be able to place the caret in empty text nodes but it won't render propery
					// Older IE versions will sometimes crash so for now ignore all IE versions
					if (!Env.ie) {
						root.normalize();
					}
	
					if (root.hasChildNodes()) {
						walker = new TreeWalker(root, root);
	
						while ((node = walker.current())) {
							if (node.nodeType == 3) {
								rng.setStart(node, 0);
								rng.setEnd(node, 0);
								break;
							}
	
							if (moveCaretBeforeOnEnterElementsMap[node.nodeName.toLowerCase()]) {
								rng.setStartBefore(node);
								rng.setEndBefore(node);
								break;
							}
	
							lastNode = node;
							node = walker.next();
						}
	
						if (!node) {
							rng.setStart(lastNode, 0);
							rng.setEnd(lastNode, 0);
						}
					} else {
						if (root.nodeName == 'BR') {
							if (root.nextSibling && dom.isBlock(root.nextSibling)) {
								// Trick on older IE versions to render the caret before the BR between two lists
								if (!documentMode || documentMode < 9) {
									tempElm = dom.create('br');
									root.parentNode.insertBefore(tempElm, root);
								}
	
								rng.setStartBefore(root);
								rng.setEndBefore(root);
							} else {
								rng.setStartAfter(root);
								rng.setEndAfter(root);
							}
						} else {
							rng.setStart(root, 0);
							rng.setEnd(root, 0);
						}
					}
	
					selection.setRng(rng);
	
					// Remove tempElm created for old IE:s
					dom.remove(tempElm);
					selection.scrollIntoView(root);
				}
	
				function setForcedBlockAttrs(node) {
					var forcedRootBlockName = settings.forced_root_block;
	
					if (forcedRootBlockName && forcedRootBlockName.toLowerCase() === node.tagName.toLowerCase()) {
						dom.setAttribs(node, settings.forced_root_block_attrs);
					}
				}
	
				function emptyBlock(elm) {
					// BR is needed in empty blocks on non IE browsers
					elm.innerHTML = !isIE ? '<br data-mce-bogus="1">' : '';
				}
	
				// Creates a new block element by cloning the current one or creating a new one if the name is specified
				// This function will also copy any text formatting from the parent block and add it to the new one
				function createNewBlock(name) {
					var node = container, block, clonedNode, caretNode, textInlineElements = schema.getTextInlineElements();
	
					if (name || parentBlockName == "TABLE") {
						block = dom.create(name || newBlockName);
						setForcedBlockAttrs(block);
					} else {
						block = parentBlock.cloneNode(false);
					}
	
					caretNode = block;
	
					// Clone any parent styles
					if (settings.keep_styles !== false) {
						do {
							if (textInlineElements[node.nodeName]) {
								// Never clone a caret containers
								if (node.id == '_mce_caret') {
									continue;
								}
	
								clonedNode = node.cloneNode(false);
								dom.setAttrib(clonedNode, 'id', ''); // Remove ID since it needs to be document unique
	
								if (block.hasChildNodes()) {
									clonedNode.appendChild(block.firstChild);
									block.appendChild(clonedNode);
								} else {
									caretNode = clonedNode;
									block.appendChild(clonedNode);
								}
							}
						} while ((node = node.parentNode) && node != editableRoot);
					}
	
					// BR is needed in empty blocks on non IE browsers
					if (!isIE) {
						caretNode.innerHTML = '<br data-mce-bogus="1">';
					}
	
					return block;
				}
	
				// Returns true/false if the caret is at the start/end of the parent block element
				function isCaretAtStartOrEndOfBlock(start) {
					var walker, node, name;
	
					// Caret is in the middle of a text node like "a|b"
					if (container.nodeType == 3 && (start ? offset > 0 : offset < container.nodeValue.length)) {
						return false;
					}
	
					// If after the last element in block node edge case for #5091
					if (container.parentNode == parentBlock && isAfterLastNodeInContainer && !start) {
						return true;
					}
	
					// If the caret if before the first element in parentBlock
					if (start && container.nodeType == 1 && container == parentBlock.firstChild) {
						return true;
					}
	
					// Caret can be before/after a table
					if (container.nodeName === "TABLE" || (container.previousSibling && container.previousSibling.nodeName == "TABLE")) {
						return (isAfterLastNodeInContainer && !start) || (!isAfterLastNodeInContainer && start);
					}
	
					// Walk the DOM and look for text nodes or non empty elements
					walker = new TreeWalker(container, parentBlock);
	
					// If caret is in beginning or end of a text block then jump to the next/previous node
					if (container.nodeType == 3) {
						if (start && offset === 0) {
							walker.prev();
						} else if (!start && offset == container.nodeValue.length) {
							walker.next();
						}
					}
	
					while ((node = walker.current())) {
						if (node.nodeType === 1) {
							// Ignore bogus elements
							if (!node.getAttribute('data-mce-bogus')) {
								// Keep empty elements like <img /> <input /> but not trailing br:s like <p>text|<br></p>
								name = node.nodeName.toLowerCase();
								if (nonEmptyElementsMap[name] && name !== 'br') {
									return false;
								}
							}
						} else if (node.nodeType === 3 && !/^[ \t\r\n]*$/.test(node.nodeValue)) {
							return false;
						}
	
						if (start) {
							walker.prev();
						} else {
							walker.next();
						}
					}
	
					return true;
				}
	
				// Wraps any text nodes or inline elements in the specified forced root block name
				function wrapSelfAndSiblingsInDefaultBlock(container, offset) {
					var newBlock, parentBlock, startNode, node, next, rootBlockName, blockName = newBlockName || 'P';
	
					// Not in a block element or in a table cell or caption
					parentBlock = dom.getParent(container, dom.isBlock);
					if (!parentBlock || !canSplitBlock(parentBlock)) {
						parentBlock = parentBlock || editableRoot;
	
						if (parentBlock == editor.getBody() || isTableCell(parentBlock)) {
							rootBlockName = parentBlock.nodeName.toLowerCase();
						} else {
							rootBlockName = parentBlock.parentNode.nodeName.toLowerCase();
						}
	
						if (!parentBlock.hasChildNodes()) {
							newBlock = dom.create(blockName);
							setForcedBlockAttrs(newBlock);
							parentBlock.appendChild(newBlock);
							rng.setStart(newBlock, 0);
							rng.setEnd(newBlock, 0);
							return newBlock;
						}
	
						// Find parent that is the first child of parentBlock
						node = container;
						while (node.parentNode != parentBlock) {
							node = node.parentNode;
						}
	
						// Loop left to find start node start wrapping at
						while (node && !dom.isBlock(node)) {
							startNode = node;
							node = node.previousSibling;
						}
	
						if (startNode && schema.isValidChild(rootBlockName, blockName.toLowerCase())) {
							newBlock = dom.create(blockName);
							setForcedBlockAttrs(newBlock);
							startNode.parentNode.insertBefore(newBlock, startNode);
	
							// Start wrapping until we hit a block
							node = startNode;
							while (node && !dom.isBlock(node)) {
								next = node.nextSibling;
								newBlock.appendChild(node);
								node = next;
							}
	
							// Restore range to it's past location
							rng.setStart(container, offset);
							rng.setEnd(container, offset);
						}
					}
	
					return container;
				}
	
				// Inserts a block or br before/after or in the middle of a split list of the LI is empty
				function handleEmptyListItem() {
					function isFirstOrLastLi(first) {
						var node = containerBlock[first ? 'firstChild' : 'lastChild'];
	
						// Find first/last element since there might be whitespace there
						while (node) {
							if (node.nodeType == 1) {
								break;
							}
	
							node = node[first ? 'nextSibling' : 'previousSibling'];
						}
	
						return node === parentBlock;
					}
	
					function getContainerBlock() {
						var containerBlockParent = containerBlock.parentNode;
	
						if (/^(LI|DT|DD)$/.test(containerBlockParent.nodeName)) {
							return containerBlockParent;
						}
	
						return containerBlock;
					}
	
					if (containerBlock == editor.getBody()) {
						return;
					}
	
					// Check if we are in an nested list
					var containerBlockParentName = containerBlock.parentNode.nodeName;
					if (/^(OL|UL|LI)$/.test(containerBlockParentName)) {
						newBlockName = 'LI';
					}
	
					newBlock = newBlockName ? createNewBlock(newBlockName) : dom.create('BR');
	
					if (isFirstOrLastLi(true) && isFirstOrLastLi()) {
						if (containerBlockParentName == 'LI') {
							// Nested list is inside a LI
							dom.insertAfter(newBlock, getContainerBlock());
						} else {
							// Is first and last list item then replace the OL/UL with a text block
							dom.replace(newBlock, containerBlock);
						}
					} else if (isFirstOrLastLi(true)) {
						if (containerBlockParentName == 'LI') {
							// List nested in an LI then move the list to a new sibling LI
							dom.insertAfter(newBlock, getContainerBlock());
							newBlock.appendChild(dom.doc.createTextNode(' ')); // Needed for IE so the caret can be placed
							newBlock.appendChild(containerBlock);
						} else {
							// First LI in list then remove LI and add text block before list
							containerBlock.parentNode.insertBefore(newBlock, containerBlock);
						}
					} else if (isFirstOrLastLi()) {
						// Last LI in list then remove LI and add text block after list
						dom.insertAfter(newBlock, getContainerBlock());
						renderBlockOnIE(newBlock);
					} else {
						// Middle LI in list the split the list and insert a text block in the middle
						// Extract after fragment and insert it after the current block
						containerBlock = getContainerBlock();
						tmpRng = rng.cloneRange();
						tmpRng.setStartAfter(parentBlock);
						tmpRng.setEndAfter(containerBlock);
						fragment = tmpRng.extractContents();
	
						if (newBlockName == 'LI' && fragment.firstChild.nodeName == 'LI') {
							newBlock = fragment.firstChild;
							dom.insertAfter(fragment, containerBlock);
						} else {
							dom.insertAfter(fragment, containerBlock);
							dom.insertAfter(newBlock, containerBlock);
						}
					}
	
					dom.remove(parentBlock);
					moveToCaretPosition(newBlock);
					undoManager.add();
				}
	
				// Inserts a BR element if the forced_root_block option is set to false or empty string
				function insertBr() {
					editor.execCommand("InsertLineBreak", false, evt);
				}
	
				// Trims any linebreaks at the beginning of node user for example when pressing enter in a PRE element
				function trimLeadingLineBreaks(node) {
					do {
						if (node.nodeType === 3) {
							node.nodeValue = node.nodeValue.replace(/^[\r\n]+/, '');
						}
	
						node = node.firstChild;
					} while (node);
				}
	
				function getEditableRoot(node) {
					var root = dom.getRoot(), parent, editableRoot;
	
					// Get all parents until we hit a non editable parent or the root
					parent = node;
					while (parent !== root && dom.getContentEditable(parent) !== "false") {
						if (dom.getContentEditable(parent) === "true") {
							editableRoot = parent;
						}
	
						parent = parent.parentNode;
					}
	
					return parent !== root ? editableRoot : root;
				}
	
				// Adds a BR at the end of blocks that only contains an IMG or INPUT since
				// these might be floated and then they won't expand the block
				function addBrToBlockIfNeeded(block) {
					var lastChild;
	
					// IE will render the blocks correctly other browsers needs a BR
					if (!isIE) {
						block.normalize(); // Remove empty text nodes that got left behind by the extract
	
						// Check if the block is empty or contains a floated last child
						lastChild = block.lastChild;
						if (!lastChild || (/^(left|right)$/gi.test(dom.getStyle(lastChild, 'float', true)))) {
							dom.add(block, 'br');
						}
					}
				}
	
				function insertNewBlockAfter() {
					// If the caret is at the end of a header we produce a P tag after it similar to Word unless we are in a hgroup
					if (/^(H[1-6]|PRE|FIGURE)$/.test(parentBlockName) && containerBlockName != 'HGROUP') {
						newBlock = createNewBlock(newBlockName);
					} else {
						newBlock = createNewBlock();
					}
	
					// Split the current container block element if enter is pressed inside an empty inner block element
					if (settings.end_container_on_empty_block && canSplitBlock(containerBlock) && dom.isEmpty(parentBlock)) {
						// Split container block for example a BLOCKQUOTE at the current blockParent location for example a P
						newBlock = dom.split(containerBlock, parentBlock);
					} else {
						dom.insertAfter(newBlock, parentBlock);
					}
	
					moveToCaretPosition(newBlock);
				}
	
				rng = selection.getRng(true);
	
				// Event is blocked by some other handler for example the lists plugin
				if (evt.isDefaultPrevented()) {
					return;
				}
	
				// Delete any selected contents
				if (!rng.collapsed) {
					editor.execCommand('Delete');
					return;
				}
	
				// Setup range items and newBlockName
				new RangeUtils(dom).normalize(rng);
				container = rng.startContainer;
				offset = rng.startOffset;
				newBlockName = (settings.force_p_newlines ? 'p' : '') || settings.forced_root_block;
				newBlockName = newBlockName ? newBlockName.toUpperCase() : '';
				documentMode = dom.doc.documentMode;
				shiftKey = evt.shiftKey;
	
				// Resolve node index
				if (container.nodeType == 1 && container.hasChildNodes()) {
					isAfterLastNodeInContainer = offset > container.childNodes.length - 1;
	
					container = container.childNodes[Math.min(offset, container.childNodes.length - 1)] || container;
					if (isAfterLastNodeInContainer && container.nodeType == 3) {
						offset = container.nodeValue.length;
					} else {
						offset = 0;
					}
				}
	
				// Get editable root node, normally the body element but sometimes a div or span
				editableRoot = getEditableRoot(container);
	
				// If there is no editable root then enter is done inside a contentEditable false element
				if (!editableRoot) {
					return;
				}
	
				undoManager.beforeChange();
	
				// If editable root isn't block nor the root of the editor
				if (!dom.isBlock(editableRoot) && editableRoot != dom.getRoot()) {
					if (!newBlockName || shiftKey) {
						insertBr();
					}
	
					return;
				}
	
				// Wrap the current node and it's sibling in a default block if it's needed.
				// for example this <td>text|<b>text2</b></td> will become this <td><p>text|<b>text2</p></b></td>
				// This won't happen if root blocks are disabled or the shiftKey is pressed
				if ((newBlockName && !shiftKey) || (!newBlockName && shiftKey)) {
					container = wrapSelfAndSiblingsInDefaultBlock(container, offset);
				}
	
				// Find parent block and setup empty block paddings
				parentBlock = dom.getParent(container, dom.isBlock);
				containerBlock = parentBlock ? dom.getParent(parentBlock.parentNode, dom.isBlock) : null;
	
				// Setup block names
				parentBlockName = parentBlock ? parentBlock.nodeName.toUpperCase() : ''; // IE < 9 & HTML5
				containerBlockName = containerBlock ? containerBlock.nodeName.toUpperCase() : ''; // IE < 9 & HTML5
	
				// Enter inside block contained within a LI then split or insert before/after LI
				if (containerBlockName == 'LI' && !evt.ctrlKey) {
					parentBlock = containerBlock;
					parentBlockName = containerBlockName;
				}
	
				// Handle enter in list item
				if (/^(LI|DT|DD)$/.test(parentBlockName)) {
					if (!newBlockName && shiftKey) {
						insertBr();
						return;
					}
	
					// Handle enter inside an empty list item
					if (dom.isEmpty(parentBlock)) {
						handleEmptyListItem();
						return;
					}
				}
	
				// Don't split PRE tags but insert a BR instead easier when writing code samples etc
				if (parentBlockName == 'PRE' && settings.br_in_pre !== false) {
					if (!shiftKey) {
						insertBr();
						return;
					}
				} else {
					// If no root block is configured then insert a BR by default or if the shiftKey is pressed
					if ((!newBlockName && !shiftKey && parentBlockName != 'LI') || (newBlockName && shiftKey)) {
						insertBr();
						return;
					}
				}
	
				// If parent block is root then never insert new blocks
				if (newBlockName && parentBlock === editor.getBody()) {
					return;
				}
	
				// Default block name if it's not configured
				newBlockName = newBlockName || 'P';
	
				// Insert new block before/after the parent block depending on caret location
				if (isCaretAtStartOrEndOfBlock()) {
					insertNewBlockAfter();
				} else if (isCaretAtStartOrEndOfBlock(true)) {
					// Insert new block before
					newBlock = parentBlock.parentNode.insertBefore(createNewBlock(), parentBlock);
					renderBlockOnIE(newBlock);
					moveToCaretPosition(parentBlock);
				} else {
					// Extract after fragment and insert it after the current block
					tmpRng = rng.cloneRange();
					tmpRng.setEndAfter(parentBlock);
					fragment = tmpRng.extractContents();
					trimLeadingLineBreaks(fragment);
					newBlock = fragment.firstChild;
					dom.insertAfter(fragment, parentBlock);
					trimInlineElementsOnLeftSideOfBlock(newBlock);
					addBrToBlockIfNeeded(parentBlock);
	
					if (dom.isEmpty(parentBlock)) {
						emptyBlock(parentBlock);
					}
	
					newBlock.normalize();
	
					// New block might become empty if it's <p><b>a |</b></p>
					if (dom.isEmpty(newBlock)) {
						dom.remove(newBlock);
						insertNewBlockAfter();
					} else {
						moveToCaretPosition(newBlock);
					}
				}
	
				dom.setAttrib(newBlock, 'id', ''); // Remove ID since it needs to be document unique
	
				// Allow custom handling of new blocks
				editor.fire('NewBlock', {newBlock: newBlock});
	
				undoManager.add();
			}
	
			editor.on('keydown', function(evt) {
				if (evt.keyCode == 13) {
					if (handleEnterKey(evt) !== false) {
						evt.preventDefault();
					}
				}
			});
		};
	});
	
	// Included from: js/tinymce/classes/ForceBlocks.js
	
	/**
	 * ForceBlocks.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * Makes sure that everything gets wrapped in paragraphs.
	 *
	 * @private
	 * @class tinymce.ForceBlocks
	 */
	define("tinymce/ForceBlocks", [], function() {
		return function(editor) {
			var settings = editor.settings, dom = editor.dom, selection = editor.selection;
			var schema = editor.schema, blockElements = schema.getBlockElements();
	
			function addRootBlocks() {
				var node = selection.getStart(), rootNode = editor.getBody(), rng;
				var startContainer, startOffset, endContainer, endOffset, rootBlockNode;
				var tempNode, offset = -0xFFFFFF, wrapped, restoreSelection;
				var tmpRng, rootNodeName, forcedRootBlock;
	
				forcedRootBlock = settings.forced_root_block;
	
				if (!node || node.nodeType !== 1 || !forcedRootBlock) {
					return;
				}
	
				// Check if node is wrapped in block
				while (node && node != rootNode) {
					if (blockElements[node.nodeName]) {
						return;
					}
	
					node = node.parentNode;
				}
	
				// Get current selection
				rng = selection.getRng();
				if (rng.setStart) {
					startContainer = rng.startContainer;
					startOffset = rng.startOffset;
					endContainer = rng.endContainer;
					endOffset = rng.endOffset;
	
					try {
						restoreSelection = editor.getDoc().activeElement === rootNode;
					} catch (ex) {
						// IE throws unspecified error here sometimes
					}
				} else {
					// Force control range into text range
					if (rng.item) {
						node = rng.item(0);
						rng = editor.getDoc().body.createTextRange();
						rng.moveToElementText(node);
					}
	
					restoreSelection = rng.parentElement().ownerDocument === editor.getDoc();
					tmpRng = rng.duplicate();
					tmpRng.collapse(true);
					startOffset = tmpRng.move('character', offset) * -1;
	
					if (!tmpRng.collapsed) {
						tmpRng = rng.duplicate();
						tmpRng.collapse(false);
						endOffset = (tmpRng.move('character', offset) * -1) - startOffset;
					}
				}
	
				// Wrap non block elements and text nodes
				node = rootNode.firstChild;
				rootNodeName = rootNode.nodeName.toLowerCase();
				while (node) {
					// TODO: Break this up, too complex
					if (((node.nodeType === 3 || (node.nodeType == 1 && !blockElements[node.nodeName]))) &&
						schema.isValidChild(rootNodeName, forcedRootBlock.toLowerCase())) {
						// Remove empty text nodes
						if (node.nodeType === 3 && node.nodeValue.length === 0) {
							tempNode = node;
							node = node.nextSibling;
							dom.remove(tempNode);
							continue;
						}
	
						if (!rootBlockNode) {
							rootBlockNode = dom.create(forcedRootBlock, editor.settings.forced_root_block_attrs);
							node.parentNode.insertBefore(rootBlockNode, node);
							wrapped = true;
						}
	
						tempNode = node;
						node = node.nextSibling;
						rootBlockNode.appendChild(tempNode);
					} else {
						rootBlockNode = null;
						node = node.nextSibling;
					}
				}
	
				if (wrapped && restoreSelection) {
					if (rng.setStart) {
						rng.setStart(startContainer, startOffset);
						rng.setEnd(endContainer, endOffset);
						selection.setRng(rng);
					} else {
						// Only select if the previous selection was inside the document to prevent auto focus in quirks mode
						try {
							rng = editor.getDoc().body.createTextRange();
							rng.moveToElementText(rootNode);
							rng.collapse(true);
							rng.moveStart('character', startOffset);
	
							if (endOffset > 0) {
								rng.moveEnd('character', endOffset);
							}
	
							rng.select();
						} catch (ex) {
							// Ignore
						}
					}
	
					editor.nodeChanged();
				}
			}
	
			// Force root blocks
			if (settings.forced_root_block) {
				editor.on('NodeChange', addRootBlocks);
			}
		};
	});
	
	// Included from: js/tinymce/classes/caret/CaretUtils.js
	
	/**
	 * CaretUtils.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * Utility functions shared by the caret logic.
	 *
	 * @private
	 * @class tinymce.caret.CaretUtils
	 */
	define("tinymce/caret/CaretUtils", [
		"tinymce/util/Fun",
		"tinymce/dom/TreeWalker",
		"tinymce/dom/NodeType",
		"tinymce/caret/CaretPosition",
		"tinymce/caret/CaretContainer",
		"tinymce/caret/CaretCandidate"
	], function(Fun, TreeWalker, NodeType, CaretPosition, CaretContainer, CaretCandidate) {
		var isContentEditableTrue = NodeType.isContentEditableTrue,
			isContentEditableFalse = NodeType.isContentEditableFalse,
			isBlockLike = NodeType.matchStyleValues('display', 'block table table-cell table-caption'),
			isCaretContainer = CaretContainer.isCaretContainer,
			curry = Fun.curry,
			isElement = NodeType.isElement,
			isCaretCandidate = CaretCandidate.isCaretCandidate;
	
		function isForwards(direction) {
			return direction > 0;
		}
	
		function isBackwards(direction) {
			return direction < 0;
		}
	
		function findNode(node, direction, predicateFn, rootNode, shallow) {
			var walker = new TreeWalker(node, rootNode);
	
			if (isBackwards(direction)) {
				if (isContentEditableFalse(node)) {
					node = walker.prev(true);
					if (predicateFn(node)) {
						return node;
					}
				}
	
				while ((node = walker.prev(shallow))) {
					if (predicateFn(node)) {
						return node;
					}
				}
			}
	
			if (isForwards(direction)) {
				if (isContentEditableFalse(node)) {
					node = walker.next(true);
					if (predicateFn(node)) {
						return node;
					}
				}
	
				while ((node = walker.next(shallow))) {
					if (predicateFn(node)) {
						return node;
					}
				}
			}
	
			return null;
		}
	
		function getEditingHost(node, rootNode) {
			for (node = node.parentNode; node && node != rootNode; node = node.parentNode) {
				if (isContentEditableTrue(node)) {
					return node;
				}
			}
	
			return rootNode;
		}
	
		function getParentBlock(node, rootNode) {
			while (node && node != rootNode) {
				if (isBlockLike(node)) {
					return node;
				}
	
				node = node.parentNode;
			}
	
			return null;
		}
	
		function isInSameBlock(caretPosition1, caretPosition2, rootNode) {
			return getParentBlock(caretPosition1.container(), rootNode) == getParentBlock(caretPosition2.container(), rootNode);
		}
	
		function isInSameEditingHost(caretPosition1, caretPosition2, rootNode) {
			return getEditingHost(caretPosition1.container(), rootNode) == getEditingHost(caretPosition2.container(), rootNode);
		}
	
		function getChildNodeAtRelativeOffset(relativeOffset, caretPosition) {
			var container, offset;
	
			if (!caretPosition) {
				return null;
			}
	
			container = caretPosition.container();
			offset = caretPosition.offset();
	
			if (!isElement(container)) {
				return null;
			}
	
			return container.childNodes[offset + relativeOffset];
		}
	
		function beforeAfter(before, node) {
			var range = node.ownerDocument.createRange();
	
			if (before) {
				range.setStartBefore(node);
				range.setEndBefore(node);
			} else {
				range.setStartAfter(node);
				range.setEndAfter(node);
			}
	
			return range;
		}
	
		function isNodesInSameBlock(rootNode, node1, node2) {
			return getParentBlock(node1, rootNode) == getParentBlock(node2, rootNode);
		}
	
		function lean(left, rootNode, node) {
			var sibling, siblingName;
	
			if (left) {
				siblingName = 'previousSibling';
			} else {
				siblingName = 'nextSibling';
			}
	
			while (node && node != rootNode) {
				sibling = node[siblingName];
	
				if (isCaretContainer(sibling)) {
					sibling = sibling[siblingName];
				}
	
				if (isContentEditableFalse(sibling)) {
					if (isNodesInSameBlock(rootNode, sibling, node)) {
						return sibling;
					}
	
					break;
				}
	
				if (isCaretCandidate(sibling)) {
					break;
				}
	
				node = node.parentNode;
			}
	
			return null;
		}
	
		var before = curry(beforeAfter, true);
		var after = curry(beforeAfter, false);
	
		function normalizeRange(direction, rootNode, range) {
			var node, container, offset, location;
			var leanLeft = curry(lean, true, rootNode);
			var leanRight = curry(lean, false, rootNode);
	
			container = range.startContainer;
			offset = range.startOffset;
	
			if (CaretContainer.isCaretContainerBlock(container)) {
				if (!isElement(container)) {
					container = container.parentNode;
				}
	
				location = container.getAttribute('data-mce-caret');
	
				if (location == 'before') {
					node = container.nextSibling;
					if (isContentEditableFalse(node)) {
						return before(node);
					}
				}
	
				if (location == 'after') {
					node = container.previousSibling;
					if (isContentEditableFalse(node)) {
						return after(node);
					}
				}
			}
	
			if (!range.collapsed) {
				return range;
			}
	
			if (NodeType.isText(container)) {
				if (isCaretContainer(container)) {
					if (direction === 1) {
						node = leanRight(container);
						if (node) {
							return before(node);
						}
	
						node = leanLeft(container);
						if (node) {
							return after(node);
						}
					}
	
					if (direction === -1) {
						node = leanLeft(container);
						if (node) {
							return after(node);
						}
	
						node = leanRight(container);
						if (node) {
							return before(node);
						}
					}
	
					return range;
				}
	
				if (CaretContainer.endsWithCaretContainer(container) && offset >= container.data.length - 1) {
					if (direction === 1) {
						node = leanRight(container);
						if (node) {
							return before(node);
						}
					}
	
					return range;
				}
	
				if (CaretContainer.startsWithCaretContainer(container) && offset <= 1) {
					if (direction === -1) {
						node = leanLeft(container);
						if (node) {
							return after(node);
						}
					}
	
					return range;
				}
	
				if (offset === container.data.length) {
					node = leanRight(container);
					if (node) {
						return before(node);
					}
	
					return range;
				}
	
				if (offset === 0) {
					node = leanLeft(container);
					if (node) {
						return after(node);
					}
	
					return range;
				}
			}
	
			return range;
		}
	
		function isNextToContentEditableFalse(relativeOffset, caretPosition) {
			return isContentEditableFalse(getChildNodeAtRelativeOffset(relativeOffset, caretPosition));
		}
	
		return {
			isForwards: isForwards,
			isBackwards: isBackwards,
			findNode: findNode,
			getEditingHost: getEditingHost,
			getParentBlock: getParentBlock,
			isInSameBlock: isInSameBlock,
			isInSameEditingHost: isInSameEditingHost,
			isBeforeContentEditableFalse: curry(isNextToContentEditableFalse, 0),
			isAfterContentEditableFalse: curry(isNextToContentEditableFalse, -1),
			normalizeRange: normalizeRange
		};
	});
	
	// Included from: js/tinymce/classes/caret/CaretWalker.js
	
	/**
	 * CaretWalker.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * This module contains logic for moving around a virtual caret in logical order within a DOM element.
	 *
	 * It ignores the most obvious invalid caret locations such as within a script element or within a
	 * contentEditable=false element but it will return locations that isn't possible to render visually.
	 *
	 * @private
	 * @class tinymce.caret.CaretWalker
	 * @example
	 * var caretWalker = new CaretWalker(rootElm);
	 *
	 * var prevLogicalCaretPosition = caretWalker.prev(CaretPosition.fromRangeStart(range));
	 * var nextLogicalCaretPosition = caretWalker.next(CaretPosition.fromRangeEnd(range));
	 */
	define("tinymce/caret/CaretWalker", [
		"tinymce/dom/NodeType",
		"tinymce/caret/CaretCandidate",
		"tinymce/caret/CaretPosition",
		"tinymce/caret/CaretUtils",
		"tinymce/util/Arr",
		"tinymce/util/Fun"
	], function(NodeType, CaretCandidate, CaretPosition, CaretUtils, Arr, Fun) {
		var isContentEditableFalse = NodeType.isContentEditableFalse,
			isText = NodeType.isText,
			isElement = NodeType.isElement,
			isBr = NodeType.isBr,
			isForwards = CaretUtils.isForwards,
			isBackwards = CaretUtils.isBackwards,
			isCaretCandidate = CaretCandidate.isCaretCandidate,
			isAtomic = CaretCandidate.isAtomic,
			isEditableCaretCandidate = CaretCandidate.isEditableCaretCandidate;
	
		function getParents(node, rootNode) {
			var parents = [];
	
			while (node && node != rootNode) {
				parents.push(node);
				node = node.parentNode;
			}
	
			return parents;
		}
	
		function nodeAtIndex(container, offset) {
			if (container.hasChildNodes() && offset < container.childNodes.length) {
				return container.childNodes[offset];
			}
	
			return null;
		}
	
		function getCaretCandidatePosition(direction, node) {
			if (isForwards(direction)) {
				if (isCaretCandidate(node.previousSibling) && !isText(node.previousSibling)) {
					return CaretPosition.before(node);
				}
	
				if (isText(node)) {
					return CaretPosition(node, 0);
				}
			}
	
			if (isBackwards(direction)) {
				if (isCaretCandidate(node.nextSibling) && !isText(node.nextSibling)) {
					return CaretPosition.after(node);
				}
	
				if (isText(node)) {
					return CaretPosition(node, node.data.length);
				}
			}
	
			if (isBackwards(direction)) {
				if (isBr(node)) {
					return CaretPosition.before(node);
				}
	
				return CaretPosition.after(node);
			}
	
			return CaretPosition.before(node);
		}
	
		// Jumps over BR elements <p>|<br></p><p>a</p> -> <p><br></p><p>|a</p>
		function isBrBeforeBlock(node, rootNode) {
			var next;
	
			if (!NodeType.isBr(node)) {
				return false;
			}
	
			next = findCaretPosition(1, CaretPosition.after(node), rootNode);
			if (!next) {
				return false;
			}
	
			return !CaretUtils.isInSameBlock(CaretPosition.before(node), CaretPosition.before(next), rootNode);
		}
	
		function findCaretPosition(direction, startCaretPosition, rootNode) {
			var container, offset, node, nextNode, innerNode,
				rootContentEditableFalseElm, caretPosition;
	
			if (!isElement(rootNode) || !startCaretPosition) {
				return null;
			}
	
			caretPosition = startCaretPosition;
			container = caretPosition.container();
			offset = caretPosition.offset();
	
			if (isText(container)) {
				if (isBackwards(direction) && offset > 0) {
					return CaretPosition(container, --offset);
				}
	
				if (isForwards(direction) && offset < container.length) {
					return CaretPosition(container, ++offset);
				}
	
				node = container;
			} else {
				if (isBackwards(direction) && offset > 0) {
					nextNode = nodeAtIndex(container, offset - 1);
					if (isCaretCandidate(nextNode)) {
						if (!isAtomic(nextNode)) {
							innerNode = CaretUtils.findNode(nextNode, direction, isEditableCaretCandidate, nextNode);
							if (innerNode) {
								if (isText(innerNode)) {
									return CaretPosition(innerNode, innerNode.data.length);
								}
	
								return CaretPosition.after(innerNode);
							}
						}
	
						if (isText(nextNode)) {
							return CaretPosition(nextNode, nextNode.data.length);
						}
	
						return CaretPosition.before(nextNode);
					}
				}
	
				if (isForwards(direction) && offset < container.childNodes.length) {
					nextNode = nodeAtIndex(container, offset);
					if (isCaretCandidate(nextNode)) {
						if (isBrBeforeBlock(nextNode, rootNode)) {
							return findCaretPosition(direction, CaretPosition.after(nextNode), rootNode);
						}
	
						if (!isAtomic(nextNode)) {
							innerNode = CaretUtils.findNode(nextNode, direction, isEditableCaretCandidate, nextNode);
							if (innerNode) {
								if (isText(innerNode)) {
									return CaretPosition(innerNode, 0);
								}
	
								return CaretPosition.before(innerNode);
							}
						}
	
						if (isText(nextNode)) {
							return CaretPosition(nextNode, 0);
						}
	
						return CaretPosition.after(nextNode);
					}
				}
	
				node = caretPosition.getNode();
			}
	
			if ((isForwards(direction) && caretPosition.isAtEnd()) || (isBackwards(direction) && caretPosition.isAtStart())) {
				node = CaretUtils.findNode(node, direction, Fun.constant(true), rootNode, true);
				if (isEditableCaretCandidate(node)) {
					return getCaretCandidatePosition(direction, node);
				}
			}
	
			nextNode = CaretUtils.findNode(node, direction, isEditableCaretCandidate, rootNode);
	
			rootContentEditableFalseElm = Arr.last(Arr.filter(getParents(container, rootNode), isContentEditableFalse));
			if (rootContentEditableFalseElm && (!nextNode || !rootContentEditableFalseElm.contains(nextNode))) {
				if (isForwards(direction)) {
					caretPosition = CaretPosition.after(rootContentEditableFalseElm);
				} else {
					caretPosition = CaretPosition.before(rootContentEditableFalseElm);
				}
	
				return caretPosition;
			}
	
			if (nextNode) {
				return getCaretCandidatePosition(direction, nextNode);
			}
	
			return null;
		}
	
		return function(rootNode) {
			return {
				/**
				 * Returns the next logical caret position from the specificed input
				 * caretPoisiton or null if there isn't any more positions left for example
				 * at the end specified root element.
				 *
				 * @method next
				 * @param {tinymce.caret.CaretPosition} caretPosition Caret position to start from.
				 * @return {tinymce.caret.CaretPosition} CaretPosition or null if no position was found.
				 */
				next: function(caretPosition) {
					return findCaretPosition(1, caretPosition, rootNode);
				},
	
				/**
				 * Returns the previous logical caret position from the specificed input
				 * caretPoisiton or null if there isn't any more positions left for example
				 * at the end specified root element.
				 *
				 * @method prev
				 * @param {tinymce.caret.CaretPosition} caretPosition Caret position to start from.
				 * @return {tinymce.caret.CaretPosition} CaretPosition or null if no position was found.
				 */
				prev: function(caretPosition) {
					return findCaretPosition(-1, caretPosition, rootNode);
				}
			};
		};
	});
	
	// Included from: js/tinymce/classes/InsertList.js
	
	/**
	 * InsertList.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2016 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * Handles inserts of lists into the editor instance.
	 *
	 * @class tinymce.InsertList
	 * @private
	 */
	define("tinymce/InsertList", [
		"tinymce/util/Tools",
		"tinymce/caret/CaretWalker",
		"tinymce/caret/CaretPosition"
	], function(Tools, CaretWalker, CaretPosition) {
		var isListFragment = function(fragment) {
			var firstChild = fragment.firstChild;
			var lastChild = fragment.lastChild;
	
			// Skip meta since it's likely <meta><ul>..</ul>
			if (firstChild && firstChild.name === 'meta') {
				firstChild = firstChild.next;
			}
	
			// Skip mce_marker since it's likely <ul>..</ul><span id="mce_marker"></span>
			if (lastChild && lastChild.attr('id') === 'mce_marker') {
				lastChild = lastChild.prev;
			}
	
			if (!firstChild || firstChild !== lastChild) {
				return false;
			}
	
			return firstChild.name === 'ul' || firstChild.name === 'ol';
		};
	
		var cleanupDomFragment = function (domFragment) {
			var firstChild = domFragment.firstChild;
			var lastChild = domFragment.lastChild;
	
			// TODO: remove the meta tag from paste logic
			if (firstChild && firstChild.nodeName === 'META') {
				firstChild.parentNode.removeChild(firstChild);
			}
	
			if (lastChild && lastChild.id === 'mce_marker') {
				lastChild.parentNode.removeChild(lastChild);
			}
	
			return domFragment;
		};
	
		var toDomFragment = function(dom, serializer, fragment) {
			var html = serializer.serialize(fragment);
			var domFragment = dom.createFragment(html);
	
			return cleanupDomFragment(domFragment);
		};
	
		var listItems = function(elm) {
			return Tools.grep(elm.childNodes, function(child) {
				return child.nodeName === 'LI';
			});
		};
	
		var isEmpty = function (elm) {
			return !elm.firstChild;
		};
	
		var trimListItems = function(elms) {
			return elms.length > 0 && isEmpty(elms[elms.length - 1]) ? elms.slice(0, -1) : elms;
		};
	
		var getParentLi = function(dom, node) {
			var parentBlock = dom.getParent(node, dom.isBlock);
			return parentBlock && parentBlock.nodeName === 'LI' ? parentBlock : null;
		};
	
		var isParentBlockLi = function(dom, node) {
			return !!getParentLi(dom, node);
		};
	
		var getSplit = function(parentNode, rng) {
			var beforeRng = rng.cloneRange();
			var afterRng = rng.cloneRange();
	
			beforeRng.setStartBefore(parentNode);
			afterRng.setEndAfter(parentNode);
	
			return [
				beforeRng.cloneContents(),
				afterRng.cloneContents()
			];
		};
	
		var findFirstIn = function(node, rootNode) {
			var caretPos = CaretPosition.before(node);
			var caretWalker = new CaretWalker(rootNode);
			var newCaretPos = caretWalker.next(caretPos);
	
			return newCaretPos ? newCaretPos.toRange() : null;
		};
	
		var findLastOf = function(node, rootNode) {
			var caretPos = CaretPosition.after(node);
			var caretWalker = new CaretWalker(rootNode);
			var newCaretPos = caretWalker.prev(caretPos);
	
			return newCaretPos ? newCaretPos.toRange() : null;
		};
	
		var insertMiddle = function(target, elms, rootNode, rng) {
			var parts = getSplit(target, rng);
			var parentElm = target.parentNode;
	
			parentElm.insertBefore(parts[0], target);
			Tools.each(elms, function(li) {
				parentElm.insertBefore(li, target);
			});
			parentElm.insertBefore(parts[1], target);
			parentElm.removeChild(target);
	
			return findLastOf(elms[elms.length - 1], rootNode);
		};
	
		var insertBefore = function(target, elms, rootNode) {
			var parentElm = target.parentNode;
	
			Tools.each(elms, function(elm) {
				parentElm.insertBefore(elm, target);
			});
	
			return findFirstIn(target, rootNode);
		};
	
		var insertAfter = function(target, elms, rootNode, dom) {
			dom.insertAfter(elms.reverse(), target);
			return findLastOf(elms[0], rootNode);
		};
	
		var insertAtCaret = function(serializer, dom, rng, fragment) {
			var domFragment = toDomFragment(dom, serializer, fragment);
			var liTarget = getParentLi(dom, rng.startContainer);
			var liElms = trimListItems(listItems(domFragment.firstChild));
			var BEGINNING = 1, END = 2;
			var rootNode = dom.getRoot();
	
			var isAt = function(location) {
				var caretPos = CaretPosition.fromRangeStart(rng);
				var caretWalker = new CaretWalker(dom.getRoot());
				var newPos = location === BEGINNING ? caretWalker.prev(caretPos) : caretWalker.next(caretPos);
	
				return newPos ? getParentLi(dom, newPos.getNode()) !== liTarget : true;
			};
	
			if (isAt(BEGINNING)) {
				return insertBefore(liTarget, liElms, rootNode);
			} else if (isAt(END)) {
				return insertAfter(liTarget, liElms, rootNode, dom);
			}
	
			return insertMiddle(liTarget, liElms, rootNode, rng);
		};
	
		return {
			isListFragment: isListFragment,
			insertAtCaret: insertAtCaret,
			isParentBlockLi: isParentBlockLi,
			trimListItems: trimListItems,
			listItems: listItems
		};
	});
	
	// Included from: js/tinymce/classes/InsertContent.js
	
	/**
	 * InsertContent.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2016 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * Handles inserts of contents into the editor instance.
	 *
	 * @class tinymce.InsertContent
	 * @private
	 */
	define("tinymce/InsertContent", [
		"tinymce/Env",
		"tinymce/util/Tools",
		"tinymce/html/Serializer",
		"tinymce/caret/CaretWalker",
		"tinymce/caret/CaretPosition",
		"tinymce/dom/ElementUtils",
		"tinymce/dom/NodeType",
		"tinymce/InsertList"
	], function(Env, Tools, Serializer, CaretWalker, CaretPosition, ElementUtils, NodeType, InsertList) {
		var isTableCell = NodeType.matchNodeNames('td th');
	
		var insertAtCaret = function(editor, value) {
			var parser, serializer, parentNode, rootNode, fragment, args;
			var marker, rng, node, node2, bookmarkHtml, merge, data;
			var textInlineElements = editor.schema.getTextInlineElements();
			var selection = editor.selection, dom = editor.dom;
	
			function trimOrPaddLeftRight(html) {
				var rng, container, offset;
	
				rng = selection.getRng(true);
				container = rng.startContainer;
				offset = rng.startOffset;
	
				function hasSiblingText(siblingName) {
					return container[siblingName] && container[siblingName].nodeType == 3;
				}
	
				if (container.nodeType == 3) {
					if (offset > 0) {
						html = html.replace(/^&nbsp;/, ' ');
					} else if (!hasSiblingText('previousSibling')) {
						html = html.replace(/^ /, '&nbsp;');
					}
	
					if (offset < container.length) {
						html = html.replace(/&nbsp;(<br>|)$/, ' ');
					} else if (!hasSiblingText('nextSibling')) {
						html = html.replace(/(&nbsp;| )(<br>|)$/, '&nbsp;');
					}
				}
	
				return html;
			}
	
			// Removes &nbsp; from a [b] c -> a &nbsp;c -> a c
			function trimNbspAfterDeleteAndPaddValue() {
				var rng, container, offset;
	
				rng = selection.getRng(true);
				container = rng.startContainer;
				offset = rng.startOffset;
	
				if (container.nodeType == 3 && rng.collapsed) {
					if (container.data[offset] === '\u00a0') {
						container.deleteData(offset, 1);
	
						if (!/[\u00a0| ]$/.test(value)) {
							value += ' ';
						}
					} else if (container.data[offset - 1] === '\u00a0') {
						container.deleteData(offset - 1, 1);
	
						if (!/[\u00a0| ]$/.test(value)) {
							value = ' ' + value;
						}
					}
				}
			}
	
			function markInlineFormatElements(fragment) {
				if (merge) {
					for (node = fragment.firstChild; node; node = node.walk(true)) {
						if (textInlineElements[node.name]) {
							node.attr('data-mce-new', "true");
						}
					}
				}
			}
	
			function reduceInlineTextElements() {
				if (merge) {
					var root = editor.getBody(), elementUtils = new ElementUtils(dom);
	
					Tools.each(dom.select('*[data-mce-new]'), function(node) {
						node.removeAttribute('data-mce-new');
	
						for (var testNode = node.parentNode; testNode && testNode != root; testNode = testNode.parentNode) {
							if (elementUtils.compare(testNode, node)) {
								dom.remove(node, true);
							}
						}
					});
				}
			}
	
			function markFragmentElements(fragment) {
				var node = fragment;
	
				while ((node = node.walk())) {
					if (node.type === 1) {
						node.attr('data-mce-fragment', '1');
					}
				}
			}
	
			function umarkFragmentElements(elm) {
				Tools.each(elm.getElementsByTagName('*'), function(elm) {
					elm.removeAttribute('data-mce-fragment');
				});
			}
	
			function isPartOfFragment(node) {
				return !!node.getAttribute('data-mce-fragment');
			}
	
			function canHaveChildren(node) {
				return node && !editor.schema.getShortEndedElements()[node.nodeName];
			}
	
			function moveSelectionToMarker(marker) {
				var parentEditableFalseElm, parentBlock, nextRng;
	
				function getContentEditableFalseParent(node) {
					var root = editor.getBody();
	
					for (; node && node !== root; node = node.parentNode) {
						if (editor.dom.getContentEditable(node) === 'false') {
							return node;
						}
					}
	
					return null;
				}
	
				if (!marker) {
					return;
				}
	
				selection.scrollIntoView(marker);
	
				// If marker is in cE=false then move selection to that element instead
				parentEditableFalseElm = getContentEditableFalseParent(marker);
				if (parentEditableFalseElm) {
					dom.remove(marker);
					selection.select(parentEditableFalseElm);
					return;
				}
	
				// Move selection before marker and remove it
				rng = dom.createRng();
	
				// If previous sibling is a text node set the selection to the end of that node
				node = marker.previousSibling;
				if (node && node.nodeType == 3) {
					rng.setStart(node, node.nodeValue.length);
	
					// TODO: Why can't we normalize on IE
					if (!Env.ie) {
						node2 = marker.nextSibling;
						if (node2 && node2.nodeType == 3) {
							node.appendData(node2.data);
							node2.parentNode.removeChild(node2);
						}
					}
				} else {
					// If the previous sibling isn't a text node or doesn't exist set the selection before the marker node
					rng.setStartBefore(marker);
					rng.setEndBefore(marker);
				}
	
				function findNextCaretRng(rng) {
					var caretPos = CaretPosition.fromRangeStart(rng);
					var caretWalker = new CaretWalker(editor.getBody());
	
					caretPos = caretWalker.next(caretPos);
					if (caretPos) {
						return caretPos.toRange();
					}
				}
	
				// Remove the marker node and set the new range
				parentBlock = dom.getParent(marker, dom.isBlock);
				dom.remove(marker);
	
				if (parentBlock && dom.isEmpty(parentBlock)) {
					editor.$(parentBlock).empty();
	
					rng.setStart(parentBlock, 0);
					rng.setEnd(parentBlock, 0);
	
					if (!isTableCell(parentBlock) && !isPartOfFragment(parentBlock) && (nextRng = findNextCaretRng(rng))) {
						rng = nextRng;
						dom.remove(parentBlock);
					} else {
						dom.add(parentBlock, dom.create('br', {'data-mce-bogus': '1'}));
					}
				}
	
				selection.setRng(rng);
			}
	
			if (typeof value != 'string') {
				merge = value.merge;
				data = value.data;
				value = value.content;
			}
	
			// Check for whitespace before/after value
			if (/^ | $/.test(value)) {
				value = trimOrPaddLeftRight(value);
			}
	
			// Setup parser and serializer
			parser = editor.parser;
			serializer = new Serializer({
				validate: editor.settings.validate
			}, editor.schema);
			bookmarkHtml = '<span id="mce_marker" data-mce-type="bookmark">&#xFEFF;&#x200B;</span>';
	
			// Run beforeSetContent handlers on the HTML to be inserted
			args = {content: value, format: 'html', selection: true};
			editor.fire('BeforeSetContent', args);
			value = args.content;
	
			// Add caret at end of contents if it's missing
			if (value.indexOf('{$caret}') == -1) {
				value += '{$caret}';
			}
	
			// Replace the caret marker with a span bookmark element
			value = value.replace(/\{\$caret\}/, bookmarkHtml);
	
			// If selection is at <body>|<p></p> then move it into <body><p>|</p>
			rng = selection.getRng();
			var caretElement = rng.startContainer || (rng.parentElement ? rng.parentElement() : null);
			var body = editor.getBody();
			if (caretElement === body && selection.isCollapsed()) {
				if (dom.isBlock(body.firstChild) && canHaveChildren(body.firstChild) && dom.isEmpty(body.firstChild)) {
					rng = dom.createRng();
					rng.setStart(body.firstChild, 0);
					rng.setEnd(body.firstChild, 0);
					selection.setRng(rng);
				}
			}
	
			// Insert node maker where we will insert the new HTML and get it's parent
			if (!selection.isCollapsed()) {
				// Fix for #2595 seems that delete removes one extra character on
				// WebKit for some odd reason if you double click select a word
				editor.selection.setRng(editor.selection.getRng());
				editor.getDoc().execCommand('Delete', false, null);
				trimNbspAfterDeleteAndPaddValue();
			}
	
			parentNode = selection.getNode();
	
			// Parse the fragment within the context of the parent node
			var parserArgs = {context: parentNode.nodeName.toLowerCase(), data: data};
			fragment = parser.parse(value, parserArgs);
	
			// Custom handling of lists
			if (InsertList.isListFragment(fragment) && InsertList.isParentBlockLi(dom, parentNode)) {
				rng = InsertList.insertAtCaret(serializer, dom, editor.selection.getRng(), fragment);
				editor.selection.setRng(rng);
				editor.fire('SetContent', args);
				return;
			}
	
			markFragmentElements(fragment);
			markInlineFormatElements(fragment);
	
			// Move the caret to a more suitable location
			node = fragment.lastChild;
			if (node.attr('id') == 'mce_marker') {
				marker = node;
	
				for (node = node.prev; node; node = node.walk(true)) {
					if (node.type == 3 || !dom.isBlock(node.name)) {
						if (editor.schema.isValidChild(node.parent.name, 'span')) {
							node.parent.insert(marker, node, node.name === 'br');
						}
						break;
					}
				}
			}
	
			editor._selectionOverrides.showBlockCaretContainer(parentNode);
	
			// If parser says valid we can insert the contents into that parent
			if (!parserArgs.invalid) {
				value = serializer.serialize(fragment);
	
				// Check if parent is empty or only has one BR element then set the innerHTML of that parent
				node = parentNode.firstChild;
				node2 = parentNode.lastChild;
				if (!node || (node === node2 && node.nodeName === 'BR')) {
					dom.setHTML(parentNode, value);
				} else {
					selection.setContent(value);
				}
			} else {
				// If the fragment was invalid within that context then we need
				// to parse and process the parent it's inserted into
	
				// Insert bookmark node and get the parent
				selection.setContent(bookmarkHtml);
				parentNode = selection.getNode();
				rootNode = editor.getBody();
	
				// Opera will return the document node when selection is in root
				if (parentNode.nodeType == 9) {
					parentNode = node = rootNode;
				} else {
					node = parentNode;
				}
	
				// Find the ancestor just before the root element
				while (node !== rootNode) {
					parentNode = node;
					node = node.parentNode;
				}
	
				// Get the outer/inner HTML depending on if we are in the root and parser and serialize that
				value = parentNode == rootNode ? rootNode.innerHTML : dom.getOuterHTML(parentNode);
				value = serializer.serialize(
					parser.parse(
						// Need to replace by using a function since $ in the contents would otherwise be a problem
						value.replace(/<span (id="mce_marker"|id=mce_marker).+?<\/span>/i, function() {
							return serializer.serialize(fragment);
						})
					)
				);
	
				// Set the inner/outer HTML depending on if we are in the root or not
				if (parentNode == rootNode) {
					dom.setHTML(rootNode, value);
				} else {
					dom.setOuterHTML(parentNode, value);
				}
			}
	
			reduceInlineTextElements();
			moveSelectionToMarker(dom.get('mce_marker'));
			umarkFragmentElements(editor.getBody());
			editor.fire('SetContent', args);
			editor.addVisual();
		};
	
		return {
			insertAtCaret: insertAtCaret
		};
	});
	
	// Included from: js/tinymce/classes/EditorCommands.js
	
	/**
	 * EditorCommands.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * This class enables you to add custom editor commands and it contains
	 * overrides for native browser commands to address various bugs and issues.
	 *
	 * @class tinymce.EditorCommands
	 */
	define("tinymce/EditorCommands", [
		"tinymce/Env",
		"tinymce/util/Tools",
		"tinymce/dom/RangeUtils",
		"tinymce/dom/TreeWalker",
		"tinymce/InsertContent"
	], function(Env, Tools, RangeUtils, TreeWalker, InsertContent) {
		// Added for compression purposes
		var each = Tools.each, extend = Tools.extend;
		var map = Tools.map, inArray = Tools.inArray, explode = Tools.explode;
		var isOldIE = Env.ie && Env.ie < 11;
		var TRUE = true, FALSE = false;
	
		return function(editor) {
			var dom, selection, formatter,
				commands = {state: {}, exec: {}, value: {}},
				settings = editor.settings,
				bookmark;
	
			editor.on('PreInit', function() {
				dom = editor.dom;
				selection = editor.selection;
				settings = editor.settings;
				formatter = editor.formatter;
			});
	
			/**
			 * Executes the specified command.
			 *
			 * @method execCommand
			 * @param {String} command Command to execute.
			 * @param {Boolean} ui Optional user interface state.
			 * @param {Object} value Optional value for command.
			 * @param {Object} args Optional extra arguments to the execCommand.
			 * @return {Boolean} true/false if the command was found or not.
			 */
			function execCommand(command, ui, value, args) {
				var func, customCommand, state = 0;
	
				if (!/^(mceAddUndoLevel|mceEndUndoLevel|mceBeginUndoLevel|mceRepaint)$/.test(command) && (!args || !args.skip_focus)) {
					editor.focus();
				}
	
				args = editor.fire('BeforeExecCommand', {command: command, ui: ui, value: value});
				if (args.isDefaultPrevented()) {
					return false;
				}
	
				customCommand = command.toLowerCase();
				if ((func = commands.exec[customCommand])) {
					func(customCommand, ui, value);
					editor.fire('ExecCommand', {command: command, ui: ui, value: value});
					return true;
				}
	
				// Plugin commands
				each(editor.plugins, function(p) {
					if (p.execCommand && p.execCommand(command, ui, value)) {
						editor.fire('ExecCommand', {command: command, ui: ui, value: value});
						state = true;
						return false;
					}
				});
	
				if (state) {
					return state;
				}
	
				// Theme commands
				if (editor.theme && editor.theme.execCommand && editor.theme.execCommand(command, ui, value)) {
					editor.fire('ExecCommand', {command: command, ui: ui, value: value});
					return true;
				}
	
				// Browser commands
				try {
					state = editor.getDoc().execCommand(command, ui, value);
				} catch (ex) {
					// Ignore old IE errors
				}
	
				if (state) {
					editor.fire('ExecCommand', {command: command, ui: ui, value: value});
					return true;
				}
	
				return false;
			}
	
			/**
			 * Queries the current state for a command for example if the current selection is "bold".
			 *
			 * @method queryCommandState
			 * @param {String} command Command to check the state of.
			 * @return {Boolean/Number} true/false if the selected contents is bold or not, -1 if it's not found.
			 */
			function queryCommandState(command) {
				var func;
	
				// Is hidden then return undefined
				if (editor.quirks.isHidden()) {
					return;
				}
	
				command = command.toLowerCase();
				if ((func = commands.state[command])) {
					return func(command);
				}
	
				// Browser commands
				try {
					return editor.getDoc().queryCommandState(command);
				} catch (ex) {
					// Fails sometimes see bug: 1896577
				}
	
				return false;
			}
	
			/**
			 * Queries the command value for example the current fontsize.
			 *
			 * @method queryCommandValue
			 * @param {String} command Command to check the value of.
			 * @return {Object} Command value of false if it's not found.
			 */
			function queryCommandValue(command) {
				var func;
	
				// Is hidden then return undefined
				if (editor.quirks.isHidden()) {
					return;
				}
	
				command = command.toLowerCase();
				if ((func = commands.value[command])) {
					return func(command);
				}
	
				// Browser commands
				try {
					return editor.getDoc().queryCommandValue(command);
				} catch (ex) {
					// Fails sometimes see bug: 1896577
				}
			}
	
			/**
			 * Adds commands to the command collection.
			 *
			 * @method addCommands
			 * @param {Object} command_list Name/value collection with commands to add, the names can also be comma separated.
			 * @param {String} type Optional type to add, defaults to exec. Can be value or state as well.
			 */
			function addCommands(command_list, type) {
				type = type || 'exec';
	
				each(command_list, function(callback, command) {
					each(command.toLowerCase().split(','), function(command) {
						commands[type][command] = callback;
					});
				});
			}
	
			function addCommand(command, callback, scope) {
				command = command.toLowerCase();
				commands.exec[command] = function(command, ui, value, args) {
					return callback.call(scope || editor, ui, value, args);
				};
			}
	
			/**
			 * Returns true/false if the command is supported or not.
			 *
			 * @method queryCommandSupported
			 * @param {String} command Command that we check support for.
			 * @return {Boolean} true/false if the command is supported or not.
			 */
			function queryCommandSupported(command) {
				command = command.toLowerCase();
	
				if (commands.exec[command]) {
					return true;
				}
	
				// Browser commands
				try {
					return editor.getDoc().queryCommandSupported(command);
				} catch (ex) {
					// Fails sometimes see bug: 1896577
				}
	
				return false;
			}
	
			function addQueryStateHandler(command, callback, scope) {
				command = command.toLowerCase();
				commands.state[command] = function() {
					return callback.call(scope || editor);
				};
			}
	
			function addQueryValueHandler(command, callback, scope) {
				command = command.toLowerCase();
				commands.value[command] = function() {
					return callback.call(scope || editor);
				};
			}
	
			function hasCustomCommand(command) {
				command = command.toLowerCase();
				return !!commands.exec[command];
			}
	
			// Expose public methods
			extend(this, {
				execCommand: execCommand,
				queryCommandState: queryCommandState,
				queryCommandValue: queryCommandValue,
				queryCommandSupported: queryCommandSupported,
				addCommands: addCommands,
				addCommand: addCommand,
				addQueryStateHandler: addQueryStateHandler,
				addQueryValueHandler: addQueryValueHandler,
				hasCustomCommand: hasCustomCommand
			});
	
			// Private methods
	
			function execNativeCommand(command, ui, value) {
				if (ui === undefined) {
					ui = FALSE;
				}
	
				if (value === undefined) {
					value = null;
				}
	
				return editor.getDoc().execCommand(command, ui, value);
			}
	
			function isFormatMatch(name) {
				return formatter.match(name);
			}
	
			function toggleFormat(name, value) {
				formatter.toggle(name, value ? {value: value} : undefined);
				editor.nodeChanged();
			}
	
			function storeSelection(type) {
				bookmark = selection.getBookmark(type);
			}
	
			function restoreSelection() {
				selection.moveToBookmark(bookmark);
			}
	
			// Add execCommand overrides
			addCommands({
				// Ignore these, added for compatibility
				'mceResetDesignMode,mceBeginUndoLevel': function() {},
	
				// Add undo manager logic
				'mceEndUndoLevel,mceAddUndoLevel': function() {
					editor.undoManager.add();
				},
	
				'Cut,Copy,Paste': function(command) {
					var doc = editor.getDoc(), failed;
	
					// Try executing the native command
					try {
						execNativeCommand(command);
					} catch (ex) {
						// Command failed
						failed = TRUE;
					}
	
					// Chrome reports the paste command as supported however older IE:s will return false for cut/paste
					if (command === 'paste' && !doc.queryCommandEnabled(command)) {
						failed = true;
					}
	
					// Present alert message about clipboard access not being available
					if (failed || !doc.queryCommandSupported(command)) {
						var msg = editor.translate(
							"Your browser doesn't support direct access to the clipboard. " +
							"Please use the Ctrl+X/C/V keyboard shortcuts instead."
						);
	
						if (Env.mac) {
							msg = msg.replace(/Ctrl\+/g, '\u2318+');
						}
	
						editor.notificationManager.open({text: msg, type: 'error'});
					}
				},
	
				// Override unlink command
				unlink: function() {
					if (selection.isCollapsed()) {
						var elm = selection.getNode();
						if (elm.tagName == 'A') {
							editor.dom.remove(elm, true);
						}
	
						return;
					}
	
					formatter.remove("link");
				},
	
				// Override justify commands to use the text formatter engine
				'JustifyLeft,JustifyCenter,JustifyRight,JustifyFull,JustifyNone': function(command) {
					var align = command.substring(7);
	
					if (align == 'full') {
						align = 'justify';
					}
	
					// Remove all other alignments first
					each('left,center,right,justify'.split(','), function(name) {
						if (align != name) {
							formatter.remove('align' + name);
						}
					});
	
					if (align != 'none') {
						toggleFormat('align' + align);
					}
				},
	
				// Override list commands to fix WebKit bug
				'InsertUnorderedList,InsertOrderedList': function(command) {
					var listElm, listParent;
	
					execNativeCommand(command);
	
					// WebKit produces lists within block elements so we need to split them
					// we will replace the native list creation logic to custom logic later on
					// TODO: Remove this when the list creation logic is removed
					listElm = dom.getParent(selection.getNode(), 'ol,ul');
					if (listElm) {
						listParent = listElm.parentNode;
	
						// If list is within a text block then split that block
						if (/^(H[1-6]|P|ADDRESS|PRE)$/.test(listParent.nodeName)) {
							storeSelection();
							dom.split(listParent, listElm);
							restoreSelection();
						}
					}
				},
	
				// Override commands to use the text formatter engine
				'Bold,Italic,Underline,Strikethrough,Superscript,Subscript': function(command) {
					toggleFormat(command);
				},
	
				// Override commands to use the text formatter engine
				'ForeColor,HiliteColor,FontName': function(command, ui, value) {
					toggleFormat(command, value);
				},
	
				FontSize: function(command, ui, value) {
					var fontClasses, fontSizes;
	
					// Convert font size 1-7 to styles
					if (value >= 1 && value <= 7) {
						fontSizes = explode(settings.font_size_style_values);
						fontClasses = explode(settings.font_size_classes);
	
						if (fontClasses) {
							value = fontClasses[value - 1] || value;
						} else {
							value = fontSizes[value - 1] || value;
						}
					}
	
					toggleFormat(command, value);
				},
	
				RemoveFormat: function(command) {
					formatter.remove(command);
				},
	
				mceBlockQuote: function() {
					toggleFormat('blockquote');
				},
	
				FormatBlock: function(command, ui, value) {
					return toggleFormat(value || 'p');
				},
	
				mceCleanup: function() {
					var bookmark = selection.getBookmark();
	
					editor.setContent(editor.getContent({cleanup: TRUE}), {cleanup: TRUE});
	
					selection.moveToBookmark(bookmark);
				},
	
				mceRemoveNode: function(command, ui, value) {
					var node = value || selection.getNode();
	
					// Make sure that the body node isn't removed
					if (node != editor.getBody()) {
						storeSelection();
						editor.dom.remove(node, TRUE);
						restoreSelection();
					}
				},
	
				mceSelectNodeDepth: function(command, ui, value) {
					var counter = 0;
	
					dom.getParent(selection.getNode(), function(node) {
						if (node.nodeType == 1 && counter++ == value) {
							selection.select(node);
							return FALSE;
						}
					}, editor.getBody());
				},
	
				mceSelectNode: function(command, ui, value) {
					selection.select(value);
				},
	
				mceInsertContent: function(command, ui, value) {
					InsertContent.insertAtCaret(editor, value);
				},
	
				mceInsertRawHTML: function(command, ui, value) {
					selection.setContent('tiny_mce_marker');
					editor.setContent(
						editor.getContent().replace(/tiny_mce_marker/g, function() {
							return value;
						})
					);
				},
	
				mceToggleFormat: function(command, ui, value) {
					toggleFormat(value);
				},
	
				mceSetContent: function(command, ui, value) {
					editor.setContent(value);
				},
	
				'Indent,Outdent': function(command) {
					var intentValue, indentUnit, value;
	
					// Setup indent level
					intentValue = settings.indentation;
					indentUnit = /[a-z%]+$/i.exec(intentValue);
					intentValue = parseInt(intentValue, 10);
	
					if (!queryCommandState('InsertUnorderedList') && !queryCommandState('InsertOrderedList')) {
						// If forced_root_blocks is set to false we don't have a block to indent so lets create a div
						if (!settings.forced_root_block && !dom.getParent(selection.getNode(), dom.isBlock)) {
							formatter.apply('div');
						}
	
						each(selection.getSelectedBlocks(), function(element) {
							if (dom.getContentEditable(element) === "false") {
								return;
							}
	
							if (element.nodeName != "LI") {
								var indentStyleName = editor.getParam('indent_use_margin', false) ? 'margin' : 'padding';
	
								indentStyleName += dom.getStyle(element, 'direction', true) == 'rtl' ? 'Right' : 'Left';
	
								if (command == 'outdent') {
									value = Math.max(0, parseInt(element.style[indentStyleName] || 0, 10) - intentValue);
									dom.setStyle(element, indentStyleName, value ? value + indentUnit : '');
								} else {
									value = (parseInt(element.style[indentStyleName] || 0, 10) + intentValue) + indentUnit;
									dom.setStyle(element, indentStyleName, value);
								}
							}
						});
					} else {
						execNativeCommand(command);
					}
				},
	
				mceRepaint: function() {
				},
	
				InsertHorizontalRule: function() {
					editor.execCommand('mceInsertContent', false, '<hr />');
				},
	
				mceToggleVisualAid: function() {
					editor.hasVisual = !editor.hasVisual;
					editor.addVisual();
				},
	
				mceReplaceContent: function(command, ui, value) {
					editor.execCommand('mceInsertContent', false, value.replace(/\{\$selection\}/g, selection.getContent({format: 'text'})));
				},
	
				mceInsertLink: function(command, ui, value) {
					var anchor;
	
					if (typeof value == 'string') {
						value = {href: value};
					}
	
					anchor = dom.getParent(selection.getNode(), 'a');
	
					// Spaces are never valid in URLs and it's a very common mistake for people to make so we fix it here.
					value.href = value.href.replace(' ', '%20');
	
					// Remove existing links if there could be child links or that the href isn't specified
					if (!anchor || !value.href) {
						formatter.remove('link');
					}
	
					// Apply new link to selection
					if (value.href) {
						formatter.apply('link', value, anchor);
					}
				},
	
				selectAll: function() {
					var root = dom.getRoot(), rng;
	
					if (selection.getRng().setStart) {
						rng = dom.createRng();
						rng.setStart(root, 0);
						rng.setEnd(root, root.childNodes.length);
						selection.setRng(rng);
					} else {
						// IE will render it's own root level block elements and sometimes
						// even put font elements in them when the user starts typing. So we need to
						// move the selection to a more suitable element from this:
						// <body>|<p></p></body> to this: <body><p>|</p></body>
						rng = selection.getRng();
						if (!rng.item) {
							rng.moveToElementText(root);
							rng.select();
						}
					}
				},
	
				"delete": function() {
					execNativeCommand("Delete");
	
					// Check if body is empty after the delete call if so then set the contents
					// to an empty string and move the caret to any block produced by that operation
					// this fixes the issue with root blocks not being properly produced after a delete call on IE
					var body = editor.getBody();
	
					if (dom.isEmpty(body)) {
						editor.setContent('');
	
						if (body.firstChild && dom.isBlock(body.firstChild)) {
							editor.selection.setCursorLocation(body.firstChild, 0);
						} else {
							editor.selection.setCursorLocation(body, 0);
						}
					}
				},
	
				mceNewDocument: function() {
					editor.setContent('');
				},
	
				InsertLineBreak: function(command, ui, value) {
					// We load the current event in from EnterKey.js when appropriate to heed
					// certain event-specific variations such as ctrl-enter in a list
					var evt = value;
					var brElm, extraBr, marker;
					var rng = selection.getRng(true);
					new RangeUtils(dom).normalize(rng);
	
					var offset = rng.startOffset;
					var container = rng.startContainer;
	
					// Resolve node index
					if (container.nodeType == 1 && container.hasChildNodes()) {
						var isAfterLastNodeInContainer = offset > container.childNodes.length - 1;
	
						container = container.childNodes[Math.min(offset, container.childNodes.length - 1)] || container;
						if (isAfterLastNodeInContainer && container.nodeType == 3) {
							offset = container.nodeValue.length;
						} else {
							offset = 0;
						}
					}
	
					var parentBlock = dom.getParent(container, dom.isBlock);
					var parentBlockName = parentBlock ? parentBlock.nodeName.toUpperCase() : ''; // IE < 9 & HTML5
					var containerBlock = parentBlock ? dom.getParent(parentBlock.parentNode, dom.isBlock) : null;
					var containerBlockName = containerBlock ? containerBlock.nodeName.toUpperCase() : ''; // IE < 9 & HTML5
	
					// Enter inside block contained within a LI then split or insert before/after LI
					var isControlKey = evt && evt.ctrlKey;
					if (containerBlockName == 'LI' && !isControlKey) {
						parentBlock = containerBlock;
						parentBlockName = containerBlockName;
					}
	
					// Walks the parent block to the right and look for BR elements
					function hasRightSideContent() {
						var walker = new TreeWalker(container, parentBlock), node;
						var nonEmptyElementsMap = editor.schema.getNonEmptyElements();
	
						while ((node = walker.next())) {
							if (nonEmptyElementsMap[node.nodeName.toLowerCase()] || node.length > 0) {
								return true;
							}
						}
					}
	
					if (container && container.nodeType == 3 && offset >= container.nodeValue.length) {
						// Insert extra BR element at the end block elements
						if (!isOldIE && !hasRightSideContent()) {
							brElm = dom.create('br');
							rng.insertNode(brElm);
							rng.setStartAfter(brElm);
							rng.setEndAfter(brElm);
							extraBr = true;
						}
					}
	
					brElm = dom.create('br');
					rng.insertNode(brElm);
	
					// Rendering modes below IE8 doesn't display BR elements in PRE unless we have a \n before it
					var documentMode = dom.doc.documentMode;
					if (isOldIE && parentBlockName == 'PRE' && (!documentMode || documentMode < 8)) {
						brElm.parentNode.insertBefore(dom.doc.createTextNode('\r'), brElm);
					}
	
					// Insert temp marker and scroll to that
					marker = dom.create('span', {}, '&nbsp;');
					brElm.parentNode.insertBefore(marker, brElm);
					selection.scrollIntoView(marker);
					dom.remove(marker);
	
					if (!extraBr) {
						rng.setStartAfter(brElm);
						rng.setEndAfter(brElm);
					} else {
						rng.setStartBefore(brElm);
						rng.setEndBefore(brElm);
					}
	
					selection.setRng(rng);
					editor.undoManager.add();
	
					return TRUE;
				}
			});
	
			// Add queryCommandState overrides
			addCommands({
				// Override justify commands
				'JustifyLeft,JustifyCenter,JustifyRight,JustifyFull': function(command) {
					var name = 'align' + command.substring(7);
					var nodes = selection.isCollapsed() ? [dom.getParent(selection.getNode(), dom.isBlock)] : selection.getSelectedBlocks();
					var matches = map(nodes, function(node) {
						return !!formatter.matchNode(node, name);
					});
					return inArray(matches, TRUE) !== -1;
				},
	
				'Bold,Italic,Underline,Strikethrough,Superscript,Subscript': function(command) {
					return isFormatMatch(command);
				},
	
				mceBlockQuote: function() {
					return isFormatMatch('blockquote');
				},
	
				Outdent: function() {
					var node;
	
					if (settings.inline_styles) {
						if ((node = dom.getParent(selection.getStart(), dom.isBlock)) && parseInt(node.style.paddingLeft, 10) > 0) {
							return TRUE;
						}
	
						if ((node = dom.getParent(selection.getEnd(), dom.isBlock)) && parseInt(node.style.paddingLeft, 10) > 0) {
							return TRUE;
						}
					}
	
					return (
						queryCommandState('InsertUnorderedList') ||
						queryCommandState('InsertOrderedList') ||
						(!settings.inline_styles && !!dom.getParent(selection.getNode(), 'BLOCKQUOTE'))
					);
				},
	
				'InsertUnorderedList,InsertOrderedList': function(command) {
					var list = dom.getParent(selection.getNode(), 'ul,ol');
	
					return list &&
						(
							command === 'insertunorderedlist' && list.tagName === 'UL' ||
							command === 'insertorderedlist' && list.tagName === 'OL'
						);
				}
			}, 'state');
	
			// Add queryCommandValue overrides
			addCommands({
				'FontSize,FontName': function(command) {
					var value = 0, parent;
	
					if ((parent = dom.getParent(selection.getNode(), 'span'))) {
						if (command == 'fontsize') {
							value = parent.style.fontSize;
						} else {
							value = parent.style.fontFamily.replace(/, /g, ',').replace(/[\'\"]/g, '').toLowerCase();
						}
					}
	
					return value;
				}
			}, 'value');
	
			// Add undo manager logic
			addCommands({
				Undo: function() {
					editor.undoManager.undo();
				},
	
				Redo: function() {
					editor.undoManager.redo();
				}
			});
		};
	});
	
	// Included from: js/tinymce/classes/util/URI.js
	
	/**
	 * URI.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * This class handles parsing, modification and serialization of URI/URL strings.
	 * @class tinymce.util.URI
	 */
	define("tinymce/util/URI", [
		"tinymce/util/Tools"
	], function(Tools) {
		var each = Tools.each, trim = Tools.trim;
		var queryParts = "source protocol authority userInfo user password host port relative path directory file query anchor".split(' ');
		var DEFAULT_PORTS = {
			'ftp': 21,
			'http': 80,
			'https': 443,
			'mailto': 25
		};
	
		/**
		 * Constructs a new URI instance.
		 *
		 * @constructor
		 * @method URI
		 * @param {String} url URI string to parse.
		 * @param {Object} settings Optional settings object.
		 */
		function URI(url, settings) {
			var self = this, baseUri, base_url;
	
			url = trim(url);
			settings = self.settings = settings || {};
			baseUri = settings.base_uri;
	
			// Strange app protocol that isn't http/https or local anchor
			// For example: mailto,skype,tel etc.
			if (/^([\w\-]+):([^\/]{2})/i.test(url) || /^\s*#/.test(url)) {
				self.source = url;
				return;
			}
	
			var isProtocolRelative = url.indexOf('//') === 0;
	
			// Absolute path with no host, fake host and protocol
			if (url.indexOf('/') === 0 && !isProtocolRelative) {
				url = (baseUri ? baseUri.protocol || 'http' : 'http') + '://mce_host' + url;
			}
	
			// Relative path http:// or protocol relative //path
			if (!/^[\w\-]*:?\/\//.test(url)) {
				base_url = settings.base_uri ? settings.base_uri.path : new URI(location.href).directory;
				if (settings.base_uri.protocol === "") {
					url = '//mce_host' + self.toAbsPath(base_url, url);
				} else {
					url = /([^#?]*)([#?]?.*)/.exec(url);
					url = ((baseUri && baseUri.protocol) || 'http') + '://mce_host' + self.toAbsPath(base_url, url[1]) + url[2];
				}
			}
	
			// Parse URL (Credits goes to Steave, http://blog.stevenlevithan.com/archives/parseuri)
			url = url.replace(/@@/g, '(mce_at)'); // Zope 3 workaround, they use @@something
	
			/*jshint maxlen: 255 */
			/*eslint max-len: 0 */
			url = /^(?:(?![^:@]+:[^:@\/]*@)([^:\/?#.]+):)?(?:\/\/)?((?:(([^:@\/]*):?([^:@\/]*))?@)?([^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/.exec(url);
	
			each(queryParts, function(v, i) {
				var part = url[i];
	
				// Zope 3 workaround, they use @@something
				if (part) {
					part = part.replace(/\(mce_at\)/g, '@@');
				}
	
				self[v] = part;
			});
	
			if (baseUri) {
				if (!self.protocol) {
					self.protocol = baseUri.protocol;
				}
	
				if (!self.userInfo) {
					self.userInfo = baseUri.userInfo;
				}
	
				if (!self.port && self.host === 'mce_host') {
					self.port = baseUri.port;
				}
	
				if (!self.host || self.host === 'mce_host') {
					self.host = baseUri.host;
				}
	
				self.source = '';
			}
	
			if (isProtocolRelative) {
				self.protocol = '';
			}
	
			//t.path = t.path || '/';
		}
	
		URI.prototype = {
			/**
			 * Sets the internal path part of the URI.
			 *
			 * @method setPath
			 * @param {string} path Path string to set.
			 */
			setPath: function(path) {
				var self = this;
	
				path = /^(.*?)\/?(\w+)?$/.exec(path);
	
				// Update path parts
				self.path = path[0];
				self.directory = path[1];
				self.file = path[2];
	
				// Rebuild source
				self.source = '';
				self.getURI();
			},
	
			/**
			 * Converts the specified URI into a relative URI based on the current URI instance location.
			 *
			 * @method toRelative
			 * @param {String} uri URI to convert into a relative path/URI.
			 * @return {String} Relative URI from the point specified in the current URI instance.
			 * @example
			 * // Converts an absolute URL to an relative URL url will be somedir/somefile.htm
			 * var url = new tinymce.util.URI('http://www.site.com/dir/').toRelative('http://www.site.com/dir/somedir/somefile.htm');
			 */
			toRelative: function(uri) {
				var self = this, output;
	
				if (uri === "./") {
					return uri;
				}
	
				uri = new URI(uri, {base_uri: self});
	
				// Not on same domain/port or protocol
				if ((uri.host != 'mce_host' && self.host != uri.host && uri.host) || self.port != uri.port ||
					(self.protocol != uri.protocol && uri.protocol !== "")) {
					return uri.getURI();
				}
	
				var tu = self.getURI(), uu = uri.getURI();
	
				// Allow usage of the base_uri when relative_urls = true
				if (tu == uu || (tu.charAt(tu.length - 1) == "/" && tu.substr(0, tu.length - 1) == uu)) {
					return tu;
				}
	
				output = self.toRelPath(self.path, uri.path);
	
				// Add query
				if (uri.query) {
					output += '?' + uri.query;
				}
	
				// Add anchor
				if (uri.anchor) {
					output += '#' + uri.anchor;
				}
	
				return output;
			},
	
			/**
			 * Converts the specified URI into a absolute URI based on the current URI instance location.
			 *
			 * @method toAbsolute
			 * @param {String} uri URI to convert into a relative path/URI.
			 * @param {Boolean} noHost No host and protocol prefix.
			 * @return {String} Absolute URI from the point specified in the current URI instance.
			 * @example
			 * // Converts an relative URL to an absolute URL url will be http://www.site.com/dir/somedir/somefile.htm
			 * var url = new tinymce.util.URI('http://www.site.com/dir/').toAbsolute('somedir/somefile.htm');
			 */
			toAbsolute: function(uri, noHost) {
				uri = new URI(uri, {base_uri: this});
	
				return uri.getURI(noHost && this.isSameOrigin(uri));
			},
	
			/**
			 * Determine whether the given URI has the same origin as this URI.  Based on RFC-6454.
			 * Supports default ports for protocols listed in DEFAULT_PORTS.  Unsupported protocols will fail safe: they
			 * won't match, if the port specifications differ.
			 *
			 * @method isSameOrigin
			 * @param {tinymce.util.URI} uri Uri instance to compare.
			 * @returns {Boolean} True if the origins are the same.
			 */
			isSameOrigin: function(uri) {
				if (this.host == uri.host && this.protocol == uri.protocol) {
					if (this.port == uri.port) {
						return true;
					}
	
					var defaultPort = DEFAULT_PORTS[this.protocol];
					if (defaultPort && ((this.port || defaultPort) == (uri.port || defaultPort))) {
						return true;
					}
				}
	
				return false;
			},
	
			/**
			 * Converts a absolute path into a relative path.
			 *
			 * @method toRelPath
			 * @param {String} base Base point to convert the path from.
			 * @param {String} path Absolute path to convert into a relative path.
			 */
			toRelPath: function(base, path) {
				var items, breakPoint = 0, out = '', i, l;
	
				// Split the paths
				base = base.substring(0, base.lastIndexOf('/'));
				base = base.split('/');
				items = path.split('/');
	
				if (base.length >= items.length) {
					for (i = 0, l = base.length; i < l; i++) {
						if (i >= items.length || base[i] != items[i]) {
							breakPoint = i + 1;
							break;
						}
					}
				}
	
				if (base.length < items.length) {
					for (i = 0, l = items.length; i < l; i++) {
						if (i >= base.length || base[i] != items[i]) {
							breakPoint = i + 1;
							break;
						}
					}
				}
	
				if (breakPoint === 1) {
					return path;
				}
	
				for (i = 0, l = base.length - (breakPoint - 1); i < l; i++) {
					out += "../";
				}
	
				for (i = breakPoint - 1, l = items.length; i < l; i++) {
					if (i != breakPoint - 1) {
						out += "/" + items[i];
					} else {
						out += items[i];
					}
				}
	
				return out;
			},
	
			/**
			 * Converts a relative path into a absolute path.
			 *
			 * @method toAbsPath
			 * @param {String} base Base point to convert the path from.
			 * @param {String} path Relative path to convert into an absolute path.
			 */
			toAbsPath: function(base, path) {
				var i, nb = 0, o = [], tr, outPath;
	
				// Split paths
				tr = /\/$/.test(path) ? '/' : '';
				base = base.split('/');
				path = path.split('/');
	
				// Remove empty chunks
				each(base, function(k) {
					if (k) {
						o.push(k);
					}
				});
	
				base = o;
	
				// Merge relURLParts chunks
				for (i = path.length - 1, o = []; i >= 0; i--) {
					// Ignore empty or .
					if (path[i].length === 0 || path[i] === ".") {
						continue;
					}
	
					// Is parent
					if (path[i] === '..') {
						nb++;
						continue;
					}
	
					// Move up
					if (nb > 0) {
						nb--;
						continue;
					}
	
					o.push(path[i]);
				}
	
				i = base.length - nb;
	
				// If /a/b/c or /
				if (i <= 0) {
					outPath = o.reverse().join('/');
				} else {
					outPath = base.slice(0, i).join('/') + '/' + o.reverse().join('/');
				}
	
				// Add front / if it's needed
				if (outPath.indexOf('/') !== 0) {
					outPath = '/' + outPath;
				}
	
				// Add traling / if it's needed
				if (tr && outPath.lastIndexOf('/') !== outPath.length - 1) {
					outPath += tr;
				}
	
				return outPath;
			},
	
			/**
			 * Returns the full URI of the internal structure.
			 *
			 * @method getURI
			 * @param {Boolean} noProtoHost Optional no host and protocol part. Defaults to false.
			 */
			getURI: function(noProtoHost) {
				var s, self = this;
	
				// Rebuild source
				if (!self.source || noProtoHost) {
					s = '';
	
					if (!noProtoHost) {
						if (self.protocol) {
							s += self.protocol + '://';
						} else {
							s += '//';
						}
	
						if (self.userInfo) {
							s += self.userInfo + '@';
						}
	
						if (self.host) {
							s += self.host;
						}
	
						if (self.port) {
							s += ':' + self.port;
						}
					}
	
					if (self.path) {
						s += self.path;
					}
	
					if (self.query) {
						s += '?' + self.query;
					}
	
					if (self.anchor) {
						s += '#' + self.anchor;
					}
	
					self.source = s;
				}
	
				return self.source;
			}
		};
	
		URI.parseDataUri = function(uri) {
			var type, matches;
	
			uri = decodeURIComponent(uri).split(',');
	
			matches = /data:([^;]+)/.exec(uri[0]);
			if (matches) {
				type = matches[1];
			}
	
			return {
				type: type,
				data: uri[1]
			};
		};
	
		URI.getDocumentBaseUrl = function(loc) {
			var baseUrl;
	
			// Pass applewebdata:// and other non web protocols though
			if (loc.protocol.indexOf('http') !== 0 && loc.protocol !== 'file:') {
				baseUrl = loc.href;
			} else {
				baseUrl = loc.protocol + '//' + loc.host + loc.pathname;
			}
	
			if (/^[^:]+:\/\/\/?[^\/]+\//.test(baseUrl)) {
				baseUrl = baseUrl.replace(/[\?#].*$/, '').replace(/[\/\\][^\/]+$/, '');
	
				if (!/[\/\\]$/.test(baseUrl)) {
					baseUrl += '/';
				}
			}
	
			return baseUrl;
		};
	
		return URI;
	});
	
	// Included from: js/tinymce/classes/util/Class.js
	
	/**
	 * Class.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * This utilitiy class is used for easier inheritance.
	 *
	 * Features:
	 * * Exposed super functions: this._super();
	 * * Mixins
	 * * Dummy functions
	 * * Property functions: var value = object.value(); and object.value(newValue);
	 * * Static functions
	 * * Defaults settings
	 */
	define("tinymce/util/Class", [
		"tinymce/util/Tools"
	], function(Tools) {
		var each = Tools.each, extend = Tools.extend;
	
		var extendClass, initializing;
	
		function Class() {
		}
	
		// Provides classical inheritance, based on code made by John Resig
		Class.extend = extendClass = function(prop) {
			var self = this, _super = self.prototype, prototype, name, member;
	
			// The dummy class constructor
			function Class() {
				var i, mixins, mixin, self = this;
	
				// All construction is actually done in the init method
				if (!initializing) {
					// Run class constuctor
					if (self.init) {
						self.init.apply(self, arguments);
					}
	
					// Run mixin constructors
					mixins = self.Mixins;
					if (mixins) {
						i = mixins.length;
						while (i--) {
							mixin = mixins[i];
							if (mixin.init) {
								mixin.init.apply(self, arguments);
							}
						}
					}
				}
			}
	
			// Dummy function, needs to be extended in order to provide functionality
			function dummy() {
				return this;
			}
	
			// Creates a overloaded method for the class
			// this enables you to use this._super(); to call the super function
			function createMethod(name, fn) {
				return function() {
					var self = this, tmp = self._super, ret;
	
					self._super = _super[name];
					ret = fn.apply(self, arguments);
					self._super = tmp;
	
					return ret;
				};
			}
	
			// Instantiate a base class (but only create the instance,
			// don't run the init constructor)
			initializing = true;
	
			/*eslint new-cap:0 */
			prototype = new self();
			initializing = false;
	
			// Add mixins
			if (prop.Mixins) {
				each(prop.Mixins, function(mixin) {
					for (var name in mixin) {
						if (name !== "init") {
							prop[name] = mixin[name];
						}
					}
				});
	
				if (_super.Mixins) {
					prop.Mixins = _super.Mixins.concat(prop.Mixins);
				}
			}
	
			// Generate dummy methods
			if (prop.Methods) {
				each(prop.Methods.split(','), function(name) {
					prop[name] = dummy;
				});
			}
	
			// Generate property methods
			if (prop.Properties) {
				each(prop.Properties.split(','), function(name) {
					var fieldName = '_' + name;
	
					prop[name] = function(value) {
						var self = this, undef;
	
						// Set value
						if (value !== undef) {
							self[fieldName] = value;
	
							return self;
						}
	
						// Get value
						return self[fieldName];
					};
				});
			}
	
			// Static functions
			if (prop.Statics) {
				each(prop.Statics, function(func, name) {
					Class[name] = func;
				});
			}
	
			// Default settings
			if (prop.Defaults && _super.Defaults) {
				prop.Defaults = extend({}, _super.Defaults, prop.Defaults);
			}
	
			// Copy the properties over onto the new prototype
			for (name in prop) {
				member = prop[name];
	
				if (typeof member == "function" && _super[name]) {
					prototype[name] = createMethod(name, member);
				} else {
					prototype[name] = member;
				}
			}
	
			// Populate our constructed prototype object
			Class.prototype = prototype;
	
			// Enforce the constructor to be what we expect
			Class.constructor = Class;
	
			// And make this class extendible
			Class.extend = extendClass;
	
			return Class;
		};
	
		return Class;
	});
	
	// Included from: js/tinymce/classes/util/EventDispatcher.js
	
	/**
	 * EventDispatcher.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * This class lets you add/remove and fire events by name on the specified scope. This makes
	 * it easy to add event listener logic to any class.
	 *
	 * @class tinymce.util.EventDispatcher
	 * @example
	 *  var eventDispatcher = new EventDispatcher();
	 *
	 *  eventDispatcher.on('click', function() {console.log('data');});
	 *  eventDispatcher.fire('click', {data: 123});
	 */
	define("tinymce/util/EventDispatcher", [
		"tinymce/util/Tools"
	], function(Tools) {
		var nativeEvents = Tools.makeMap(
			"focus blur focusin focusout click dblclick mousedown mouseup mousemove mouseover beforepaste paste cut copy selectionchange " +
			"mouseout mouseenter mouseleave wheel keydown keypress keyup input contextmenu dragstart dragend dragover " +
			"draggesture dragdrop drop drag submit " +
			"compositionstart compositionend compositionupdate touchstart touchend",
			' '
		);
	
		function Dispatcher(settings) {
			var self = this, scope, bindings = {}, toggleEvent;
	
			function returnFalse() {
				return false;
			}
	
			function returnTrue() {
				return true;
			}
	
			settings = settings || {};
			scope = settings.scope || self;
			toggleEvent = settings.toggleEvent || returnFalse;
	
			/**
			 * Fires the specified event by name.
			 *
			 * @method fire
			 * @param {String} name Name of the event to fire.
			 * @param {Object?} args Event arguments.
			 * @return {Object} Event args instance passed in.
			 * @example
			 * instance.fire('event', {...});
			 */
			function fire(name, args) {
				var handlers, i, l, callback;
	
				name = name.toLowerCase();
				args = args || {};
				args.type = name;
	
				// Setup target is there isn't one
				if (!args.target) {
					args.target = scope;
				}
	
				// Add event delegation methods if they are missing
				if (!args.preventDefault) {
					// Add preventDefault method
					args.preventDefault = function() {
						args.isDefaultPrevented = returnTrue;
					};
	
					// Add stopPropagation
					args.stopPropagation = function() {
						args.isPropagationStopped = returnTrue;
					};
	
					// Add stopImmediatePropagation
					args.stopImmediatePropagation = function() {
						args.isImmediatePropagationStopped = returnTrue;
					};
	
					// Add event delegation states
					args.isDefaultPrevented = returnFalse;
					args.isPropagationStopped = returnFalse;
					args.isImmediatePropagationStopped = returnFalse;
				}
	
				if (settings.beforeFire) {
					settings.beforeFire(args);
				}
	
				handlers = bindings[name];
				if (handlers) {
					for (i = 0, l = handlers.length; i < l; i++) {
						callback = handlers[i];
	
						// Unbind handlers marked with "once"
						if (callback.once) {
							off(name, callback.func);
						}
	
						// Stop immediate propagation if needed
						if (args.isImmediatePropagationStopped()) {
							args.stopPropagation();
							return args;
						}
	
						// If callback returns false then prevent default and stop all propagation
						if (callback.func.call(scope, args) === false) {
							args.preventDefault();
							return args;
						}
					}
				}
	
				return args;
			}
	
			/**
			 * Binds an event listener to a specific event by name.
			 *
			 * @method on
			 * @param {String} name Event name or space separated list of events to bind.
			 * @param {callback} callback Callback to be executed when the event occurs.
			 * @param {Boolean} first Optional flag if the event should be prepended. Use this with care.
			 * @return {Object} Current class instance.
			 * @example
			 * instance.on('event', function(e) {
			 *     // Callback logic
			 * });
			 */
			function on(name, callback, prepend, extra) {
				var handlers, names, i;
	
				if (callback === false) {
					callback = returnFalse;
				}
	
				if (callback) {
					callback = {
						func: callback
					};
	
					if (extra) {
						Tools.extend(callback, extra);
					}
	
					names = name.toLowerCase().split(' ');
					i = names.length;
					while (i--) {
						name = names[i];
						handlers = bindings[name];
						if (!handlers) {
							handlers = bindings[name] = [];
							toggleEvent(name, true);
						}
	
						if (prepend) {
							handlers.unshift(callback);
						} else {
							handlers.push(callback);
						}
					}
				}
	
				return self;
			}
	
			/**
			 * Unbinds an event listener to a specific event by name.
			 *
			 * @method off
			 * @param {String?} name Name of the event to unbind.
			 * @param {callback?} callback Callback to unbind.
			 * @return {Object} Current class instance.
			 * @example
			 * // Unbind specific callback
			 * instance.off('event', handler);
			 *
			 * // Unbind all listeners by name
			 * instance.off('event');
			 *
			 * // Unbind all events
			 * instance.off();
			 */
			function off(name, callback) {
				var i, handlers, bindingName, names, hi;
	
				if (name) {
					names = name.toLowerCase().split(' ');
					i = names.length;
					while (i--) {
						name = names[i];
						handlers = bindings[name];
	
						// Unbind all handlers
						if (!name) {
							for (bindingName in bindings) {
								toggleEvent(bindingName, false);
								delete bindings[bindingName];
							}
	
							return self;
						}
	
						if (handlers) {
							// Unbind all by name
							if (!callback) {
								handlers.length = 0;
							} else {
								// Unbind specific ones
								hi = handlers.length;
								while (hi--) {
									if (handlers[hi].func === callback) {
										handlers = handlers.slice(0, hi).concat(handlers.slice(hi + 1));
										bindings[name] = handlers;
									}
								}
							}
	
							if (!handlers.length) {
								toggleEvent(name, false);
								delete bindings[name];
							}
						}
					}
				} else {
					for (name in bindings) {
						toggleEvent(name, false);
					}
	
					bindings = {};
				}
	
				return self;
			}
	
			/**
			 * Binds an event listener to a specific event by name
			 * and automatically unbind the event once the callback fires.
			 *
			 * @method once
			 * @param {String} name Event name or space separated list of events to bind.
			 * @param {callback} callback Callback to be executed when the event occurs.
			 * @param {Boolean} first Optional flag if the event should be prepended. Use this with care.
			 * @return {Object} Current class instance.
			 * @example
			 * instance.once('event', function(e) {
			 *     // Callback logic
			 * });
			 */
			function once(name, callback, prepend) {
				return on(name, callback, prepend, {once: true});
			}
	
			/**
			 * Returns true/false if the dispatcher has a event of the specified name.
			 *
			 * @method has
			 * @param {String} name Name of the event to check for.
			 * @return {Boolean} true/false if the event exists or not.
			 */
			function has(name) {
				name = name.toLowerCase();
				return !(!bindings[name] || bindings[name].length === 0);
			}
	
			// Expose
			self.fire = fire;
			self.on = on;
			self.off = off;
			self.once = once;
			self.has = has;
		}
	
		/**
		 * Returns true/false if the specified event name is a native browser event or not.
		 *
		 * @method isNative
		 * @param {String} name Name to check if it's native.
		 * @return {Boolean} true/false if the event is native or not.
		 * @static
		 */
		Dispatcher.isNative = function(name) {
			return !!nativeEvents[name.toLowerCase()];
		};
	
		return Dispatcher;
	});
	
	// Included from: js/tinymce/classes/data/Binding.js
	
	/**
	 * Binding.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * This class gets dynamically extended to provide a binding between two models. This makes it possible to
	 * sync the state of two properties in two models by a layer of abstraction.
	 *
	 * @private
	 * @class tinymce.data.Binding
	 */
	define("tinymce/data/Binding", [], function() {
		/**
		 * Constructs a new bidning.
		 *
		 * @constructor
		 * @method Binding
		 * @param {Object} settings Settings to the binding.
		 */
		function Binding(settings) {
			this.create = settings.create;
		}
	
		/**
		 * Creates a binding for a property on a model.
		 *
		 * @method create
		 * @param {tinymce.data.ObservableObject} model Model to create binding to.
		 * @param {String} name Name of property to bind.
		 * @return {tinymce.data.Binding} Binding instance.
		 */
		Binding.create = function(model, name) {
			return new Binding({
				create: function(otherModel, otherName) {
					var bindings;
	
					function fromSelfToOther(e) {
						otherModel.set(otherName, e.value);
					}
	
					function fromOtherToSelf(e) {
						model.set(name, e.value);
					}
	
					otherModel.on('change:' + otherName, fromOtherToSelf);
					model.on('change:' + name, fromSelfToOther);
	
					// Keep track of the bindings
					bindings = otherModel._bindings;
	
					if (!bindings) {
						bindings = otherModel._bindings = [];
	
						otherModel.on('destroy', function() {
							var i = bindings.length;
	
							while (i--) {
								bindings[i]();
							}
						});
					}
	
					bindings.push(function() {
						model.off('change:' + name, fromSelfToOther);
					});
	
					return model.get(name);
				}
			});
		};
	
		return Binding;
	});
	
	// Included from: js/tinymce/classes/util/Observable.js
	
	/**
	 * Observable.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * This mixin will add event binding logic to classes.
	 *
	 * @mixin tinymce.util.Observable
	 */
	define("tinymce/util/Observable", [
		"tinymce/util/EventDispatcher"
	], function(EventDispatcher) {
		function getEventDispatcher(obj) {
			if (!obj._eventDispatcher) {
				obj._eventDispatcher = new EventDispatcher({
					scope: obj,
					toggleEvent: function(name, state) {
						if (EventDispatcher.isNative(name) && obj.toggleNativeEvent) {
							obj.toggleNativeEvent(name, state);
						}
					}
				});
			}
	
			return obj._eventDispatcher;
		}
	
		return {
			/**
			 * Fires the specified event by name.
			 *
			 * @method fire
			 * @param {String} name Name of the event to fire.
			 * @param {Object?} args Event arguments.
			 * @param {Boolean?} bubble True/false if the event is to be bubbled.
			 * @return {Object} Event args instance passed in.
			 * @example
			 * instance.fire('event', {...});
			 */
			fire: function(name, args, bubble) {
				var self = this;
	
				// Prevent all events except the remove event after the instance has been removed
				if (self.removed && name !== "remove") {
					return args;
				}
	
				args = getEventDispatcher(self).fire(name, args, bubble);
	
				// Bubble event up to parents
				if (bubble !== false && self.parent) {
					var parent = self.parent();
					while (parent && !args.isPropagationStopped()) {
						parent.fire(name, args, false);
						parent = parent.parent();
					}
				}
	
				return args;
			},
	
			/**
			 * Binds an event listener to a specific event by name.
			 *
			 * @method on
			 * @param {String} name Event name or space separated list of events to bind.
			 * @param {callback} callback Callback to be executed when the event occurs.
			 * @param {Boolean} first Optional flag if the event should be prepended. Use this with care.
			 * @return {Object} Current class instance.
			 * @example
			 * instance.on('event', function(e) {
			 *     // Callback logic
			 * });
			 */
			on: function(name, callback, prepend) {
				return getEventDispatcher(this).on(name, callback, prepend);
			},
	
			/**
			 * Unbinds an event listener to a specific event by name.
			 *
			 * @method off
			 * @param {String?} name Name of the event to unbind.
			 * @param {callback?} callback Callback to unbind.
			 * @return {Object} Current class instance.
			 * @example
			 * // Unbind specific callback
			 * instance.off('event', handler);
			 *
			 * // Unbind all listeners by name
			 * instance.off('event');
			 *
			 * // Unbind all events
			 * instance.off();
			 */
			off: function(name, callback) {
				return getEventDispatcher(this).off(name, callback);
			},
	
			/**
			 * Bind the event callback and once it fires the callback is removed.
			 *
			 * @method once
			 * @param {String} name Name of the event to bind.
			 * @param {callback} callback Callback to bind only once.
			 * @return {Object} Current class instance.
			 */
			once: function(name, callback) {
				return getEventDispatcher(this).once(name, callback);
			},
	
			/**
			 * Returns true/false if the object has a event of the specified name.
			 *
			 * @method hasEventListeners
			 * @param {String} name Name of the event to check for.
			 * @return {Boolean} true/false if the event exists or not.
			 */
			hasEventListeners: function(name) {
				return getEventDispatcher(this).has(name);
			}
		};
	});
	
	// Included from: js/tinymce/classes/data/ObservableObject.js
	
	/**
	 * ObservableObject.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * This class is a object that is observable when properties changes a change event gets emitted.
	 *
	 * @private
	 * @class tinymce.data.ObservableObject
	 */
	define("tinymce/data/ObservableObject", [
		"tinymce/data/Binding",
		"tinymce/util/Observable",
		"tinymce/util/Class",
		"tinymce/util/Tools"
	], function(Binding, Observable, Class, Tools) {
		function isNode(node) {
			return node.nodeType > 0;
		}
	
		// Todo: Maybe this should be shallow compare since it might be huge object references
		function isEqual(a, b) {
			var k, checked;
	
			// Strict equals
			if (a === b) {
				return true;
			}
	
			// Compare null
			if (a === null || b === null) {
				return a === b;
			}
	
			// Compare number, boolean, string, undefined
			if (typeof a !== "object" || typeof b !== "object") {
				return a === b;
			}
	
			// Compare arrays
			if (Tools.isArray(b)) {
				if (a.length !== b.length) {
					return false;
				}
	
				k = a.length;
				while (k--) {
					if (!isEqual(a[k], b[k])) {
						return false;
					}
				}
			}
	
			// Shallow compare nodes
			if (isNode(a) || isNode(b)) {
				return a === b;
			}
	
			// Compare objects
			checked = {};
			for (k in b) {
				if (!isEqual(a[k], b[k])) {
					return false;
				}
	
				checked[k] = true;
			}
	
			for (k in a) {
				if (!checked[k] && !isEqual(a[k], b[k])) {
					return false;
				}
			}
	
			return true;
		}
	
		return Class.extend({
			Mixins: [Observable],
	
			/**
			 * Constructs a new observable object instance.
			 *
			 * @constructor
			 * @param {Object} data Initial data for the object.
			 */
			init: function(data) {
				var name, value;
	
				data = data || {};
	
				for (name in data) {
					value = data[name];
	
					if (value instanceof Binding) {
						data[name] = value.create(this, name);
					}
				}
	
				this.data = data;
			},
	
			/**
			 * Sets a property on the value this will call
			 * observers if the value is a change from the current value.
			 *
			 * @method set
			 * @param {String/object} name Name of the property to set or a object of items to set.
			 * @param {Object} value Value to set for the property.
			 * @return {tinymce.data.ObservableObject} Observable object instance.
			 */
			set: function(name, value) {
				var key, args, oldValue = this.data[name];
	
				if (value instanceof Binding) {
					value = value.create(this, name);
				}
	
				if (typeof name === "object") {
					for (key in name) {
						this.set(key, name[key]);
					}
	
					return this;
				}
	
				if (!isEqual(oldValue, value)) {
					this.data[name] = value;
	
					args = {
						target: this,
						name: name,
						value: value,
						oldValue: oldValue
					};
	
					this.fire('change:' + name, args);
					this.fire('change', args);
				}
	
				return this;
			},
	
			/**
			 * Gets a property by name.
			 *
			 * @method get
			 * @param {String} name Name of the property to get.
			 * @return {Object} Object value of propery.
			 */
			get: function(name) {
				return this.data[name];
			},
	
			/**
			 * Returns true/false if the specified property exists.
			 *
			 * @method has
			 * @param {String} name Name of the property to check for.
			 * @return {Boolean} true/false if the item exists.
			 */
			has: function(name) {
				return name in this.data;
			},
	
			/**
			 * Returns a dynamic property binding for the specified property name. This makes
			 * it possible to sync the state of two properties in two ObservableObject instances.
			 *
			 * @method bind
			 * @param {String} name Name of the property to sync with the property it's inserted to.
			 * @return {tinymce.data.Binding} Data binding instance.
			 */
			bind: function(name) {
				return Binding.create(this, name);
			},
	
			/**
			 * Destroys the observable object and fires the "destroy"
			 * event and clean up any internal resources.
			 *
			 * @method destroy
			 */
			destroy: function() {
				this.fire('destroy');
			}
		});
	});
	
	// Included from: js/tinymce/classes/ui/Selector.js
	
	/**
	 * Selector.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/*eslint no-nested-ternary:0 */
	
	/**
	 * Selector engine, enables you to select controls by using CSS like expressions.
	 * We currently only support basic CSS expressions to reduce the size of the core
	 * and the ones we support should be enough for most cases.
	 *
	 * @example
	 * Supported expressions:
	 *  element
	 *  element#name
	 *  element.class
	 *  element[attr]
	 *  element[attr*=value]
	 *  element[attr~=value]
	 *  element[attr!=value]
	 *  element[attr^=value]
	 *  element[attr$=value]
	 *  element:<state>
	 *  element:not(<expression>)
	 *  element:first
	 *  element:last
	 *  element:odd
	 *  element:even
	 *  element element
	 *  element > element
	 *
	 * @class tinymce.ui.Selector
	 */
	define("tinymce/ui/Selector", [
		"tinymce/util/Class"
	], function(Class) {
		"use strict";
	
		/**
		 * Produces an array with a unique set of objects. It will not compare the values
		 * but the references of the objects.
		 *
		 * @private
		 * @method unqiue
		 * @param {Array} array Array to make into an array with unique items.
		 * @return {Array} Array with unique items.
		 */
		function unique(array) {
			var uniqueItems = [], i = array.length, item;
	
			while (i--) {
				item = array[i];
	
				if (!item.__checked) {
					uniqueItems.push(item);
					item.__checked = 1;
				}
			}
	
			i = uniqueItems.length;
			while (i--) {
				delete uniqueItems[i].__checked;
			}
	
			return uniqueItems;
		}
	
		var expression = /^([\w\\*]+)?(?:#([\w\-\\]+))?(?:\.([\w\\\.]+))?(?:\[\@?([\w\\]+)([\^\$\*!~]?=)([\w\\]+)\])?(?:\:(.+))?/i;
	
		/*jshint maxlen:255 */
		/*eslint max-len:0 */
		var chunker = /((?:\((?:\([^()]+\)|[^()]+)+\)|\[(?:\[[^\[\]]*\]|['"][^'"]*['"]|[^\[\]'"]+)+\]|\\.|[^ >+~,(\[\\]+)+|[>+~])(\s*,\s*)?((?:.|\r|\n)*)/g,
			whiteSpace = /^\s*|\s*$/g,
			Collection;
	
		var Selector = Class.extend({
			/**
			 * Constructs a new Selector instance.
			 *
			 * @constructor
			 * @method init
			 * @param {String} selector CSS like selector expression.
			 */
			init: function(selector) {
				var match = this.match;
	
				function compileNameFilter(name) {
					if (name) {
						name = name.toLowerCase();
	
						return function(item) {
							return name === '*' || item.type === name;
						};
					}
				}
	
				function compileIdFilter(id) {
					if (id) {
						return function(item) {
							return item._name === id;
						};
					}
				}
	
				function compileClassesFilter(classes) {
					if (classes) {
						classes = classes.split('.');
	
						return function(item) {
							var i = classes.length;
	
							while (i--) {
								if (!item.classes.contains(classes[i])) {
									return false;
								}
							}
	
							return true;
						};
					}
				}
	
				function compileAttrFilter(name, cmp, check) {
					if (name) {
						return function(item) {
							var value = item[name] ? item[name]() : '';
	
							return !cmp ? !!check :
								cmp === "=" ? value === check :
								cmp === "*=" ? value.indexOf(check) >= 0 :
								cmp === "~=" ? (" " + value + " ").indexOf(" " + check + " ") >= 0 :
								cmp === "!=" ? value != check :
								cmp === "^=" ? value.indexOf(check) === 0 :
								cmp === "$=" ? value.substr(value.length - check.length) === check :
								false;
						};
					}
				}
	
				function compilePsuedoFilter(name) {
					var notSelectors;
	
					if (name) {
						name = /(?:not\((.+)\))|(.+)/i.exec(name);
	
						if (!name[1]) {
							name = name[2];
	
							return function(item, index, length) {
								return name === 'first' ? index === 0 :
									name === 'last' ? index === length - 1 :
									name === 'even' ? index % 2 === 0 :
									name === 'odd' ? index % 2 === 1 :
									item[name] ? item[name]() :
									false;
							};
						}
	
						// Compile not expression
						notSelectors = parseChunks(name[1], []);
	
						return function(item) {
							return !match(item, notSelectors);
						};
					}
				}
	
				function compile(selector, filters, direct) {
					var parts;
	
					function add(filter) {
						if (filter) {
							filters.push(filter);
						}
					}
	
					// Parse expression into parts
					parts = expression.exec(selector.replace(whiteSpace, ''));
	
					add(compileNameFilter(parts[1]));
					add(compileIdFilter(parts[2]));
					add(compileClassesFilter(parts[3]));
					add(compileAttrFilter(parts[4], parts[5], parts[6]));
					add(compilePsuedoFilter(parts[7]));
	
					// Mark the filter with pseudo for performance
					filters.pseudo = !!parts[7];
					filters.direct = direct;
	
					return filters;
				}
	
				// Parser logic based on Sizzle by John Resig
				function parseChunks(selector, selectors) {
					var parts = [], extra, matches, i;
	
					do {
						chunker.exec("");
						matches = chunker.exec(selector);
	
						if (matches) {
							selector = matches[3];
							parts.push(matches[1]);
	
							if (matches[2]) {
								extra = matches[3];
								break;
							}
						}
					} while (matches);
	
					if (extra) {
						parseChunks(extra, selectors);
					}
	
					selector = [];
					for (i = 0; i < parts.length; i++) {
						if (parts[i] != '>') {
							selector.push(compile(parts[i], [], parts[i - 1] === '>'));
						}
					}
	
					selectors.push(selector);
	
					return selectors;
				}
	
				this._selectors = parseChunks(selector, []);
			},
	
			/**
			 * Returns true/false if the selector matches the specified control.
			 *
			 * @method match
			 * @param {tinymce.ui.Control} control Control to match against the selector.
			 * @param {Array} selectors Optional array of selectors, mostly used internally.
			 * @return {Boolean} true/false state if the control matches or not.
			 */
			match: function(control, selectors) {
				var i, l, si, sl, selector, fi, fl, filters, index, length, siblings, count, item;
	
				selectors = selectors || this._selectors;
				for (i = 0, l = selectors.length; i < l; i++) {
					selector = selectors[i];
					sl = selector.length;
					item = control;
					count = 0;
	
					for (si = sl - 1; si >= 0; si--) {
						filters = selector[si];
	
						while (item) {
							// Find the index and length since a pseudo filter like :first needs it
							if (filters.pseudo) {
								siblings = item.parent().items();
								index = length = siblings.length;
								while (index--) {
									if (siblings[index] === item) {
										break;
									}
								}
							}
	
							for (fi = 0, fl = filters.length; fi < fl; fi++) {
								if (!filters[fi](item, index, length)) {
									fi = fl + 1;
									break;
								}
							}
	
							if (fi === fl) {
								count++;
								break;
							} else {
								// If it didn't match the right most expression then
								// break since it's no point looking at the parents
								if (si === sl - 1) {
									break;
								}
							}
	
							item = item.parent();
						}
					}
	
					// If we found all selectors then return true otherwise continue looking
					if (count === sl) {
						return true;
					}
				}
	
				return false;
			},
	
			/**
			 * Returns a tinymce.ui.Collection with matches of the specified selector inside the specified container.
			 *
			 * @method find
			 * @param {tinymce.ui.Control} container Container to look for items in.
			 * @return {tinymce.ui.Collection} Collection with matched elements.
			 */
			find: function(container) {
				var matches = [], i, l, selectors = this._selectors;
	
				function collect(items, selector, index) {
					var i, l, fi, fl, item, filters = selector[index];
	
					for (i = 0, l = items.length; i < l; i++) {
						item = items[i];
	
						// Run each filter against the item
						for (fi = 0, fl = filters.length; fi < fl; fi++) {
							if (!filters[fi](item, i, l)) {
								fi = fl + 1;
								break;
							}
						}
	
						// All filters matched the item
						if (fi === fl) {
							// Matched item is on the last expression like: panel toolbar [button]
							if (index == selector.length - 1) {
								matches.push(item);
							} else {
								// Collect next expression type
								if (item.items) {
									collect(item.items(), selector, index + 1);
								}
							}
						} else if (filters.direct) {
							return;
						}
	
						// Collect child items
						if (item.items) {
							collect(item.items(), selector, index);
						}
					}
				}
	
				if (container.items) {
					for (i = 0, l = selectors.length; i < l; i++) {
						collect(container.items(), selectors[i], 0);
					}
	
					// Unique the matches if needed
					if (l > 1) {
						matches = unique(matches);
					}
				}
	
				// Fix for circular reference
				if (!Collection) {
					// TODO: Fix me!
					Collection = Selector.Collection;
				}
	
				return new Collection(matches);
			}
		});
	
		return Selector;
	});
	
	// Included from: js/tinymce/classes/ui/Collection.js
	
	/**
	 * Collection.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * Control collection, this class contains control instances and it enables you to
	 * perform actions on all the contained items. This is very similar to how jQuery works.
	 *
	 * @example
	 * someCollection.show().disabled(true);
	 *
	 * @class tinymce.ui.Collection
	 */
	define("tinymce/ui/Collection", [
		"tinymce/util/Tools",
		"tinymce/ui/Selector",
		"tinymce/util/Class"
	], function(Tools, Selector, Class) {
		"use strict";
	
		var Collection, proto, push = Array.prototype.push, slice = Array.prototype.slice;
	
		proto = {
			/**
			 * Current number of contained control instances.
			 *
			 * @field length
			 * @type Number
			 */
			length: 0,
	
			/**
			 * Constructor for the collection.
			 *
			 * @constructor
			 * @method init
			 * @param {Array} items Optional array with items to add.
			 */
			init: function(items) {
				if (items) {
					this.add(items);
				}
			},
	
			/**
			 * Adds new items to the control collection.
			 *
			 * @method add
			 * @param {Array} items Array if items to add to collection.
			 * @return {tinymce.ui.Collection} Current collection instance.
			 */
			add: function(items) {
				var self = this;
	
				// Force single item into array
				if (!Tools.isArray(items)) {
					if (items instanceof Collection) {
						self.add(items.toArray());
					} else {
						push.call(self, items);
					}
				} else {
					push.apply(self, items);
				}
	
				return self;
			},
	
			/**
			 * Sets the contents of the collection. This will remove any existing items
			 * and replace them with the ones specified in the input array.
			 *
			 * @method set
			 * @param {Array} items Array with items to set into the Collection.
			 * @return {tinymce.ui.Collection} Collection instance.
			 */
			set: function(items) {
				var self = this, len = self.length, i;
	
				self.length = 0;
				self.add(items);
	
				// Remove old entries
				for (i = self.length; i < len; i++) {
					delete self[i];
				}
	
				return self;
			},
	
			/**
			 * Filters the collection item based on the specified selector expression or selector function.
			 *
			 * @method filter
			 * @param {String} selector Selector expression to filter items by.
			 * @return {tinymce.ui.Collection} Collection containing the filtered items.
			 */
			filter: function(selector) {
				var self = this, i, l, matches = [], item, match;
	
				// Compile string into selector expression
				if (typeof selector === "string") {
					selector = new Selector(selector);
	
					match = function(item) {
						return selector.match(item);
					};
				} else {
					// Use selector as matching function
					match = selector;
				}
	
				for (i = 0, l = self.length; i < l; i++) {
					item = self[i];
	
					if (match(item)) {
						matches.push(item);
					}
				}
	
				return new Collection(matches);
			},
	
			/**
			 * Slices the items within the collection.
			 *
			 * @method slice
			 * @param {Number} index Index to slice at.
			 * @param {Number} len Optional length to slice.
			 * @return {tinymce.ui.Collection} Current collection.
			 */
			slice: function() {
				return new Collection(slice.apply(this, arguments));
			},
	
			/**
			 * Makes the current collection equal to the specified index.
			 *
			 * @method eq
			 * @param {Number} index Index of the item to set the collection to.
			 * @return {tinymce.ui.Collection} Current collection.
			 */
			eq: function(index) {
				return index === -1 ? this.slice(index) : this.slice(index, +index + 1);
			},
	
			/**
			 * Executes the specified callback on each item in collection.
			 *
			 * @method each
			 * @param {function} callback Callback to execute for each item in collection.
			 * @return {tinymce.ui.Collection} Current collection instance.
			 */
			each: function(callback) {
				Tools.each(this, callback);
	
				return this;
			},
	
			/**
			 * Returns an JavaScript array object of the contents inside the collection.
			 *
			 * @method toArray
			 * @return {Array} Array with all items from collection.
			 */
			toArray: function() {
				return Tools.toArray(this);
			},
	
			/**
			 * Finds the index of the specified control or return -1 if it isn't in the collection.
			 *
			 * @method indexOf
			 * @param {Control} ctrl Control instance to look for.
			 * @return {Number} Index of the specified control or -1.
			 */
			indexOf: function(ctrl) {
				var self = this, i = self.length;
	
				while (i--) {
					if (self[i] === ctrl) {
						break;
					}
				}
	
				return i;
			},
	
			/**
			 * Returns a new collection of the contents in reverse order.
			 *
			 * @method reverse
			 * @return {tinymce.ui.Collection} Collection instance with reversed items.
			 */
			reverse: function() {
				return new Collection(Tools.toArray(this).reverse());
			},
	
			/**
			 * Returns true/false if the class exists or not.
			 *
			 * @method hasClass
			 * @param {String} cls Class to check for.
			 * @return {Boolean} true/false state if the class exists or not.
			 */
			hasClass: function(cls) {
				return this[0] ? this[0].classes.contains(cls) : false;
			},
	
			/**
			 * Sets/gets the specific property on the items in the collection. The same as executing control.<property>(<value>);
			 *
			 * @method prop
			 * @param {String} name Property name to get/set.
			 * @param {Object} value Optional object value to set.
			 * @return {tinymce.ui.Collection} Current collection instance or value of the first item on a get operation.
			 */
			prop: function(name, value) {
				var self = this, undef, item;
	
				if (value !== undef) {
					self.each(function(item) {
						if (item[name]) {
							item[name](value);
						}
					});
	
					return self;
				}
	
				item = self[0];
	
				if (item && item[name]) {
					return item[name]();
				}
			},
	
			/**
			 * Executes the specific function name with optional arguments an all items in collection if it exists.
			 *
			 * @example collection.exec("myMethod", arg1, arg2, arg3);
			 * @method exec
			 * @param {String} name Name of the function to execute.
			 * @param {Object} ... Multiple arguments to pass to each function.
			 * @return {tinymce.ui.Collection} Current collection.
			 */
			exec: function(name) {
				var self = this, args = Tools.toArray(arguments).slice(1);
	
				self.each(function(item) {
					if (item[name]) {
						item[name].apply(item, args);
					}
				});
	
				return self;
			},
	
			/**
			 * Remove all items from collection and DOM.
			 *
			 * @method remove
			 * @return {tinymce.ui.Collection} Current collection.
			 */
			remove: function() {
				var i = this.length;
	
				while (i--) {
					this[i].remove();
				}
	
				return this;
			},
	
			/**
			 * Adds a class to all items in the collection.
			 *
			 * @method addClass
			 * @param {String} cls Class to add to each item.
			 * @return {tinymce.ui.Collection} Current collection instance.
			 */
			addClass: function(cls) {
				return this.each(function(item) {
					item.classes.add(cls);
				});
			},
	
			/**
			 * Removes the specified class from all items in collection.
			 *
			 * @method removeClass
			 * @param {String} cls Class to remove from each item.
			 * @return {tinymce.ui.Collection} Current collection instance.
			 */
			removeClass: function(cls) {
				return this.each(function(item) {
					item.classes.remove(cls);
				});
			}
	
			/**
			 * Fires the specified event by name and arguments on the control. This will execute all
			 * bound event handlers.
			 *
			 * @method fire
			 * @param {String} name Name of the event to fire.
			 * @param {Object} args Optional arguments to pass to the event.
			 * @return {tinymce.ui.Collection} Current collection instance.
			 */
			// fire: function(event, args) {}, -- Generated by code below
	
			/**
			 * Binds a callback to the specified event. This event can both be
			 * native browser events like "click" or custom ones like PostRender.
			 *
			 * The callback function will have two parameters the first one being the control that received the event
			 * the second one will be the event object either the browsers native event object or a custom JS object.
			 *
			 * @method on
			 * @param {String} name Name of the event to bind. For example "click".
			 * @param {String/function} callback Callback function to execute ones the event occurs.
			 * @return {tinymce.ui.Collection} Current collection instance.
			 */
			// on: function(name, callback) {}, -- Generated by code below
	
			/**
			 * Unbinds the specified event and optionally a specific callback. If you omit the name
			 * parameter all event handlers will be removed. If you omit the callback all event handles
			 * by the specified name will be removed.
			 *
			 * @method off
			 * @param {String} name Optional name for the event to unbind.
			 * @param {function} callback Optional callback function to unbind.
			 * @return {tinymce.ui.Collection} Current collection instance.
			 */
			// off: function(name, callback) {}, -- Generated by code below
	
			/**
			 * Shows the items in the current collection.
			 *
			 * @method show
			 * @return {tinymce.ui.Collection} Current collection instance.
			 */
			// show: function() {}, -- Generated by code below
	
			/**
			 * Hides the items in the current collection.
			 *
			 * @method hide
			 * @return {tinymce.ui.Collection} Current collection instance.
			 */
			// hide: function() {}, -- Generated by code below
	
			/**
			 * Sets/gets the text contents of the items in the current collection.
			 *
			 * @method text
			 * @return {tinymce.ui.Collection} Current collection instance or text value of the first item on a get operation.
			 */
			// text: function(value) {}, -- Generated by code below
	
			/**
			 * Sets/gets the name contents of the items in the current collection.
			 *
			 * @method name
			 * @return {tinymce.ui.Collection} Current collection instance or name value of the first item on a get operation.
			 */
			// name: function(value) {}, -- Generated by code below
	
			/**
			 * Sets/gets the disabled state on the items in the current collection.
			 *
			 * @method disabled
			 * @return {tinymce.ui.Collection} Current collection instance or disabled state of the first item on a get operation.
			 */
			// disabled: function(state) {}, -- Generated by code below
	
			/**
			 * Sets/gets the active state on the items in the current collection.
			 *
			 * @method active
			 * @return {tinymce.ui.Collection} Current collection instance or active state of the first item on a get operation.
			 */
			// active: function(state) {}, -- Generated by code below
	
			/**
			 * Sets/gets the selected state on the items in the current collection.
			 *
			 * @method selected
			 * @return {tinymce.ui.Collection} Current collection instance or selected state of the first item on a get operation.
			 */
			// selected: function(state) {}, -- Generated by code below
	
			/**
			 * Sets/gets the selected state on the items in the current collection.
			 *
			 * @method visible
			 * @return {tinymce.ui.Collection} Current collection instance or visible state of the first item on a get operation.
			 */
			// visible: function(state) {}, -- Generated by code below
		};
	
		// Extend tinymce.ui.Collection prototype with some generated control specific methods
		Tools.each('fire on off show hide append prepend before after reflow'.split(' '), function(name) {
			proto[name] = function() {
				var args = Tools.toArray(arguments);
	
				this.each(function(ctrl) {
					if (name in ctrl) {
						ctrl[name].apply(ctrl, args);
					}
				});
	
				return this;
			};
		});
	
		// Extend tinymce.ui.Collection prototype with some property methods
		Tools.each('text name disabled active selected checked visible parent value data'.split(' '), function(name) {
			proto[name] = function(value) {
				return this.prop(name, value);
			};
		});
	
		// Create class based on the new prototype
		Collection = Class.extend(proto);
	
		// Stick Collection into Selector to prevent circual references
		Selector.Collection = Collection;
	
		return Collection;
	});
	
	// Included from: js/tinymce/classes/ui/DomUtils.js
	
	/**
	 * DomUtils.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * Private UI DomUtils proxy.
	 *
	 * @private
	 * @class tinymce.ui.DomUtils
	 */
	define("tinymce/ui/DomUtils", [
		"tinymce/util/Tools",
		"tinymce/dom/DOMUtils"
	], function(Tools, DOMUtils) {
		"use strict";
	
		var count = 0;
	
		return {
			id: function() {
				return 'mceu_' + (count++);
			},
	
			create: function(name, attrs, children) {
				var elm = document.createElement(name);
	
				DOMUtils.DOM.setAttribs(elm, attrs);
	
				if (typeof children === 'string') {
					elm.innerHTML = children;
				} else {
					Tools.each(children, function(child) {
						if (child.nodeType) {
							elm.appendChild(child);
						}
					});
				}
	
				return elm;
			},
	
			createFragment: function(html) {
				return DOMUtils.DOM.createFragment(html);
			},
	
			getWindowSize: function() {
				return DOMUtils.DOM.getViewPort();
			},
	
			getSize: function(elm) {
				var width, height;
	
				if (elm.getBoundingClientRect) {
					var rect = elm.getBoundingClientRect();
	
					width = Math.max(rect.width || (rect.right - rect.left), elm.offsetWidth);
					height = Math.max(rect.height || (rect.bottom - rect.bottom), elm.offsetHeight);
				} else {
					width = elm.offsetWidth;
					height = elm.offsetHeight;
				}
	
				return {width: width, height: height};
			},
	
			getPos: function(elm, root) {
				return DOMUtils.DOM.getPos(elm, root);
			},
	
			getViewPort: function(win) {
				return DOMUtils.DOM.getViewPort(win);
			},
	
			get: function(id) {
				return document.getElementById(id);
			},
	
			addClass: function(elm, cls) {
				return DOMUtils.DOM.addClass(elm, cls);
			},
	
			removeClass: function(elm, cls) {
				return DOMUtils.DOM.removeClass(elm, cls);
			},
	
			hasClass: function(elm, cls) {
				return DOMUtils.DOM.hasClass(elm, cls);
			},
	
			toggleClass: function(elm, cls, state) {
				return DOMUtils.DOM.toggleClass(elm, cls, state);
			},
	
			css: function(elm, name, value) {
				return DOMUtils.DOM.setStyle(elm, name, value);
			},
	
			getRuntimeStyle: function(elm, name) {
				return DOMUtils.DOM.getStyle(elm, name, true);
			},
	
			on: function(target, name, callback, scope) {
				return DOMUtils.DOM.bind(target, name, callback, scope);
			},
	
			off: function(target, name, callback) {
				return DOMUtils.DOM.unbind(target, name, callback);
			},
	
			fire: function(target, name, args) {
				return DOMUtils.DOM.fire(target, name, args);
			},
	
			innerHtml: function(elm, html) {
				// Workaround for <div> in <p> bug on IE 8 #6178
				DOMUtils.DOM.setHTML(elm, html);
			}
		};
	});
	
	// Included from: js/tinymce/classes/ui/BoxUtils.js
	
	/**
	 * BoxUtils.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * Utility class for box parsing and measuring.
	 *
	 * @private
	 * @class tinymce.ui.BoxUtils
	 */
	define("tinymce/ui/BoxUtils", [
	], function() {
		"use strict";
	
		return {
			/**
			 * Parses the specified box value. A box value contains 1-4 properties in clockwise order.
			 *
			 * @method parseBox
			 * @param {String/Number} value Box value "0 1 2 3" or "0" etc.
			 * @return {Object} Object with top/right/bottom/left properties.
			 * @private
			 */
			parseBox: function(value) {
				var len, radix = 10;
	
				if (!value) {
					return;
				}
	
				if (typeof value === "number") {
					value = value || 0;
	
					return {
						top: value,
						left: value,
						bottom: value,
						right: value
					};
				}
	
				value = value.split(' ');
				len = value.length;
	
				if (len === 1) {
					value[1] = value[2] = value[3] = value[0];
				} else if (len === 2) {
					value[2] = value[0];
					value[3] = value[1];
				} else if (len === 3) {
					value[3] = value[1];
				}
	
				return {
					top: parseInt(value[0], radix) || 0,
					right: parseInt(value[1], radix) || 0,
					bottom: parseInt(value[2], radix) || 0,
					left: parseInt(value[3], radix) || 0
				};
			},
	
			measureBox: function(elm, prefix) {
				function getStyle(name) {
					var defaultView = document.defaultView;
	
					if (defaultView) {
						// Remove camelcase
						name = name.replace(/[A-Z]/g, function(a) {
							return '-' + a;
						});
	
						return defaultView.getComputedStyle(elm, null).getPropertyValue(name);
					}
	
					return elm.currentStyle[name];
				}
	
				function getSide(name) {
					var val = parseFloat(getStyle(name), 10);
	
					return isNaN(val) ? 0 : val;
				}
	
				return {
					top: getSide(prefix + "TopWidth"),
					right: getSide(prefix + "RightWidth"),
					bottom: getSide(prefix + "BottomWidth"),
					left: getSide(prefix + "LeftWidth")
				};
			}
		};
	});
	
	// Included from: js/tinymce/classes/ui/ClassList.js
	
	/**
	 * ClassList.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * Handles adding and removal of classes.
	 *
	 * @private
	 * @class tinymce.ui.ClassList
	 */
	define("tinymce/ui/ClassList", [
		"tinymce/util/Tools"
	], function(Tools) {
		"use strict";
	
		function noop() {
		}
	
		/**
		 * Constructs a new class list the specified onchange
		 * callback will be executed when the class list gets modifed.
		 *
		 * @constructor ClassList
		 * @param {function} onchange Onchange callback to be executed.
		 */
		function ClassList(onchange) {
			this.cls = [];
			this.cls._map = {};
			this.onchange = onchange || noop;
			this.prefix = '';
		}
	
		Tools.extend(ClassList.prototype, {
			/**
			 * Adds a new class to the class list.
			 *
			 * @method add
			 * @param {String} cls Class to be added.
			 * @return {tinymce.ui.ClassList} Current class list instance.
			 */
			add: function(cls) {
				if (cls && !this.contains(cls)) {
					this.cls._map[cls] = true;
					this.cls.push(cls);
					this._change();
				}
	
				return this;
			},
	
			/**
			 * Removes the specified class from the class list.
			 *
			 * @method remove
			 * @param {String} cls Class to be removed.
			 * @return {tinymce.ui.ClassList} Current class list instance.
			 */
			remove: function(cls) {
				if (this.contains(cls)) {
					for (var i = 0; i < this.cls.length; i++) {
						if (this.cls[i] === cls) {
							break;
						}
					}
	
					this.cls.splice(i, 1);
					delete this.cls._map[cls];
					this._change();
				}
	
				return this;
			},
	
			/**
			 * Toggles a class in the class list.
			 *
			 * @method toggle
			 * @param {String} cls Class to be added/removed.
			 * @param {Boolean} state Optional state if it should be added/removed.
			 * @return {tinymce.ui.ClassList} Current class list instance.
			 */
			toggle: function(cls, state) {
				var curState = this.contains(cls);
	
				if (curState !== state) {
					if (curState) {
						this.remove(cls);
					} else {
						this.add(cls);
					}
	
					this._change();
				}
	
				return this;
			},
	
			/**
			 * Returns true if the class list has the specified class.
			 *
			 * @method contains
			 * @param {String} cls Class to look for.
			 * @return {Boolean} true/false if the class exists or not.
			 */
			contains: function(cls) {
				return !!this.cls._map[cls];
			},
	
			/**
			 * Returns a space separated list of classes.
			 *
			 * @method toString
			 * @return {String} Space separated list of classes.
			 */
	
			_change: function() {
				delete this.clsValue;
				this.onchange.call(this);
			}
		});
	
		// IE 8 compatibility
		ClassList.prototype.toString = function() {
			var value;
	
			if (this.clsValue) {
				return this.clsValue;
			}
	
			value = '';
			for (var i = 0; i < this.cls.length; i++) {
				if (i > 0) {
					value += ' ';
				}
	
				value += this.prefix + this.cls[i];
			}
	
			return value;
		};
	
		return ClassList;
	});
	
	// Included from: js/tinymce/classes/ui/ReflowQueue.js
	
	/**
	 * ReflowQueue.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * This class will automatically reflow controls on the next animation frame within a few milliseconds on older browsers.
	 * If the user manually reflows then the automatic reflow will be cancelled. This class is used internally when various control states
	 * changes that triggers a reflow.
	 *
	 * @class tinymce.ui.ReflowQueue
	 * @static
	 */
	define("tinymce/ui/ReflowQueue", [
		"tinymce/util/Delay"
	], function(Delay) {
		var dirtyCtrls = {}, animationFrameRequested;
	
		return {
			/**
			 * Adds a control to the next automatic reflow call. This is the control that had a state
			 * change for example if the control was hidden/shown.
			 *
			 * @method add
			 * @param {tinymce.ui.Control} ctrl Control to add to queue.
			 */
			add: function(ctrl) {
				var parent = ctrl.parent();
	
				if (parent) {
					if (!parent._layout || parent._layout.isNative()) {
						return;
					}
	
					if (!dirtyCtrls[parent._id]) {
						dirtyCtrls[parent._id] = parent;
					}
	
					if (!animationFrameRequested) {
						animationFrameRequested = true;
	
						Delay.requestAnimationFrame(function() {
							var id, ctrl;
	
							animationFrameRequested = false;
	
							for (id in dirtyCtrls) {
								ctrl = dirtyCtrls[id];
	
								if (ctrl.state.get('rendered')) {
									ctrl.reflow();
								}
							}
	
							dirtyCtrls = {};
						}, document.body);
					}
				}
			},
	
			/**
			 * Removes the specified control from the automatic reflow. This will happen when for example the user
			 * manually triggers a reflow.
			 *
			 * @method remove
			 * @param {tinymce.ui.Control} ctrl Control to remove from queue.
			 */
			remove: function(ctrl) {
				if (dirtyCtrls[ctrl._id]) {
					delete dirtyCtrls[ctrl._id];
				}
			}
		};
	});
	
	// Included from: js/tinymce/classes/ui/Control.js
	
	/**
	 * Control.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/*eslint consistent-this:0 */
	
	/**
	 * This is the base class for all controls and containers. All UI control instances inherit
	 * from this one as it has the base logic needed by all of them.
	 *
	 * @class tinymce.ui.Control
	 */
	define("tinymce/ui/Control", [
		"tinymce/util/Class",
		"tinymce/util/Tools",
		"tinymce/util/EventDispatcher",
		"tinymce/data/ObservableObject",
		"tinymce/ui/Collection",
		"tinymce/ui/DomUtils",
		"tinymce/dom/DomQuery",
		"tinymce/ui/BoxUtils",
		"tinymce/ui/ClassList",
		"tinymce/ui/ReflowQueue"
	], function(Class, Tools, EventDispatcher, ObservableObject, Collection, DomUtils, $, BoxUtils, ClassList, ReflowQueue) {
		"use strict";
	
		var hasMouseWheelEventSupport = "onmousewheel" in document;
		var hasWheelEventSupport = false;
		var classPrefix = "mce-";
		var Control, idCounter = 0;
	
		var proto = {
			Statics: {
				classPrefix: classPrefix
			},
	
			isRtl: function() {
				return Control.rtl;
			},
	
			/**
			 * Class/id prefix to use for all controls.
			 *
			 * @final
			 * @field {String} classPrefix
			 */
			classPrefix: classPrefix,
	
			/**
			 * Constructs a new control instance with the specified settings.
			 *
			 * @constructor
			 * @param {Object} settings Name/value object with settings.
			 * @setting {String} style Style CSS properties to add.
			 * @setting {String} border Border box values example: 1 1 1 1
			 * @setting {String} padding Padding box values example: 1 1 1 1
			 * @setting {String} margin Margin box values example: 1 1 1 1
			 * @setting {Number} minWidth Minimal width for the control.
			 * @setting {Number} minHeight Minimal height for the control.
			 * @setting {String} classes Space separated list of classes to add.
			 * @setting {String} role WAI-ARIA role to use for control.
			 * @setting {Boolean} hidden Is the control hidden by default.
			 * @setting {Boolean} disabled Is the control disabled by default.
			 * @setting {String} name Name of the control instance.
			 */
			init: function(settings) {
				var self = this, classes, defaultClasses;
	
				function applyClasses(classes) {
					var i;
	
					classes = classes.split(' ');
					for (i = 0; i < classes.length; i++) {
						self.classes.add(classes[i]);
					}
				}
	
				self.settings = settings = Tools.extend({}, self.Defaults, settings);
	
				// Initial states
				self._id = settings.id || ('mceu_' + (idCounter++));
				self._aria = {role: settings.role};
				self._elmCache = {};
				self.$ = $;
	
				self.state = new ObservableObject({
					visible: true,
					active: false,
					disabled: false,
					value: ''
				});
	
				self.data = new ObservableObject(settings.data);
	
				self.classes = new ClassList(function() {
					if (self.state.get('rendered')) {
						self.getEl().className = this.toString();
					}
				});
				self.classes.prefix = self.classPrefix;
	
				// Setup classes
				classes = settings.classes;
				if (classes) {
					if (self.Defaults) {
						defaultClasses = self.Defaults.classes;
	
						if (defaultClasses && classes != defaultClasses) {
							applyClasses(defaultClasses);
						}
					}
	
					applyClasses(classes);
				}
	
				Tools.each('title text name visible disabled active value'.split(' '), function(name) {
					if (name in settings) {
						self[name](settings[name]);
					}
				});
	
				self.on('click', function() {
					if (self.disabled()) {
						return false;
					}
				});
	
				/**
				 * Name/value object with settings for the current control.
				 *
				 * @field {Object} settings
				 */
				self.settings = settings;
	
				self.borderBox = BoxUtils.parseBox(settings.border);
				self.paddingBox = BoxUtils.parseBox(settings.padding);
				self.marginBox = BoxUtils.parseBox(settings.margin);
	
				if (settings.hidden) {
					self.hide();
				}
			},
	
			// Will generate getter/setter methods for these properties
			Properties: 'parent,name',
	
			/**
			 * Returns the root element to render controls into.
			 *
			 * @method getContainerElm
			 * @return {Element} HTML DOM element to render into.
			 */
			getContainerElm: function() {
				return document.body;
			},
	
			/**
			 * Returns a control instance for the current DOM element.
			 *
			 * @method getParentCtrl
			 * @param {Element} elm HTML dom element to get parent control from.
			 * @return {tinymce.ui.Control} Control instance or undefined.
			 */
			getParentCtrl: function(elm) {
				var ctrl, lookup = this.getRoot().controlIdLookup;
	
				while (elm && lookup) {
					ctrl = lookup[elm.id];
					if (ctrl) {
						break;
					}
	
					elm = elm.parentNode;
				}
	
				return ctrl;
			},
	
			/**
			 * Initializes the current controls layout rect.
			 * This will be executed by the layout managers to determine the
			 * default minWidth/minHeight etc.
			 *
			 * @method initLayoutRect
			 * @return {Object} Layout rect instance.
			 */
			initLayoutRect: function() {
				var self = this, settings = self.settings, borderBox, layoutRect;
				var elm = self.getEl(), width, height, minWidth, minHeight, autoResize;
				var startMinWidth, startMinHeight, initialSize;
	
				// Measure the current element
				borderBox = self.borderBox = self.borderBox || BoxUtils.measureBox(elm, 'border');
				self.paddingBox = self.paddingBox || BoxUtils.measureBox(elm, 'padding');
				self.marginBox = self.marginBox || BoxUtils.measureBox(elm, 'margin');
				initialSize = DomUtils.getSize(elm);
	
				// Setup minWidth/minHeight and width/height
				startMinWidth = settings.minWidth;
				startMinHeight = settings.minHeight;
				minWidth = startMinWidth || initialSize.width;
				minHeight = startMinHeight || initialSize.height;
				width = settings.width;
				height = settings.height;
				autoResize = settings.autoResize;
				autoResize = typeof autoResize != "undefined" ? autoResize : !width && !height;
	
				width = width || minWidth;
				height = height || minHeight;
	
				var deltaW = borderBox.left + borderBox.right;
				var deltaH = borderBox.top + borderBox.bottom;
	
				var maxW = settings.maxWidth || 0xFFFF;
				var maxH = settings.maxHeight || 0xFFFF;
	
				// Setup initial layout rect
				self._layoutRect = layoutRect = {
					x: settings.x || 0,
					y: settings.y || 0,
					w: width,
					h: height,
					deltaW: deltaW,
					deltaH: deltaH,
					contentW: width - deltaW,
					contentH: height - deltaH,
					innerW: width - deltaW,
					innerH: height - deltaH,
					startMinWidth: startMinWidth || 0,
					startMinHeight: startMinHeight || 0,
					minW: Math.min(minWidth, maxW),
					minH: Math.min(minHeight, maxH),
					maxW: maxW,
					maxH: maxH,
					autoResize: autoResize,
					scrollW: 0
				};
	
				self._lastLayoutRect = {};
	
				return layoutRect;
			},
	
			/**
			 * Getter/setter for the current layout rect.
			 *
			 * @method layoutRect
			 * @param {Object} [newRect] Optional new layout rect.
			 * @return {tinymce.ui.Control/Object} Current control or rect object.
			 */
			layoutRect: function(newRect) {
				var self = this, curRect = self._layoutRect, lastLayoutRect, size, deltaWidth, deltaHeight, undef, repaintControls;
	
				// Initialize default layout rect
				if (!curRect) {
					curRect = self.initLayoutRect();
				}
	
				// Set new rect values
				if (newRect) {
					// Calc deltas between inner and outer sizes
					deltaWidth = curRect.deltaW;
					deltaHeight = curRect.deltaH;
	
					// Set x position
					if (newRect.x !== undef) {
						curRect.x = newRect.x;
					}
	
					// Set y position
					if (newRect.y !== undef) {
						curRect.y = newRect.y;
					}
	
					// Set minW
					if (newRect.minW !== undef) {
						curRect.minW = newRect.minW;
					}
	
					// Set minH
					if (newRect.minH !== undef) {
						curRect.minH = newRect.minH;
					}
	
					// Set new width and calculate inner width
					size = newRect.w;
					if (size !== undef) {
						size = size < curRect.minW ? curRect.minW : size;
						size = size > curRect.maxW ? curRect.maxW : size;
						curRect.w = size;
						curRect.innerW = size - deltaWidth;
					}
	
					// Set new height and calculate inner height
					size = newRect.h;
					if (size !== undef) {
						size = size < curRect.minH ? curRect.minH : size;
						size = size > curRect.maxH ? curRect.maxH : size;
						curRect.h = size;
						curRect.innerH = size - deltaHeight;
					}
	
					// Set new inner width and calculate width
					size = newRect.innerW;
					if (size !== undef) {
						size = size < curRect.minW - deltaWidth ? curRect.minW - deltaWidth : size;
						size = size > curRect.maxW - deltaWidth ? curRect.maxW - deltaWidth : size;
						curRect.innerW = size;
						curRect.w = size + deltaWidth;
					}
	
					// Set new height and calculate inner height
					size = newRect.innerH;
					if (size !== undef) {
						size = size < curRect.minH - deltaHeight ? curRect.minH - deltaHeight : size;
						size = size > curRect.maxH - deltaHeight ? curRect.maxH - deltaHeight : size;
						curRect.innerH = size;
						curRect.h = size + deltaHeight;
					}
	
					// Set new contentW
					if (newRect.contentW !== undef) {
						curRect.contentW = newRect.contentW;
					}
	
					// Set new contentH
					if (newRect.contentH !== undef) {
						curRect.contentH = newRect.contentH;
					}
	
					// Compare last layout rect with the current one to see if we need to repaint or not
					lastLayoutRect = self._lastLayoutRect;
					if (lastLayoutRect.x !== curRect.x || lastLayoutRect.y !== curRect.y ||
						lastLayoutRect.w !== curRect.w || lastLayoutRect.h !== curRect.h) {
						repaintControls = Control.repaintControls;
	
						if (repaintControls) {
							if (repaintControls.map && !repaintControls.map[self._id]) {
								repaintControls.push(self);
								repaintControls.map[self._id] = true;
							}
						}
	
						lastLayoutRect.x = curRect.x;
						lastLayoutRect.y = curRect.y;
						lastLayoutRect.w = curRect.w;
						lastLayoutRect.h = curRect.h;
					}
	
					return self;
				}
	
				return curRect;
			},
	
			/**
			 * Repaints the control after a layout operation.
			 *
			 * @method repaint
			 */
			repaint: function() {
				var self = this, style, bodyStyle, bodyElm, rect, borderBox;
				var borderW, borderH, lastRepaintRect, round, value;
	
				// Use Math.round on all values on IE < 9
				round = !document.createRange ? Math.round : function(value) {
					return value;
				};
	
				style = self.getEl().style;
				rect = self._layoutRect;
				lastRepaintRect = self._lastRepaintRect || {};
	
				borderBox = self.borderBox;
				borderW = borderBox.left + borderBox.right;
				borderH = borderBox.top + borderBox.bottom;
	
				if (rect.x !== lastRepaintRect.x) {
					style.left = round(rect.x) + 'px';
					lastRepaintRect.x = rect.x;
				}
	
				if (rect.y !== lastRepaintRect.y) {
					style.top = round(rect.y) + 'px';
					lastRepaintRect.y = rect.y;
				}
	
				if (rect.w !== lastRepaintRect.w) {
					value = round(rect.w - borderW);
					style.width = (value >= 0 ? value : 0) + 'px';
					lastRepaintRect.w = rect.w;
				}
	
				if (rect.h !== lastRepaintRect.h) {
					value = round(rect.h - borderH);
					style.height = (value >= 0 ? value : 0) + 'px';
					lastRepaintRect.h = rect.h;
				}
	
				// Update body if needed
				if (self._hasBody && rect.innerW !== lastRepaintRect.innerW) {
					value = round(rect.innerW);
	
					bodyElm = self.getEl('body');
					if (bodyElm) {
						bodyStyle = bodyElm.style;
						bodyStyle.width = (value >= 0 ? value : 0) + 'px';
					}
	
					lastRepaintRect.innerW = rect.innerW;
				}
	
				if (self._hasBody && rect.innerH !== lastRepaintRect.innerH) {
					value = round(rect.innerH);
	
					bodyElm = bodyElm || self.getEl('body');
					if (bodyElm) {
						bodyStyle = bodyStyle || bodyElm.style;
						bodyStyle.height = (value >= 0 ? value : 0) + 'px';
					}
	
					lastRepaintRect.innerH = rect.innerH;
				}
	
				self._lastRepaintRect = lastRepaintRect;
				self.fire('repaint', {}, false);
			},
	
			/**
			 * Updates the controls layout rect by re-measuing it.
			 */
			updateLayoutRect: function() {
				var self = this;
	
				self.parent()._lastRect = null;
	
				DomUtils.css(self.getEl(), {width: '', height: ''});
	
				self._layoutRect = self._lastRepaintRect = self._lastLayoutRect = null;
				self.initLayoutRect();
			},
	
			/**
			 * Binds a callback to the specified event. This event can both be
			 * native browser events like "click" or custom ones like PostRender.
			 *
			 * The callback function will be passed a DOM event like object that enables yout do stop propagation.
			 *
			 * @method on
			 * @param {String} name Name of the event to bind. For example "click".
			 * @param {String/function} callback Callback function to execute ones the event occurs.
			 * @return {tinymce.ui.Control} Current control object.
			 */
			on: function(name, callback) {
				var self = this;
	
				function resolveCallbackName(name) {
					var callback, scope;
	
					if (typeof name != 'string') {
						return name;
					}
	
					return function(e) {
						if (!callback) {
							self.parentsAndSelf().each(function(ctrl) {
								var callbacks = ctrl.settings.callbacks;
	
								if (callbacks && (callback = callbacks[name])) {
									scope = ctrl;
									return false;
								}
							});
						}
	
						if (!callback) {
							e.action = name;
							this.fire('execute', e);
							return;
						}
	
						return callback.call(scope, e);
					};
				}
	
				getEventDispatcher(self).on(name, resolveCallbackName(callback));
	
				return self;
			},
	
			/**
			 * Unbinds the specified event and optionally a specific callback. If you omit the name
			 * parameter all event handlers will be removed. If you omit the callback all event handles
			 * by the specified name will be removed.
			 *
			 * @method off
			 * @param {String} [name] Name for the event to unbind.
			 * @param {function} [callback] Callback function to unbind.
			 * @return {tinymce.ui.Control} Current control object.
			 */
			off: function(name, callback) {
				getEventDispatcher(this).off(name, callback);
				return this;
			},
	
			/**
			 * Fires the specified event by name and arguments on the control. This will execute all
			 * bound event handlers.
			 *
			 * @method fire
			 * @param {String} name Name of the event to fire.
			 * @param {Object} [args] Arguments to pass to the event.
			 * @param {Boolean} [bubble] Value to control bubbling. Defaults to true.
			 * @return {Object} Current arguments object.
			 */
			fire: function(name, args, bubble) {
				var self = this;
	
				args = args || {};
	
				if (!args.control) {
					args.control = self;
				}
	
				args = getEventDispatcher(self).fire(name, args);
	
				// Bubble event up to parents
				if (bubble !== false && self.parent) {
					var parent = self.parent();
					while (parent && !args.isPropagationStopped()) {
						parent.fire(name, args, false);
						parent = parent.parent();
					}
				}
	
				return args;
			},
	
			/**
			 * Returns true/false if the specified event has any listeners.
			 *
			 * @method hasEventListeners
			 * @param {String} name Name of the event to check for.
			 * @return {Boolean} True/false state if the event has listeners.
			 */
			hasEventListeners: function(name) {
				return getEventDispatcher(this).has(name);
			},
	
			/**
			 * Returns a control collection with all parent controls.
			 *
			 * @method parents
			 * @param {String} selector Optional selector expression to find parents.
			 * @return {tinymce.ui.Collection} Collection with all parent controls.
			 */
			parents: function(selector) {
				var self = this, ctrl, parents = new Collection();
	
				// Add each parent to collection
				for (ctrl = self.parent(); ctrl; ctrl = ctrl.parent()) {
					parents.add(ctrl);
				}
	
				// Filter away everything that doesn't match the selector
				if (selector) {
					parents = parents.filter(selector);
				}
	
				return parents;
			},
	
			/**
			 * Returns the current control and it's parents.
			 *
			 * @method parentsAndSelf
			 * @param {String} selector Optional selector expression to find parents.
			 * @return {tinymce.ui.Collection} Collection with all parent controls.
			 */
			parentsAndSelf: function(selector) {
				return new Collection(this).add(this.parents(selector));
			},
	
			/**
			 * Returns the control next to the current control.
			 *
			 * @method next
			 * @return {tinymce.ui.Control} Next control instance.
			 */
			next: function() {
				var parentControls = this.parent().items();
	
				return parentControls[parentControls.indexOf(this) + 1];
			},
	
			/**
			 * Returns the control previous to the current control.
			 *
			 * @method prev
			 * @return {tinymce.ui.Control} Previous control instance.
			 */
			prev: function() {
				var parentControls = this.parent().items();
	
				return parentControls[parentControls.indexOf(this) - 1];
			},
	
			/**
			 * Sets the inner HTML of the control element.
			 *
			 * @method innerHtml
			 * @param {String} html Html string to set as inner html.
			 * @return {tinymce.ui.Control} Current control object.
			 */
			innerHtml: function(html) {
				this.$el.html(html);
				return this;
			},
	
			/**
			 * Returns the control DOM element or sub element.
			 *
			 * @method getEl
			 * @param {String} [suffix] Suffix to get element by.
			 * @return {Element} HTML DOM element for the current control or it's children.
			 */
			getEl: function(suffix) {
				var id = suffix ? this._id + '-' + suffix : this._id;
	
				if (!this._elmCache[id]) {
					this._elmCache[id] = $('#' + id)[0];
				}
	
				return this._elmCache[id];
			},
	
			/**
			 * Sets the visible state to true.
			 *
			 * @method show
			 * @return {tinymce.ui.Control} Current control instance.
			 */
			show: function() {
				return this.visible(true);
			},
	
			/**
			 * Sets the visible state to false.
			 *
			 * @method hide
			 * @return {tinymce.ui.Control} Current control instance.
			 */
			hide: function() {
				return this.visible(false);
			},
	
			/**
			 * Focuses the current control.
			 *
			 * @method focus
			 * @return {tinymce.ui.Control} Current control instance.
			 */
			focus: function() {
				try {
					this.getEl().focus();
				} catch (ex) {
					// Ignore IE error
				}
	
				return this;
			},
	
			/**
			 * Blurs the current control.
			 *
			 * @method blur
			 * @return {tinymce.ui.Control} Current control instance.
			 */
			blur: function() {
				this.getEl().blur();
	
				return this;
			},
	
			/**
			 * Sets the specified aria property.
			 *
			 * @method aria
			 * @param {String} name Name of the aria property to set.
			 * @param {String} value Value of the aria property.
			 * @return {tinymce.ui.Control} Current control instance.
			 */
			aria: function(name, value) {
				var self = this, elm = self.getEl(self.ariaTarget);
	
				if (typeof value === "undefined") {
					return self._aria[name];
				}
	
				self._aria[name] = value;
	
				if (self.state.get('rendered')) {
					elm.setAttribute(name == 'role' ? name : 'aria-' + name, value);
				}
	
				return self;
			},
	
			/**
			 * Encodes the specified string with HTML entities. It will also
			 * translate the string to different languages.
			 *
			 * @method encode
			 * @param {String/Object/Array} text Text to entity encode.
			 * @param {Boolean} [translate=true] False if the contents shouldn't be translated.
			 * @return {String} Encoded and possible traslated string.
			 */
			encode: function(text, translate) {
				if (translate !== false) {
					text = this.translate(text);
				}
	
				return (text || '').replace(/[&<>"]/g, function(match) {
					return '&#' + match.charCodeAt(0) + ';';
				});
			},
	
			/**
			 * Returns the translated string.
			 *
			 * @method translate
			 * @param {String} text Text to translate.
			 * @return {String} Translated string or the same as the input.
			 */
			translate: function(text) {
				return Control.translate ? Control.translate(text) : text;
			},
	
			/**
			 * Adds items before the current control.
			 *
			 * @method before
			 * @param {Array/tinymce.ui.Collection} items Array of items to prepend before this control.
			 * @return {tinymce.ui.Control} Current control instance.
			 */
			before: function(items) {
				var self = this, parent = self.parent();
	
				if (parent) {
					parent.insert(items, parent.items().indexOf(self), true);
				}
	
				return self;
			},
	
			/**
			 * Adds items after the current control.
			 *
			 * @method after
			 * @param {Array/tinymce.ui.Collection} items Array of items to append after this control.
			 * @return {tinymce.ui.Control} Current control instance.
			 */
			after: function(items) {
				var self = this, parent = self.parent();
	
				if (parent) {
					parent.insert(items, parent.items().indexOf(self));
				}
	
				return self;
			},
	
			/**
			 * Removes the current control from DOM and from UI collections.
			 *
			 * @method remove
			 * @return {tinymce.ui.Control} Current control instance.
			 */
			remove: function() {
				var self = this, elm = self.getEl(), parent = self.parent(), newItems, i;
	
				if (self.items) {
					var controls = self.items().toArray();
					i = controls.length;
					while (i--) {
						controls[i].remove();
					}
				}
	
				if (parent && parent.items) {
					newItems = [];
	
					parent.items().each(function(item) {
						if (item !== self) {
							newItems.push(item);
						}
					});
	
					parent.items().set(newItems);
					parent._lastRect = null;
				}
	
				if (self._eventsRoot && self._eventsRoot == self) {
					$(elm).off();
				}
	
				var lookup = self.getRoot().controlIdLookup;
				if (lookup) {
					delete lookup[self._id];
				}
	
				if (elm && elm.parentNode) {
					elm.parentNode.removeChild(elm);
				}
	
				self.state.set('rendered', false);
				self.state.destroy();
	
				self.fire('remove');
	
				return self;
			},
	
			/**
			 * Renders the control before the specified element.
			 *
			 * @method renderBefore
			 * @param {Element} elm Element to render before.
			 * @return {tinymce.ui.Control} Current control instance.
			 */
			renderBefore: function(elm) {
				$(elm).before(this.renderHtml());
				this.postRender();
				return this;
			},
	
			/**
			 * Renders the control to the specified element.
			 *
			 * @method renderBefore
			 * @param {Element} elm Element to render to.
			 * @return {tinymce.ui.Control} Current control instance.
			 */
			renderTo: function(elm) {
				$(elm || this.getContainerElm()).append(this.renderHtml());
				this.postRender();
				return this;
			},
	
			preRender: function() {
			},
	
			render: function() {
			},
	
			renderHtml: function() {
				return '<div id="' + this._id + '" class="' + this.classes + '"></div>';
			},
	
			/**
			 * Post render method. Called after the control has been rendered to the target.
			 *
			 * @method postRender
			 * @return {tinymce.ui.Control} Current control instance.
			 */
			postRender: function() {
				var self = this, settings = self.settings, elm, box, parent, name, parentEventsRoot;
	
				self.$el = $(self.getEl());
				self.state.set('rendered', true);
	
				// Bind on<event> settings
				for (name in settings) {
					if (name.indexOf("on") === 0) {
						self.on(name.substr(2), settings[name]);
					}
				}
	
				if (self._eventsRoot) {
					for (parent = self.parent(); !parentEventsRoot && parent; parent = parent.parent()) {
						parentEventsRoot = parent._eventsRoot;
					}
	
					if (parentEventsRoot) {
						for (name in parentEventsRoot._nativeEvents) {
							self._nativeEvents[name] = true;
						}
					}
				}
	
				bindPendingEvents(self);
	
				if (settings.style) {
					elm = self.getEl();
					if (elm) {
						elm.setAttribute('style', settings.style);
						elm.style.cssText = settings.style;
					}
				}
	
				if (self.settings.border) {
					box = self.borderBox;
					self.$el.css({
						'border-top-width': box.top,
						'border-right-width': box.right,
						'border-bottom-width': box.bottom,
						'border-left-width': box.left
					});
				}
	
				// Add instance to lookup
				var root = self.getRoot();
				if (!root.controlIdLookup) {
					root.controlIdLookup = {};
				}
	
				root.controlIdLookup[self._id] = self;
	
				for (var key in self._aria) {
					self.aria(key, self._aria[key]);
				}
	
				if (self.state.get('visible') === false) {
					self.getEl().style.display = 'none';
				}
	
				self.bindStates();
	
				self.state.on('change:visible', function(e) {
					var state = e.value, parentCtrl;
	
					if (self.state.get('rendered')) {
						self.getEl().style.display = state === false ? 'none' : '';
	
						// Need to force a reflow here on IE 8
						self.getEl().getBoundingClientRect();
					}
	
					// Parent container needs to reflow
					parentCtrl = self.parent();
					if (parentCtrl) {
						parentCtrl._lastRect = null;
					}
	
					self.fire(state ? 'show' : 'hide');
	
					ReflowQueue.add(self);
				});
	
				self.fire('postrender', {}, false);
			},
	
			bindStates: function() {
			},
	
			/**
			 * Scrolls the current control into view.
			 *
			 * @method scrollIntoView
			 * @param {String} align Alignment in view top|center|bottom.
			 * @return {tinymce.ui.Control} Current control instance.
			 */
			scrollIntoView: function(align) {
				function getOffset(elm, rootElm) {
					var x, y, parent = elm;
	
					x = y = 0;
					while (parent && parent != rootElm && parent.nodeType) {
						x += parent.offsetLeft || 0;
						y += parent.offsetTop || 0;
						parent = parent.offsetParent;
					}
	
					return {x: x, y: y};
				}
	
				var elm = this.getEl(), parentElm = elm.parentNode;
				var x, y, width, height, parentWidth, parentHeight;
				var pos = getOffset(elm, parentElm);
	
				x = pos.x;
				y = pos.y;
				width = elm.offsetWidth;
				height = elm.offsetHeight;
				parentWidth = parentElm.clientWidth;
				parentHeight = parentElm.clientHeight;
	
				if (align == "end") {
					x -= parentWidth - width;
					y -= parentHeight - height;
				} else if (align == "center") {
					x -= (parentWidth / 2) - (width / 2);
					y -= (parentHeight / 2) - (height / 2);
				}
	
				parentElm.scrollLeft = x;
				parentElm.scrollTop = y;
	
				return this;
			},
	
			getRoot: function() {
				var ctrl = this, rootControl, parents = [];
	
				while (ctrl) {
					if (ctrl.rootControl) {
						rootControl = ctrl.rootControl;
						break;
					}
	
					parents.push(ctrl);
					rootControl = ctrl;
					ctrl = ctrl.parent();
				}
	
				if (!rootControl) {
					rootControl = this;
				}
	
				var i = parents.length;
				while (i--) {
					parents[i].rootControl = rootControl;
				}
	
				return rootControl;
			},
	
			/**
			 * Reflows the current control and it's parents.
			 * This should be used after you for example append children to the current control so
			 * that the layout managers know that they need to reposition everything.
			 *
			 * @example
			 * container.append({type: 'button', text: 'My button'}).reflow();
			 *
			 * @method reflow
			 * @return {tinymce.ui.Control} Current control instance.
			 */
			reflow: function() {
				ReflowQueue.remove(this);
	
				var parent = this.parent();
				if (parent._layout && !parent._layout.isNative()) {
					parent.reflow();
				}
	
				return this;
			}
	
			/**
			 * Sets/gets the parent container for the control.
			 *
			 * @method parent
			 * @param {tinymce.ui.Container} parent Optional parent to set.
			 * @return {tinymce.ui.Control} Parent control or the current control on a set action.
			 */
			// parent: function(parent) {} -- Generated
	
			/**
			 * Sets/gets the text for the control.
			 *
			 * @method text
			 * @param {String} value Value to set to control.
			 * @return {String/tinymce.ui.Control} Current control on a set operation or current value on a get.
			 */
			// text: function(value) {} -- Generated
	
			/**
			 * Sets/gets the disabled state on the control.
			 *
			 * @method disabled
			 * @param {Boolean} state Value to set to control.
			 * @return {Boolean/tinymce.ui.Control} Current control on a set operation or current state on a get.
			 */
			// disabled: function(state) {} -- Generated
	
			/**
			 * Sets/gets the active for the control.
			 *
			 * @method active
			 * @param {Boolean} state Value to set to control.
			 * @return {Boolean/tinymce.ui.Control} Current control on a set operation or current state on a get.
			 */
			// active: function(state) {} -- Generated
	
			/**
			 * Sets/gets the name for the control.
			 *
			 * @method name
			 * @param {String} value Value to set to control.
			 * @return {String/tinymce.ui.Control} Current control on a set operation or current value on a get.
			 */
			// name: function(value) {} -- Generated
	
			/**
			 * Sets/gets the title for the control.
			 *
			 * @method title
			 * @param {String} value Value to set to control.
			 * @return {String/tinymce.ui.Control} Current control on a set operation or current value on a get.
			 */
			// title: function(value) {} -- Generated
	
			/**
			 * Sets/gets the visible for the control.
			 *
			 * @method visible
			 * @param {Boolean} state Value to set to control.
			 * @return {Boolean/tinymce.ui.Control} Current control on a set operation or current state on a get.
			 */
			// visible: function(value) {} -- Generated
		};
	
		/**
		 * Setup state properties.
		 */
		Tools.each('text title visible disabled active value'.split(' '), function(name) {
			proto[name] = function(value) {
				if (arguments.length === 0) {
					return this.state.get(name);
				}
	
				if (typeof value != "undefined") {
					this.state.set(name, value);
				}
	
				return this;
			};
		});
	
		Control = Class.extend(proto);
	
		function getEventDispatcher(obj) {
			if (!obj._eventDispatcher) {
				obj._eventDispatcher = new EventDispatcher({
					scope: obj,
					toggleEvent: function(name, state) {
						if (state && EventDispatcher.isNative(name)) {
							if (!obj._nativeEvents) {
								obj._nativeEvents = {};
							}
	
							obj._nativeEvents[name] = true;
	
							if (obj.state.get('rendered')) {
								bindPendingEvents(obj);
							}
						}
					}
				});
			}
	
			return obj._eventDispatcher;
		}
	
		function bindPendingEvents(eventCtrl) {
			var i, l, parents, eventRootCtrl, nativeEvents, name;
	
			function delegate(e) {
				var control = eventCtrl.getParentCtrl(e.target);
	
				if (control) {
					control.fire(e.type, e);
				}
			}
	
			function mouseLeaveHandler() {
				var ctrl = eventRootCtrl._lastHoverCtrl;
	
				if (ctrl) {
					ctrl.fire("mouseleave", {target: ctrl.getEl()});
	
					ctrl.parents().each(function(ctrl) {
						ctrl.fire("mouseleave", {target: ctrl.getEl()});
					});
	
					eventRootCtrl._lastHoverCtrl = null;
				}
			}
	
			function mouseEnterHandler(e) {
				var ctrl = eventCtrl.getParentCtrl(e.target), lastCtrl = eventRootCtrl._lastHoverCtrl, idx = 0, i, parents, lastParents;
	
				// Over on a new control
				if (ctrl !== lastCtrl) {
					eventRootCtrl._lastHoverCtrl = ctrl;
	
					parents = ctrl.parents().toArray().reverse();
					parents.push(ctrl);
	
					if (lastCtrl) {
						lastParents = lastCtrl.parents().toArray().reverse();
						lastParents.push(lastCtrl);
	
						for (idx = 0; idx < lastParents.length; idx++) {
							if (parents[idx] !== lastParents[idx]) {
								break;
							}
						}
	
						for (i = lastParents.length - 1; i >= idx; i--) {
							lastCtrl = lastParents[i];
							lastCtrl.fire("mouseleave", {
								target: lastCtrl.getEl()
							});
						}
					}
	
					for (i = idx; i < parents.length; i++) {
						ctrl = parents[i];
						ctrl.fire("mouseenter", {
							target: ctrl.getEl()
						});
					}
				}
			}
	
			function fixWheelEvent(e) {
				e.preventDefault();
	
				if (e.type == "mousewheel") {
					e.deltaY = -1 / 40 * e.wheelDelta;
	
					if (e.wheelDeltaX) {
						e.deltaX = -1 / 40 * e.wheelDeltaX;
					}
				} else {
					e.deltaX = 0;
					e.deltaY = e.detail;
				}
	
				e = eventCtrl.fire("wheel", e);
			}
	
			nativeEvents = eventCtrl._nativeEvents;
			if (nativeEvents) {
				// Find event root element if it exists
				parents = eventCtrl.parents().toArray();
				parents.unshift(eventCtrl);
				for (i = 0, l = parents.length; !eventRootCtrl && i < l; i++) {
					eventRootCtrl = parents[i]._eventsRoot;
				}
	
				// Event root wasn't found the use the root control
				if (!eventRootCtrl) {
					eventRootCtrl = parents[parents.length - 1] || eventCtrl;
				}
	
				// Set the eventsRoot property on children that didn't have it
				eventCtrl._eventsRoot = eventRootCtrl;
				for (l = i, i = 0; i < l; i++) {
					parents[i]._eventsRoot = eventRootCtrl;
				}
	
				var eventRootDelegates = eventRootCtrl._delegates;
				if (!eventRootDelegates) {
					eventRootDelegates = eventRootCtrl._delegates = {};
				}
	
				// Bind native event delegates
				for (name in nativeEvents) {
					if (!nativeEvents) {
						return false;
					}
	
					if (name === "wheel" && !hasWheelEventSupport) {
						if (hasMouseWheelEventSupport) {
							$(eventCtrl.getEl()).on("mousewheel", fixWheelEvent);
						} else {
							$(eventCtrl.getEl()).on("DOMMouseScroll", fixWheelEvent);
						}
	
						continue;
					}
	
					// Special treatment for mousenter/mouseleave since these doesn't bubble
					if (name === "mouseenter" || name === "mouseleave") {
						// Fake mousenter/mouseleave
						if (!eventRootCtrl._hasMouseEnter) {
							$(eventRootCtrl.getEl()).on("mouseleave", mouseLeaveHandler).on("mouseover", mouseEnterHandler);
							eventRootCtrl._hasMouseEnter = 1;
						}
					} else if (!eventRootDelegates[name]) {
						$(eventRootCtrl.getEl()).on(name, delegate);
						eventRootDelegates[name] = true;
					}
	
					// Remove the event once it's bound
					nativeEvents[name] = false;
				}
			}
		}
	
		return Control;
	});
	
	// Included from: js/tinymce/classes/ui/Factory.js
	
	/**
	 * Factory.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/*global tinymce:true */
	
	/**
	 * This class is a factory for control instances. This enables you
	 * to create instances of controls without having to require the UI controls directly.
	 *
	 * It also allow you to override or add new control types.
	 *
	 * @class tinymce.ui.Factory
	 */
	define("tinymce/ui/Factory", [], function() {
		"use strict";
	
		var types = {}, namespaceInit;
	
		return {
			/**
			 * Adds a new control instance type to the factory.
			 *
			 * @method add
			 * @param {String} type Type name for example "button".
			 * @param {function} typeClass Class type function.
			 */
			add: function(type, typeClass) {
				types[type.toLowerCase()] = typeClass;
			},
	
			/**
			 * Returns true/false if the specified type exists or not.
			 *
			 * @method has
			 * @param {String} type Type to look for.
			 * @return {Boolean} true/false if the control by name exists.
			 */
			has: function(type) {
				return !!types[type.toLowerCase()];
			},
	
			/**
			 * Creates a new control instance based on the settings provided. The instance created will be
			 * based on the specified type property it can also create whole structures of components out of
			 * the specified JSON object.
			 *
			 * @example
			 * tinymce.ui.Factory.create({
			 *     type: 'button',
			 *     text: 'Hello world!'
			 * });
			 *
			 * @method create
			 * @param {Object/String} settings Name/Value object with items used to create the type.
			 * @return {tinymce.ui.Control} Control instance based on the specified type.
			 */
			create: function(type, settings) {
				var ControlType, name, namespace;
	
				// Build type lookup
				if (!namespaceInit) {
					namespace = tinymce.ui;
	
					for (name in namespace) {
						types[name.toLowerCase()] = namespace[name];
					}
	
					namespaceInit = true;
				}
	
				// If string is specified then use it as the type
				if (typeof type == 'string') {
					settings = settings || {};
					settings.type = type;
				} else {
					settings = type;
					type = settings.type;
				}
	
				// Find control type
				type = type.toLowerCase();
				ControlType = types[type];
	
				// #if debug
	
				if (!ControlType) {
					throw new Error("Could not find control by type: " + type);
				}
	
				// #endif
	
				ControlType = new ControlType(settings);
				ControlType.type = type; // Set the type on the instance, this will be used by the Selector engine
	
				return ControlType;
			}
		};
	});
	
	// Included from: js/tinymce/classes/ui/KeyboardNavigation.js
	
	/**
	 * KeyboardNavigation.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * This class handles keyboard navigation of controls and elements.
	 *
	 * @class tinymce.ui.KeyboardNavigation
	 */
	define("tinymce/ui/KeyboardNavigation", [
	], function() {
		"use strict";
	
		/**
		 * This class handles all keyboard navigation for WAI-ARIA support. Each root container
		 * gets an instance of this class.
		 *
		 * @constructor
		 */
		return function(settings) {
			var root = settings.root, focusedElement, focusedControl;
	
			function isElement(node) {
				return node && node.nodeType === 1;
			}
	
			try {
				focusedElement = document.activeElement;
			} catch (ex) {
				// IE sometimes fails to return a proper element
				focusedElement = document.body;
			}
	
			focusedControl = root.getParentCtrl(focusedElement);
	
			/**
			 * Returns the currently focused elements wai aria role of the currently
			 * focused element or specified element.
			 *
			 * @private
			 * @param {Element} elm Optional element to get role from.
			 * @return {String} Role of specified element.
			 */
			function getRole(elm) {
				elm = elm || focusedElement;
	
				if (isElement(elm)) {
					return elm.getAttribute('role');
				}
	
				return null;
			}
	
			/**
			 * Returns the wai role of the parent element of the currently
			 * focused element or specified element.
			 *
			 * @private
			 * @param {Element} elm Optional element to get parent role from.
			 * @return {String} Role of the first parent that has a role.
			 */
			function getParentRole(elm) {
				var role, parent = elm || focusedElement;
	
				while ((parent = parent.parentNode)) {
					if ((role = getRole(parent))) {
						return role;
					}
				}
			}
	
			/**
			 * Returns a wai aria property by name for example aria-selected.
			 *
			 * @private
			 * @param {String} name Name of the aria property to get for example "disabled".
			 * @return {String} Aria property value.
			 */
			function getAriaProp(name) {
				var elm = focusedElement;
	
				if (isElement(elm)) {
					return elm.getAttribute('aria-' + name);
				}
			}
	
			/**
			 * Is the element a text input element or not.
			 *
			 * @private
			 * @param {Element} elm Element to check if it's an text input element or not.
			 * @return {Boolean} True/false if the element is a text element or not.
			 */
			function isTextInputElement(elm) {
				var tagName = elm.tagName.toUpperCase();
	
				// Notice: since type can be "email" etc we don't check the type
				// So all input elements gets treated as text input elements
				return tagName == "INPUT" || tagName == "TEXTAREA" || tagName == "SELECT";
			}
	
			/**
			 * Returns true/false if the specified element can be focused or not.
			 *
			 * @private
			 * @param {Element} elm DOM element to check if it can be focused or not.
			 * @return {Boolean} True/false if the element can have focus.
			 */
			function canFocus(elm) {
				if (isTextInputElement(elm) && !elm.hidden) {
					return true;
				}
	
				if (/^(button|menuitem|checkbox|tab|menuitemcheckbox|option|gridcell|slider)$/.test(getRole(elm))) {
					return true;
				}
	
				return false;
			}
	
			/**
			 * Returns an array of focusable visible elements within the specified container element.
			 *
			 * @private
			 * @param {Element} elm DOM element to find focusable elements within.
			 * @return {Array} Array of focusable elements.
			 */
			function getFocusElements(elm) {
				var elements = [];
	
				function collect(elm) {
					if (elm.nodeType != 1 || elm.style.display == 'none') {
						return;
					}
	
					if (canFocus(elm)) {
						elements.push(elm);
					}
	
					for (var i = 0; i < elm.childNodes.length; i++) {
						collect(elm.childNodes[i]);
					}
				}
	
				collect(elm || root.getEl());
	
				return elements;
			}
	
			/**
			 * Returns the navigation root control for the specified control. The navigation root
			 * is the control that the keyboard navigation gets scoped to for example a menubar or toolbar group.
			 * It will look for parents of the specified target control or the currently focused control if this option is omitted.
			 *
			 * @private
			 * @param {tinymce.ui.Control} targetControl Optional target control to find root of.
			 * @return {tinymce.ui.Control} Navigation root control.
			 */
			function getNavigationRoot(targetControl) {
				var navigationRoot, controls;
	
				targetControl = targetControl || focusedControl;
				controls = targetControl.parents().toArray();
				controls.unshift(targetControl);
	
				for (var i = 0; i < controls.length; i++) {
					navigationRoot = controls[i];
	
					if (navigationRoot.settings.ariaRoot) {
						break;
					}
				}
	
				return navigationRoot;
			}
	
			/**
			 * Focuses the first item in the specified targetControl element or the last aria index if the
			 * navigation root has the ariaRemember option enabled.
			 *
			 * @private
			 * @param {tinymce.ui.Control} targetControl Target control to focus the first item in.
			 */
			function focusFirst(targetControl) {
				var navigationRoot = getNavigationRoot(targetControl);
				var focusElements = getFocusElements(navigationRoot.getEl());
	
				if (navigationRoot.settings.ariaRemember && "lastAriaIndex" in navigationRoot) {
					moveFocusToIndex(navigationRoot.lastAriaIndex, focusElements);
				} else {
					moveFocusToIndex(0, focusElements);
				}
			}
	
			/**
			 * Moves the focus to the specified index within the elements list.
			 * This will scope the index to the size of the element list if it changed.
			 *
			 * @private
			 * @param {Number} idx Specified index to move to.
			 * @param {Array} elements Array with dom elements to move focus within.
			 * @return {Number} Input index or a changed index if it was out of range.
			 */
			function moveFocusToIndex(idx, elements) {
				if (idx < 0) {
					idx = elements.length - 1;
				} else if (idx >= elements.length) {
					idx = 0;
				}
	
				if (elements[idx]) {
					elements[idx].focus();
				}
	
				return idx;
			}
	
			/**
			 * Moves the focus forwards or backwards.
			 *
			 * @private
			 * @param {Number} dir Direction to move in positive means forward, negative means backwards.
			 * @param {Array} elements Optional array of elements to move within defaults to the current navigation roots elements.
			 */
			function moveFocus(dir, elements) {
				var idx = -1, navigationRoot = getNavigationRoot();
	
				elements = elements || getFocusElements(navigationRoot.getEl());
	
				for (var i = 0; i < elements.length; i++) {
					if (elements[i] === focusedElement) {
						idx = i;
					}
				}
	
				idx += dir;
				navigationRoot.lastAriaIndex = moveFocusToIndex(idx, elements);
			}
	
			/**
			 * Moves the focus to the left this is called by the left key.
			 *
			 * @private
			 */
			function left() {
				var parentRole = getParentRole();
	
				if (parentRole == "tablist") {
					moveFocus(-1, getFocusElements(focusedElement.parentNode));
				} else if (focusedControl.parent().submenu) {
					cancel();
				} else {
					moveFocus(-1);
				}
			}
	
			/**
			 * Moves the focus to the right this is called by the right key.
			 *
			 * @private
			 */
			function right() {
				var role = getRole(), parentRole = getParentRole();
	
				if (parentRole == "tablist") {
					moveFocus(1, getFocusElements(focusedElement.parentNode));
				} else if (role == "menuitem" && parentRole == "menu" && getAriaProp('haspopup')) {
					enter();
				} else {
					moveFocus(1);
				}
			}
	
			/**
			 * Moves the focus to the up this is called by the up key.
			 *
			 * @private
			 */
			function up() {
				moveFocus(-1);
			}
	
			/**
			 * Moves the focus to the up this is called by the down key.
			 *
			 * @private
			 */
			function down() {
				var role = getRole(), parentRole = getParentRole();
	
				if (role == "menuitem" && parentRole == "menubar") {
					enter();
				} else if (role == "button" && getAriaProp('haspopup')) {
					enter({key: 'down'});
				} else {
					moveFocus(1);
				}
			}
	
			/**
			 * Moves the focus to the next item or previous item depending on shift key.
			 *
			 * @private
			 * @param {DOMEvent} e DOM event object.
			 */
			function tab(e) {
				var parentRole = getParentRole();
	
				if (parentRole == "tablist") {
					var elm = getFocusElements(focusedControl.getEl('body'))[0];
	
					if (elm) {
						elm.focus();
					}
				} else {
					moveFocus(e.shiftKey ? -1 : 1);
				}
			}
	
			/**
			 * Calls the cancel event on the currently focused control. This is normally done using the Esc key.
			 *
			 * @private
			 */
			function cancel() {
				focusedControl.fire('cancel');
			}
	
			/**
			 * Calls the click event on the currently focused control. This is normally done using the Enter/Space keys.
			 *
			 * @private
			 * @param {Object} aria Optional aria data to pass along with the enter event.
			 */
			function enter(aria) {
				aria = aria || {};
				focusedControl.fire('click', {target: focusedElement, aria: aria});
			}
	
			root.on('keydown', function(e) {
				function handleNonTabOrEscEvent(e, handler) {
					// Ignore non tab keys for text elements
					if (isTextInputElement(focusedElement)) {
						return;
					}
	
					if (getRole(focusedElement) === 'slider') {
						return;
					}
	
					if (handler(e) !== false) {
						e.preventDefault();
					}
				}
	
				if (e.isDefaultPrevented()) {
					return;
				}
	
				switch (e.keyCode) {
					case 37: // DOM_VK_LEFT
						handleNonTabOrEscEvent(e, left);
						break;
	
					case 39: // DOM_VK_RIGHT
						handleNonTabOrEscEvent(e, right);
						break;
	
					case 38: // DOM_VK_UP
						handleNonTabOrEscEvent(e, up);
						break;
	
					case 40: // DOM_VK_DOWN
						handleNonTabOrEscEvent(e, down);
						break;
	
					case 27: // DOM_VK_ESCAPE
						cancel();
						break;
	
					case 14: // DOM_VK_ENTER
					case 13: // DOM_VK_RETURN
					case 32: // DOM_VK_SPACE
						handleNonTabOrEscEvent(e, enter);
						break;
	
					case 9: // DOM_VK_TAB
						if (tab(e) !== false) {
							e.preventDefault();
						}
						break;
				}
			});
	
			root.on('focusin', function(e) {
				focusedElement = e.target;
				focusedControl = e.control;
			});
	
			return {
				focusFirst: focusFirst
			};
		};
	});
	
	// Included from: js/tinymce/classes/ui/Container.js
	
	/**
	 * Container.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * Container control. This is extended by all controls that can have
	 * children such as panels etc. You can also use this class directly as an
	 * generic container instance. The container doesn't have any specific role or style.
	 *
	 * @-x-less Container.less
	 * @class tinymce.ui.Container
	 * @extends tinymce.ui.Control
	 */
	define("tinymce/ui/Container", [
		"tinymce/ui/Control",
		"tinymce/ui/Collection",
		"tinymce/ui/Selector",
		"tinymce/ui/Factory",
		"tinymce/ui/KeyboardNavigation",
		"tinymce/util/Tools",
		"tinymce/dom/DomQuery",
		"tinymce/ui/ClassList",
		"tinymce/ui/ReflowQueue"
	], function(Control, Collection, Selector, Factory, KeyboardNavigation, Tools, $, ClassList, ReflowQueue) {
		"use strict";
	
		var selectorCache = {};
	
		return Control.extend({
			/**
			 * Constructs a new control instance with the specified settings.
			 *
			 * @constructor
			 * @param {Object} settings Name/value object with settings.
			 * @setting {Array} items Items to add to container in JSON format or control instances.
			 * @setting {String} layout Layout manager by name to use.
			 * @setting {Object} defaults Default settings to apply to all items.
			 */
			init: function(settings) {
				var self = this;
	
				self._super(settings);
				settings = self.settings;
	
				if (settings.fixed) {
					self.state.set('fixed', true);
				}
	
				self._items = new Collection();
	
				if (self.isRtl()) {
					self.classes.add('rtl');
				}
	
				self.bodyClasses = new ClassList(function() {
					if (self.state.get('rendered')) {
						self.getEl('body').className = this.toString();
					}
				});
				self.bodyClasses.prefix = self.classPrefix;
	
				self.classes.add('container');
				self.bodyClasses.add('container-body');
	
				if (settings.containerCls) {
					self.classes.add(settings.containerCls);
				}
	
				self._layout = Factory.create((settings.layout || '') + 'layout');
	
				if (self.settings.items) {
					self.add(self.settings.items);
				} else {
					self.add(self.render());
				}
	
				// TODO: Fix this!
				self._hasBody = true;
			},
	
			/**
			 * Returns a collection of child items that the container currently have.
			 *
			 * @method items
			 * @return {tinymce.ui.Collection} Control collection direct child controls.
			 */
			items: function() {
				return this._items;
			},
	
			/**
			 * Find child controls by selector.
			 *
			 * @method find
			 * @param {String} selector Selector CSS pattern to find children by.
			 * @return {tinymce.ui.Collection} Control collection with child controls.
			 */
			find: function(selector) {
				selector = selectorCache[selector] = selectorCache[selector] || new Selector(selector);
	
				return selector.find(this);
			},
	
			/**
			 * Adds one or many items to the current container. This will create instances of
			 * the object representations if needed.
			 *
			 * @method add
			 * @param {Array/Object/tinymce.ui.Control} items Array or item that will be added to the container.
			 * @return {tinymce.ui.Collection} Current collection control.
			 */
			add: function(items) {
				var self = this;
	
				self.items().add(self.create(items)).parent(self);
	
				return self;
			},
	
			/**
			 * Focuses the current container instance. This will look
			 * for the first control in the container and focus that.
			 *
			 * @method focus
			 * @param {Boolean} keyboard Optional true/false if the focus was a keyboard focus or not.
			 * @return {tinymce.ui.Collection} Current instance.
			 */
			focus: function(keyboard) {
				var self = this, focusCtrl, keyboardNav, items;
	
				if (keyboard) {
					keyboardNav = self.keyboardNav || self.parents().eq(-1)[0].keyboardNav;
	
					if (keyboardNav) {
						keyboardNav.focusFirst(self);
						return;
					}
				}
	
				items = self.find('*');
	
				// TODO: Figure out a better way to auto focus alert dialog buttons
				if (self.statusbar) {
					items.add(self.statusbar.items());
				}
	
				items.each(function(ctrl) {
					if (ctrl.settings.autofocus) {
						focusCtrl = null;
						return false;
					}
	
					if (ctrl.canFocus) {
						focusCtrl = focusCtrl || ctrl;
					}
				});
	
				if (focusCtrl) {
					focusCtrl.focus();
				}
	
				return self;
			},
	
			/**
			 * Replaces the specified child control with a new control.
			 *
			 * @method replace
			 * @param {tinymce.ui.Control} oldItem Old item to be replaced.
			 * @param {tinymce.ui.Control} newItem New item to be inserted.
			 */
			replace: function(oldItem, newItem) {
				var ctrlElm, items = this.items(), i = items.length;
	
				// Replace the item in collection
				while (i--) {
					if (items[i] === oldItem) {
						items[i] = newItem;
						break;
					}
				}
	
				if (i >= 0) {
					// Remove new item from DOM
					ctrlElm = newItem.getEl();
					if (ctrlElm) {
						ctrlElm.parentNode.removeChild(ctrlElm);
					}
	
					// Remove old item from DOM
					ctrlElm = oldItem.getEl();
					if (ctrlElm) {
						ctrlElm.parentNode.removeChild(ctrlElm);
					}
				}
	
				// Adopt the item
				newItem.parent(this);
			},
	
			/**
			 * Creates the specified items. If any of the items is plain JSON style objects
			 * it will convert these into real tinymce.ui.Control instances.
			 *
			 * @method create
			 * @param {Array} items Array of items to convert into control instances.
			 * @return {Array} Array with control instances.
			 */
			create: function(items) {
				var self = this, settings, ctrlItems = [];
	
				// Non array structure, then force it into an array
				if (!Tools.isArray(items)) {
					items = [items];
				}
	
				// Add default type to each child control
				Tools.each(items, function(item) {
					if (item) {
						// Construct item if needed
						if (!(item instanceof Control)) {
							// Name only then convert it to an object
							if (typeof item == "string") {
								item = {type: item};
							}
	
							// Create control instance based on input settings and default settings
							settings = Tools.extend({}, self.settings.defaults, item);
							item.type = settings.type = settings.type || item.type || self.settings.defaultType ||
								(settings.defaults ? settings.defaults.type : null);
							item = Factory.create(settings);
						}
	
						ctrlItems.push(item);
					}
				});
	
				return ctrlItems;
			},
	
			/**
			 * Renders new control instances.
			 *
			 * @private
			 */
			renderNew: function() {
				var self = this;
	
				// Render any new items
				self.items().each(function(ctrl, index) {
					var containerElm;
	
					ctrl.parent(self);
	
					if (!ctrl.state.get('rendered')) {
						containerElm = self.getEl('body');
	
						// Insert or append the item
						if (containerElm.hasChildNodes() && index <= containerElm.childNodes.length - 1) {
							$(containerElm.childNodes[index]).before(ctrl.renderHtml());
						} else {
							$(containerElm).append(ctrl.renderHtml());
						}
	
						ctrl.postRender();
						ReflowQueue.add(ctrl);
					}
				});
	
				self._layout.applyClasses(self.items().filter(':visible'));
				self._lastRect = null;
	
				return self;
			},
	
			/**
			 * Appends new instances to the current container.
			 *
			 * @method append
			 * @param {Array/tinymce.ui.Collection} items Array if controls to append.
			 * @return {tinymce.ui.Container} Current container instance.
			 */
			append: function(items) {
				return this.add(items).renderNew();
			},
	
			/**
			 * Prepends new instances to the current container.
			 *
			 * @method prepend
			 * @param {Array/tinymce.ui.Collection} items Array if controls to prepend.
			 * @return {tinymce.ui.Container} Current container instance.
			 */
			prepend: function(items) {
				var self = this;
	
				self.items().set(self.create(items).concat(self.items().toArray()));
	
				return self.renderNew();
			},
	
			/**
			 * Inserts an control at a specific index.
			 *
			 * @method insert
			 * @param {Array/tinymce.ui.Collection} items Array if controls to insert.
			 * @param {Number} index Index to insert controls at.
			 * @param {Boolean} [before=false] Inserts controls before the index.
			 */
			insert: function(items, index, before) {
				var self = this, curItems, beforeItems, afterItems;
	
				items = self.create(items);
				curItems = self.items();
	
				if (!before && index < curItems.length - 1) {
					index += 1;
				}
	
				if (index >= 0 && index < curItems.length) {
					beforeItems = curItems.slice(0, index).toArray();
					afterItems = curItems.slice(index).toArray();
					curItems.set(beforeItems.concat(items, afterItems));
				}
	
				return self.renderNew();
			},
	
			/**
			 * Populates the form fields from the specified JSON data object.
			 *
			 * Control items in the form that matches the data will have it's value set.
			 *
			 * @method fromJSON
			 * @param {Object} data JSON data object to set control values by.
			 * @return {tinymce.ui.Container} Current form instance.
			 */
			fromJSON: function(data) {
				var self = this;
	
				for (var name in data) {
					self.find('#' + name).value(data[name]);
				}
	
				return self;
			},
	
			/**
			 * Serializes the form into a JSON object by getting all items
			 * that has a name and a value.
			 *
			 * @method toJSON
			 * @return {Object} JSON object with form data.
			 */
			toJSON: function() {
				var self = this, data = {};
	
				self.find('*').each(function(ctrl) {
					var name = ctrl.name(), value = ctrl.value();
	
					if (name && typeof value != "undefined") {
						data[name] = value;
					}
				});
	
				return data;
			},
	
			/**
			 * Renders the control as a HTML string.
			 *
			 * @method renderHtml
			 * @return {String} HTML representing the control.
			 */
			renderHtml: function() {
				var self = this, layout = self._layout, role = this.settings.role;
	
				self.preRender();
				layout.preRender(self);
	
				return (
					'<div id="' + self._id + '" class="' + self.classes + '"' + (role ? ' role="' + this.settings.role + '"' : '') + '>' +
						'<div id="' + self._id + '-body" class="' + self.bodyClasses + '">' +
							(self.settings.html || '') + layout.renderHtml(self) +
						'</div>' +
					'</div>'
				);
			},
	
			/**
			 * Post render method. Called after the control has been rendered to the target.
			 *
			 * @method postRender
			 * @return {tinymce.ui.Container} Current combobox instance.
			 */
			postRender: function() {
				var self = this, box;
	
				self.items().exec('postRender');
				self._super();
	
				self._layout.postRender(self);
				self.state.set('rendered', true);
	
				if (self.settings.style) {
					self.$el.css(self.settings.style);
				}
	
				if (self.settings.border) {
					box = self.borderBox;
					self.$el.css({
						'border-top-width': box.top,
						'border-right-width': box.right,
						'border-bottom-width': box.bottom,
						'border-left-width': box.left
					});
				}
	
				if (!self.parent()) {
					self.keyboardNav = new KeyboardNavigation({
						root: self
					});
				}
	
				return self;
			},
	
			/**
			 * Initializes the current controls layout rect.
			 * This will be executed by the layout managers to determine the
			 * default minWidth/minHeight etc.
			 *
			 * @method initLayoutRect
			 * @return {Object} Layout rect instance.
			 */
			initLayoutRect: function() {
				var self = this, layoutRect = self._super();
	
				// Recalc container size by asking layout manager
				self._layout.recalc(self);
	
				return layoutRect;
			},
	
			/**
			 * Recalculates the positions of the controls in the current container.
			 * This is invoked by the reflow method and shouldn't be called directly.
			 *
			 * @method recalc
			 */
			recalc: function() {
				var self = this, rect = self._layoutRect, lastRect = self._lastRect;
	
				if (!lastRect || lastRect.w != rect.w || lastRect.h != rect.h) {
					self._layout.recalc(self);
					rect = self.layoutRect();
					self._lastRect = {x: rect.x, y: rect.y, w: rect.w, h: rect.h};
					return true;
				}
			},
	
			/**
			 * Reflows the current container and it's children and possible parents.
			 * This should be used after you for example append children to the current control so
			 * that the layout managers know that they need to reposition everything.
			 *
			 * @example
			 * container.append({type: 'button', text: 'My button'}).reflow();
			 *
			 * @method reflow
			 * @return {tinymce.ui.Container} Current container instance.
			 */
			reflow: function() {
				var i;
	
				ReflowQueue.remove(this);
	
				if (this.visible()) {
					Control.repaintControls = [];
					Control.repaintControls.map = {};
	
					this.recalc();
					i = Control.repaintControls.length;
	
					while (i--) {
						Control.repaintControls[i].repaint();
					}
	
					// TODO: Fix me!
					if (this.settings.layout !== "flow" && this.settings.layout !== "stack") {
						this.repaint();
					}
	
					Control.repaintControls = [];
				}
	
				return this;
			}
		});
	});
	
	// Included from: js/tinymce/classes/ui/DragHelper.js
	
	/**
	 * DragHelper.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * Drag/drop helper class.
	 *
	 * @example
	 * var dragHelper = new tinymce.ui.DragHelper('mydiv', {
	 *     start: function(evt) {
	 *     },
	 *
	 *     drag: function(evt) {
	 *     },
	 *
	 *     end: function(evt) {
	 *     }
	 * });
	 *
	 * @class tinymce.ui.DragHelper
	 */
	define("tinymce/ui/DragHelper", [
		"tinymce/dom/DomQuery"
	], function($) {
		"use strict";
	
		function getDocumentSize(doc) {
			var documentElement, body, scrollWidth, clientWidth;
			var offsetWidth, scrollHeight, clientHeight, offsetHeight, max = Math.max;
	
			documentElement = doc.documentElement;
			body = doc.body;
	
			scrollWidth = max(documentElement.scrollWidth, body.scrollWidth);
			clientWidth = max(documentElement.clientWidth, body.clientWidth);
			offsetWidth = max(documentElement.offsetWidth, body.offsetWidth);
	
			scrollHeight = max(documentElement.scrollHeight, body.scrollHeight);
			clientHeight = max(documentElement.clientHeight, body.clientHeight);
			offsetHeight = max(documentElement.offsetHeight, body.offsetHeight);
	
			return {
				width: scrollWidth < offsetWidth ? clientWidth : scrollWidth,
				height: scrollHeight < offsetHeight ? clientHeight : scrollHeight
			};
		}
	
		function updateWithTouchData(e) {
			var keys, i;
	
			if (e.changedTouches) {
				keys = "screenX screenY pageX pageY clientX clientY".split(' ');
				for (i = 0; i < keys.length; i++) {
					e[keys[i]] = e.changedTouches[0][keys[i]];
				}
			}
		}
	
		return function(id, settings) {
			var $eventOverlay, doc = settings.document || document, downButton, start, stop, drag, startX, startY;
	
			settings = settings || {};
	
			function getHandleElm() {
				return doc.getElementById(settings.handle || id);
			}
	
			start = function(e) {
				var docSize = getDocumentSize(doc), handleElm, cursor;
	
				updateWithTouchData(e);
	
				e.preventDefault();
				downButton = e.button;
				handleElm = getHandleElm();
				startX = e.screenX;
				startY = e.screenY;
	
				// Grab cursor from handle so we can place it on overlay
				if (window.getComputedStyle) {
					cursor = window.getComputedStyle(handleElm, null).getPropertyValue("cursor");
				} else {
					cursor = handleElm.runtimeStyle.cursor;
				}
	
				$eventOverlay = $('<div>').css({
					position: "absolute",
					top: 0, left: 0,
					width: docSize.width,
					height: docSize.height,
					zIndex: 0x7FFFFFFF,
					opacity: 0.0001,
					cursor: cursor
				}).appendTo(doc.body);
	
				$(doc).on('mousemove touchmove', drag).on('mouseup touchend', stop);
	
				settings.start(e);
			};
	
			drag = function(e) {
				updateWithTouchData(e);
	
				if (e.button !== downButton) {
					return stop(e);
				}
	
				e.deltaX = e.screenX - startX;
				e.deltaY = e.screenY - startY;
	
				e.preventDefault();
				settings.drag(e);
			};
	
			stop = function(e) {
				updateWithTouchData(e);
	
				$(doc).off('mousemove touchmove', drag).off('mouseup touchend', stop);
	
				$eventOverlay.remove();
	
				if (settings.stop) {
					settings.stop(e);
				}
			};
	
			/**
			 * Destroys the drag/drop helper instance.
			 *
			 * @method destroy
			 */
			this.destroy = function() {
				$(getHandleElm()).off();
			};
	
			$(getHandleElm()).on('mousedown touchstart', start);
		};
	});
	
	// Included from: js/tinymce/classes/ui/Scrollable.js
	
	/**
	 * Scrollable.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * This mixin makes controls scrollable using custom scrollbars.
	 *
	 * @-x-less Scrollable.less
	 * @mixin tinymce.ui.Scrollable
	 */
	define("tinymce/ui/Scrollable", [
		"tinymce/dom/DomQuery",
		"tinymce/ui/DragHelper"
	], function($, DragHelper) {
		"use strict";
	
		return {
			init: function() {
				var self = this;
				self.on('repaint', self.renderScroll);
			},
	
			renderScroll: function() {
				var self = this, margin = 2;
	
				function repaintScroll() {
					var hasScrollH, hasScrollV, bodyElm;
	
					function repaintAxis(axisName, posName, sizeName, contentSizeName, hasScroll, ax) {
						var containerElm, scrollBarElm, scrollThumbElm;
						var containerSize, scrollSize, ratio, rect;
						var posNameLower, sizeNameLower;
	
						scrollBarElm = self.getEl('scroll' + axisName);
						if (scrollBarElm) {
							posNameLower = posName.toLowerCase();
							sizeNameLower = sizeName.toLowerCase();
	
							$(self.getEl('absend')).css(posNameLower, self.layoutRect()[contentSizeName] - 1);
	
							if (!hasScroll) {
								$(scrollBarElm).css('display', 'none');
								return;
							}
	
							$(scrollBarElm).css('display', 'block');
							containerElm = self.getEl('body');
							scrollThumbElm = self.getEl('scroll' + axisName + "t");
							containerSize = containerElm["client" + sizeName] - (margin * 2);
							containerSize -= hasScrollH && hasScrollV ? scrollBarElm["client" + ax] : 0;
							scrollSize = containerElm["scroll" + sizeName];
							ratio = containerSize / scrollSize;
	
							rect = {};
							rect[posNameLower] = containerElm["offset" + posName] + margin;
							rect[sizeNameLower] = containerSize;
							$(scrollBarElm).css(rect);
	
							rect = {};
							rect[posNameLower] = containerElm["scroll" + posName] * ratio;
							rect[sizeNameLower] = containerSize * ratio;
							$(scrollThumbElm).css(rect);
						}
					}
	
					bodyElm = self.getEl('body');
					hasScrollH = bodyElm.scrollWidth > bodyElm.clientWidth;
					hasScrollV = bodyElm.scrollHeight > bodyElm.clientHeight;
	
					repaintAxis("h", "Left", "Width", "contentW", hasScrollH, "Height");
					repaintAxis("v", "Top", "Height", "contentH", hasScrollV, "Width");
				}
	
				function addScroll() {
					function addScrollAxis(axisName, posName, sizeName, deltaPosName, ax) {
						var scrollStart, axisId = self._id + '-scroll' + axisName, prefix = self.classPrefix;
	
						$(self.getEl()).append(
							'<div id="' + axisId + '" class="' + prefix + 'scrollbar ' + prefix + 'scrollbar-' + axisName + '">' +
								'<div id="' + axisId + 't" class="' + prefix + 'scrollbar-thumb"></div>' +
							'</div>'
						);
	
						self.draghelper = new DragHelper(axisId + 't', {
							start: function() {
								scrollStart = self.getEl('body')["scroll" + posName];
								$('#' + axisId).addClass(prefix + 'active');
							},
	
							drag: function(e) {
								var ratio, hasScrollH, hasScrollV, containerSize, layoutRect = self.layoutRect();
	
								hasScrollH = layoutRect.contentW > layoutRect.innerW;
								hasScrollV = layoutRect.contentH > layoutRect.innerH;
								containerSize = self.getEl('body')["client" + sizeName] - (margin * 2);
								containerSize -= hasScrollH && hasScrollV ? self.getEl('scroll' + axisName)["client" + ax] : 0;
	
								ratio = containerSize / self.getEl('body')["scroll" + sizeName];
								self.getEl('body')["scroll" + posName] = scrollStart + (e["delta" + deltaPosName] / ratio);
							},
	
							stop: function() {
								$('#' + axisId).removeClass(prefix + 'active');
							}
						});
					}
	
					self.classes.add('scroll');
	
					addScrollAxis("v", "Top", "Height", "Y", "Width");
					addScrollAxis("h", "Left", "Width", "X", "Height");
				}
	
				if (self.settings.autoScroll) {
					if (!self._hasScroll) {
						self._hasScroll = true;
						addScroll();
	
						self.on('wheel', function(e) {
							var bodyEl = self.getEl('body');
	
							bodyEl.scrollLeft += (e.deltaX || 0) * 10;
							bodyEl.scrollTop += e.deltaY * 10;
	
							repaintScroll();
						});
	
						$(self.getEl('body')).on("scroll", repaintScroll);
					}
	
					repaintScroll();
				}
			}
		};
	});
	
	// Included from: js/tinymce/classes/ui/Panel.js
	
	/**
	 * Panel.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * Creates a new panel.
	 *
	 * @-x-less Panel.less
	 * @class tinymce.ui.Panel
	 * @extends tinymce.ui.Container
	 * @mixes tinymce.ui.Scrollable
	 */
	define("tinymce/ui/Panel", [
		"tinymce/ui/Container",
		"tinymce/ui/Scrollable"
	], function(Container, Scrollable) {
		"use strict";
	
		return Container.extend({
			Defaults: {
				layout: 'fit',
				containerCls: 'panel'
			},
	
			Mixins: [Scrollable],
	
			/**
			 * Renders the control as a HTML string.
			 *
			 * @method renderHtml
			 * @return {String} HTML representing the control.
			 */
			renderHtml: function() {
				var self = this, layout = self._layout, innerHtml = self.settings.html;
	
				self.preRender();
				layout.preRender(self);
	
				if (typeof innerHtml == "undefined") {
					innerHtml = (
						'<div id="' + self._id + '-body" class="' + self.bodyClasses + '">' +
							layout.renderHtml(self) +
						'</div>'
					);
				} else {
					if (typeof innerHtml == 'function') {
						innerHtml = innerHtml.call(self);
					}
	
					self._hasBody = false;
				}
	
				return (
					'<div id="' + self._id + '" class="' + self.classes + '" hidefocus="1" tabindex="-1" role="group">' +
						(self._preBodyHtml || '') +
						innerHtml +
					'</div>'
				);
			}
		});
	});
	
	// Included from: js/tinymce/classes/ui/Movable.js
	
	/**
	 * Movable.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * Movable mixin. Makes controls movable absolute and relative to other elements.
	 *
	 * @mixin tinymce.ui.Movable
	 */
	define("tinymce/ui/Movable", [
		"tinymce/ui/DomUtils"
	], function(DomUtils) {
		"use strict";
	
		function calculateRelativePosition(ctrl, targetElm, rel) {
			var ctrlElm, pos, x, y, selfW, selfH, targetW, targetH, viewport, size;
	
			viewport = DomUtils.getViewPort();
	
			// Get pos of target
			pos = DomUtils.getPos(targetElm);
			x = pos.x;
			y = pos.y;
	
			if (ctrl.state.get('fixed') && DomUtils.getRuntimeStyle(document.body, 'position') == 'static') {
				x -= viewport.x;
				y -= viewport.y;
			}
	
			// Get size of self
			ctrlElm = ctrl.getEl();
			size = DomUtils.getSize(ctrlElm);
			selfW = size.width;
			selfH = size.height;
	
			// Get size of target
			size = DomUtils.getSize(targetElm);
			targetW = size.width;
			targetH = size.height;
	
			// Parse align string
			rel = (rel || '').split('');
	
			// Target corners
			if (rel[0] === 'b') {
				y += targetH;
			}
	
			if (rel[1] === 'r') {
				x += targetW;
			}
	
			if (rel[0] === 'c') {
				y += Math.round(targetH / 2);
			}
	
			if (rel[1] === 'c') {
				x += Math.round(targetW / 2);
			}
	
			// Self corners
			if (rel[3] === 'b') {
				y -= selfH;
			}
	
			if (rel[4] === 'r') {
				x -= selfW;
			}
	
			if (rel[3] === 'c') {
				y -= Math.round(selfH / 2);
			}
	
			if (rel[4] === 'c') {
				x -= Math.round(selfW / 2);
			}
	
			return {
				x: x,
				y: y,
				w: selfW,
				h: selfH
			};
		}
	
		return {
			/**
			 * Tests various positions to get the most suitable one.
			 *
			 * @method testMoveRel
			 * @param {DOMElement} elm Element to position against.
			 * @param {Array} rels Array with relative positions.
			 * @return {String} Best suitable relative position.
			 */
			testMoveRel: function(elm, rels) {
				var viewPortRect = DomUtils.getViewPort();
	
				for (var i = 0; i < rels.length; i++) {
					var pos = calculateRelativePosition(this, elm, rels[i]);
	
					if (this.state.get('fixed')) {
						if (pos.x > 0 && pos.x + pos.w < viewPortRect.w && pos.y > 0 && pos.y + pos.h < viewPortRect.h) {
							return rels[i];
						}
					} else {
						if (pos.x > viewPortRect.x && pos.x + pos.w < viewPortRect.w + viewPortRect.x &&
							pos.y > viewPortRect.y && pos.y + pos.h < viewPortRect.h + viewPortRect.y) {
							return rels[i];
						}
					}
				}
	
				return rels[0];
			},
	
			/**
			 * Move relative to the specified element.
			 *
			 * @method moveRel
			 * @param {Element} elm Element to move relative to.
			 * @param {String} rel Relative mode. For example: br-tl.
			 * @return {tinymce.ui.Control} Current control instance.
			 */
			moveRel: function(elm, rel) {
				if (typeof rel != 'string') {
					rel = this.testMoveRel(elm, rel);
				}
	
				var pos = calculateRelativePosition(this, elm, rel);
				return this.moveTo(pos.x, pos.y);
			},
	
			/**
			 * Move by a relative x, y values.
			 *
			 * @method moveBy
			 * @param {Number} dx Relative x position.
			 * @param {Number} dy Relative y position.
			 * @return {tinymce.ui.Control} Current control instance.
			 */
			moveBy: function(dx, dy) {
				var self = this, rect = self.layoutRect();
	
				self.moveTo(rect.x + dx, rect.y + dy);
	
				return self;
			},
	
			/**
			 * Move to absolute position.
			 *
			 * @method moveTo
			 * @param {Number} x Absolute x position.
			 * @param {Number} y Absolute y position.
			 * @return {tinymce.ui.Control} Current control instance.
			 */
			moveTo: function(x, y) {
				var self = this;
	
				// TODO: Move this to some global class
				function constrain(value, max, size) {
					if (value < 0) {
						return 0;
					}
	
					if (value + size > max) {
						value = max - size;
						return value < 0 ? 0 : value;
					}
	
					return value;
				}
	
				if (self.settings.constrainToViewport) {
					var viewPortRect = DomUtils.getViewPort(window);
					var layoutRect = self.layoutRect();
	
					x = constrain(x, viewPortRect.w + viewPortRect.x, layoutRect.w);
					y = constrain(y, viewPortRect.h + viewPortRect.y, layoutRect.h);
				}
	
				if (self.state.get('rendered')) {
					self.layoutRect({x: x, y: y}).repaint();
				} else {
					self.settings.x = x;
					self.settings.y = y;
				}
	
				self.fire('move', {x: x, y: y});
	
				return self;
			}
		};
	});
	
	// Included from: js/tinymce/classes/ui/Resizable.js
	
	/**
	 * Resizable.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * Resizable mixin. Enables controls to be resized.
	 *
	 * @mixin tinymce.ui.Resizable
	 */
	define("tinymce/ui/Resizable", [
		"tinymce/ui/DomUtils"
	], function(DomUtils) {
		"use strict";
	
		return {
			/**
			 * Resizes the control to contents.
			 *
			 * @method resizeToContent
			 */
			resizeToContent: function() {
				this._layoutRect.autoResize = true;
				this._lastRect = null;
				this.reflow();
			},
	
			/**
			 * Resizes the control to a specific width/height.
			 *
			 * @method resizeTo
			 * @param {Number} w Control width.
			 * @param {Number} h Control height.
			 * @return {tinymce.ui.Control} Current control instance.
			 */
			resizeTo: function(w, h) {
				// TODO: Fix hack
				if (w <= 1 || h <= 1) {
					var rect = DomUtils.getWindowSize();
	
					w = w <= 1 ? w * rect.w : w;
					h = h <= 1 ? h * rect.h : h;
				}
	
				this._layoutRect.autoResize = false;
				return this.layoutRect({minW: w, minH: h, w: w, h: h}).reflow();
			},
	
			/**
			 * Resizes the control to a specific relative width/height.
			 *
			 * @method resizeBy
			 * @param {Number} dw Relative control width.
			 * @param {Number} dh Relative control height.
			 * @return {tinymce.ui.Control} Current control instance.
			 */
			resizeBy: function(dw, dh) {
				var self = this, rect = self.layoutRect();
	
				return self.resizeTo(rect.w + dw, rect.h + dh);
			}
		};
	});
	
	// Included from: js/tinymce/classes/ui/FloatPanel.js
	
	/**
	 * FloatPanel.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * This class creates a floating panel.
	 *
	 * @-x-less FloatPanel.less
	 * @class tinymce.ui.FloatPanel
	 * @extends tinymce.ui.Panel
	 * @mixes tinymce.ui.Movable
	 * @mixes tinymce.ui.Resizable
	 */
	define("tinymce/ui/FloatPanel", [
		"tinymce/ui/Panel",
		"tinymce/ui/Movable",
		"tinymce/ui/Resizable",
		"tinymce/ui/DomUtils",
		"tinymce/dom/DomQuery",
		"tinymce/util/Delay"
	], function(Panel, Movable, Resizable, DomUtils, $, Delay) {
		"use strict";
	
		var documentClickHandler, documentScrollHandler, windowResizeHandler, visiblePanels = [];
		var zOrder = [], hasModal;
	
		function isChildOf(ctrl, parent) {
			while (ctrl) {
				if (ctrl == parent) {
					return true;
				}
	
				ctrl = ctrl.parent();
			}
		}
	
		function skipOrHidePanels(e) {
			// Hide any float panel when a click/focus out is out side that float panel and the
			// float panels direct parent for example a click on a menu button
			var i = visiblePanels.length;
	
			while (i--) {
				var panel = visiblePanels[i], clickCtrl = panel.getParentCtrl(e.target);
	
				if (panel.settings.autohide) {
					if (clickCtrl) {
						if (isChildOf(clickCtrl, panel) || panel.parent() === clickCtrl) {
							continue;
						}
					}
	
					e = panel.fire('autohide', {target: e.target});
					if (!e.isDefaultPrevented()) {
						panel.hide();
					}
				}
			}
		}
	
		function bindDocumentClickHandler() {
	
			if (!documentClickHandler) {
				documentClickHandler = function(e) {
					// Gecko fires click event and in the wrong order on Mac so lets normalize
					if (e.button == 2) {
						return;
					}
	
					skipOrHidePanels(e);
				};
	
				$(document).on('click touchstart', documentClickHandler);
			}
		}
	
		function bindDocumentScrollHandler() {
			if (!documentScrollHandler) {
				documentScrollHandler = function() {
					var i;
	
					i = visiblePanels.length;
					while (i--) {
						repositionPanel(visiblePanels[i]);
					}
				};
	
				$(window).on('scroll', documentScrollHandler);
			}
		}
	
		function bindWindowResizeHandler() {
			if (!windowResizeHandler) {
				var docElm = document.documentElement, clientWidth = docElm.clientWidth, clientHeight = docElm.clientHeight;
	
				windowResizeHandler = function() {
					// Workaround for #7065 IE 7 fires resize events event though the window wasn't resized
					if (!document.all || clientWidth != docElm.clientWidth || clientHeight != docElm.clientHeight) {
						clientWidth = docElm.clientWidth;
						clientHeight = docElm.clientHeight;
						FloatPanel.hideAll();
					}
				};
	
				$(window).on('resize', windowResizeHandler);
			}
		}
	
		/**
		 * Repositions the panel to the top of page if the panel is outside of the visual viewport. It will
		 * also reposition all child panels of the current panel.
		 */
		function repositionPanel(panel) {
			var scrollY = DomUtils.getViewPort().y;
	
			function toggleFixedChildPanels(fixed, deltaY) {
				var parent;
	
				for (var i = 0; i < visiblePanels.length; i++) {
					if (visiblePanels[i] != panel) {
						parent = visiblePanels[i].parent();
	
						while (parent && (parent = parent.parent())) {
							if (parent == panel) {
								visiblePanels[i].fixed(fixed).moveBy(0, deltaY).repaint();
							}
						}
					}
				}
			}
	
			if (panel.settings.autofix) {
				if (!panel.state.get('fixed')) {
					panel._autoFixY = panel.layoutRect().y;
	
					if (panel._autoFixY < scrollY) {
						panel.fixed(true).layoutRect({y: 0}).repaint();
						toggleFixedChildPanels(true, scrollY - panel._autoFixY);
					}
				} else {
					if (panel._autoFixY > scrollY) {
						panel.fixed(false).layoutRect({y: panel._autoFixY}).repaint();
						toggleFixedChildPanels(false, panel._autoFixY - scrollY);
					}
				}
			}
		}
	
		function addRemove(add, ctrl) {
			var i, zIndex = FloatPanel.zIndex || 0xFFFF, topModal;
	
			if (add) {
				zOrder.push(ctrl);
			} else {
				i = zOrder.length;
	
				while (i--) {
					if (zOrder[i] === ctrl) {
						zOrder.splice(i, 1);
					}
				}
			}
	
			if (zOrder.length) {
				for (i = 0; i < zOrder.length; i++) {
					if (zOrder[i].modal) {
						zIndex++;
						topModal = zOrder[i];
					}
	
					zOrder[i].getEl().style.zIndex = zIndex;
					zOrder[i].zIndex = zIndex;
					zIndex++;
				}
			}
	
			var modalBlockEl = $('#' + ctrl.classPrefix + 'modal-block', ctrl.getContainerElm())[0];
	
			if (topModal) {
				$(modalBlockEl).css('z-index', topModal.zIndex - 1);
			} else if (modalBlockEl) {
				modalBlockEl.parentNode.removeChild(modalBlockEl);
				hasModal = false;
			}
	
			FloatPanel.currentZIndex = zIndex;
		}
	
		var FloatPanel = Panel.extend({
			Mixins: [Movable, Resizable],
	
			/**
			 * Constructs a new control instance with the specified settings.
			 *
			 * @constructor
			 * @param {Object} settings Name/value object with settings.
			 * @setting {Boolean} autohide Automatically hide the panel.
			 */
			init: function(settings) {
				var self = this;
	
				self._super(settings);
				self._eventsRoot = self;
	
				self.classes.add('floatpanel');
	
				// Hide floatpanes on click out side the root button
				if (settings.autohide) {
					bindDocumentClickHandler();
					bindWindowResizeHandler();
					visiblePanels.push(self);
				}
	
				if (settings.autofix) {
					bindDocumentScrollHandler();
	
					self.on('move', function() {
						repositionPanel(this);
					});
				}
	
				self.on('postrender show', function(e) {
					if (e.control == self) {
						var $modalBlockEl, prefix = self.classPrefix;
	
						if (self.modal && !hasModal) {
							$modalBlockEl = $('#' + prefix + 'modal-block', self.getContainerElm());
							if (!$modalBlockEl[0]) {
								$modalBlockEl = $(
									'<div id="' + prefix + 'modal-block" class="' + prefix + 'reset ' + prefix + 'fade"></div>'
								).appendTo(self.getContainerElm());
							}
	
							Delay.setTimeout(function() {
								$modalBlockEl.addClass(prefix + 'in');
								$(self.getEl()).addClass(prefix + 'in');
							});
	
							hasModal = true;
						}
	
						addRemove(true, self);
					}
				});
	
				self.on('show', function() {
					self.parents().each(function(ctrl) {
						if (ctrl.state.get('fixed')) {
							self.fixed(true);
							return false;
						}
					});
				});
	
				if (settings.popover) {
					self._preBodyHtml = '<div class="' + self.classPrefix + 'arrow"></div>';
					self.classes.add('popover').add('bottom').add(self.isRtl() ? 'end' : 'start');
				}
	
				self.aria('label', settings.ariaLabel);
				self.aria('labelledby', self._id);
				self.aria('describedby', self.describedBy || self._id + '-none');
			},
	
			fixed: function(state) {
				var self = this;
	
				if (self.state.get('fixed') != state) {
					if (self.state.get('rendered')) {
						var viewport = DomUtils.getViewPort();
	
						if (state) {
							self.layoutRect().y -= viewport.y;
						} else {
							self.layoutRect().y += viewport.y;
						}
					}
	
					self.classes.toggle('fixed', state);
					self.state.set('fixed', state);
				}
	
				return self;
			},
	
			/**
			 * Shows the current float panel.
			 *
			 * @method show
			 * @return {tinymce.ui.FloatPanel} Current floatpanel instance.
			 */
			show: function() {
				var self = this, i, state = self._super();
	
				i = visiblePanels.length;
				while (i--) {
					if (visiblePanels[i] === self) {
						break;
					}
				}
	
				if (i === -1) {
					visiblePanels.push(self);
				}
	
				return state;
			},
	
			/**
			 * Hides the current float panel.
			 *
			 * @method hide
			 * @return {tinymce.ui.FloatPanel} Current floatpanel instance.
			 */
			hide: function() {
				removeVisiblePanel(this);
				addRemove(false, this);
	
				return this._super();
			},
	
			/**
			 * Hide all visible float panels with he autohide setting enabled. This is for
			 * manually hiding floating menus or panels.
			 *
			 * @method hideAll
			 */
			hideAll: function() {
				FloatPanel.hideAll();
			},
	
			/**
			 * Closes the float panel. This will remove the float panel from page and fire the close event.
			 *
			 * @method close
			 */
			close: function() {
				var self = this;
	
				if (!self.fire('close').isDefaultPrevented()) {
					self.remove();
					addRemove(false, self);
				}
	
				return self;
			},
	
			/**
			 * Removes the float panel from page.
			 *
			 * @method remove
			 */
			remove: function() {
				removeVisiblePanel(this);
				this._super();
			},
	
			postRender: function() {
				var self = this;
	
				if (self.settings.bodyRole) {
					this.getEl('body').setAttribute('role', self.settings.bodyRole);
				}
	
				return self._super();
			}
		});
	
		/**
		 * Hide all visible float panels with he autohide setting enabled. This is for
		 * manually hiding floating menus or panels.
		 *
		 * @static
		 * @method hideAll
		 */
		FloatPanel.hideAll = function() {
			var i = visiblePanels.length;
	
			while (i--) {
				var panel = visiblePanels[i];
	
				if (panel && panel.settings.autohide) {
					panel.hide();
					visiblePanels.splice(i, 1);
				}
			}
		};
	
		function removeVisiblePanel(panel) {
			var i;
	
			i = visiblePanels.length;
			while (i--) {
				if (visiblePanels[i] === panel) {
					visiblePanels.splice(i, 1);
				}
			}
	
			i = zOrder.length;
			while (i--) {
				if (zOrder[i] === panel) {
					zOrder.splice(i, 1);
				}
			}
		}
	
		return FloatPanel;
	});
	
	// Included from: js/tinymce/classes/ui/Window.js
	
	/**
	 * Window.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * Creates a new window.
	 *
	 * @-x-less Window.less
	 * @class tinymce.ui.Window
	 * @extends tinymce.ui.FloatPanel
	 */
	define("tinymce/ui/Window", [
		"tinymce/ui/FloatPanel",
		"tinymce/ui/Panel",
		"tinymce/ui/DomUtils",
		"tinymce/dom/DomQuery",
		"tinymce/ui/DragHelper",
		"tinymce/ui/BoxUtils",
		"tinymce/Env",
		"tinymce/util/Delay"
	], function(FloatPanel, Panel, DomUtils, $, DragHelper, BoxUtils, Env, Delay) {
		"use strict";
	
		var windows = [], oldMetaValue = '';
	
		function toggleFullScreenState(state) {
			var noScaleMetaValue = 'width=device-width,initial-scale=1.0,user-scalable=0,minimum-scale=1.0,maximum-scale=1.0',
				viewport = $("meta[name=viewport]")[0],
				contentValue;
	
			if (Env.overrideViewPort === false) {
				return;
			}
	
			if (!viewport) {
				viewport = document.createElement('meta');
				viewport.setAttribute('name', 'viewport');
				document.getElementsByTagName('head')[0].appendChild(viewport);
			}
	
			contentValue = viewport.getAttribute('content');
			if (contentValue && typeof oldMetaValue != 'undefined') {
				oldMetaValue = contentValue;
			}
	
			viewport.setAttribute('content', state ? noScaleMetaValue : oldMetaValue);
		}
	
		function toggleBodyFullScreenClasses(classPrefix) {
			for (var i = 0; i < windows.length; i++) {
				if (windows[i]._fullscreen) {
					return;
				}
			}
	
			$([document.documentElement, document.body]).removeClass(classPrefix + 'fullscreen');
		}
	
		function handleWindowResize() {
			if (!Env.desktop) {
				var lastSize = {
					w: window.innerWidth,
					h: window.innerHeight
				};
	
				Delay.setInterval(function() {
					var w = window.innerWidth,
						h = window.innerHeight;
	
					if (lastSize.w != w || lastSize.h != h) {
						lastSize = {
							w: w,
							h: h
						};
	
						$(window).trigger('resize');
					}
				}, 100);
			}
	
			function reposition() {
				var i, rect = DomUtils.getWindowSize(), layoutRect;
	
				for (i = 0; i < windows.length; i++) {
					layoutRect = windows[i].layoutRect();
	
					windows[i].moveTo(
						windows[i].settings.x || Math.max(0, rect.w / 2 - layoutRect.w / 2),
						windows[i].settings.y || Math.max(0, rect.h / 2 - layoutRect.h / 2)
					);
				}
			}
	
			$(window).on('resize', reposition);
		}
	
		var Window = FloatPanel.extend({
			modal: true,
	
			Defaults: {
				border: 1,
				layout: 'flex',
				containerCls: 'panel',
				role: 'dialog',
				callbacks: {
					submit: function() {
						this.fire('submit', {data: this.toJSON()});
					},
	
					close: function() {
						this.close();
					}
				}
			},
	
			/**
			 * Constructs a instance with the specified settings.
			 *
			 * @constructor
			 * @param {Object} settings Name/value object with settings.
			 */
			init: function(settings) {
				var self = this;
	
				self._super(settings);
	
				if (self.isRtl()) {
					self.classes.add('rtl');
				}
	
				self.classes.add('window');
				self.bodyClasses.add('window-body');
				self.state.set('fixed', true);
	
				// Create statusbar
				if (settings.buttons) {
					self.statusbar = new Panel({
						layout: 'flex',
						border: '1 0 0 0',
						spacing: 3,
						padding: 10,
						align: 'center',
						pack: self.isRtl() ? 'start' : 'end',
						defaults: {
							type: 'button'
						},
						items: settings.buttons
					});
	
					self.statusbar.classes.add('foot');
					self.statusbar.parent(self);
				}
	
				self.on('click', function(e) {
					var closeClass = self.classPrefix + 'close';
	
					if (DomUtils.hasClass(e.target, closeClass) || DomUtils.hasClass(e.target.parentNode, closeClass)) {
						self.close();
					}
				});
	
				self.on('cancel', function() {
					self.close();
				});
	
				self.aria('describedby', self.describedBy || self._id + '-none');
				self.aria('label', settings.title);
				self._fullscreen = false;
			},
	
			/**
			 * Recalculates the positions of the controls in the current container.
			 * This is invoked by the reflow method and shouldn't be called directly.
			 *
			 * @method recalc
			 */
			recalc: function() {
				var self = this, statusbar = self.statusbar, layoutRect, width, x, needsRecalc;
	
				if (self._fullscreen) {
					self.layoutRect(DomUtils.getWindowSize());
					self.layoutRect().contentH = self.layoutRect().innerH;
				}
	
				self._super();
	
				layoutRect = self.layoutRect();
	
				// Resize window based on title width
				if (self.settings.title && !self._fullscreen) {
					width = layoutRect.headerW;
					if (width > layoutRect.w) {
						x = layoutRect.x - Math.max(0, width / 2);
						self.layoutRect({w: width, x: x});
						needsRecalc = true;
					}
				}
	
				// Resize window based on statusbar width
				if (statusbar) {
					statusbar.layoutRect({w: self.layoutRect().innerW}).recalc();
	
					width = statusbar.layoutRect().minW + layoutRect.deltaW;
					if (width > layoutRect.w) {
						x = layoutRect.x - Math.max(0, width - layoutRect.w);
						self.layoutRect({w: width, x: x});
						needsRecalc = true;
					}
				}
	
				// Recalc body and disable auto resize
				if (needsRecalc) {
					self.recalc();
				}
			},
	
			/**
			 * Initializes the current controls layout rect.
			 * This will be executed by the layout managers to determine the
			 * default minWidth/minHeight etc.
			 *
			 * @method initLayoutRect
			 * @return {Object} Layout rect instance.
			 */
			initLayoutRect: function() {
				var self = this, layoutRect = self._super(), deltaH = 0, headEl;
	
				// Reserve vertical space for title
				if (self.settings.title && !self._fullscreen) {
					headEl = self.getEl('head');
	
					var size = DomUtils.getSize(headEl);
	
					layoutRect.headerW = size.width;
					layoutRect.headerH = size.height;
	
					deltaH += layoutRect.headerH;
				}
	
				// Reserve vertical space for statusbar
				if (self.statusbar) {
					deltaH += self.statusbar.layoutRect().h;
				}
	
				layoutRect.deltaH += deltaH;
				layoutRect.minH += deltaH;
				//layoutRect.innerH -= deltaH;
				layoutRect.h += deltaH;
	
				var rect = DomUtils.getWindowSize();
	
				layoutRect.x = self.settings.x || Math.max(0, rect.w / 2 - layoutRect.w / 2);
				layoutRect.y = self.settings.y || Math.max(0, rect.h / 2 - layoutRect.h / 2);
	
				return layoutRect;
			},
	
			/**
			 * Renders the control as a HTML string.
			 *
			 * @method renderHtml
			 * @return {String} HTML representing the control.
			 */
			renderHtml: function() {
				var self = this, layout = self._layout, id = self._id, prefix = self.classPrefix;
				var settings = self.settings, headerHtml = '', footerHtml = '', html = settings.html;
	
				self.preRender();
				layout.preRender(self);
	
				if (settings.title) {
					headerHtml = (
						'<div id="' + id + '-head" class="' + prefix + 'window-head">' +
							'<div id="' + id + '-title" class="' + prefix + 'title">' + self.encode(settings.title) + '</div>' +
							'<div id="' + id + '-dragh" class="' + prefix + 'dragh"></div>' +
							'<button type="button" class="' + prefix + 'close" aria-hidden="true">' +
								'<i class="mce-ico mce-i-remove"></i>' +
							'</button>' +
						'</div>'
					);
				}
	
				if (settings.url) {
					html = '<iframe src="' + settings.url + '" tabindex="-1"></iframe>';
				}
	
				if (typeof html == "undefined") {
					html = layout.renderHtml(self);
				}
	
				if (self.statusbar) {
					footerHtml = self.statusbar.renderHtml();
				}
	
				return (
					'<div id="' + id + '" class="' + self.classes + '" hidefocus="1">' +
						'<div class="' + self.classPrefix + 'reset" role="application">' +
							headerHtml +
							'<div id="' + id + '-body" class="' + self.bodyClasses + '">' +
								html +
							'</div>' +
							footerHtml +
						'</div>' +
					'</div>'
				);
			},
	
			/**
			 * Switches the window fullscreen mode.
			 *
			 * @method fullscreen
			 * @param {Boolean} state True/false state.
			 * @return {tinymce.ui.Window} Current window instance.
			 */
			fullscreen: function(state) {
				var self = this, documentElement = document.documentElement, slowRendering, prefix = self.classPrefix, layoutRect;
	
				if (state != self._fullscreen) {
					$(window).on('resize', function() {
						var time;
	
						if (self._fullscreen) {
							// Time the layout time if it's to slow use a timeout to not hog the CPU
							if (!slowRendering) {
								time = new Date().getTime();
	
								var rect = DomUtils.getWindowSize();
								self.moveTo(0, 0).resizeTo(rect.w, rect.h);
	
								if ((new Date().getTime()) - time > 50) {
									slowRendering = true;
								}
							} else {
								if (!self._timer) {
									self._timer = Delay.setTimeout(function() {
										var rect = DomUtils.getWindowSize();
										self.moveTo(0, 0).resizeTo(rect.w, rect.h);
	
										self._timer = 0;
									}, 50);
								}
							}
						}
					});
	
					layoutRect = self.layoutRect();
					self._fullscreen = state;
	
					if (!state) {
						self.borderBox = BoxUtils.parseBox(self.settings.border);
						self.getEl('head').style.display = '';
						layoutRect.deltaH += layoutRect.headerH;
						$([documentElement, document.body]).removeClass(prefix + 'fullscreen');
						self.classes.remove('fullscreen');
						self.moveTo(self._initial.x, self._initial.y).resizeTo(self._initial.w, self._initial.h);
					} else {
						self._initial = {x: layoutRect.x, y: layoutRect.y, w: layoutRect.w, h: layoutRect.h};
	
						self.borderBox = BoxUtils.parseBox('0');
						self.getEl('head').style.display = 'none';
						layoutRect.deltaH -= layoutRect.headerH + 2;
						$([documentElement, document.body]).addClass(prefix + 'fullscreen');
						self.classes.add('fullscreen');
	
						var rect = DomUtils.getWindowSize();
						self.moveTo(0, 0).resizeTo(rect.w, rect.h);
					}
				}
	
				return self.reflow();
			},
	
			/**
			 * Called after the control has been rendered.
			 *
			 * @method postRender
			 */
			postRender: function() {
				var self = this, startPos;
	
				setTimeout(function() {
					self.classes.add('in');
					self.fire('open');
				}, 0);
	
				self._super();
	
				if (self.statusbar) {
					self.statusbar.postRender();
				}
	
				self.focus();
	
				this.dragHelper = new DragHelper(self._id + '-dragh', {
					start: function() {
						startPos = {
							x: self.layoutRect().x,
							y: self.layoutRect().y
						};
					},
	
					drag: function(e) {
						self.moveTo(startPos.x + e.deltaX, startPos.y + e.deltaY);
					}
				});
	
				self.on('submit', function(e) {
					if (!e.isDefaultPrevented()) {
						self.close();
					}
				});
	
				windows.push(self);
				toggleFullScreenState(true);
			},
	
			/**
			 * Fires a submit event with the serialized form.
			 *
			 * @method submit
			 * @return {Object} Event arguments object.
			 */
			submit: function() {
				return this.fire('submit', {data: this.toJSON()});
			},
	
			/**
			 * Removes the current control from DOM and from UI collections.
			 *
			 * @method remove
			 * @return {tinymce.ui.Control} Current control instance.
			 */
			remove: function() {
				var self = this, i;
	
				self.dragHelper.destroy();
				self._super();
	
				if (self.statusbar) {
					this.statusbar.remove();
				}
	
				i = windows.length;
				while (i--) {
					if (windows[i] === self) {
						windows.splice(i, 1);
					}
				}
	
				toggleFullScreenState(windows.length > 0);
				toggleBodyFullScreenClasses(self.classPrefix);
			},
	
			/**
			 * Returns the contentWindow object of the iframe if it exists.
			 *
			 * @method getContentWindow
			 * @return {Window} window object or null.
			 */
			getContentWindow: function() {
				var ifr = this.getEl().getElementsByTagName('iframe')[0];
				return ifr ? ifr.contentWindow : null;
			}
		});
	
		handleWindowResize();
	
		return Window;
	});
	
	// Included from: js/tinymce/classes/ui/MessageBox.js
	
	/**
	 * MessageBox.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * This class is used to create MessageBoxes like alerts/confirms etc.
	 *
	 * @class tinymce.ui.MessageBox
	 * @extends tinymce.ui.FloatPanel
	 */
	define("tinymce/ui/MessageBox", [
		"tinymce/ui/Window"
	], function(Window) {
		"use strict";
	
		var MessageBox = Window.extend({
			/**
			 * Constructs a instance with the specified settings.
			 *
			 * @constructor
			 * @param {Object} settings Name/value object with settings.
			 */
			init: function(settings) {
				settings = {
					border: 1,
					padding: 20,
					layout: 'flex',
					pack: "center",
					align: "center",
					containerCls: 'panel',
					autoScroll: true,
					buttons: {type: "button", text: "Ok", action: "ok"},
					items: {
						type: "label",
						multiline: true,
						maxWidth: 500,
						maxHeight: 200
					}
				};
	
				this._super(settings);
			},
	
			Statics: {
				/**
				 * Ok buttons constant.
				 *
				 * @static
				 * @final
				 * @field {Number} OK
				 */
				OK: 1,
	
				/**
				 * Ok/cancel buttons constant.
				 *
				 * @static
				 * @final
				 * @field {Number} OK_CANCEL
				 */
				OK_CANCEL: 2,
	
				/**
				 * yes/no buttons constant.
				 *
				 * @static
				 * @final
				 * @field {Number} YES_NO
				 */
				YES_NO: 3,
	
				/**
				 * yes/no/cancel buttons constant.
				 *
				 * @static
				 * @final
				 * @field {Number} YES_NO_CANCEL
				 */
				YES_NO_CANCEL: 4,
	
				/**
				 * Constructs a new message box and renders it to the body element.
				 *
				 * @static
				 * @method msgBox
				 * @param {Object} settings Name/value object with settings.
				 */
				msgBox: function(settings) {
					var buttons, callback = settings.callback || function() {};
	
					function createButton(text, status, primary) {
						return {
							type: "button",
							text: text,
							subtype: primary ? 'primary' : '',
							onClick: function(e) {
								e.control.parents()[1].close();
								callback(status);
							}
						};
					}
	
					switch (settings.buttons) {
						case MessageBox.OK_CANCEL:
							buttons = [
								createButton('Ok', true, true),
								createButton('Cancel', false)
							];
							break;
	
						case MessageBox.YES_NO:
						case MessageBox.YES_NO_CANCEL:
							buttons = [
								createButton('Yes', 1, true),
								createButton('No', 0)
							];
	
							if (settings.buttons == MessageBox.YES_NO_CANCEL) {
								buttons.push(createButton('Cancel', -1));
							}
							break;
	
						default:
							buttons = [
								createButton('Ok', true, true)
							];
							break;
					}
	
					return new Window({
						padding: 20,
						x: settings.x,
						y: settings.y,
						minWidth: 300,
						minHeight: 100,
						layout: "flex",
						pack: "center",
						align: "center",
						buttons: buttons,
						title: settings.title,
						role: 'alertdialog',
						items: {
							type: "label",
							multiline: true,
							maxWidth: 500,
							maxHeight: 200,
							text: settings.text
						},
						onPostRender: function() {
							this.aria('describedby', this.items()[0]._id);
						},
						onClose: settings.onClose,
						onCancel: function() {
							callback(false);
						}
					}).renderTo(document.body).reflow();
				},
	
				/**
				 * Creates a new alert dialog.
				 *
				 * @method alert
				 * @param {Object} settings Settings for the alert dialog.
				 * @param {function} [callback] Callback to execute when the user makes a choice.
				 */
				alert: function(settings, callback) {
					if (typeof settings == "string") {
						settings = {text: settings};
					}
	
					settings.callback = callback;
					return MessageBox.msgBox(settings);
				},
	
				/**
				 * Creates a new confirm dialog.
				 *
				 * @method confirm
				 * @param {Object} settings Settings for the confirm dialog.
				 * @param {function} [callback] Callback to execute when the user makes a choice.
				 */
				confirm: function(settings, callback) {
					if (typeof settings == "string") {
						settings = {text: settings};
					}
	
					settings.callback = callback;
					settings.buttons = MessageBox.OK_CANCEL;
	
					return MessageBox.msgBox(settings);
				}
			}
		});
	
		return MessageBox;
	});
	
	// Included from: js/tinymce/classes/WindowManager.js
	
	/**
	 * WindowManager.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * This class handles the creation of native windows and dialogs. This class can be extended to provide for example inline dialogs.
	 *
	 * @class tinymce.WindowManager
	 * @example
	 * // Opens a new dialog with the file.htm file and the size 320x240
	 * // It also adds a custom parameter this can be retrieved by using tinyMCEPopup.getWindowArg inside the dialog.
	 * tinymce.activeEditor.windowManager.open({
	 *    url: 'file.htm',
	 *    width: 320,
	 *    height: 240
	 * }, {
	 *    custom_param: 1
	 * });
	 *
	 * // Displays an alert box using the active editors window manager instance
	 * tinymce.activeEditor.windowManager.alert('Hello world!');
	 *
	 * // Displays an confirm box and an alert message will be displayed depending on what you choose in the confirm
	 * tinymce.activeEditor.windowManager.confirm("Do you want to do something", function(s) {
	 *    if (s)
	 *       tinymce.activeEditor.windowManager.alert("Ok");
	 *    else
	 *       tinymce.activeEditor.windowManager.alert("Cancel");
	 * });
	 */
	define("tinymce/WindowManager", [
		"tinymce/ui/Window",
		"tinymce/ui/MessageBox"
	], function(Window, MessageBox) {
		return function(editor) {
			var self = this, windows = [];
	
			function getTopMostWindow() {
				if (windows.length) {
					return windows[windows.length - 1];
				}
			}
	
			function fireOpenEvent(win) {
				editor.fire('OpenWindow', {
					win: win
				});
			}
	
			function fireCloseEvent(win) {
				editor.fire('CloseWindow', {
					win: win
				});
			}
	
			self.windows = windows;
	
			editor.on('remove', function() {
				var i = windows.length;
	
				while (i--) {
					windows[i].close();
				}
			});
	
			/**
			 * Opens a new window.
			 *
			 * @method open
			 * @param {Object} args Optional name/value settings collection contains things like width/height/url etc.
			 * @param {Object} params Options like title, file, width, height etc.
			 * @option {String} title Window title.
			 * @option {String} file URL of the file to open in the window.
			 * @option {Number} width Width in pixels.
			 * @option {Number} height Height in pixels.
			 * @option {Boolean} autoScroll Specifies whether the popup window can have scrollbars if required (i.e. content
			 * larger than the popup size specified).
			 */
			self.open = function(args, params) {
				var win;
	
				editor.editorManager.setActive(editor);
	
				args.title = args.title || ' ';
	
				// Handle URL
				args.url = args.url || args.file; // Legacy
				if (args.url) {
					args.width = parseInt(args.width || 320, 10);
					args.height = parseInt(args.height || 240, 10);
				}
	
				// Handle body
				if (args.body) {
					args.items = {
						defaults: args.defaults,
						type: args.bodyType || 'form',
						items: args.body,
						data: args.data,
						callbacks: args.commands
					};
				}
	
				if (!args.url && !args.buttons) {
					args.buttons = [
						{text: 'Ok', subtype: 'primary', onclick: function() {
							win.find('form')[0].submit();
						}},
	
						{text: 'Cancel', onclick: function() {
							win.close();
						}}
					];
				}
	
				win = new Window(args);
				windows.push(win);
	
				win.on('close', function() {
					var i = windows.length;
	
					while (i--) {
						if (windows[i] === win) {
							windows.splice(i, 1);
						}
					}
	
					if (!windows.length) {
						editor.focus();
					}
	
					fireCloseEvent(win);
				});
	
				// Handle data
				if (args.data) {
					win.on('postRender', function() {
						this.find('*').each(function(ctrl) {
							var name = ctrl.name();
	
							if (name in args.data) {
								ctrl.value(args.data[name]);
							}
						});
					});
				}
	
				// store args and parameters
				win.features = args || {};
				win.params = params || {};
	
				// Takes a snapshot in the FocusManager of the selection before focus is lost to dialog
				if (windows.length === 1) {
					editor.nodeChanged();
				}
	
				win = win.renderTo().reflow();
	
				fireOpenEvent(win);
	
				return win;
			};
	
			/**
			 * Creates a alert dialog. Please don't use the blocking behavior of this
			 * native version use the callback method instead then it can be extended.
			 *
			 * @method alert
			 * @param {String} message Text to display in the new alert dialog.
			 * @param {function} callback Callback function to be executed after the user has selected ok.
			 * @param {Object} scope Optional scope to execute the callback in.
			 * @example
			 * // Displays an alert box using the active editors window manager instance
			 * tinymce.activeEditor.windowManager.alert('Hello world!');
			 */
			self.alert = function(message, callback, scope) {
				var win;
	
				win = MessageBox.alert(message, function() {
					if (callback) {
						callback.call(scope || this);
					} else {
						editor.focus();
					}
				});
	
				win.on('close', function() {
					fireCloseEvent(win);
				});
	
				fireOpenEvent(win);
			};
	
			/**
			 * Creates a confirm dialog. Please don't use the blocking behavior of this
			 * native version use the callback method instead then it can be extended.
			 *
			 * @method confirm
			 * @param {String} message Text to display in the new confirm dialog.
			 * @param {function} callback Callback function to be executed after the user has selected ok or cancel.
			 * @param {Object} scope Optional scope to execute the callback in.
			 * @example
			 * // Displays an confirm box and an alert message will be displayed depending on what you choose in the confirm
			 * tinymce.activeEditor.windowManager.confirm("Do you want to do something", function(s) {
			 *    if (s)
			 *       tinymce.activeEditor.windowManager.alert("Ok");
			 *    else
			 *       tinymce.activeEditor.windowManager.alert("Cancel");
			 * });
			 */
			self.confirm = function(message, callback, scope) {
				var win;
	
				win = MessageBox.confirm(message, function(state) {
					callback.call(scope || this, state);
				});
	
				win.on('close', function() {
					fireCloseEvent(win);
				});
	
				fireOpenEvent(win);
			};
	
			/**
			 * Closes the top most window.
			 *
			 * @method close
			 */
			self.close = function() {
				if (getTopMostWindow()) {
					getTopMostWindow().close();
				}
			};
	
			/**
			 * Returns the params of the last window open call. This can be used in iframe based
			 * dialog to get params passed from the tinymce plugin.
			 *
			 * @example
			 * var dialogArguments = top.tinymce.activeEditor.windowManager.getParams();
			 *
			 * @method getParams
			 * @return {Object} Name/value object with parameters passed from windowManager.open call.
			 */
			self.getParams = function() {
				return getTopMostWindow() ? getTopMostWindow().params : null;
			};
	
			/**
			 * Sets the params of the last opened window.
			 *
			 * @method setParams
			 * @param {Object} params Params object to set for the last opened window.
			 */
			self.setParams = function(params) {
				if (getTopMostWindow()) {
					getTopMostWindow().params = params;
				}
			};
	
			/**
			 * Returns the currently opened window objects.
			 *
			 * @method getWindows
			 * @return {Array} Array of the currently opened windows.
			 */
			self.getWindows = function() {
				return windows;
			};
		};
	});
	
	// Included from: js/tinymce/classes/ui/Tooltip.js
	
	/**
	 * Tooltip.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * Creates a tooltip instance.
	 *
	 * @-x-less ToolTip.less
	 * @class tinymce.ui.ToolTip
	 * @extends tinymce.ui.Control
	 * @mixes tinymce.ui.Movable
	 */
	define("tinymce/ui/Tooltip", [
		"tinymce/ui/Control",
		"tinymce/ui/Movable"
	], function(Control, Movable) {
		return Control.extend({
			Mixins: [Movable],
	
			Defaults: {
				classes: 'widget tooltip tooltip-n'
			},
	
			/**
			 * Renders the control as a HTML string.
			 *
			 * @method renderHtml
			 * @return {String} HTML representing the control.
			 */
			renderHtml: function() {
				var self = this, prefix = self.classPrefix;
	
				return (
					'<div id="' + self._id + '" class="' + self.classes + '" role="presentation">' +
						'<div class="' + prefix + 'tooltip-arrow"></div>' +
						'<div class="' + prefix + 'tooltip-inner">' + self.encode(self.state.get('text')) + '</div>' +
					'</div>'
				);
			},
	
			bindStates: function() {
				var self = this;
	
				self.state.on('change:text', function(e) {
					self.getEl().lastChild.innerHTML = self.encode(e.value);
				});
	
				return self._super();
			},
	
			/**
			 * Repaints the control after a layout operation.
			 *
			 * @method repaint
			 */
			repaint: function() {
				var self = this, style, rect;
	
				style = self.getEl().style;
				rect = self._layoutRect;
	
				style.left = rect.x + 'px';
				style.top = rect.y + 'px';
				style.zIndex = 0xFFFF + 0xFFFF;
			}
		});
	});
	
	// Included from: js/tinymce/classes/ui/Widget.js
	
	/**
	 * Widget.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * Widget base class a widget is a control that has a tooltip and some basic states.
	 *
	 * @class tinymce.ui.Widget
	 * @extends tinymce.ui.Control
	 */
	define("tinymce/ui/Widget", [
		"tinymce/ui/Control",
		"tinymce/ui/Tooltip"
	], function(Control, Tooltip) {
		"use strict";
	
		var tooltip;
	
		var Widget = Control.extend({
			/**
			 * Constructs a instance with the specified settings.
			 *
			 * @constructor
			 * @param {Object} settings Name/value object with settings.
			 * @setting {String} tooltip Tooltip text to display when hovering.
			 * @setting {Boolean} autofocus True if the control should be focused when rendered.
			 * @setting {String} text Text to display inside widget.
			 */
			init: function(settings) {
				var self = this;
	
				self._super(settings);
				settings = self.settings;
				self.canFocus = true;
	
				if (settings.tooltip && Widget.tooltips !== false) {
					self.on('mouseenter', function(e) {
						var tooltip = self.tooltip().moveTo(-0xFFFF);
	
						if (e.control == self) {
							var rel = tooltip.text(settings.tooltip).show().testMoveRel(self.getEl(), ['bc-tc', 'bc-tl', 'bc-tr']);
	
							tooltip.classes.toggle('tooltip-n', rel == 'bc-tc');
							tooltip.classes.toggle('tooltip-nw', rel == 'bc-tl');
							tooltip.classes.toggle('tooltip-ne', rel == 'bc-tr');
	
							tooltip.moveRel(self.getEl(), rel);
						} else {
							tooltip.hide();
						}
					});
	
					self.on('mouseleave mousedown click', function() {
						self.tooltip().hide();
					});
				}
	
				self.aria('label', settings.ariaLabel || settings.tooltip);
			},
	
			/**
			 * Returns the current tooltip instance.
			 *
			 * @method tooltip
			 * @return {tinymce.ui.Tooltip} Tooltip instance.
			 */
			tooltip: function() {
				if (!tooltip) {
					tooltip = new Tooltip({type: 'tooltip'});
					tooltip.renderTo();
				}
	
				return tooltip;
			},
	
			/**
			 * Called after the control has been rendered.
			 *
			 * @method postRender
			 */
			postRender: function() {
				var self = this, settings = self.settings;
	
				self._super();
	
				if (!self.parent() && (settings.width || settings.height)) {
					self.initLayoutRect();
					self.repaint();
				}
	
				if (settings.autofocus) {
					self.focus();
				}
			},
	
			bindStates: function() {
				var self = this;
	
				function disable(state) {
					self.aria('disabled', state);
					self.classes.toggle('disabled', state);
				}
	
				function active(state) {
					self.aria('pressed', state);
					self.classes.toggle('active', state);
				}
	
				self.state.on('change:disabled', function(e) {
					disable(e.value);
				});
	
				self.state.on('change:active', function(e) {
					active(e.value);
				});
	
				if (self.state.get('disabled')) {
					disable(true);
				}
	
				if (self.state.get('active')) {
					active(true);
				}
	
				return self._super();
			},
	
			/**
			 * Removes the current control from DOM and from UI collections.
			 *
			 * @method remove
			 * @return {tinymce.ui.Control} Current control instance.
			 */
			remove: function() {
				this._super();
	
				if (tooltip) {
					tooltip.remove();
					tooltip = null;
				}
			}
		});
	
		return Widget;
	});
	
	// Included from: js/tinymce/classes/ui/Progress.js
	
	/**
	 * Progress.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * Progress control.
	 *
	 * @-x-less Progress.less
	 * @class tinymce.ui.Progress
	 * @extends tinymce.ui.Control
	 */
	define("tinymce/ui/Progress", [
		"tinymce/ui/Widget"
	], function(Widget) {
		"use strict";
	
		return Widget.extend({
			Defaults: {
				value: 0
			},
	
			init: function(settings) {
				var self = this;
	
				self._super(settings);
				self.classes.add('progress');
	
				if (!self.settings.filter) {
					self.settings.filter = function(value) {
						return Math.round(value);
					};
				}
			},
	
			renderHtml: function() {
				var self = this, id = self._id, prefix = this.classPrefix;
	
				return (
					'<div id="' + id + '" class="' + self.classes + '">' +
						'<div class="' + prefix + 'bar-container">' +
							'<div class="' + prefix + 'bar"></div>' +
						'</div>' +
						'<div class="' + prefix + 'text">0%</div>' +
					'</div>'
				);
			},
	
			postRender: function() {
				var self = this;
	
				self._super();
				self.value(self.settings.value);
	
				return self;
			},
	
			bindStates: function() {
				var self = this;
	
				function setValue(value) {
					value = self.settings.filter(value);
					self.getEl().lastChild.innerHTML = value + '%';
					self.getEl().firstChild.firstChild.style.width = value + '%';
				}
	
				self.state.on('change:value', function(e) {
					setValue(e.value);
				});
	
				setValue(self.state.get('value'));
	
				return self._super();
			}
		});
	});
	
	// Included from: js/tinymce/classes/ui/Notification.js
	
	/**
	 * Notification.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * Creates a notification instance.
	 *
	 * @-x-less Notification.less
	 * @class tinymce.ui.Notification
	 * @extends tinymce.ui.Container
	 * @mixes tinymce.ui.Movable
	 */
	define("tinymce/ui/Notification", [
		"tinymce/ui/Control",
		"tinymce/ui/Movable",
		"tinymce/ui/Progress",
		"tinymce/util/Delay"
	], function(Control, Movable, Progress, Delay) {
		return Control.extend({
			Mixins: [Movable],
	
			Defaults: {
				classes: 'widget notification'
			},
	
			init: function(settings) {
				var self = this;
	
				self._super(settings);
	
				if (settings.text) {
					self.text(settings.text);
				}
	
				if (settings.icon) {
					self.icon = settings.icon;
				}
	
				if (settings.color) {
					self.color = settings.color;
				}
	
				if (settings.type) {
					self.classes.add('notification-' + settings.type);
				}
	
				if (settings.timeout && (settings.timeout < 0 || settings.timeout > 0) && !settings.closeButton) {
					self.closeButton = false;
				} else {
					self.classes.add('has-close');
					self.closeButton = true;
				}
	
				if (settings.progressBar) {
					self.progressBar = new Progress();
				}
	
				self.on('click', function(e) {
					if (e.target.className.indexOf(self.classPrefix + 'close') != -1) {
						self.close();
					}
				});
			},
	
			/**
			 * Renders the control as a HTML string.
			 *
			 * @method renderHtml
			 * @return {String} HTML representing the control.
			 */
			renderHtml: function() {
				var self = this, prefix = self.classPrefix, icon = '', closeButton = '', progressBar = '', notificationStyle = '';
	
				if (self.icon) {
					icon = '<i class="' + prefix + 'ico' + ' ' + prefix + 'i-' + self.icon + '"></i>';
				}
	
				if (self.color) {
					notificationStyle = ' style="background-color: ' + self.color + '"';
				}
	
				if (self.closeButton) {
					closeButton = '<button type="button" class="' + prefix + 'close" aria-hidden="true">\u00d7</button>';
				}
	
				if (self.progressBar) {
					progressBar = self.progressBar.renderHtml();
				}
	
				return (
					'<div id="' + self._id + '" class="' + self.classes + '"' + notificationStyle + ' role="presentation">' +
						icon +
						'<div class="' + prefix + 'notification-inner">' + self.state.get('text') + '</div>' +
						progressBar +
						closeButton +
					'</div>'
				);
			},
	
			postRender: function() {
				var self = this;
	
				Delay.setTimeout(function() {
					self.$el.addClass(self.classPrefix + 'in');
				});
	
				return self._super();
			},
	
			bindStates: function() {
				var self = this;
	
				self.state.on('change:text', function(e) {
					self.getEl().childNodes[1].innerHTML = e.value;
				});
				if (self.progressBar) {
					self.progressBar.bindStates();
				}
				return self._super();
			},
	
			close: function() {
				var self = this;
	
				if (!self.fire('close').isDefaultPrevented()) {
					self.remove();
				}
	
				return self;
			},
	
			/**
			 * Repaints the control after a layout operation.
			 *
			 * @method repaint
			 */
			repaint: function() {
				var self = this, style, rect;
	
				style = self.getEl().style;
				rect = self._layoutRect;
	
				style.left = rect.x + 'px';
				style.top = rect.y + 'px';
				style.zIndex = 0xFFFF + 0xFFFF;
			}
		});
	});
	
	// Included from: js/tinymce/classes/NotificationManager.js
	
	/**
	 * NotificationManager.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * This class handles the creation of TinyMCE's notifications.
	 *
	 * @class tinymce.notificationManager
	 * @example
	 * // Opens a new notification of type "error" with text "An error occurred."
	 * tinymce.activeEditor.notificationManager.open({
	 *    text: 'An error occurred.',
	 *    type: 'error'
	 * });
	 */
	define("tinymce/NotificationManager", [
		"tinymce/ui/Notification",
		"tinymce/util/Delay"
	], function(Notification, Delay) {
		return function(editor) {
			var self = this, notifications = [];
	
			function getLastNotification() {
				if (notifications.length) {
					return notifications[notifications.length - 1];
				}
			}
	
			self.notifications = notifications;
	
			function resizeWindowEvent() {
				Delay.requestAnimationFrame(function() {
					prePositionNotifications();
					positionNotifications();
				});
			}
	
			// Since the viewport will change based on the present notifications, we need to move them all to the
			// top left of the viewport to give an accurate size measurement so we can position them later.
			function prePositionNotifications() {
				for (var i = 0; i < notifications.length; i++) {
					notifications[i].moveTo(0, 0);
				}
			}
	
			function positionNotifications() {
				if (notifications.length > 0) {
					var firstItem = notifications.slice(0, 1)[0];
					var container = editor.inline ? editor.getElement() : editor.getContentAreaContainer();
					firstItem.moveRel(container, 'tc-tc');
					if (notifications.length > 1) {
						for (var i = 1; i < notifications.length; i++) {
							notifications[i].moveRel(notifications[i - 1].getEl(), 'bc-tc');
						}
					}
				}
			}
	
			editor.on('remove', function() {
				var i = notifications.length;
	
				while (i--) {
					notifications[i].close();
				}
			});
	
			editor.on('ResizeEditor', positionNotifications);
			editor.on('ResizeWindow', resizeWindowEvent);
	
			/**
			 * Opens a new notification.
			 *
			 * @method open
			 * @param {Object} args Optional name/value settings collection contains things like timeout/color/message etc.
			 */
			self.open = function(args) {
				var notif;
	
				editor.editorManager.setActive(editor);
	
				notif = new Notification(args);
				notifications.push(notif);
	
				//If we have a timeout value
				if (args.timeout > 0) {
					notif.timer = setTimeout(function() {
						notif.close();
					}, args.timeout);
				}
	
				notif.on('close', function() {
					var i = notifications.length;
	
					if (notif.timer) {
						editor.getWin().clearTimeout(notif.timer);
					}
	
					while (i--) {
						if (notifications[i] === notif) {
							notifications.splice(i, 1);
						}
					}
	
					positionNotifications();
				});
	
				notif.renderTo();
	
				positionNotifications();
	
				return notif;
			};
	
			/**
			 * Closes the top most notification.
			 *
			 * @method close
			 */
			self.close = function() {
				if (getLastNotification()) {
					getLastNotification().close();
				}
			};
	
			/**
			 * Returns the currently opened notification objects.
			 *
			 * @method getNotifications
			 * @return {Array} Array of the currently opened notifications.
			 */
			self.getNotifications = function() {
				return notifications;
			};
	
			editor.on('SkinLoaded', function() {
				var serviceMessage = editor.settings.service_message;
	
				if (serviceMessage) {
					editor.notificationManager.open({
						text: serviceMessage,
						type: 'warning',
						timeout: 0,
						icon: ''
					});
				}
			});
	
			//self.positionNotifications = positionNotifications;
		};
	});
	
	// Included from: js/tinymce/classes/dom/NodePath.js
	
	/**
	 * NodePath.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * Handles paths of nodes within an element.
	 *
	 * @private
	 * @class tinymce.dom.NodePath
	 */
	define("tinymce/dom/NodePath", [
		"tinymce/dom/DOMUtils"
	], function(DOMUtils) {
		function create(rootNode, targetNode, normalized) {
			var path = [];
	
			for (; targetNode && targetNode != rootNode; targetNode = targetNode.parentNode) {
				path.push(DOMUtils.nodeIndex(targetNode, normalized));
			}
	
			return path;
		}
	
		function resolve(rootNode, path) {
			var i, node, children;
	
			for (node = rootNode, i = path.length - 1; i >= 0; i--) {
				children = node.childNodes;
	
				if (path[i] > children.length - 1) {
					return null;
				}
	
				node = children[path[i]];
			}
	
			return node;
		}
	
		return {
			create: create,
			resolve: resolve
		};
	});
	
	// Included from: js/tinymce/classes/util/Quirks.js
	
	/**
	 * Quirks.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 *
	 * @ignore-file
	 */
	
	/**
	 * This file includes fixes for various browser quirks it's made to make it easy to add/remove browser specific fixes.
	 *
	 * @private
	 * @class tinymce.util.Quirks
	 */
	define("tinymce/util/Quirks", [
		"tinymce/util/VK",
		"tinymce/dom/RangeUtils",
		"tinymce/dom/TreeWalker",
		"tinymce/dom/NodePath",
		"tinymce/html/Node",
		"tinymce/html/Entities",
		"tinymce/Env",
		"tinymce/util/Tools",
		"tinymce/util/Delay",
		"tinymce/caret/CaretContainer"
	], function(VK, RangeUtils, TreeWalker, NodePath, Node, Entities, Env, Tools, Delay, CaretContainer) {
		return function(editor) {
			var each = Tools.each, $ = editor.$;
			var BACKSPACE = VK.BACKSPACE, DELETE = VK.DELETE, dom = editor.dom, selection = editor.selection,
				settings = editor.settings, parser = editor.parser, serializer = editor.serializer;
			var isGecko = Env.gecko, isIE = Env.ie, isWebKit = Env.webkit;
			var mceInternalUrlPrefix = 'data:text/mce-internal,';
			var mceInternalDataType = isIE ? 'Text' : 'URL';
	
			/**
			 * Executes a command with a specific state this can be to enable/disable browser editing features.
			 */
			function setEditorCommandState(cmd, state) {
				try {
					editor.getDoc().execCommand(cmd, false, state);
				} catch (ex) {
					// Ignore
				}
			}
	
			/**
			 * Returns current IE document mode.
			 */
			function getDocumentMode() {
				var documentMode = editor.getDoc().documentMode;
	
				return documentMode ? documentMode : 6;
			}
	
			/**
			 * Returns true/false if the event is prevented or not.
			 *
			 * @private
			 * @param {Event} e Event object.
			 * @return {Boolean} true/false if the event is prevented or not.
			 */
			function isDefaultPrevented(e) {
				return e.isDefaultPrevented();
			}
	
			/**
			 * Sets Text/URL data on the event's dataTransfer object to a special data:text/mce-internal url.
			 * This is to workaround the inability to set custom contentType on IE and Safari.
			 * The editor's selected content is encoded into this url so drag and drop between editors will work.
			 *
			 * @private
			 * @param {DragEvent} e Event object
			 */
			function setMceInternalContent(e) {
				var selectionHtml, internalContent;
	
				if (e.dataTransfer) {
					if (editor.selection.isCollapsed() && e.target.tagName == 'IMG') {
						selection.select(e.target);
					}
	
					selectionHtml = editor.selection.getContent();
	
					// Safari/IE doesn't support custom dataTransfer items so we can only use URL and Text
					if (selectionHtml.length > 0) {
						internalContent = mceInternalUrlPrefix + escape(editor.id) + ',' + escape(selectionHtml);
						e.dataTransfer.setData(mceInternalDataType, internalContent);
					}
				}
			}
	
			/**
			 * Gets content of special data:text/mce-internal url on the event's dataTransfer object.
			 * This is to workaround the inability to set custom contentType on IE and Safari.
			 * The editor's selected content is encoded into this url so drag and drop between editors will work.
			 *
			 * @private
			 * @param {DragEvent} e Event object
			 * @returns {String} mce-internal content
			 */
			function getMceInternalContent(e) {
				var internalContent;
	
				if (e.dataTransfer) {
					internalContent = e.dataTransfer.getData(mceInternalDataType);
	
					if (internalContent && internalContent.indexOf(mceInternalUrlPrefix) >= 0) {
						internalContent = internalContent.substr(mceInternalUrlPrefix.length).split(',');
	
						return {
							id: unescape(internalContent[0]),
							html: unescape(internalContent[1])
						};
					}
				}
	
				return null;
			}
	
			/**
			 * Inserts contents using the paste clipboard command if it's available if it isn't it will fallback
			 * to the core command.
			 *
			 * @private
			 * @param {String} content Content to insert at selection.
			 */
			function insertClipboardContents(content) {
				if (editor.queryCommandSupported('mceInsertClipboardContent')) {
					editor.execCommand('mceInsertClipboardContent', false, {content: content});
				} else {
					editor.execCommand('mceInsertContent', false, content);
				}
			}
	
			/**
			 * Fixes a WebKit bug when deleting contents using backspace or delete key.
			 * WebKit will produce a span element if you delete across two block elements.
			 *
			 * Example:
			 * <h1>a</h1><p>|b</p>
			 *
			 * Will produce this on backspace:
			 * <h1>a<span style="<all runtime styles>">b</span></p>
			 *
			 * This fixes the backspace to produce:
			 * <h1>a|b</p>
			 *
			 * See bug: https://bugs.webkit.org/show_bug.cgi?id=45784
			 *
			 * This fixes the following delete scenarios:
			 *  1. Delete by pressing backspace key.
			 *  2. Delete by pressing delete key.
			 *  3. Delete by pressing backspace key with ctrl/cmd (Word delete).
			 *  4. Delete by pressing delete key with ctrl/cmd (Word delete).
			 *  5. Delete by drag/dropping contents inside the editor.
			 *  6. Delete by using Cut Ctrl+X/Cmd+X.
			 *  7. Delete by selecting contents and writing a character.
			 *
			 * This code is a ugly hack since writing full custom delete logic for just this bug
			 * fix seemed like a huge task. I hope we can remove this before the year 2030.
			 */
			function cleanupStylesWhenDeleting() {
				var doc = editor.getDoc(), dom = editor.dom, selection = editor.selection;
				var MutationObserver = window.MutationObserver, olderWebKit, dragStartRng;
	
				// Add mini polyfill for older WebKits
				// TODO: Remove this when old Safari versions gets updated
				if (!MutationObserver) {
					olderWebKit = true;
	
					MutationObserver = function() {
						var records = [], target;
	
						function nodeInsert(e) {
							var target = e.relatedNode || e.target;
							records.push({target: target, addedNodes: [target]});
						}
	
						function attrModified(e) {
							var target = e.relatedNode || e.target;
							records.push({target: target, attributeName: e.attrName});
						}
	
						this.observe = function(node) {
							target = node;
							target.addEventListener('DOMSubtreeModified', nodeInsert, false);
							target.addEventListener('DOMNodeInsertedIntoDocument', nodeInsert, false);
							target.addEventListener('DOMNodeInserted', nodeInsert, false);
							target.addEventListener('DOMAttrModified', attrModified, false);
						};
	
						this.disconnect = function() {
							target.removeEventListener('DOMSubtreeModified', nodeInsert, false);
							target.removeEventListener('DOMNodeInsertedIntoDocument', nodeInsert, false);
							target.removeEventListener('DOMNodeInserted', nodeInsert, false);
							target.removeEventListener('DOMAttrModified', attrModified, false);
						};
	
						this.takeRecords = function() {
							return records;
						};
					};
				}
	
				function isTrailingBr(node) {
					var blockElements = dom.schema.getBlockElements(), rootNode = editor.getBody();
	
					if (node.nodeName != 'BR') {
						return false;
					}
	
					for (; node != rootNode && !blockElements[node.nodeName]; node = node.parentNode) {
						if (node.nextSibling) {
							return false;
						}
					}
	
					return true;
				}
	
				function isSiblingsIgnoreWhiteSpace(node1, node2) {
					var node;
	
					for (node = node1.nextSibling; node && node != node2; node = node.nextSibling) {
						if (node.nodeType == 3 && $.trim(node.data).length === 0) {
							continue;
						}
	
						if (node !== node2) {
							return false;
						}
					}
	
					return node === node2;
				}
	
				function findCaretNode(node, forward, startNode) {
					var walker, current, nonEmptyElements;
	
					nonEmptyElements = dom.schema.getNonEmptyElements();
	
					walker = new TreeWalker(startNode || node, node);
	
					while ((current = walker[forward ? 'next' : 'prev']())) {
						if (nonEmptyElements[current.nodeName] && !isTrailingBr(current)) {
							return current;
						}
	
						if (current.nodeType == 3 && current.data.length > 0) {
							return current;
						}
					}
				}
	
				function deleteRangeBetweenTextBlocks(rng) {
					var startBlock, endBlock, caretNodeBefore, caretNodeAfter, textBlockElements;
	
					if (rng.collapsed) {
						return;
					}
	
					startBlock = dom.getParent(RangeUtils.getNode(rng.startContainer, rng.startOffset), dom.isBlock);
					endBlock = dom.getParent(RangeUtils.getNode(rng.endContainer, rng.endOffset), dom.isBlock);
					textBlockElements = editor.schema.getTextBlockElements();
	
					if (startBlock == endBlock) {
						return;
					}
	
					if (!textBlockElements[startBlock.nodeName] || !textBlockElements[endBlock.nodeName]) {
						return;
					}
	
					if (dom.getContentEditable(startBlock) === "false" || dom.getContentEditable(endBlock) === "false") {
						return;
					}
	
					rng.deleteContents();
	
					caretNodeBefore = findCaretNode(startBlock, false);
					caretNodeAfter = findCaretNode(endBlock, true);
	
					if (!dom.isEmpty(endBlock)) {
						$(startBlock).append(endBlock.childNodes);
					}
	
					$(endBlock).remove();
	
					if (caretNodeBefore) {
						if (caretNodeBefore.nodeType == 1) {
							if (caretNodeBefore.nodeName == "BR") {
								rng.setStartBefore(caretNodeBefore);
								rng.setEndBefore(caretNodeBefore);
							} else {
								rng.setStartAfter(caretNodeBefore);
								rng.setEndAfter(caretNodeBefore);
							}
						} else {
							rng.setStart(caretNodeBefore, caretNodeBefore.data.length);
							rng.setEnd(caretNodeBefore, caretNodeBefore.data.length);
						}
					} else if (caretNodeAfter) {
						if (caretNodeAfter.nodeType == 1) {
							rng.setStartBefore(caretNodeAfter);
							rng.setEndBefore(caretNodeAfter);
						} else {
							rng.setStart(caretNodeAfter, 0);
							rng.setEnd(caretNodeAfter, 0);
						}
					}
	
					selection.setRng(rng);
	
					return true;
				}
	
				function expandBetweenBlocks(rng, isForward) {
					var caretNode, targetCaretNode, textBlock, targetTextBlock, container, offset;
	
					if (!rng.collapsed) {
						return rng;
					}
	
					container = rng.startContainer;
					offset = rng.startOffset;
	
					if (container.nodeType == 3) {
						if (isForward) {
							if (offset < container.data.length) {
								return rng;
							}
						} else {
							if (offset > 0) {
								return rng;
							}
						}
					}
	
					caretNode = RangeUtils.getNode(rng.startContainer, rng.startOffset);
					textBlock = dom.getParent(caretNode, dom.isBlock);
					targetCaretNode = findCaretNode(editor.getBody(), isForward, caretNode);
					targetTextBlock = dom.getParent(targetCaretNode, dom.isBlock);
	
					if (!caretNode || !targetCaretNode) {
						return rng;
					}
	
					if (targetTextBlock && textBlock != targetTextBlock) {
						if (!isForward) {
							if (!isSiblingsIgnoreWhiteSpace(targetTextBlock, textBlock)) {
								return rng;
							}
	
							if (targetCaretNode.nodeType == 1) {
								if (targetCaretNode.nodeName == "BR") {
									rng.setStartBefore(targetCaretNode);
								} else {
									rng.setStartAfter(targetCaretNode);
								}
							} else {
								rng.setStart(targetCaretNode, targetCaretNode.data.length);
							}
	
							if (caretNode.nodeType == 1) {
								rng.setEnd(caretNode, 0);
							} else {
								rng.setEndBefore(caretNode);
							}
						} else {
							if (!isSiblingsIgnoreWhiteSpace(textBlock, targetTextBlock)) {
								return rng;
							}
	
							if (caretNode.nodeType == 1) {
								if (caretNode.nodeName == "BR") {
									rng.setStartBefore(caretNode);
								} else {
									rng.setStartAfter(caretNode);
								}
							} else {
								rng.setStart(caretNode, caretNode.data.length);
							}
	
							if (targetCaretNode.nodeType == 1) {
								rng.setEnd(targetCaretNode, 0);
							} else {
								rng.setEndBefore(targetCaretNode);
							}
						}
					}
	
					return rng;
				}
	
				function handleTextBlockMergeDelete(isForward) {
					var rng = selection.getRng();
	
					rng = expandBetweenBlocks(rng, isForward);
	
					if (deleteRangeBetweenTextBlocks(rng)) {
						return true;
					}
				}
	
				/**
				 * This retains the formatting if the last character is to be deleted.
				 *
				 * Backspace on this: <p><b><i>a|</i></b></p> would become <p>|</p> in WebKit.
				 * With this patch: <p><b><i>|<br></i></b></p>
				 */
				function handleLastBlockCharacterDelete(isForward, rng) {
					var path, blockElm, newBlockElm, clonedBlockElm, sibling,
						container, offset, br, currentFormatNodes;
	
					function cloneTextBlockWithFormats(blockElm, node) {
						currentFormatNodes = $(node).parents().filter(function(idx, node) {
							return !!editor.schema.getTextInlineElements()[node.nodeName];
						});
	
						newBlockElm = blockElm.cloneNode(false);
	
						currentFormatNodes = Tools.map(currentFormatNodes, function(formatNode) {
							formatNode = formatNode.cloneNode(false);
	
							if (newBlockElm.hasChildNodes()) {
								formatNode.appendChild(newBlockElm.firstChild);
								newBlockElm.appendChild(formatNode);
							} else {
								newBlockElm.appendChild(formatNode);
							}
	
							newBlockElm.appendChild(formatNode);
	
							return formatNode;
						});
	
						if (currentFormatNodes.length) {
							br = dom.create('br');
							currentFormatNodes[0].appendChild(br);
							dom.replace(newBlockElm, blockElm);
	
							rng.setStartBefore(br);
							rng.setEndBefore(br);
							editor.selection.setRng(rng);
	
							return br;
						}
	
						return null;
					}
	
					function isTextBlock(node) {
						return node && editor.schema.getTextBlockElements()[node.tagName];
					}
	
					if (!rng.collapsed) {
						return;
					}
	
					container = rng.startContainer;
					offset = rng.startOffset;
					blockElm = dom.getParent(container, dom.isBlock);
					if (!isTextBlock(blockElm)) {
						return;
					}
	
					if (container.nodeType == 1) {
						container = container.childNodes[offset];
						if (container && container.tagName != 'BR') {
							return;
						}
	
						if (isForward) {
							sibling = blockElm.nextSibling;
						} else {
							sibling = blockElm.previousSibling;
						}
	
						if (dom.isEmpty(blockElm) && isTextBlock(sibling) && dom.isEmpty(sibling)) {
							if (cloneTextBlockWithFormats(blockElm, container)) {
								dom.remove(sibling);
								return true;
							}
						}
					} else if (container.nodeType == 3) {
						path = NodePath.create(blockElm, container);
						clonedBlockElm = blockElm.cloneNode(true);
						container = NodePath.resolve(clonedBlockElm, path);
	
						if (isForward) {
							if (offset >= container.data.length) {
								return;
							}
	
							container.deleteData(offset, 1);
						} else {
							if (offset <= 0) {
								return;
							}
	
							container.deleteData(offset - 1, 1);
						}
	
						if (dom.isEmpty(clonedBlockElm)) {
							return cloneTextBlockWithFormats(blockElm, container);
						}
					}
				}
	
				function customDelete(isForward) {
					var mutationObserver, rng, caretElement;
	
					if (handleTextBlockMergeDelete(isForward)) {
						return;
					}
	
					Tools.each(editor.getBody().getElementsByTagName('*'), function(elm) {
						// Mark existing spans
						if (elm.tagName == 'SPAN') {
							elm.setAttribute('mce-data-marked', 1);
						}
	
						// Make sure all elements has a data-mce-style attribute
						if (!elm.hasAttribute('data-mce-style') && elm.hasAttribute('style')) {
							editor.dom.setAttrib(elm, 'style', editor.dom.getAttrib(elm, 'style'));
						}
					});
	
					// Observe added nodes and style attribute changes
					mutationObserver = new MutationObserver(function() {});
					mutationObserver.observe(editor.getDoc(), {
						childList: true,
						attributes: true,
						subtree: true,
						attributeFilter: ['style']
					});
	
					editor.getDoc().execCommand(isForward ? 'ForwardDelete' : 'Delete', false, null);
	
					rng = editor.selection.getRng();
					caretElement = rng.startContainer.parentNode;
	
					Tools.each(mutationObserver.takeRecords(), function(record) {
						if (!dom.isChildOf(record.target, editor.getBody())) {
							return;
						}
	
						// Restore style attribute to previous value
						if (record.attributeName == "style") {
							var oldValue = record.target.getAttribute('data-mce-style');
	
							if (oldValue) {
								record.target.setAttribute("style", oldValue);
							} else {
								record.target.removeAttribute("style");
							}
						}
	
						// Remove all spans that aren't marked and retain selection
						Tools.each(record.addedNodes, function(node) {
							if (node.nodeName == "SPAN" && !node.getAttribute('mce-data-marked')) {
								var offset, container;
	
								if (node == caretElement) {
									offset = rng.startOffset;
									container = node.firstChild;
								}
	
								dom.remove(node, true);
	
								if (container) {
									rng.setStart(container, offset);
									rng.setEnd(container, offset);
									editor.selection.setRng(rng);
								}
							}
						});
					});
	
					mutationObserver.disconnect();
	
					// Remove any left over marks
					Tools.each(editor.dom.select('span[mce-data-marked]'), function(span) {
						span.removeAttribute('mce-data-marked');
					});
				}
	
				editor.on('keydown', function(e) {
					var isForward = e.keyCode == DELETE, isMetaOrCtrl = e.ctrlKey || e.metaKey;
	
					if (!isDefaultPrevented(e) && (isForward || e.keyCode == BACKSPACE)) {
						var rng = editor.selection.getRng(), container = rng.startContainer, offset = rng.startOffset;
	
						// Shift+Delete is cut
						if (isForward && e.shiftKey) {
							return;
						}
	
						if (handleLastBlockCharacterDelete(isForward, rng)) {
							e.preventDefault();
							return;
						}
	
						// Ignore non meta delete in the where there is text before/after the caret
						if (!isMetaOrCtrl && rng.collapsed && container.nodeType == 3) {
							if (isForward ? offset < container.data.length : offset > 0) {
								return;
							}
						}
	
						e.preventDefault();
	
						if (isMetaOrCtrl) {
							editor.selection.getSel().modify("extend", isForward ? "forward" : "backward", e.metaKey ? "lineboundary" : "word");
						}
	
						customDelete(isForward);
					}
				});
	
				// Handle case where text is deleted by typing over
				editor.on('keypress', function(e) {
					if (!isDefaultPrevented(e) && !selection.isCollapsed() && e.charCode > 31 && !VK.metaKeyPressed(e)) {
						var rng, currentFormatNodes, fragmentNode, blockParent, caretNode, charText;
	
						rng = editor.selection.getRng();
						charText = String.fromCharCode(e.charCode);
						e.preventDefault();
	
						// Keep track of current format nodes
						currentFormatNodes = $(rng.startContainer).parents().filter(function(idx, node) {
							return !!editor.schema.getTextInlineElements()[node.nodeName];
						});
	
						customDelete(true);
	
						// Check if the browser removed them
						currentFormatNodes = currentFormatNodes.filter(function(idx, node) {
							return !$.contains(editor.getBody(), node);
						});
	
						// Then re-add them
						if (currentFormatNodes.length) {
							fragmentNode = dom.createFragment();
	
							currentFormatNodes.each(function(idx, formatNode) {
								formatNode = formatNode.cloneNode(false);
	
								if (fragmentNode.hasChildNodes()) {
									formatNode.appendChild(fragmentNode.firstChild);
									fragmentNode.appendChild(formatNode);
								} else {
									caretNode = formatNode;
									fragmentNode.appendChild(formatNode);
								}
	
								fragmentNode.appendChild(formatNode);
							});
	
							caretNode.appendChild(editor.getDoc().createTextNode(charText));
	
							// Prevent edge case where older WebKit would add an extra BR element
							blockParent = dom.getParent(rng.startContainer, dom.isBlock);
							if (dom.isEmpty(blockParent)) {
								$(blockParent).empty().append(fragmentNode);
							} else {
								rng.insertNode(fragmentNode);
							}
	
							rng.setStart(caretNode.firstChild, 1);
							rng.setEnd(caretNode.firstChild, 1);
							editor.selection.setRng(rng);
						} else {
							editor.selection.setContent(charText);
						}
					}
				});
	
				editor.addCommand('Delete', function() {
					customDelete();
				});
	
				editor.addCommand('ForwardDelete', function() {
					customDelete(true);
				});
	
				// Older WebKits doesn't properly handle the clipboard so we can't add the rest
				if (olderWebKit) {
					return;
				}
	
				editor.on('dragstart', function(e) {
					dragStartRng = selection.getRng();
					setMceInternalContent(e);
				});
	
				editor.on('drop', function(e) {
					if (!isDefaultPrevented(e)) {
						var internalContent = getMceInternalContent(e);
	
						if (internalContent) {
							e.preventDefault();
	
							// Safari has a weird issue where drag/dropping images sometimes
							// produces a green plus icon. When this happens the caretRangeFromPoint
							// will return "null" even though the x, y coordinate is correct.
							// But if we detach the insert from the drop event we will get a proper range
							Delay.setEditorTimeout(editor, function() {
								var pointRng = RangeUtils.getCaretRangeFromPoint(e.x, e.y, doc);
	
								if (dragStartRng) {
									selection.setRng(dragStartRng);
									dragStartRng = null;
								}
	
								customDelete();
								selection.setRng(pointRng);
								insertClipboardContents(internalContent.html);
							});
						}
					}
				});
	
				editor.on('cut', function(e) {
					if (!isDefaultPrevented(e) && e.clipboardData && !editor.selection.isCollapsed()) {
						e.preventDefault();
						e.clipboardData.clearData();
						e.clipboardData.setData('text/html', editor.selection.getContent());
						e.clipboardData.setData('text/plain', editor.selection.getContent({format: 'text'}));
	
						// Needed delay for https://code.google.com/p/chromium/issues/detail?id=363288#c3
						// Nested delete/forwardDelete not allowed on execCommand("cut")
						// This is ugly but not sure how to work around it otherwise
						Delay.setEditorTimeout(editor, function() {
							customDelete(true);
						});
					}
				});
			}
	
			/**
			 * Makes sure that the editor body becomes empty when backspace or delete is pressed in empty editors.
			 *
			 * For example:
			 * <p><b>|</b></p>
			 *
			 * Or:
			 * <h1>|</h1>
			 *
			 * Or:
			 * [<h1></h1>]
			 */
			function emptyEditorWhenDeleting() {
				function serializeRng(rng) {
					var body = dom.create("body");
					var contents = rng.cloneContents();
					body.appendChild(contents);
					return selection.serializer.serialize(body, {format: 'html'});
				}
	
				function allContentsSelected(rng) {
					if (!rng.setStart) {
						if (rng.item) {
							return false;
						}
	
						var bodyRng = rng.duplicate();
						bodyRng.moveToElementText(editor.getBody());
						return RangeUtils.compareRanges(rng, bodyRng);
					}
	
					var selection = serializeRng(rng);
	
					var allRng = dom.createRng();
					allRng.selectNode(editor.getBody());
	
					var allSelection = serializeRng(allRng);
					return selection === allSelection;
				}
	
				editor.on('keydown', function(e) {
					var keyCode = e.keyCode, isCollapsed, body;
	
					// Empty the editor if it's needed for example backspace at <p><b>|</b></p>
					if (!isDefaultPrevented(e) && (keyCode == DELETE || keyCode == BACKSPACE)) {
						isCollapsed = editor.selection.isCollapsed();
						body = editor.getBody();
	
						// Selection is collapsed but the editor isn't empty
						if (isCollapsed && !dom.isEmpty(body)) {
							return;
						}
	
						// Selection isn't collapsed but not all the contents is selected
						if (!isCollapsed && !allContentsSelected(editor.selection.getRng())) {
							return;
						}
	
						// Manually empty the editor
						e.preventDefault();
						editor.setContent('');
	
						if (body.firstChild && dom.isBlock(body.firstChild)) {
							editor.selection.setCursorLocation(body.firstChild, 0);
						} else {
							editor.selection.setCursorLocation(body, 0);
						}
	
						editor.nodeChanged();
					}
				});
			}
	
			/**
			 * WebKit doesn't select all the nodes in the body when you press Ctrl+A.
			 * IE selects more than the contents <body>[<p>a</p>]</body> instead of <body><p>[a]</p]</body> see bug #6438
			 * This selects the whole body so that backspace/delete logic will delete everything
			 */
			function selectAll() {
				editor.shortcuts.add('meta+a', null, 'SelectAll');
			}
	
			/**
			 * WebKit has a weird issue where it some times fails to properly convert keypresses to input method keystrokes.
			 * The IME on Mac doesn't initialize when it doesn't fire a proper focus event.
			 *
			 * This seems to happen when the user manages to click the documentElement element then the window doesn't get proper focus until
			 * you enter a character into the editor.
			 *
			 * It also happens when the first focus in made to the body.
			 *
			 * See: https://bugs.webkit.org/show_bug.cgi?id=83566
			 */
			function inputMethodFocus() {
				if (!editor.settings.content_editable) {
					// Case 1 IME doesn't initialize if you focus the document
					// Disabled since it was interferring with the cE=false logic
					// Also coultn't reproduce the issue on Safari 9
					/*dom.bind(editor.getDoc(), 'focusin', function() {
						selection.setRng(selection.getRng());
					});*/
	
					// Case 2 IME doesn't initialize if you click the documentElement it also doesn't properly fire the focusin event
					// Needs to be both down/up due to weird rendering bug on Chrome Windows
					dom.bind(editor.getDoc(), 'mousedown mouseup', function(e) {
						var rng;
	
						if (e.target == editor.getDoc().documentElement) {
							rng = selection.getRng();
							editor.getBody().focus();
	
							if (e.type == 'mousedown') {
								if (CaretContainer.isCaretContainer(rng.startContainer)) {
									return;
								}
	
								// Edge case for mousedown, drag select and mousedown again within selection on Chrome Windows to render caret
								selection.placeCaretAt(e.clientX, e.clientY);
							} else {
								selection.setRng(rng);
							}
						}
					});
				}
			}
	
			/**
			 * Backspacing in FireFox/IE from a paragraph into a horizontal rule results in a floating text node because the
			 * browser just deletes the paragraph - the browser fails to merge the text node with a horizontal rule so it is
			 * left there. TinyMCE sees a floating text node and wraps it in a paragraph on the key up event (ForceBlocks.js
			 * addRootBlocks), meaning the action does nothing. With this code, FireFox/IE matche the behaviour of other
			 * browsers.
			 *
			 * It also fixes a bug on Firefox where it's impossible to delete HR elements.
			 */
			function removeHrOnBackspace() {
				editor.on('keydown', function(e) {
					if (!isDefaultPrevented(e) && e.keyCode === BACKSPACE) {
						// Check if there is any HR elements this is faster since getRng on IE 7 & 8 is slow
						if (!editor.getBody().getElementsByTagName('hr').length) {
							return;
						}
	
						if (selection.isCollapsed() && selection.getRng(true).startOffset === 0) {
							var node = selection.getNode();
							var previousSibling = node.previousSibling;
	
							if (node.nodeName == 'HR') {
								dom.remove(node);
								e.preventDefault();
								return;
							}
	
							if (previousSibling && previousSibling.nodeName && previousSibling.nodeName.toLowerCase() === "hr") {
								dom.remove(previousSibling);
								e.preventDefault();
							}
						}
					}
				});
			}
	
			/**
			 * Firefox 3.x has an issue where the body element won't get proper focus if you click out
			 * side it's rectangle.
			 */
			function focusBody() {
				// Fix for a focus bug in FF 3.x where the body element
				// wouldn't get proper focus if the user clicked on the HTML element
				if (!window.Range.prototype.getClientRects) { // Detect getClientRects got introduced in FF 4
					editor.on('mousedown', function(e) {
						if (!isDefaultPrevented(e) && e.target.nodeName === "HTML") {
							var body = editor.getBody();
	
							// Blur the body it's focused but not correctly focused
							body.blur();
	
							// Refocus the body after a little while
							Delay.setEditorTimeout(editor, function() {
								body.focus();
							});
						}
					});
				}
			}
	
			/**
			 * WebKit has a bug where it isn't possible to select image, hr or anchor elements
			 * by clicking on them so we need to fake that.
			 */
			function selectControlElements() {
				editor.on('click', function(e) {
					var target = e.target;
	
					// Workaround for bug, http://bugs.webkit.org/show_bug.cgi?id=12250
					// WebKit can't even do simple things like selecting an image
					// Needs to be the setBaseAndExtend or it will fail to select floated images
					if (/^(IMG|HR)$/.test(target.nodeName) && dom.getContentEditableParent(target) !== "false") {
						e.preventDefault();
						selection.getSel().setBaseAndExtent(target, 0, target, 1);
						editor.nodeChanged();
					}
	
					if (target.nodeName == 'A' && dom.hasClass(target, 'mce-item-anchor')) {
						e.preventDefault();
						selection.select(target);
					}
				});
			}
	
			/**
			 * Fixes a Gecko bug where the style attribute gets added to the wrong element when deleting between two block elements.
			 *
			 * Fixes do backspace/delete on this:
			 * <p>bla[ck</p><p style="color:red">r]ed</p>
			 *
			 * Would become:
			 * <p>bla|ed</p>
			 *
			 * Instead of:
			 * <p style="color:red">bla|ed</p>
			 */
			function removeStylesWhenDeletingAcrossBlockElements() {
				function getAttributeApplyFunction() {
					var template = dom.getAttribs(selection.getStart().cloneNode(false));
	
					return function() {
						var target = selection.getStart();
	
						if (target !== editor.getBody()) {
							dom.setAttrib(target, "style", null);
	
							each(template, function(attr) {
								target.setAttributeNode(attr.cloneNode(true));
							});
						}
					};
				}
	
				function isSelectionAcrossElements() {
					return !selection.isCollapsed() &&
						dom.getParent(selection.getStart(), dom.isBlock) != dom.getParent(selection.getEnd(), dom.isBlock);
				}
	
				editor.on('keypress', function(e) {
					var applyAttributes;
	
					if (!isDefaultPrevented(e) && (e.keyCode == 8 || e.keyCode == 46) && isSelectionAcrossElements()) {
						applyAttributes = getAttributeApplyFunction();
						editor.getDoc().execCommand('delete', false, null);
						applyAttributes();
						e.preventDefault();
						return false;
					}
				});
	
				dom.bind(editor.getDoc(), 'cut', function(e) {
					var applyAttributes;
	
					if (!isDefaultPrevented(e) && isSelectionAcrossElements()) {
						applyAttributes = getAttributeApplyFunction();
	
						Delay.setEditorTimeout(editor, function() {
							applyAttributes();
						});
					}
				});
			}
	
			/**
			 * Screen readers on IE needs to have the role application set on the body.
			 */
			function ensureBodyHasRoleApplication() {
				document.body.setAttribute("role", "application");
			}
	
			/**
			 * Backspacing into a table behaves differently depending upon browser type.
			 * Therefore, disable Backspace when cursor immediately follows a table.
			 */
			function disableBackspaceIntoATable() {
				editor.on('keydown', function(e) {
					if (!isDefaultPrevented(e) && e.keyCode === BACKSPACE) {
						if (selection.isCollapsed() && selection.getRng(true).startOffset === 0) {
							var previousSibling = selection.getNode().previousSibling;
							if (previousSibling && previousSibling.nodeName && previousSibling.nodeName.toLowerCase() === "table") {
								e.preventDefault();
								return false;
							}
						}
					}
				});
			}
	
			/**
			 * Old IE versions can't properly render BR elements in PRE tags white in contentEditable mode. So this
			 * logic adds a \n before the BR so that it will get rendered.
			 */
			function addNewLinesBeforeBrInPre() {
				// IE8+ rendering mode does the right thing with BR in PRE
				if (getDocumentMode() > 7) {
					return;
				}
	
				// Enable display: none in area and add a specific class that hides all BR elements in PRE to
				// avoid the caret from getting stuck at the BR elements while pressing the right arrow key
				setEditorCommandState('RespectVisibilityInDesign', true);
				editor.contentStyles.push('.mceHideBrInPre pre br {display: none}');
				dom.addClass(editor.getBody(), 'mceHideBrInPre');
	
				// Adds a \n before all BR elements in PRE to get them visual
				parser.addNodeFilter('pre', function(nodes) {
					var i = nodes.length, brNodes, j, brElm, sibling;
	
					while (i--) {
						brNodes = nodes[i].getAll('br');
						j = brNodes.length;
						while (j--) {
							brElm = brNodes[j];
	
							// Add \n before BR in PRE elements on older IE:s so the new lines get rendered
							sibling = brElm.prev;
							if (sibling && sibling.type === 3 && sibling.value.charAt(sibling.value - 1) != '\n') {
								sibling.value += '\n';
							} else {
								brElm.parent.insert(new Node('#text', 3), brElm, true).value = '\n';
							}
						}
					}
				});
	
				// Removes any \n before BR elements in PRE since other browsers and in contentEditable=false mode they will be visible
				serializer.addNodeFilter('pre', function(nodes) {
					var i = nodes.length, brNodes, j, brElm, sibling;
	
					while (i--) {
						brNodes = nodes[i].getAll('br');
						j = brNodes.length;
						while (j--) {
							brElm = brNodes[j];
							sibling = brElm.prev;
							if (sibling && sibling.type == 3) {
								sibling.value = sibling.value.replace(/\r?\n$/, '');
							}
						}
					}
				});
			}
	
			/**
			 * Moves style width/height to attribute width/height when the user resizes an image on IE.
			 */
			function removePreSerializedStylesWhenSelectingControls() {
				dom.bind(editor.getBody(), 'mouseup', function() {
					var value, node = selection.getNode();
	
					// Moved styles to attributes on IMG eements
					if (node.nodeName == 'IMG') {
						// Convert style width to width attribute
						if ((value = dom.getStyle(node, 'width'))) {
							dom.setAttrib(node, 'width', value.replace(/[^0-9%]+/g, ''));
							dom.setStyle(node, 'width', '');
						}
	
						// Convert style height to height attribute
						if ((value = dom.getStyle(node, 'height'))) {
							dom.setAttrib(node, 'height', value.replace(/[^0-9%]+/g, ''));
							dom.setStyle(node, 'height', '');
						}
					}
				});
			}
	
			/**
			 * Removes a blockquote when backspace is pressed at the beginning of it.
			 *
			 * For example:
			 * <blockquote><p>|x</p></blockquote>
			 *
			 * Becomes:
			 * <p>|x</p>
			 */
			function removeBlockQuoteOnBackSpace() {
				// Add block quote deletion handler
				editor.on('keydown', function(e) {
					var rng, container, offset, root, parent;
	
					if (isDefaultPrevented(e) || e.keyCode != VK.BACKSPACE) {
						return;
					}
	
					rng = selection.getRng();
					container = rng.startContainer;
					offset = rng.startOffset;
					root = dom.getRoot();
					parent = container;
	
					if (!rng.collapsed || offset !== 0) {
						return;
					}
	
					while (parent && parent.parentNode && parent.parentNode.firstChild == parent && parent.parentNode != root) {
						parent = parent.parentNode;
					}
	
					// Is the cursor at the beginning of a blockquote?
					if (parent.tagName === 'BLOCKQUOTE') {
						// Remove the blockquote
						editor.formatter.toggle('blockquote', null, parent);
	
						// Move the caret to the beginning of container
						rng = dom.createRng();
						rng.setStart(container, 0);
						rng.setEnd(container, 0);
						selection.setRng(rng);
					}
				});
			}
	
			/**
			 * Sets various Gecko editing options on mouse down and before a execCommand to disable inline table editing that is broken etc.
			 */
			function setGeckoEditingOptions() {
				function setOpts() {
					refreshContentEditable();
	
					setEditorCommandState("StyleWithCSS", false);
					setEditorCommandState("enableInlineTableEditing", false);
	
					if (!settings.object_resizing) {
						setEditorCommandState("enableObjectResizing", false);
					}
				}
	
				if (!settings.readonly) {
					editor.on('BeforeExecCommand MouseDown', setOpts);
				}
			}
	
			/**
			 * Fixes a gecko link bug, when a link is placed at the end of block elements there is
			 * no way to move the caret behind the link. This fix adds a bogus br element after the link.
			 *
			 * For example this:
			 * <p><b><a href="#">x</a></b></p>
			 *
			 * Becomes this:
			 * <p><b><a href="#">x</a></b><br></p>
			 */
			function addBrAfterLastLinks() {
				function fixLinks() {
					each(dom.select('a'), function(node) {
						var parentNode = node.parentNode, root = dom.getRoot();
	
						if (parentNode.lastChild === node) {
							while (parentNode && !dom.isBlock(parentNode)) {
								if (parentNode.parentNode.lastChild !== parentNode || parentNode === root) {
									return;
								}
	
								parentNode = parentNode.parentNode;
							}
	
							dom.add(parentNode, 'br', {'data-mce-bogus': 1});
						}
					});
				}
	
				editor.on('SetContent ExecCommand', function(e) {
					if (e.type == "setcontent" || e.command === 'mceInsertLink') {
						fixLinks();
					}
				});
			}
	
			/**
			 * WebKit will produce DIV elements here and there by default. But since TinyMCE uses paragraphs by
			 * default we want to change that behavior.
			 */
			function setDefaultBlockType() {
				if (settings.forced_root_block) {
					editor.on('init', function() {
						setEditorCommandState('DefaultParagraphSeparator', settings.forced_root_block);
					});
				}
			}
	
			/**
			 * Deletes the selected image on IE instead of navigating to previous page.
			 */
			function deleteControlItemOnBackSpace() {
				editor.on('keydown', function(e) {
					var rng;
	
					if (!isDefaultPrevented(e) && e.keyCode == BACKSPACE) {
						rng = editor.getDoc().selection.createRange();
						if (rng && rng.item) {
							e.preventDefault();
							editor.undoManager.beforeChange();
							dom.remove(rng.item(0));
							editor.undoManager.add();
						}
					}
				});
			}
	
			/**
			 * IE10 doesn't properly render block elements with the right height until you add contents to them.
			 * This fixes that by adding a padding-right to all empty text block elements.
			 * See: https://connect.microsoft.com/IE/feedback/details/743881
			 */
			function renderEmptyBlocksFix() {
				var emptyBlocksCSS;
	
				// IE10+
				if (getDocumentMode() >= 10) {
					emptyBlocksCSS = '';
					each('p div h1 h2 h3 h4 h5 h6'.split(' '), function(name, i) {
						emptyBlocksCSS += (i > 0 ? ',' : '') + name + ':empty';
					});
	
					editor.contentStyles.push(emptyBlocksCSS + '{padding-right: 1px !important}');
				}
			}
	
			/**
			 * Old IE versions can't retain contents within noscript elements so this logic will store the contents
			 * as a attribute and the insert that value as it's raw text when the DOM is serialized.
			 */
			function keepNoScriptContents() {
				if (getDocumentMode() < 9) {
					parser.addNodeFilter('noscript', function(nodes) {
						var i = nodes.length, node, textNode;
	
						while (i--) {
							node = nodes[i];
							textNode = node.firstChild;
	
							if (textNode) {
								node.attr('data-mce-innertext', textNode.value);
							}
						}
					});
	
					serializer.addNodeFilter('noscript', function(nodes) {
						var i = nodes.length, node, textNode, value;
	
						while (i--) {
							node = nodes[i];
							textNode = nodes[i].firstChild;
	
							if (textNode) {
								textNode.value = Entities.decode(textNode.value);
							} else {
								// Old IE can't retain noscript value so an attribute is used to store it
								value = node.attributes.map['data-mce-innertext'];
								if (value) {
									node.attr('data-mce-innertext', null);
									textNode = new Node('#text', 3);
									textNode.value = value;
									textNode.raw = true;
									node.append(textNode);
								}
							}
						}
					});
				}
			}
	
			/**
			 * IE has an issue where you can't select/move the caret by clicking outside the body if the document is in standards mode.
			 */
			function fixCaretSelectionOfDocumentElementOnIe() {
				var doc = dom.doc, body = doc.body, started, startRng, htmlElm;
	
				// Return range from point or null if it failed
				function rngFromPoint(x, y) {
					var rng = body.createTextRange();
	
					try {
						rng.moveToPoint(x, y);
					} catch (ex) {
						// IE sometimes throws and exception, so lets just ignore it
						rng = null;
					}
	
					return rng;
				}
	
				// Fires while the selection is changing
				function selectionChange(e) {
					var pointRng;
	
					// Check if the button is down or not
					if (e.button) {
						// Create range from mouse position
						pointRng = rngFromPoint(e.x, e.y);
	
						if (pointRng) {
							// Check if pointRange is before/after selection then change the endPoint
							if (pointRng.compareEndPoints('StartToStart', startRng) > 0) {
								pointRng.setEndPoint('StartToStart', startRng);
							} else {
								pointRng.setEndPoint('EndToEnd', startRng);
							}
	
							pointRng.select();
						}
					} else {
						endSelection();
					}
				}
	
				// Removes listeners
				function endSelection() {
					var rng = doc.selection.createRange();
	
					// If the range is collapsed then use the last start range
					if (startRng && !rng.item && rng.compareEndPoints('StartToEnd', rng) === 0) {
						startRng.select();
					}
	
					dom.unbind(doc, 'mouseup', endSelection);
					dom.unbind(doc, 'mousemove', selectionChange);
					startRng = started = 0;
				}
	
				// Make HTML element unselectable since we are going to handle selection by hand
				doc.documentElement.unselectable = true;
	
				// Detect when user selects outside BODY
				dom.bind(doc, 'mousedown contextmenu', function(e) {
					if (e.target.nodeName === 'HTML') {
						if (started) {
							endSelection();
						}
	
						// Detect vertical scrollbar, since IE will fire a mousedown on the scrollbar and have target set as HTML
						htmlElm = doc.documentElement;
						if (htmlElm.scrollHeight > htmlElm.clientHeight) {
							return;
						}
	
						started = 1;
						// Setup start position
						startRng = rngFromPoint(e.x, e.y);
						if (startRng) {
							// Listen for selection change events
							dom.bind(doc, 'mouseup', endSelection);
							dom.bind(doc, 'mousemove', selectionChange);
	
							dom.getRoot().focus();
							startRng.select();
						}
					}
				});
			}
	
			/**
			 * Fixes selection issues where the caret can be placed between two inline elements like <b>a</b>|<b>b</b>
			 * this fix will lean the caret right into the closest inline element.
			 */
			function normalizeSelection() {
				// Normalize selection for example <b>a</b><i>|a</i> becomes <b>a|</b><i>a</i> except for Ctrl+A since it selects everything
				editor.on('keyup focusin mouseup', function(e) {
					if (e.keyCode != 65 || !VK.metaKeyPressed(e)) {
						selection.normalize();
					}
				}, true);
			}
	
			/**
			 * Forces Gecko to render a broken image icon if it fails to load an image.
			 */
			function showBrokenImageIcon() {
				editor.contentStyles.push(
					'img:-moz-broken {' +
						'-moz-force-broken-image-icon:1;' +
						'min-width:24px;' +
						'min-height:24px' +
					'}'
				);
			}
	
			/**
			 * iOS has a bug where it's impossible to type if the document has a touchstart event
			 * bound and the user touches the document while having the on screen keyboard visible.
			 *
			 * The touch event moves the focus to the parent document while having the caret inside the iframe
			 * this fix moves the focus back into the iframe document.
			 */
			function restoreFocusOnKeyDown() {
				if (!editor.inline) {
					editor.on('keydown', function() {
						if (document.activeElement == document.body) {
							editor.getWin().focus();
						}
					});
				}
			}
	
			/**
			 * IE 11 has an annoying issue where you can't move focus into the editor
			 * by clicking on the white area HTML element. We used to be able to to fix this with
			 * the fixCaretSelectionOfDocumentElementOnIe fix. But since M$ removed the selection
			 * object it's not possible anymore. So we need to hack in a ungly CSS to force the
			 * body to be at least 150px. If the user clicks the HTML element out side this 150px region
			 * we simply move the focus into the first paragraph. Not ideal since you loose the
			 * positioning of the caret but goot enough for most cases.
			 */
			function bodyHeight() {
				if (!editor.inline) {
					editor.contentStyles.push('body {min-height: 150px}');
					editor.on('click', function(e) {
						var rng;
	
						if (e.target.nodeName == 'HTML') {
							// Edge seems to only need focus if we set the range
							// the caret will become invisible and moved out of the iframe!!
							if (Env.ie > 11) {
								editor.getBody().focus();
								return;
							}
	
							// Need to store away non collapsed ranges since the focus call will mess that up see #7382
							rng = editor.selection.getRng();
							editor.getBody().focus();
							editor.selection.setRng(rng);
							editor.selection.normalize();
							editor.nodeChanged();
						}
					});
				}
			}
	
			/**
			 * Firefox on Mac OS will move the browser back to the previous page if you press CMD+Left arrow.
			 * You might then loose all your work so we need to block that behavior and replace it with our own.
			 */
			function blockCmdArrowNavigation() {
				if (Env.mac) {
					editor.on('keydown', function(e) {
						if (VK.metaKeyPressed(e) && !e.shiftKey && (e.keyCode == 37 || e.keyCode == 39)) {
							e.preventDefault();
							editor.selection.getSel().modify('move', e.keyCode == 37 ? 'backward' : 'forward', 'lineboundary');
						}
					});
				}
			}
	
			/**
			 * Disables the autolinking in IE 9+ this is then re-enabled by the autolink plugin.
			 */
			function disableAutoUrlDetect() {
				setEditorCommandState("AutoUrlDetect", false);
			}
	
			/**
			 * iOS 7.1 introduced two new bugs:
			 * 1) It's possible to open links within a contentEditable area by clicking on them.
			 * 2) If you hold down the finger it will display the link/image touch callout menu.
			 */
			function tapLinksAndImages() {
				editor.on('click', function(e) {
					var elm = e.target;
	
					do {
						if (elm.tagName === 'A') {
							e.preventDefault();
							return;
						}
					} while ((elm = elm.parentNode));
				});
	
				editor.contentStyles.push('.mce-content-body {-webkit-touch-callout: none}');
			}
	
			/**
			 * iOS Safari and possible other browsers have a bug where it won't fire
			 * a click event when a contentEditable is focused. This function fakes click events
			 * by using touchstart/touchend and measuring the time and distance travelled.
			 */
			/*
			function touchClickEvent() {
				editor.on('touchstart', function(e) {
					var elm, time, startTouch, changedTouches;
	
					elm = e.target;
					time = new Date().getTime();
					changedTouches = e.changedTouches;
	
					if (!changedTouches || changedTouches.length > 1) {
						return;
					}
	
					startTouch = changedTouches[0];
	
					editor.once('touchend', function(e) {
						var endTouch = e.changedTouches[0], args;
	
						if (new Date().getTime() - time > 500) {
							return;
						}
	
						if (Math.abs(startTouch.clientX - endTouch.clientX) > 5) {
							return;
						}
	
						if (Math.abs(startTouch.clientY - endTouch.clientY) > 5) {
							return;
						}
	
						args = {
							target: elm
						};
	
						each('pageX pageY clientX clientY screenX screenY'.split(' '), function(key) {
							args[key] = endTouch[key];
						});
	
						args = editor.fire('click', args);
	
						if (!args.isDefaultPrevented()) {
							// iOS WebKit can't place the caret properly once
							// you bind touch events so we need to do this manually
							// TODO: Expand to the closest word? Touble tap still works.
							editor.selection.placeCaretAt(endTouch.clientX, endTouch.clientY);
							editor.nodeChanged();
						}
					});
				});
			}
			*/
	
			/**
			 * WebKit has a bug where it will allow forms to be submitted if they are inside a contentEditable element.
			 * For example this: <form><button></form>
			 */
			function blockFormSubmitInsideEditor() {
				editor.on('init', function() {
					editor.dom.bind(editor.getBody(), 'submit', function(e) {
						e.preventDefault();
					});
				});
			}
	
			/**
			 * Sometimes WebKit/Blink generates BR elements with the Apple-interchange-newline class.
			 *
			 * Scenario:
			 *  1) Create a table 2x2.
			 *  2) Select and copy cells A2-B2.
			 *  3) Paste and it will add BR element to table cell.
			 */
			function removeAppleInterchangeBrs() {
				parser.addNodeFilter('br', function(nodes) {
					var i = nodes.length;
	
					while (i--) {
						if (nodes[i].attr('class') == 'Apple-interchange-newline') {
							nodes[i].remove();
						}
					}
				});
			}
	
			/**
			 * IE cannot set custom contentType's on drag events, and also does not properly drag/drop between
			 * editors. This uses a special data:text/mce-internal URL to pass data when drag/drop between editors.
			 */
			function ieInternalDragAndDrop() {
				editor.on('dragstart', function(e) {
					setMceInternalContent(e);
				});
	
				editor.on('drop', function(e) {
					if (!isDefaultPrevented(e)) {
						var internalContent = getMceInternalContent(e);
	
						if (internalContent && internalContent.id != editor.id) {
							e.preventDefault();
	
							var rng = RangeUtils.getCaretRangeFromPoint(e.x, e.y, editor.getDoc());
							selection.setRng(rng);
							insertClipboardContents(internalContent.html);
						}
					}
				});
			}
	
			function refreshContentEditable() {
				var body, parent;
	
				// Check if the editor was hidden and the re-initialize contentEditable mode by removing and adding the body again
				if (isHidden()) {
					body = editor.getBody();
					parent = body.parentNode;
	
					parent.removeChild(body);
					parent.appendChild(body);
	
					body.focus();
				}
			}
	
			function isHidden() {
				var sel;
	
				if (!isGecko) {
					return 0;
				}
	
				// Weird, wheres that cursor selection?
				sel = editor.selection.getSel();
				return (!sel || !sel.rangeCount || sel.rangeCount === 0);
			}
	
			// All browsers
			removeBlockQuoteOnBackSpace();
			emptyEditorWhenDeleting();
	
			// Windows phone will return a range like [body, 0] on mousedown so
			// it will always normalize to the wrong location
			if (!Env.windowsPhone) {
				normalizeSelection();
			}
	
			// WebKit
			if (isWebKit) {
				cleanupStylesWhenDeleting();
				inputMethodFocus();
				selectControlElements();
				setDefaultBlockType();
				blockFormSubmitInsideEditor();
				disableBackspaceIntoATable();
				removeAppleInterchangeBrs();
				//touchClickEvent();
	
				// iOS
				if (Env.iOS) {
					restoreFocusOnKeyDown();
					bodyHeight();
					tapLinksAndImages();
				} else {
					selectAll();
				}
			}
	
			// IE
			if (isIE && Env.ie < 11) {
				removeHrOnBackspace();
				ensureBodyHasRoleApplication();
				addNewLinesBeforeBrInPre();
				removePreSerializedStylesWhenSelectingControls();
				deleteControlItemOnBackSpace();
				renderEmptyBlocksFix();
				keepNoScriptContents();
				fixCaretSelectionOfDocumentElementOnIe();
			}
	
			if (Env.ie >= 11) {
				bodyHeight();
				disableBackspaceIntoATable();
			}
	
			if (Env.ie) {
				selectAll();
				disableAutoUrlDetect();
				ieInternalDragAndDrop();
			}
	
			// Gecko
			if (isGecko) {
				removeHrOnBackspace();
				focusBody();
				removeStylesWhenDeletingAcrossBlockElements();
				setGeckoEditingOptions();
				addBrAfterLastLinks();
				showBrokenImageIcon();
				blockCmdArrowNavigation();
				disableBackspaceIntoATable();
			}
	
			return {
				refreshContentEditable: refreshContentEditable,
				isHidden: isHidden
			};
		};
	});
	
	// Included from: js/tinymce/classes/EditorObservable.js
	
	/**
	 * EditorObservable.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * This mixin contains the event logic for the tinymce.Editor class.
	 *
	 * @mixin tinymce.EditorObservable
	 * @extends tinymce.util.Observable
	 */
	define("tinymce/EditorObservable", [
		"tinymce/util/Observable",
		"tinymce/dom/DOMUtils",
		"tinymce/util/Tools"
	], function(Observable, DOMUtils, Tools) {
		var DOM = DOMUtils.DOM, customEventRootDelegates;
	
		/**
		 * Returns the event target so for the specified event. Some events fire
		 * only on document, some fire on documentElement etc. This also handles the
		 * custom event root setting where it returns that element instead of the body.
		 *
		 * @private
		 * @param {tinymce.Editor} editor Editor instance to get event target from.
		 * @param {String} eventName Name of the event for example "click".
		 * @return {Element/Document} HTML Element or document target to bind on.
		 */
		function getEventTarget(editor, eventName) {
			if (eventName == 'selectionchange') {
				return editor.getDoc();
			}
	
			// Need to bind mousedown/mouseup etc to document not body in iframe mode
			// Since the user might click on the HTML element not the BODY
			if (!editor.inline && /^mouse|click|contextmenu|drop|dragover|dragend/.test(eventName)) {
				return editor.getDoc().documentElement;
			}
	
			// Bind to event root instead of body if it's defined
			if (editor.settings.event_root) {
				if (!editor.eventRoot) {
					editor.eventRoot = DOM.select(editor.settings.event_root)[0];
				}
	
				return editor.eventRoot;
			}
	
			return editor.getBody();
		}
	
		/**
		 * Binds a event delegate for the specified name this delegate will fire
		 * the event to the editor dispatcher.
		 *
		 * @private
		 * @param {tinymce.Editor} editor Editor instance to get event target from.
		 * @param {String} eventName Name of the event for example "click".
		 */
		function bindEventDelegate(editor, eventName) {
			var eventRootElm = getEventTarget(editor, eventName), delegate;
	
			function isListening(editor) {
				return !editor.hidden && !editor.readonly;
			}
	
			if (!editor.delegates) {
				editor.delegates = {};
			}
	
			if (editor.delegates[eventName]) {
				return;
			}
	
			if (editor.settings.event_root) {
				if (!customEventRootDelegates) {
					customEventRootDelegates = {};
					editor.editorManager.on('removeEditor', function() {
						var name;
	
						if (!editor.editorManager.activeEditor) {
							if (customEventRootDelegates) {
								for (name in customEventRootDelegates) {
									editor.dom.unbind(getEventTarget(editor, name));
								}
	
								customEventRootDelegates = null;
							}
						}
					});
				}
	
				if (customEventRootDelegates[eventName]) {
					return;
				}
	
				delegate = function(e) {
					var target = e.target, editors = editor.editorManager.editors, i = editors.length;
	
					while (i--) {
						var body = editors[i].getBody();
	
						if (body === target || DOM.isChildOf(target, body)) {
							if (isListening(editors[i])) {
								editors[i].fire(eventName, e);
							}
						}
					}
				};
	
				customEventRootDelegates[eventName] = delegate;
				DOM.bind(eventRootElm, eventName, delegate);
			} else {
				delegate = function(e) {
					if (isListening(editor)) {
						editor.fire(eventName, e);
					}
				};
	
				DOM.bind(eventRootElm, eventName, delegate);
				editor.delegates[eventName] = delegate;
			}
		}
	
		var EditorObservable = {
			/**
			 * Bind any pending event delegates. This gets executed after the target body/document is created.
			 *
			 * @private
			 */
			bindPendingEventDelegates: function() {
				var self = this;
	
				Tools.each(self._pendingNativeEvents, function(name) {
					bindEventDelegate(self, name);
				});
			},
	
			/**
			 * Toggles a native event on/off this is called by the EventDispatcher when
			 * the first native event handler is added and when the last native event handler is removed.
			 *
			 * @private
			 */
			toggleNativeEvent: function(name, state) {
				var self = this;
	
				// Never bind focus/blur since the FocusManager fakes those
				if (name == "focus" || name == "blur") {
					return;
				}
	
				if (state) {
					if (self.initialized) {
						bindEventDelegate(self, name);
					} else {
						if (!self._pendingNativeEvents) {
							self._pendingNativeEvents = [name];
						} else {
							self._pendingNativeEvents.push(name);
						}
					}
				} else if (self.initialized) {
					self.dom.unbind(getEventTarget(self, name), name, self.delegates[name]);
					delete self.delegates[name];
				}
			},
	
			/**
			 * Unbinds all native event handlers that means delegates, custom events bound using the Events API etc.
			 *
			 * @private
			 */
			unbindAllNativeEvents: function() {
				var self = this, name;
	
				if (self.delegates) {
					for (name in self.delegates) {
						self.dom.unbind(getEventTarget(self, name), name, self.delegates[name]);
					}
	
					delete self.delegates;
				}
	
				if (!self.inline) {
					self.getBody().onload = null;
					self.dom.unbind(self.getWin());
					self.dom.unbind(self.getDoc());
				}
	
				self.dom.unbind(self.getBody());
				self.dom.unbind(self.getContainer());
			}
		};
	
		EditorObservable = Tools.extend({}, Observable, EditorObservable);
	
		return EditorObservable;
	});
	
	// Included from: js/tinymce/classes/Mode.js
	
	/**
	 * Mode.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * Mode switcher logic.
	 *
	 * @private
	 * @class tinymce.Mode
	 */
	define("tinymce/Mode", [], function() {
		function setEditorCommandState(editor, cmd, state) {
			try {
				editor.getDoc().execCommand(cmd, false, state);
			} catch (ex) {
				// Ignore
			}
		}
	
		function clickBlocker(editor) {
			var target, handler;
	
			target = editor.getBody();
	
			handler = function(e) {
				if (editor.dom.getParents(e.target, 'a').length > 0) {
					e.preventDefault();
				}
			};
	
			editor.dom.bind(target, 'click', handler);
	
			return {
				unbind: function() {
					editor.dom.unbind(target, 'click', handler);
				}
			};
		}
	
		function toggleReadOnly(editor, state) {
			if (editor._clickBlocker) {
				editor._clickBlocker.unbind();
				editor._clickBlocker = null;
			}
	
			if (state) {
				editor._clickBlocker = clickBlocker(editor);
				editor.selection.controlSelection.hideResizeRect();
				editor.readonly = true;
				editor.getBody().contentEditable = false;
			} else {
				editor.readonly = false;
				editor.getBody().contentEditable = true;
				setEditorCommandState(editor, "StyleWithCSS", false);
				setEditorCommandState(editor, "enableInlineTableEditing", false);
				setEditorCommandState(editor, "enableObjectResizing", false);
				editor.focus();
				editor.nodeChanged();
			}
		}
	
		function setMode(editor, mode) {
			var currentMode = editor.readonly ? 'readonly' : 'design';
	
			if (mode == currentMode) {
				return;
			}
	
			if (editor.initialized) {
				toggleReadOnly(editor, mode == 'readonly');
			} else {
				editor.on('init', function() {
					toggleReadOnly(editor, mode == 'readonly');
				});
			}
	
			// Event is NOT preventable
			editor.fire('SwitchMode', {mode: mode});
		}
	
		return {
			setMode: setMode
		};
	});
	
	// Included from: js/tinymce/classes/Shortcuts.js
	
	/**
	 * Shortcuts.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * Contains all logic for handling of keyboard shortcuts.
	 *
	 * @class tinymce.Shortcuts
	 * @example
	 * editor.shortcuts.add('ctrl+a', function() {});
	 * editor.shortcuts.add('meta+a', function() {}); // "meta" maps to Command on Mac and Ctrl on PC
	 * editor.shortcuts.add('ctrl+alt+a', function() {});
	 * editor.shortcuts.add('access+a', function() {}); // "access" maps to ctrl+alt on Mac and shift+alt on PC
	 */
	define("tinymce/Shortcuts", [
		"tinymce/util/Tools",
		"tinymce/Env"
	], function(Tools, Env) {
		var each = Tools.each, explode = Tools.explode;
	
		var keyCodeLookup = {
			"f9": 120,
			"f10": 121,
			"f11": 122
		};
	
		var modifierNames = Tools.makeMap('alt,ctrl,shift,meta,access');
	
		return function(editor) {
			var self = this, shortcuts = {}, pendingPatterns = [];
	
			function parseShortcut(pattern) {
				var id, key, shortcut = {};
	
				// Parse modifiers and keys ctrl+alt+b for example
				each(explode(pattern, '+'), function(value) {
					if (value in modifierNames) {
						shortcut[value] = true;
					} else {
						// Allow numeric keycodes like ctrl+219 for ctrl+[
						if (/^[0-9]{2,}$/.test(value)) {
							shortcut.keyCode = parseInt(value, 10);
						} else {
							shortcut.charCode = value.charCodeAt(0);
							shortcut.keyCode = keyCodeLookup[value] || value.toUpperCase().charCodeAt(0);
						}
					}
				});
	
				// Generate unique id for modifier combination and set default state for unused modifiers
				id = [shortcut.keyCode];
				for (key in modifierNames) {
					if (shortcut[key]) {
						id.push(key);
					} else {
						shortcut[key] = false;
					}
				}
				shortcut.id = id.join(',');
	
				// Handle special access modifier differently depending on Mac/Win
				if (shortcut.access) {
					shortcut.alt = true;
	
					if (Env.mac) {
						shortcut.ctrl = true;
					} else {
						shortcut.shift = true;
					}
				}
	
				// Handle special meta modifier differently depending on Mac/Win
				if (shortcut.meta) {
					if (Env.mac) {
						shortcut.meta = true;
					} else {
						shortcut.ctrl = true;
						shortcut.meta = false;
					}
				}
	
				return shortcut;
			}
	
			function createShortcut(pattern, desc, cmdFunc, scope) {
				var shortcuts;
	
				shortcuts = Tools.map(explode(pattern, '>'), parseShortcut);
				shortcuts[shortcuts.length - 1] = Tools.extend(shortcuts[shortcuts.length - 1], {
					func: cmdFunc,
					scope: scope || editor
				});
	
				return Tools.extend(shortcuts[0], {
					desc: editor.translate(desc),
					subpatterns: shortcuts.slice(1)
				});
			}
	
			function hasModifier(e) {
				return e.altKey || e.ctrlKey || e.metaKey;
			}
	
			function isFunctionKey(e) {
				return e.keyCode >= 112 && e.keyCode <= 123;
			}
	
			function matchShortcut(e, shortcut) {
				if (!shortcut) {
					return false;
				}
	
				if (shortcut.ctrl != e.ctrlKey || shortcut.meta != e.metaKey) {
					return false;
				}
	
				if (shortcut.alt != e.altKey || shortcut.shift != e.shiftKey) {
					return false;
				}
	
				if (e.keyCode == shortcut.keyCode || (e.charCode && e.charCode == shortcut.charCode)) {
					e.preventDefault();
					return true;
				}
	
				return false;
			}
	
			function executeShortcutAction(shortcut) {
				return shortcut.func ? shortcut.func.call(shortcut.scope) : null;
			}
	
			editor.on('keyup keypress keydown', function(e) {
				if ((hasModifier(e) || isFunctionKey(e)) && !e.isDefaultPrevented()) {
					each(shortcuts, function(shortcut) {
						if (matchShortcut(e, shortcut)) {
							pendingPatterns = shortcut.subpatterns.slice(0);
	
							if (e.type == "keydown") {
								executeShortcutAction(shortcut);
							}
	
							return true;
						}
					});
	
					if (matchShortcut(e, pendingPatterns[0])) {
						if (pendingPatterns.length === 1) {
							if (e.type == "keydown") {
								executeShortcutAction(pendingPatterns[0]);
							}
						}
	
						pendingPatterns.shift();
					}
				}
			});
	
			/**
			 * Adds a keyboard shortcut for some command or function.
			 *
			 * @method addShortcut
			 * @param {String} pattern Shortcut pattern. Like for example: ctrl+alt+o.
			 * @param {String} desc Text description for the command.
			 * @param {String/Function} cmdFunc Command name string or function to execute when the key is pressed.
			 * @param {Object} scope Optional scope to execute the function in.
			 * @return {Boolean} true/false state if the shortcut was added or not.
			 */
			self.add = function(pattern, desc, cmdFunc, scope) {
				var cmd;
	
				cmd = cmdFunc;
	
				if (typeof cmdFunc === 'string') {
					cmdFunc = function() {
						editor.execCommand(cmd, false, null);
					};
				} else if (Tools.isArray(cmd)) {
					cmdFunc = function() {
						editor.execCommand(cmd[0], cmd[1], cmd[2]);
					};
				}
	
				each(explode(Tools.trim(pattern.toLowerCase())), function(pattern) {
					var shortcut = createShortcut(pattern, desc, cmdFunc, scope);
					shortcuts[shortcut.id] = shortcut;
				});
	
				return true;
			};
	
			/**
			 * Remove a keyboard shortcut by pattern.
			 *
			 * @method remove
			 * @param {String} pattern Shortcut pattern. Like for example: ctrl+alt+o.
			 * @return {Boolean} true/false state if the shortcut was removed or not.
			 */
			self.remove = function(pattern) {
				var shortcut = createShortcut(pattern);
	
				if (shortcuts[shortcut.id]) {
					delete shortcuts[shortcut.id];
					return true;
				}
	
				return false;
			};
		};
	});
	
	// Included from: js/tinymce/classes/file/Uploader.js
	
	/**
	 * Uploader.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * Upload blobs or blob infos to the specified URL or handler.
	 *
	 * @private
	 * @class tinymce.file.Uploader
	 * @example
	 * var uploader = new Uploader({
	 *     url: '/upload.php',
	 *     basePath: '/base/path',
	 *     credentials: true,
	 *     handler: function(data, success, failure) {
	 *         ...
	 *     }
	 * });
	 *
	 * uploader.upload(blobInfos).then(function(result) {
	 *     ...
	 * });
	 */
	define("tinymce/file/Uploader", [
		"tinymce/util/Promise",
		"tinymce/util/Tools",
		"tinymce/util/Fun"
	], function(Promise, Tools, Fun) {
		return function(uploadStatus, settings) {
			var pendingPromises = {};
	
			function fileName(blobInfo) {
				var ext, extensions;
	
				extensions = {
					'image/jpeg': 'jpg',
					'image/jpg': 'jpg',
					'image/gif': 'gif',
					'image/png': 'png'
				};
	
				ext = extensions[blobInfo.blob().type.toLowerCase()] || 'dat';
	
				return blobInfo.id() + '.' + ext;
			}
	
			function pathJoin(path1, path2) {
				if (path1) {
					return path1.replace(/\/$/, '') + '/' + path2.replace(/^\//, '');
				}
	
				return path2;
			}
	
			function blobInfoToData(blobInfo) {
				return {
					id: blobInfo.id,
					blob: blobInfo.blob,
					base64: blobInfo.base64,
					filename: Fun.constant(fileName(blobInfo))
				};
			}
	
			function defaultHandler(blobInfo, success, failure, progress) {
				var xhr, formData;
	
				xhr = new XMLHttpRequest();
				xhr.open('POST', settings.url);
				xhr.withCredentials = settings.credentials;
	
				xhr.upload.onprogress = function(e) {
					progress(e.loaded / e.total * 100);
				};
	
				xhr.onerror = function() {
					failure("Image upload failed due to a XHR Transport error. Code: " + xhr.status);
				};
	
				xhr.onload = function() {
					var json;
	
					if (xhr.status != 200) {
						failure("HTTP Error: " + xhr.status);
						return;
					}
	
					json = JSON.parse(xhr.responseText);
	
					if (!json || typeof json.location != "string") {
						failure("Invalid JSON: " + xhr.responseText);
						return;
					}
	
					success(pathJoin(settings.basePath, json.location));
				};
	
				formData = new FormData();
				formData.append('file', blobInfo.blob(), fileName(blobInfo));
	
				xhr.send(formData);
			}
	
			function noUpload() {
				return new Promise(function(resolve) {
					resolve([]);
				});
			}
	
			function handlerSuccess(blobInfo, url) {
				return {
					url: url,
					blobInfo: blobInfo,
					status: true
				};
			}
	
			function handlerFailure(blobInfo, error) {
				return {
					url: '',
					blobInfo: blobInfo,
					status: false,
					error: error
				};
			}
	
			function resolvePending(blobUri, result) {
				Tools.each(pendingPromises[blobUri], function(resolve) {
					resolve(result);
				});
	
				delete pendingPromises[blobUri];
			}
	
			function uploadBlobInfo(blobInfo, handler, openNotification) {
				uploadStatus.markPending(blobInfo.blobUri());
	
				return new Promise(function(resolve) {
					var notification, progress;
	
					var noop = function() {
					};
	
					try {
						var closeNotification = function() {
							if (notification) {
								notification.close();
								progress = noop; // Once it's closed it's closed
							}
						};
	
						var success = function(url) {
							closeNotification();
							uploadStatus.markUploaded(blobInfo.blobUri(), url);
							resolvePending(blobInfo.blobUri(), handlerSuccess(blobInfo, url));
							resolve(handlerSuccess(blobInfo, url));
						};
	
						var failure = function() {
							closeNotification();
							uploadStatus.removeFailed(blobInfo.blobUri());
							resolvePending(blobInfo.blobUri(), handlerFailure(blobInfo, failure));
							resolve(handlerFailure(blobInfo, failure));
						};
	
						progress = function(percent) {
							if (percent < 0 || percent > 100) {
								return;
							}
	
							if (!notification) {
								notification = openNotification();
							}
	
							notification.progressBar.value(percent);
						};
	
						handler(blobInfoToData(blobInfo), success, failure, progress);
					} catch (ex) {
						resolve(handlerFailure(blobInfo, ex.message));
					}
				});
			}
	
			function isDefaultHandler(handler) {
				return handler === defaultHandler;
			}
	
			function pendingUploadBlobInfo(blobInfo) {
				var blobUri = blobInfo.blobUri();
	
				return new Promise(function(resolve) {
					pendingPromises[blobUri] = pendingPromises[blobUri] || [];
					pendingPromises[blobUri].push(resolve);
				});
			}
	
			function uploadBlobs(blobInfos, openNotification) {
				blobInfos = Tools.grep(blobInfos, function(blobInfo) {
					return !uploadStatus.isUploaded(blobInfo.blobUri());
				});
	
				return Promise.all(Tools.map(blobInfos, function(blobInfo) {
					return uploadStatus.isPending(blobInfo.blobUri()) ?
						pendingUploadBlobInfo(blobInfo) : uploadBlobInfo(blobInfo, settings.handler, openNotification);
				}));
			}
	
			function upload(blobInfos, openNotification) {
				return (!settings.url && isDefaultHandler(settings.handler)) ? noUpload() : uploadBlobs(blobInfos, openNotification);
			}
	
			settings = Tools.extend({
				credentials: false,
				// We are adding a notify argument to this (at the moment, until it doesn't work)
				handler: defaultHandler
			}, settings);
	
			return {
				upload: upload
			};
		};
	});
	
	// Included from: js/tinymce/classes/file/Conversions.js
	
	/**
	 * Conversions.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * Converts blob/uris back and forth.
	 *
	 * @private
	 * @class tinymce.file.Conversions
	 */
	define("tinymce/file/Conversions", [
		"tinymce/util/Promise"
	], function(Promise) {
		function blobUriToBlob(url) {
			return new Promise(function(resolve) {
				var xhr = new XMLHttpRequest();
	
				xhr.open('GET', url, true);
				xhr.responseType = 'blob';
	
				xhr.onload = function() {
					if (this.status == 200) {
						resolve(this.response);
					}
				};
	
				xhr.send();
			});
		}
	
		function parseDataUri(uri) {
			var type, matches;
	
			uri = decodeURIComponent(uri).split(',');
	
			matches = /data:([^;]+)/.exec(uri[0]);
			if (matches) {
				type = matches[1];
			}
	
			return {
				type: type,
				data: uri[1]
			};
		}
	
		function dataUriToBlob(uri) {
			return new Promise(function(resolve) {
				var str, arr, i;
	
				uri = parseDataUri(uri);
	
				// Might throw error if data isn't proper base64
				try {
					str = atob(uri.data);
				} catch (e) {
					resolve(new Blob([]));
					return;
				}
	
				arr = new Uint8Array(str.length);
	
				for (i = 0; i < arr.length; i++) {
					arr[i] = str.charCodeAt(i);
				}
	
				resolve(new Blob([arr], {type: uri.type}));
			});
		}
	
		function uriToBlob(url) {
			if (url.indexOf('blob:') === 0) {
				return blobUriToBlob(url);
			}
	
			if (url.indexOf('data:') === 0) {
				return dataUriToBlob(url);
			}
	
			return null;
		}
	
		function blobToDataUri(blob) {
			return new Promise(function(resolve) {
				var reader = new FileReader();
	
				reader.onloadend = function() {
					resolve(reader.result);
				};
	
				reader.readAsDataURL(blob);
			});
		}
	
		return {
			uriToBlob: uriToBlob,
			blobToDataUri: blobToDataUri,
			parseDataUri: parseDataUri
		};
	});
	
	// Included from: js/tinymce/classes/file/ImageScanner.js
	
	/**
	 * ImageScanner.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * Finds images with data uris or blob uris. If data uris are found it will convert them into blob uris.
	 *
	 * @private
	 * @class tinymce.file.ImageScanner
	 */
	define("tinymce/file/ImageScanner", [
		"tinymce/util/Promise",
		"tinymce/util/Arr",
		"tinymce/util/Fun",
		"tinymce/file/Conversions",
		"tinymce/Env"
	], function(Promise, Arr, Fun, Conversions, Env) {
		var count = 0;
	
		return function(uploadStatus, blobCache) {
			var cachedPromises = {};
	
			function findAll(elm, predicate) {
				var images, promises;
	
				function imageToBlobInfo(img, resolve) {
					var base64, blobInfo;
	
					if (img.src.indexOf('blob:') === 0) {
						blobInfo = blobCache.getByUri(img.src);
	
						if (blobInfo) {
							resolve({
								image: img,
								blobInfo: blobInfo
							});
						}
	
						return;
					}
	
					base64 = Conversions.parseDataUri(img.src).data;
					blobInfo = blobCache.findFirst(function(cachedBlobInfo) {
						return cachedBlobInfo.base64() === base64;
					});
	
					if (blobInfo) {
						resolve({
							image: img,
							blobInfo: blobInfo
						});
					} else {
						Conversions.uriToBlob(img.src).then(function(blob) {
							var blobInfoId = 'blobid' + (count++),
								blobInfo = blobCache.create(blobInfoId, blob, base64);
	
							blobCache.add(blobInfo);
	
							resolve({
								image: img,
								blobInfo: blobInfo
							});
						});
					}
				}
	
				if (!predicate) {
					predicate = Fun.constant(true);
				}
	
				images = Arr.filter(elm.getElementsByTagName('img'), function(img) {
					var src = img.src;
	
					if (!Env.fileApi) {
						return false;
					}
	
					if (img.hasAttribute('data-mce-bogus')) {
						return false;
					}
	
					if (img.hasAttribute('data-mce-placeholder')) {
						return false;
					}
	
					if (!src || src == Env.transparentSrc) {
						return false;
					}
	
					if (src.indexOf('blob:') === 0) {
						return !uploadStatus.isUploaded(src);
					}
	
					if (src.indexOf('data:') === 0) {
						return predicate(img);
					}
	
					return false;
				});
	
				promises = Arr.map(images, function(img) {
					var newPromise;
	
					if (cachedPromises[img.src]) {
						// Since the cached promise will return the cached image
						// We need to wrap it and resolve with the actual image
						return new Promise(function(resolve) {
							cachedPromises[img.src].then(function(imageInfo) {
								resolve({
									image: img,
									blobInfo: imageInfo.blobInfo
								});
							});
						});
					}
	
					newPromise = new Promise(function(resolve) {
						imageToBlobInfo(img, resolve);
					}).then(function(result) {
						delete cachedPromises[result.image.src];
						return result;
					})['catch'](function(error) {
						delete cachedPromises[img.src];
						return error;
					});
	
					cachedPromises[img.src] = newPromise;
	
					return newPromise;
				});
	
				return Promise.all(promises);
			}
	
			return {
				findAll: findAll
			};
		};
	});
	
	// Included from: js/tinymce/classes/file/BlobCache.js
	
	/**
	 * BlobCache.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * Hold blob info objects where a blob has extra internal information.
	 *
	 * @private
	 * @class tinymce.file.BlobCache
	 */
	define("tinymce/file/BlobCache", [
		"tinymce/util/Arr",
		"tinymce/util/Fun"
	], function(Arr, Fun) {
		return function() {
			var cache = [], constant = Fun.constant;
	
			function create(id, blob, base64) {
				return {
					id: constant(id),
					blob: constant(blob),
					base64: constant(base64),
					blobUri: constant(URL.createObjectURL(blob))
				};
			}
	
			function add(blobInfo) {
				if (!get(blobInfo.id())) {
					cache.push(blobInfo);
				}
			}
	
			function get(id) {
				return findFirst(function(cachedBlobInfo) {
					return cachedBlobInfo.id() === id;
				});
			}
	
			function findFirst(predicate) {
				return Arr.filter(cache, predicate)[0];
			}
	
			function getByUri(blobUri) {
				return findFirst(function(blobInfo) {
					return blobInfo.blobUri() == blobUri;
				});
			}
	
			function removeByUri(blobUri) {
				cache = Arr.filter(cache, function(blobInfo) {
					if (blobInfo.blobUri() === blobUri) {
						URL.revokeObjectURL(blobInfo.blobUri());
						return false;
					}
	
					return true;
				});
			}
	
			function destroy() {
				Arr.each(cache, function(cachedBlobInfo) {
					URL.revokeObjectURL(cachedBlobInfo.blobUri());
				});
	
				cache = [];
			}
	
			return {
				create: create,
				add: add,
				get: get,
				getByUri: getByUri,
				findFirst: findFirst,
				removeByUri: removeByUri,
				destroy: destroy
			};
		};
	});
	
	// Included from: js/tinymce/classes/file/UploadStatus.js
	
	/**
	 * UploadStatus.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2016 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * Holds the current status of a blob uri, if it's pending or uploaded and what the result urls was.
	 *
	 * @private
	 * @class tinymce.file.UploadStatus
	 */
	define("tinymce/file/UploadStatus", [
	], function() {
		return function() {
			var PENDING = 1, UPLOADED = 2;
			var blobUriStatuses = {};
	
			function createStatus(status, resultUri) {
				return {
					status: status,
					resultUri: resultUri
				};
			}
	
			function hasBlobUri(blobUri) {
				return blobUri in blobUriStatuses;
			}
	
			function getResultUri(blobUri) {
				var result = blobUriStatuses[blobUri];
	
				return result ? result.resultUri : null;
			}
	
			function isPending(blobUri) {
				return hasBlobUri(blobUri) ? blobUriStatuses[blobUri].status === PENDING : false;
			}
	
			function isUploaded(blobUri) {
				return hasBlobUri(blobUri) ? blobUriStatuses[blobUri].status === UPLOADED : false;
			}
	
			function markPending(blobUri) {
				blobUriStatuses[blobUri] = createStatus(PENDING, null);
			}
	
			function markUploaded(blobUri, resultUri) {
				blobUriStatuses[blobUri] = createStatus(UPLOADED, resultUri);
			}
	
			function removeFailed(blobUri) {
				delete blobUriStatuses[blobUri];
			}
	
			function destroy() {
				blobUriStatuses = {};
			}
	
			return {
				hasBlobUri: hasBlobUri,
				getResultUri: getResultUri,
				isPending: isPending,
				isUploaded: isUploaded,
				markPending: markPending,
				markUploaded: markUploaded,
				removeFailed: removeFailed,
				destroy: destroy
			};
		};
	});
	
	// Included from: js/tinymce/classes/EditorUpload.js
	
	/**
	 * EditorUpload.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * Handles image uploads, updates undo stack and patches over various internal functions.
	 *
	 * @private
	 * @class tinymce.EditorUpload
	 */
	define("tinymce/EditorUpload", [
		"tinymce/util/Arr",
		"tinymce/file/Uploader",
		"tinymce/file/ImageScanner",
		"tinymce/file/BlobCache",
		"tinymce/file/UploadStatus"
	], function(Arr, Uploader, ImageScanner, BlobCache, UploadStatus) {
		return function(editor) {
			var blobCache = new BlobCache(), uploader, imageScanner, settings = editor.settings;
			var uploadStatus = new UploadStatus();
	
			function aliveGuard(callback) {
				return function(result) {
					if (editor.selection) {
						return callback(result);
					}
	
					return [];
				};
			}
	
			// Replaces strings without regexps to avoid FF regexp to big issue
			function replaceString(content, search, replace) {
				var index = 0;
	
				do {
					index = content.indexOf(search, index);
	
					if (index !== -1) {
						content = content.substring(0, index) + replace + content.substr(index + search.length);
						index += replace.length - search.length + 1;
					}
				} while (index !== -1);
	
				return content;
			}
	
			function replaceImageUrl(content, targetUrl, replacementUrl) {
				content = replaceString(content, 'src="' + targetUrl + '"', 'src="' + replacementUrl + '"');
				content = replaceString(content, 'data-mce-src="' + targetUrl + '"', 'data-mce-src="' + replacementUrl + '"');
	
				return content;
			}
	
			function replaceUrlInUndoStack(targetUrl, replacementUrl) {
				Arr.each(editor.undoManager.data, function(level) {
					level.content = replaceImageUrl(level.content, targetUrl, replacementUrl);
				});
			}
	
			function openNotification() {
				return editor.notificationManager.open({
					text: editor.translate('Image uploading...'),
					type: 'info',
					timeout: -1,
					progressBar: true
				});
			}
	
			function replaceImageUri(image, resultUri) {
				blobCache.removeByUri(image.src);
				replaceUrlInUndoStack(image.src, resultUri);
	
				editor.$(image).attr({
					src: resultUri,
					'data-mce-src': editor.convertURL(resultUri, 'src')
				});
			}
	
			function uploadImages(callback) {
				if (!uploader) {
					uploader = new Uploader(uploadStatus, {
						url: settings.images_upload_url,
						basePath: settings.images_upload_base_path,
						credentials: settings.images_upload_credentials,
						handler: settings.images_upload_handler
					});
				}
	
				return scanForImages().then(aliveGuard(function(imageInfos) {
					var blobInfos;
	
					blobInfos = Arr.map(imageInfos, function(imageInfo) {
						return imageInfo.blobInfo;
					});
	
					return uploader.upload(blobInfos, openNotification).then(aliveGuard(function(result) {
						result = Arr.map(result, function(uploadInfo, index) {
							var image = imageInfos[index].image;
	
							if (uploadInfo.status && editor.settings.images_replace_blob_uris !== false) {
								replaceImageUri(image, uploadInfo.url);
							}
	
							return {
								element: image,
								status: uploadInfo.status
							};
						});
	
						if (callback) {
							callback(result);
						}
	
						return result;
					}));
				}));
			}
	
			function uploadImagesAuto(callback) {
				if (settings.automatic_uploads !== false) {
					return uploadImages(callback);
				}
			}
	
			function isValidDataUriImage(imgElm) {
				return settings.images_dataimg_filter ? settings.images_dataimg_filter(imgElm) : true;
			}
	
			function scanForImages() {
				if (!imageScanner) {
					imageScanner = new ImageScanner(uploadStatus, blobCache);
				}
	
				return imageScanner.findAll(editor.getBody(), isValidDataUriImage).then(aliveGuard(function(result) {
					Arr.each(result, function(resultItem) {
						replaceUrlInUndoStack(resultItem.image.src, resultItem.blobInfo.blobUri());
						resultItem.image.src = resultItem.blobInfo.blobUri();
						resultItem.image.removeAttribute('data-mce-src');
					});
	
					return result;
				}));
			}
	
			function destroy() {
				blobCache.destroy();
				uploadStatus.destroy();
				imageScanner = uploader = null;
			}
	
			function replaceBlobUris(content) {
				return content.replace(/src="(blob:[^"]+)"/g, function(match, blobUri) {
					var resultUri = uploadStatus.getResultUri(blobUri);
	
					if (resultUri) {
						return 'src="' + resultUri + '"';
					}
	
					var blobInfo = blobCache.getByUri(blobUri);
	
					if (!blobInfo) {
						blobInfo = Arr.reduce(editor.editorManager.editors, function(result, editor) {
							return result || editor.editorUpload.blobCache.getByUri(blobUri);
						}, null);
					}
	
					if (blobInfo) {
						return 'src="data:' + blobInfo.blob().type + ';base64,' + blobInfo.base64() + '"';
					}
	
					return match;
				});
			}
	
			editor.on('setContent', function() {
				if (editor.settings.automatic_uploads !== false) {
					uploadImagesAuto();
				} else {
					scanForImages();
				}
			});
	
			editor.on('RawSaveContent', function(e) {
				e.content = replaceBlobUris(e.content);
			});
	
			editor.on('getContent', function(e) {
				if (e.source_view || e.format == 'raw') {
					return;
				}
	
				e.content = replaceBlobUris(e.content);
			});
	
			editor.on('PostRender', function() {
				editor.parser.addNodeFilter('img', function(images) {
					Arr.each(images, function(img) {
						var src = img.attr('src');
	
						if (blobCache.getByUri(src)) {
							return;
						}
	
						var resultUri = uploadStatus.getResultUri(src);
						if (resultUri) {
							img.attr('src', resultUri);
						}
					});
				});
			});
	
			return {
				blobCache: blobCache,
				uploadImages: uploadImages,
				uploadImagesAuto: uploadImagesAuto,
				scanForImages: scanForImages,
				destroy: destroy
			};
		};
	});
	
	// Included from: js/tinymce/classes/caret/FakeCaret.js
	
	/**
	 * FakeCaret.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * This module contains logic for rendering a fake visual caret.
	 *
	 * @private
	 * @class tinymce.caret.FakeCaret
	 */
	define("tinymce/caret/FakeCaret", [
		"tinymce/caret/CaretContainer",
		"tinymce/caret/CaretPosition",
		"tinymce/dom/NodeType",
		"tinymce/dom/RangeUtils",
		"tinymce/dom/DomQuery",
		"tinymce/geom/ClientRect",
		"tinymce/util/Delay"
	], function(CaretContainer, CaretPosition, NodeType, RangeUtils, $, ClientRect, Delay) {
		var isContentEditableFalse = NodeType.isContentEditableFalse;
	
		return function(rootNode, isBlock) {
			var cursorInterval, $lastVisualCaret, caretContainerNode;
	
			function getAbsoluteClientRect(node, before) {
				var clientRect = ClientRect.collapse(node.getBoundingClientRect(), before),
					docElm, scrollX, scrollY, margin, rootRect;
	
				if (rootNode.tagName == 'BODY') {
					docElm = rootNode.ownerDocument.documentElement;
					scrollX = rootNode.scrollLeft || docElm.scrollLeft;
					scrollY = rootNode.scrollTop || docElm.scrollTop;
				} else {
					rootRect = rootNode.getBoundingClientRect();
					scrollX = rootNode.scrollLeft - rootRect.left;
					scrollY = rootNode.scrollTop - rootRect.top;
				}
	
				clientRect.left += scrollX;
				clientRect.right += scrollX;
				clientRect.top += scrollY;
				clientRect.bottom += scrollY;
				clientRect.width = 1;
	
				margin = node.offsetWidth - node.clientWidth;
	
				if (margin > 0) {
					if (before) {
						margin *= -1;
					}
	
					clientRect.left += margin;
					clientRect.right += margin;
				}
	
				return clientRect;
			}
	
			function trimInlineCaretContainers() {
				var contentEditableFalseNodes, node, sibling, i, data;
	
				contentEditableFalseNodes = $('*[contentEditable=false]', rootNode);
				for (i = 0; i < contentEditableFalseNodes.length; i++) {
					node = contentEditableFalseNodes[i];
	
					sibling = node.previousSibling;
					if (CaretContainer.endsWithCaretContainer(sibling)) {
						data = sibling.data;
	
						if (data.length == 1) {
							sibling.parentNode.removeChild(sibling);
						} else {
							sibling.deleteData(data.length - 1, 1);
						}
					}
	
					sibling = node.nextSibling;
					if (CaretContainer.startsWithCaretContainer(sibling)) {
						data = sibling.data;
	
						if (data.length == 1) {
							sibling.parentNode.removeChild(sibling);
						} else {
							sibling.deleteData(0, 1);
						}
					}
				}
	
				return null;
			}
	
			function show(before, node) {
				var clientRect, rng, container;
	
				hide();
	
				if (isBlock(node)) {
					caretContainerNode = CaretContainer.insertBlock('p', node, before);
					clientRect = getAbsoluteClientRect(node, before);
					$(caretContainerNode).css('top', clientRect.top);
	
					$lastVisualCaret = $('<div class="mce-visual-caret" data-mce-bogus="all"></div>').css(clientRect).appendTo(rootNode);
	
					if (before) {
						$lastVisualCaret.addClass('mce-visual-caret-before');
					}
	
					startBlink();
	
					rng = node.ownerDocument.createRange();
					container = caretContainerNode.firstChild;
					rng.setStart(container, 0);
					rng.setEnd(container, 1);
				} else {
					caretContainerNode = CaretContainer.insertInline(node, before);
					rng = node.ownerDocument.createRange();
	
					if (isContentEditableFalse(caretContainerNode.nextSibling)) {
						rng.setStart(caretContainerNode, 0);
						rng.setEnd(caretContainerNode, 0);
					} else {
						rng.setStart(caretContainerNode, 1);
						rng.setEnd(caretContainerNode, 1);
					}
	
					return rng;
				}
	
				return rng;
			}
	
			function hide() {
				trimInlineCaretContainers();
	
				if (caretContainerNode) {
					CaretContainer.remove(caretContainerNode);
					caretContainerNode = null;
				}
	
				if ($lastVisualCaret) {
					$lastVisualCaret.remove();
					$lastVisualCaret = null;
				}
	
				clearInterval(cursorInterval);
			}
	
			function startBlink() {
				cursorInterval = Delay.setInterval(function() {
					$('div.mce-visual-caret', rootNode).toggleClass('mce-visual-caret-hidden');
				}, 500);
			}
	
			function destroy() {
				Delay.clearInterval(cursorInterval);
			}
	
			function getCss() {
				return (
					'.mce-visual-caret {' +
						'position: absolute;' +
						'background-color: black;' +
						'background-color: currentcolor;' +
					'}' +
					'.mce-visual-caret-hidden {' +
						'display: none;' +
					'}' +
					'*[data-mce-caret] {' +
						'position: absolute;' +
						'left: -1000px;' +
						'right: auto;' +
						'top: 0;' +
						'margin: 0;' +
						'padding: 0;' +
					'}'
				);
			}
	
			return {
				show: show,
				hide: hide,
				getCss: getCss,
				destroy: destroy
			};
		};
	});
	
	// Included from: js/tinymce/classes/dom/Dimensions.js
	
	/**
	 * Dimensions.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * This module measures nodes and returns client rects. The client rects has an
	 * extra node property.
	 *
	 * @private
	 * @class tinymce.dom.Dimensions
	 */
	define("tinymce/dom/Dimensions", [
		"tinymce/util/Arr",
		"tinymce/dom/NodeType",
		"tinymce/geom/ClientRect"
	], function(Arr, NodeType, ClientRect) {
	
		function getClientRects(node) {
			function toArrayWithNode(clientRects) {
				return Arr.map(clientRects, function(clientRect) {
					clientRect = ClientRect.clone(clientRect);
					clientRect.node = node;
	
					return clientRect;
				});
			}
	
			if (Arr.isArray(node)) {
				return Arr.reduce(node, function(result, node) {
					return result.concat(getClientRects(node));
				}, []);
			}
	
			if (NodeType.isElement(node)) {
				return toArrayWithNode(node.getClientRects());
			}
	
			if (NodeType.isText(node)) {
				var rng = node.ownerDocument.createRange();
	
				rng.setStart(node, 0);
				rng.setEnd(node, node.data.length);
	
				return toArrayWithNode(rng.getClientRects());
			}
		}
	
		return {
			/**
			 * Returns the client rects for a specific node.
			 *
			 * @method getClientRects
			 * @param {Array/DOMNode} node Node or array of nodes to get client rects on.
			 * @param {Array} Array of client rects with a extra node property.
			 */
			getClientRects: getClientRects
		};
	});
	
	// Included from: js/tinymce/classes/caret/LineWalker.js
	
	/**
	 * LineWalker.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * This module lets you walk the document line by line
	 * returing nodes and client rects for each line.
	 *
	 * @private
	 * @class tinymce.caret.LineWalker
	 */
	define("tinymce/caret/LineWalker", [
		"tinymce/util/Fun",
		"tinymce/util/Arr",
		"tinymce/dom/Dimensions",
		"tinymce/caret/CaretCandidate",
		"tinymce/caret/CaretUtils",
		"tinymce/caret/CaretWalker",
		"tinymce/caret/CaretPosition",
		"tinymce/geom/ClientRect"
	], function(Fun, Arr, Dimensions, CaretCandidate, CaretUtils, CaretWalker, CaretPosition, ClientRect) {
		var curry = Fun.curry;
	
		function findUntil(direction, rootNode, predicateFn, node) {
			while ((node = CaretUtils.findNode(node, direction, CaretCandidate.isEditableCaretCandidate, rootNode))) {
				if (predicateFn(node)) {
					return;
				}
			}
		}
	
		function walkUntil(direction, isAboveFn, isBeflowFn, rootNode, predicateFn, caretPosition) {
			var line = 0, node, result = [], targetClientRect;
	
			function add(node) {
				var i, clientRect, clientRects;
	
				clientRects = Dimensions.getClientRects(node);
				if (direction == -1) {
					clientRects = clientRects.reverse();
				}
	
				for (i = 0; i < clientRects.length; i++) {
					clientRect = clientRects[i];
					if (isBeflowFn(clientRect, targetClientRect)) {
						continue;
					}
	
					if (result.length > 0 && isAboveFn(clientRect, Arr.last(result))) {
						line++;
					}
	
					clientRect.line = line;
	
					if (predicateFn(clientRect)) {
						return true;
					}
	
					result.push(clientRect);
				}
			}
	
			targetClientRect = Arr.last(caretPosition.getClientRects());
			if (!targetClientRect) {
				return result;
			}
	
			node = caretPosition.getNode();
			add(node);
			findUntil(direction, rootNode, add, node);
	
			return result;
		}
	
		function aboveLineNumber(lineNumber, clientRect) {
			return clientRect.line > lineNumber;
		}
	
		function isLine(lineNumber, clientRect) {
			return clientRect.line === lineNumber;
		}
	
		var upUntil = curry(walkUntil, -1, ClientRect.isAbove, ClientRect.isBelow);
		var downUntil = curry(walkUntil, 1, ClientRect.isBelow, ClientRect.isAbove);
	
		function positionsUntil(direction, rootNode, predicateFn, node) {
			var caretWalker = new CaretWalker(rootNode), walkFn, isBelowFn, isAboveFn,
				caretPosition, result = [], line = 0, clientRect, targetClientRect;
	
			function getClientRect(caretPosition) {
				if (direction == 1) {
					return Arr.last(caretPosition.getClientRects());
				}
	
				return Arr.last(caretPosition.getClientRects());
			}
	
			if (direction == 1) {
				walkFn = caretWalker.next;
				isBelowFn = ClientRect.isBelow;
				isAboveFn = ClientRect.isAbove;
				caretPosition = CaretPosition.after(node);
			} else {
				walkFn = caretWalker.prev;
				isBelowFn = ClientRect.isAbove;
				isAboveFn = ClientRect.isBelow;
				caretPosition = CaretPosition.before(node);
			}
	
			targetClientRect = getClientRect(caretPosition);
	
			do {
				if (!caretPosition.isVisible()) {
					continue;
				}
	
				clientRect = getClientRect(caretPosition);
	
				if (isAboveFn(clientRect, targetClientRect)) {
					continue;
				}
	
				if (result.length > 0 && isBelowFn(clientRect, Arr.last(result))) {
					line++;
				}
	
				clientRect = ClientRect.clone(clientRect);
				clientRect.position = caretPosition;
				clientRect.line = line;
	
				if (predicateFn(clientRect)) {
					return result;
				}
	
				result.push(clientRect);
			} while ((caretPosition = walkFn(caretPosition)));
	
			return result;
		}
	
		return {
			upUntil: upUntil,
			downUntil: downUntil,
	
			/**
			 * Find client rects with line and caret position until the predicate returns true.
			 *
			 * @method positionsUntil
			 * @param {Number} direction Direction forward/backward 1/-1.
			 * @param {DOMNode} rootNode Root node to walk within.
			 * @param {function} predicateFn Gets the client rect as it's input.
			 * @param {DOMNode} node Node to start walking from.
			 * @return {Array} Array of client rects with line and position properties.
			 */
			positionsUntil: positionsUntil,
	
			isAboveLine: curry(aboveLineNumber),
			isLine: curry(isLine)
		};
	});
	
	// Included from: js/tinymce/classes/caret/LineUtils.js
	
	/**
	 * LineUtils.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * Utility functions for working with lines.
	 *
	 * @private
	 * @class tinymce.caret.LineUtils
	 */
	define("tinymce/caret/LineUtils", [
		"tinymce/util/Fun",
		"tinymce/util/Arr",
		"tinymce/dom/NodeType",
		"tinymce/dom/Dimensions",
		"tinymce/geom/ClientRect",
		"tinymce/caret/CaretUtils",
		"tinymce/caret/CaretCandidate"
	], function(Fun, Arr, NodeType, Dimensions, ClientRect, CaretUtils, CaretCandidate) {
		var isContentEditableFalse = NodeType.isContentEditableFalse,
			findNode = CaretUtils.findNode,
			curry = Fun.curry;
	
		function distanceToRectLeft(clientRect, clientX) {
			return Math.abs(clientRect.left - clientX);
		}
	
		function distanceToRectRight(clientRect, clientX) {
			return Math.abs(clientRect.right - clientX);
		}
	
		function findClosestClientRect(clientRects, clientX) {
			function isInside(clientX, clientRect) {
				return clientX >= clientRect.left && clientX <= clientRect.right;
			}
	
			return Arr.reduce(clientRects, function(oldClientRect, clientRect) {
				var oldDistance, newDistance;
	
				oldDistance = Math.min(distanceToRectLeft(oldClientRect, clientX), distanceToRectRight(oldClientRect, clientX));
				newDistance = Math.min(distanceToRectLeft(clientRect, clientX), distanceToRectRight(clientRect, clientX));
	
				if (isInside(clientX, clientRect)) {
					return clientRect;
				}
	
				if (isInside(clientX, oldClientRect)) {
					return oldClientRect;
				}
	
				// cE=false has higher priority
				if (newDistance == oldDistance && isContentEditableFalse(clientRect.node)) {
					return clientRect;
				}
	
				if (newDistance < oldDistance) {
					return clientRect;
				}
	
				return oldClientRect;
			});
		}
	
		function walkUntil(direction, rootNode, predicateFn, node) {
			while ((node = findNode(node, direction, CaretCandidate.isEditableCaretCandidate, rootNode))) {
				if (predicateFn(node)) {
					return;
				}
			}
		}
	
		function findLineNodeRects(rootNode, targetNodeRect) {
			var clientRects = [];
	
			function collect(checkPosFn, node) {
				var lineRects;
	
				lineRects = Arr.filter(Dimensions.getClientRects(node), function(clientRect) {
					return !checkPosFn(clientRect, targetNodeRect);
				});
	
				clientRects = clientRects.concat(lineRects);
	
				return lineRects.length === 0;
			}
	
			clientRects.push(targetNodeRect);
			walkUntil(-1, rootNode, curry(collect, ClientRect.isAbove), targetNodeRect.node);
			walkUntil(1, rootNode, curry(collect, ClientRect.isBelow), targetNodeRect.node);
	
			return clientRects;
		}
	
		function getContentEditableFalseChildren(rootNode) {
			return Arr.filter(Arr.toArray(rootNode.getElementsByTagName('*')), isContentEditableFalse);
		}
	
		function caretInfo(clientRect, clientX) {
			return {
				node: clientRect.node,
				before: distanceToRectLeft(clientRect, clientX) < distanceToRectRight(clientRect, clientX)
			};
		}
	
		function closestCaret(rootNode, clientX, clientY) {
			var contentEditableFalseNodeRects, closestNodeRect;
	
			contentEditableFalseNodeRects = Dimensions.getClientRects(getContentEditableFalseChildren(rootNode));
			contentEditableFalseNodeRects = Arr.filter(contentEditableFalseNodeRects, function(clientRect) {
				return clientY >= clientRect.top && clientY <= clientRect.bottom;
			});
	
			closestNodeRect = findClosestClientRect(contentEditableFalseNodeRects, clientX);
			if (closestNodeRect) {
				closestNodeRect = findClosestClientRect(findLineNodeRects(rootNode, closestNodeRect), clientX);
				if (closestNodeRect && isContentEditableFalse(closestNodeRect.node)) {
					return caretInfo(closestNodeRect, clientX);
				}
			}
	
			return null;
		}
	
		return {
			findClosestClientRect: findClosestClientRect,
			findLineNodeRects: findLineNodeRects,
			closestCaret: closestCaret
		};
	});
	
	// Included from: js/tinymce/classes/DragDropOverrides.js
	
	/**
	 * DragDropOverrides.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * This module contains logic overriding the drag/drop logic of the editor.
	 *
	 * @private
	 * @class tinymce.DragDropOverrides
	 */
	define("tinymce/DragDropOverrides", [
		"tinymce/dom/NodeType",
		"tinymce/util/Arr",
		"tinymce/util/Fun"
	], function(
		NodeType,
		Arr,
		Fun
	) {
		var isContentEditableFalse = NodeType.isContentEditableFalse,
			isContentEditableTrue = NodeType.isContentEditableTrue;
	
		function init(editor) {
			var $ = editor.$, rootDocument = document,
				editableDoc = editor.getDoc(),
				dom = editor.dom, state = {};
	
			function isDraggable(elm) {
				return isContentEditableFalse(elm);
			}
	
			function setBodyCursor(cursor) {
				$(editor.getBody()).css('cursor', cursor);
			}
	
			function isValidDropTarget(elm) {
				if (elm == state.element || editor.dom.isChildOf(elm, state.element)) {
					return false;
				}
	
				if (isContentEditableFalse(elm)) {
					return false;
				}
	
				return true;
			}
	
			function move(e) {
				var deltaX, deltaY, pos, viewPort,
					overflowX = 0, overflowY = 0, movement,
					clientX, clientY, rootClientRect;
	
				if (e.button !== 0) {
					return;
				}
	
				deltaX = e.screenX - state.screenX;
				deltaY = e.screenY - state.screenY;
				movement = Math.max(Math.abs(deltaX), Math.abs(deltaY));
	
				if (!state.dragging && movement > 10) {
					state.dragging = true;
					setBodyCursor('default');
	
					state.clone = state.element.cloneNode(true);
	
					pos = dom.getPos(state.element);
					state.relX = state.clientX - pos.x;
					state.relY = state.clientY - pos.y;
					state.width = state.element.offsetWidth;
					state.height = state.element.offsetHeight;
	
					$(state.clone).css({
						width: state.width,
						height: state.height
					}).removeAttr('data-mce-selected');
	
					state.ghost = $('<div>').css({
						position: 'absolute',
						opacity: 0.5,
						overflow: 'hidden',
						width: state.width,
						height: state.height
					}).attr({
						'data-mce-bogus': 'all',
						unselectable: 'on',
						contenteditable: 'false'
					}).addClass('mce-drag-container mce-reset').
						append(state.clone).
						appendTo(editor.getBody())[0];
	
					viewPort = editor.dom.getViewPort(editor.getWin());
					state.maxX = viewPort.w;
					state.maxY = viewPort.h;
				}
	
				if (state.dragging) {
					editor.selection.placeCaretAt(e.clientX, e.clientY);
	
					clientX = state.clientX + deltaX - state.relX;
					clientY = state.clientY + deltaY + 5;
	
					if (clientX + state.width > state.maxX) {
						overflowX = (clientX + state.width) - state.maxX;
					}
	
					if (clientY + state.height > state.maxY) {
						overflowY = (clientY + state.height) - state.maxY;
					}
	
					if (editor.getBody().nodeName != 'BODY') {
						rootClientRect = editor.getBody().getBoundingClientRect();
					} else {
						rootClientRect = {left: 0, top: 0};
					}
	
					$(state.ghost).css({
						left: clientX - rootClientRect.left,
						top: clientY - rootClientRect.top,
						width: state.width - overflowX,
						height: state.height - overflowY
					});
				}
			}
	
			function drop() {
				var evt;
	
				if (state.dragging) {
					// Hack for IE since it doesn't sync W3C Range with IE Specific range
					editor.selection.setRng(editor.selection.getSel().getRangeAt(0));
	
					if (isValidDropTarget(editor.selection.getNode())) {
						var targetClone = state.element;
	
						evt = editor.fire('drop', {targetClone: targetClone});
						if (evt.isDefaultPrevented()) {
							return;
						}
	
						targetClone = evt.targetClone;
	
						editor.undoManager.transact(function() {
							editor.insertContent(dom.getOuterHTML(targetClone));
							$(state.element).remove();
						});
					}
				}
	
				stop();
			}
	
			function start(e) {
				var ceElm, evt;
	
				stop();
	
				if (e.button !== 0) {
					return;
				}
	
				ceElm = Arr.find(editor.dom.getParents(e.target), Fun.or(isContentEditableFalse, isContentEditableTrue));
	
				if (isDraggable(ceElm)) {
					evt = editor.fire('dragstart', {target: ceElm});
					if (evt.isDefaultPrevented()) {
						return;
					}
	
					editor.on('mousemove', move);
					editor.on('mouseup', drop);
	
					if (rootDocument != editableDoc) {
						dom.bind(rootDocument, 'mousemove', move);
						dom.bind(rootDocument, 'mouseup', drop);
					}
	
					state = {
						screenX: e.screenX,
						screenY: e.screenY,
						clientX: e.clientX,
						clientY: e.clientY,
						element: ceElm
					};
				}
			}
	
			function stop() {
				$(state.ghost).remove();
				setBodyCursor(null);
	
				editor.off('mousemove', move);
				editor.off('mouseup', stop);
	
				if (rootDocument != editableDoc) {
					dom.unbind(rootDocument, 'mousemove', move);
					dom.unbind(rootDocument, 'mouseup', stop);
				}
	
				state = {};
			}
	
			editor.on('mousedown', start);
	
			// Blocks drop inside cE=false on IE
			editor.on('drop', function(e) {
				var realTarget = editor.getDoc().elementFromPoint(e.clientX, e.clientY);
	
				if (isContentEditableFalse(realTarget) || isContentEditableFalse(editor.dom.getContentEditableParent(realTarget))) {
					e.preventDefault();
				}
			});
		}
	
		return {
			init: init
		};
	});
	
	// Included from: js/tinymce/classes/SelectionOverrides.js
	
	/**
	 * SelectionOverrides.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * This module contains logic overriding the selection with keyboard/mouse
	 * around contentEditable=false regions.
	 *
	 * @example
	 * // Disable the default cE=false selection
	 * tinymce.activeEditor.on('ShowCaret BeforeObjectSelected', function(e) {
	 *     e.preventDefault();
	 * });
	 *
	 * @private
	 * @class tinymce.SelectionOverrides
	 */
	define("tinymce/SelectionOverrides", [
		"tinymce/Env",
		"tinymce/caret/CaretWalker",
		"tinymce/caret/CaretPosition",
		"tinymce/caret/CaretContainer",
		"tinymce/caret/CaretUtils",
		"tinymce/caret/FakeCaret",
		"tinymce/caret/LineWalker",
		"tinymce/caret/LineUtils",
		"tinymce/dom/NodeType",
		"tinymce/dom/RangeUtils",
		"tinymce/geom/ClientRect",
		"tinymce/util/VK",
		"tinymce/util/Fun",
		"tinymce/util/Arr",
		"tinymce/util/Delay",
		"tinymce/DragDropOverrides",
		"tinymce/text/Zwsp"
	], function(
		Env, CaretWalker, CaretPosition, CaretContainer, CaretUtils, FakeCaret, LineWalker,
		LineUtils, NodeType, RangeUtils, ClientRect, VK, Fun, Arr, Delay, DragDropOverrides, Zwsp
	) {
		var curry = Fun.curry,
			isContentEditableTrue = NodeType.isContentEditableTrue,
			isContentEditableFalse = NodeType.isContentEditableFalse,
			isElement = NodeType.isElement,
			isAfterContentEditableFalse = CaretUtils.isAfterContentEditableFalse,
			isBeforeContentEditableFalse = CaretUtils.isBeforeContentEditableFalse,
			getSelectedNode = RangeUtils.getSelectedNode;
	
		function getVisualCaretPosition(walkFn, caretPosition) {
			while ((caretPosition = walkFn(caretPosition))) {
				if (caretPosition.isVisible()) {
					return caretPosition;
				}
			}
	
			return caretPosition;
		}
	
		function SelectionOverrides(editor) {
			var rootNode = editor.getBody(), caretWalker = new CaretWalker(rootNode);
			var getNextVisualCaretPosition = curry(getVisualCaretPosition, caretWalker.next);
			var getPrevVisualCaretPosition = curry(getVisualCaretPosition, caretWalker.prev),
				fakeCaret = new FakeCaret(editor.getBody(), isBlock),
				realSelectionId = 'sel-' + editor.dom.uniqueId(),
				selectedContentEditableNode, $ = editor.$;
	
			function isBlock(node) {
				return editor.dom.isBlock(node);
			}
	
			function setRange(range) {
				//console.log('setRange', range);
				if (range) {
					editor.selection.setRng(range);
				}
			}
	
			function getRange() {
				return editor.selection.getRng();
			}
	
			function scrollIntoView(node, alignToTop) {
				editor.selection.scrollIntoView(node, alignToTop);
			}
	
			function showCaret(direction, node, before) {
				var e;
	
				e = editor.fire('ShowCaret', {
					target: node,
					direction: direction,
					before: before
				});
	
				if (e.isDefaultPrevented()) {
					return null;
				}
	
				scrollIntoView(node, direction === -1);
	
				return fakeCaret.show(before, node);
			}
	
			function selectNode(node) {
				var e;
	
				fakeCaret.hide();
	
				e = editor.fire('BeforeObjectSelected', {target: node});
				if (e.isDefaultPrevented()) {
					return null;
				}
	
				return getNodeRange(node);
			}
	
			function getNodeRange(node) {
				var rng = node.ownerDocument.createRange();
	
				rng.selectNode(node);
	
				return rng;
			}
	
			function isMoveInsideSameBlock(fromCaretPosition, toCaretPosition) {
				var inSameBlock = CaretUtils.isInSameBlock(fromCaretPosition, toCaretPosition);
	
				// Handle bogus BR <p>abc|<br></p>
				if (!inSameBlock && NodeType.isBr(fromCaretPosition.getNode())) {
					return true;
				}
	
				return inSameBlock;
			}
	
			function getNormalizedRangeEndPoint(direction, range) {
				range = CaretUtils.normalizeRange(direction, rootNode, range);
	
				if (direction == -1) {
					return CaretPosition.fromRangeStart(range);
				}
	
				return CaretPosition.fromRangeEnd(range);
			}
	
			function isRangeInCaretContainerBlock(range) {
				return CaretContainer.isCaretContainerBlock(range.startContainer);
			}
	
			function moveToCeFalseHorizontally(direction, getNextPosFn, isBeforeContentEditableFalseFn, range) {
				var node, caretPosition, peekCaretPosition, rangeIsInContainerBlock;
	
				if (!range.collapsed) {
					node = getSelectedNode(range);
					if (isContentEditableFalse(node)) {
						return showCaret(direction, node, direction == -1);
					}
				}
	
				rangeIsInContainerBlock = isRangeInCaretContainerBlock(range);
				caretPosition = getNormalizedRangeEndPoint(direction, range);
	
				if (isBeforeContentEditableFalseFn(caretPosition)) {
					return selectNode(caretPosition.getNode(direction == -1));
				}
	
				caretPosition = getNextPosFn(caretPosition);
				if (!caretPosition) {
					if (rangeIsInContainerBlock) {
						return range;
					}
	
					return null;
				}
	
				if (isBeforeContentEditableFalseFn(caretPosition)) {
					return showCaret(direction, caretPosition.getNode(direction == -1), direction == 1);
				}
	
				// Peek ahead for handling of ab|c<span cE=false> -> abc|<span cE=false>
				peekCaretPosition = getNextPosFn(caretPosition);
				if (isBeforeContentEditableFalseFn(peekCaretPosition)) {
					if (isMoveInsideSameBlock(caretPosition, peekCaretPosition)) {
						return showCaret(direction, peekCaretPosition.getNode(direction == -1), direction == 1);
					}
				}
	
				if (rangeIsInContainerBlock) {
					return renderRangeCaret(caretPosition.toRange());
				}
	
				return null;
			}
	
			function moveToCeFalseVertically(direction, walkerFn, range) {
				var caretPosition, linePositions, nextLinePositions,
					closestNextLineRect, caretClientRect, clientX,
					dist1, dist2, contentEditableFalseNode;
	
				contentEditableFalseNode = getSelectedNode(range);
				caretPosition = getNormalizedRangeEndPoint(direction, range);
				linePositions = walkerFn(rootNode, LineWalker.isAboveLine(1), caretPosition);
				nextLinePositions = Arr.filter(linePositions, LineWalker.isLine(1));
				caretClientRect = Arr.last(caretPosition.getClientRects());
	
				if (isBeforeContentEditableFalse(caretPosition)) {
					contentEditableFalseNode = caretPosition.getNode();
				}
	
				if (isAfterContentEditableFalse(caretPosition)) {
					contentEditableFalseNode = caretPosition.getNode(true);
				}
	
				if (!caretClientRect) {
					return null;
				}
	
				clientX = caretClientRect.left;
	
				closestNextLineRect = LineUtils.findClosestClientRect(nextLinePositions, clientX);
				if (closestNextLineRect) {
					if (isContentEditableFalse(closestNextLineRect.node)) {
						dist1 = Math.abs(clientX - closestNextLineRect.left);
						dist2 = Math.abs(clientX - closestNextLineRect.right);
	
						return showCaret(direction, closestNextLineRect.node, dist1 < dist2);
					}
				}
	
				if (contentEditableFalseNode) {
					var caretPositions = LineWalker.positionsUntil(direction, rootNode, LineWalker.isAboveLine(1), contentEditableFalseNode);
	
					closestNextLineRect = LineUtils.findClosestClientRect(Arr.filter(caretPositions, LineWalker.isLine(1)), clientX);
					if (closestNextLineRect) {
						return renderRangeCaret(closestNextLineRect.position.toRange());
					}
	
					closestNextLineRect = Arr.last(Arr.filter(caretPositions, LineWalker.isLine(0)));
					if (closestNextLineRect) {
						return renderRangeCaret(closestNextLineRect.position.toRange());
					}
				}
			}
	
			function exitPreBlock(direction, range) {
				var pre, caretPos, newBlock;
	
				function createTextBlock() {
					var textBlock = editor.dom.create(editor.settings.forced_root_block);
	
					if (!Env.ie || Env.ie >= 11) {
						textBlock.innerHTML = '<br data-mce-bogus="1">';
					}
	
					return textBlock;
				}
	
				if (range.collapsed && editor.settings.forced_root_block) {
					pre = editor.dom.getParent(range.startContainer, 'PRE');
					if (!pre) {
						return;
					}
	
					if (direction == 1) {
						caretPos = getNextVisualCaretPosition(CaretPosition.fromRangeStart(range));
					} else {
						caretPos = getPrevVisualCaretPosition(CaretPosition.fromRangeStart(range));
					}
	
					if (!caretPos) {
						newBlock = createTextBlock();
	
						if (direction == 1) {
							editor.$(pre).after(newBlock);
						} else {
							editor.$(pre).before(newBlock);
						}
	
						editor.selection.select(newBlock, true);
						editor.selection.collapse();
					}
				}
			}
	
			function moveH(direction, getNextPosFn, isBeforeContentEditableFalseFn, range) {
				var newRange;
	
				newRange = moveToCeFalseHorizontally(direction, getNextPosFn, isBeforeContentEditableFalseFn, range);
				if (newRange) {
					return newRange;
				}
	
				newRange = exitPreBlock(direction, range);
				if (newRange) {
					return newRange;
				}
	
				return null;
			}
	
			function moveV(direction, walkerFn, range) {
				var newRange;
	
				newRange = moveToCeFalseVertically(direction, walkerFn, range);
				if (newRange) {
					return newRange;
				}
	
				newRange = exitPreBlock(direction, range);
				if (newRange) {
					return newRange;
				}
	
				return null;
			}
	
			function getBlockCaretContainer() {
				return $('*[data-mce-caret]')[0];
			}
	
			function showBlockCaretContainer(blockCaretContainer) {
				blockCaretContainer = $(blockCaretContainer);
	
				if (blockCaretContainer.attr('data-mce-caret')) {
					fakeCaret.hide();
					blockCaretContainer.removeAttr('data-mce-caret');
					blockCaretContainer.removeAttr('data-mce-bogus');
					blockCaretContainer.removeAttr('style');
	
					// Removes control rect on IE
					setRange(getRange());
					scrollIntoView(blockCaretContainer[0]);
				}
			}
	
			function renderCaretAtRange(range) {
				var caretPosition, ceRoot;
	
				range = CaretUtils.normalizeRange(1, rootNode, range);
				caretPosition = CaretPosition.fromRangeStart(range);
	
				if (isContentEditableFalse(caretPosition.getNode())) {
					return showCaret(1, caretPosition.getNode(), !caretPosition.isAtEnd());
				}
	
				if (isContentEditableFalse(caretPosition.getNode(true))) {
					return showCaret(1, caretPosition.getNode(true), false);
				}
	
				// TODO: Should render caret before/after depending on where you click on the page forces after now
				ceRoot = editor.dom.getParent(caretPosition.getNode(), Fun.or(isContentEditableFalse, isContentEditableTrue));
				if (isContentEditableFalse(ceRoot)) {
					return showCaret(1, ceRoot, false);
				}
	
				fakeCaret.hide();
	
				return null;
			}
	
			function renderRangeCaret(range) {
				var caretRange;
	
				if (!range || !range.collapsed) {
					return range;
				}
	
				caretRange = renderCaretAtRange(range);
				if (caretRange) {
					return caretRange;
				}
	
				return range;
			}
	
			function deleteContentEditableNode(node) {
				var nextCaretPosition, prevCaretPosition, prevCeFalseElm, nextElement;
	
				if (!isContentEditableFalse(node)) {
					return null;
				}
	
				if (isContentEditableFalse(node.previousSibling)) {
					prevCeFalseElm = node.previousSibling;
				}
	
				prevCaretPosition = getPrevVisualCaretPosition(CaretPosition.before(node));
				if (!prevCaretPosition) {
					nextCaretPosition = getNextVisualCaretPosition(CaretPosition.after(node));
				}
	
				if (nextCaretPosition && isElement(nextCaretPosition.getNode())) {
					nextElement = nextCaretPosition.getNode();
				}
	
				CaretContainer.remove(node.previousSibling);
				CaretContainer.remove(node.nextSibling);
				editor.dom.remove(node);
				clearContentEditableSelection();
	
				if (editor.dom.isEmpty(editor.getBody())) {
					editor.setContent('');
					editor.focus();
					return;
				}
	
				if (prevCeFalseElm) {
					return CaretPosition.after(prevCeFalseElm).toRange();
				}
	
				if (nextElement) {
					return CaretPosition.before(nextElement).toRange();
				}
	
				if (prevCaretPosition) {
					return prevCaretPosition.toRange();
				}
	
				if (nextCaretPosition) {
					return nextCaretPosition.toRange();
				}
	
				return null;
			}
	
			function mergeTextBlocks(direction, fromCaretPosition, toCaretPosition) {
				var dom = editor.dom, fromBlock, toBlock, node, textBlocks;
	
				if (direction === -1) {
					if (isAfterContentEditableFalse(toCaretPosition) && isBlock(toCaretPosition.getNode(true))) {
						return deleteContentEditableNode(toCaretPosition.getNode(true));
					}
				} else {
					if (isBeforeContentEditableFalse(fromCaretPosition) && isBlock(fromCaretPosition.getNode())) {
						return deleteContentEditableNode(fromCaretPosition.getNode());
					}
				}
	
				textBlocks = editor.schema.getTextBlockElements();
				fromBlock = dom.getParent(fromCaretPosition.getNode(), dom.isBlock);
				toBlock = dom.getParent(toCaretPosition.getNode(), dom.isBlock);
	
				// Verify that both blocks are text blocks
				if (fromBlock === toBlock || !textBlocks[fromBlock.nodeName] || !textBlocks[toBlock.nodeName]) {
					return null;
				}
	
				while ((node = fromBlock.firstChild)) {
					toBlock.appendChild(node);
				}
	
				editor.dom.remove(fromBlock);
	
				return toCaretPosition.toRange();
			}
	
			function backspaceDelete(direction, beforeFn, range) {
				var node, caretPosition, peekCaretPosition;
	
				if (!range.collapsed) {
					node = getSelectedNode(range);
					if (isContentEditableFalse(node)) {
						return renderRangeCaret(deleteContentEditableNode(node));
					}
				}
	
				caretPosition = getNormalizedRangeEndPoint(direction, range);
	
				if (beforeFn(caretPosition)) {
					return renderRangeCaret(deleteContentEditableNode(caretPosition.getNode(direction == -1)));
				}
	
				peekCaretPosition = direction == -1 ? caretWalker.prev(caretPosition) : caretWalker.next(caretPosition);
				if (beforeFn(peekCaretPosition)) {
					if (direction === -1) {
						return mergeTextBlocks(direction, caretPosition, peekCaretPosition);
					}
	
					return mergeTextBlocks(direction, peekCaretPosition, caretPosition);
				}
			}
	
			function registerEvents() {
				var right = curry(moveH, 1, getNextVisualCaretPosition, isBeforeContentEditableFalse);
				var left = curry(moveH, -1, getPrevVisualCaretPosition, isAfterContentEditableFalse);
				var deleteForward = curry(backspaceDelete, 1, isBeforeContentEditableFalse);
				var backspace = curry(backspaceDelete, -1, isAfterContentEditableFalse);
				var up = curry(moveV, -1, LineWalker.upUntil);
				var down = curry(moveV, 1, LineWalker.downUntil);
	
				function override(evt, moveFn) {
					var range = moveFn(getRange());
	
					if (range && !evt.isDefaultPrevented()) {
						evt.preventDefault();
						setRange(range);
					}
				}
	
				function getContentEditableRoot(node) {
					var root = editor.getBody();
	
					while (node && node != root) {
						if (isContentEditableTrue(node) || isContentEditableFalse(node)) {
							return node;
						}
	
						node = node.parentNode;
					}
	
					return null;
				}
	
				function isXYWithinRange(clientX, clientY, range) {
					if (range.collapsed) {
						return false;
					}
	
					return Arr.reduce(range.getClientRects(), function(state, rect) {
						return state || ClientRect.containsXY(rect, clientX, clientY);
					}, false);
				}
	
				// Some browsers (Chrome) lets you place the caret after a cE=false
				// Make sure we render the caret container in this case
				editor.on('mouseup', function() {
					var range = getRange();
	
					if (range.collapsed) {
						setRange(renderCaretAtRange(range));
					}
				});
	
				editor.on('click', function(e) {
					var contentEditableRoot;
	
					// Prevent clicks on links in a cE=false element
					contentEditableRoot	= getContentEditableRoot(e.target);
					if (contentEditableRoot) {
						if (isContentEditableFalse(contentEditableRoot)) {
							e.preventDefault();
						}
					}
				});
	
				var hasNormalCaretPosition = function (elm) {
					var caretWalker = new CaretWalker(elm);
	
					if (!elm.firstChild) {
						return false;
					}
	
					var startPos = CaretPosition.before(elm.firstChild);
					var newPos = caretWalker.next(startPos);
	
					return newPos && !isBeforeContentEditableFalse(newPos) && !isAfterContentEditableFalse(newPos);
				};
	
				var isInSameBlock = function (node1, node2) {
					var block1 = editor.dom.getParent(node1, editor.dom.isBlock);
					var block2 = editor.dom.getParent(node2, editor.dom.isBlock);
					return block1 === block2;
				};
	
				// Checks if the target node is in a block and if that block has a caret position better than the
				// suggested caretNode this is to prevent the caret from being sucked in towards a cE=false block if
				// they are adjacent on the vertical axis
				var hasBetterMouseTarget = function (targetNode, caretNode) {
					var targetBlock = editor.dom.getParent(targetNode, editor.dom.isBlock);
					var caretBlock = editor.dom.getParent(caretNode, editor.dom.isBlock);
	
					return targetBlock && !isInSameBlock(targetBlock, caretBlock) && hasNormalCaretPosition(targetBlock);
				};
	
				editor.on('mousedown', function(e) {
					var contentEditableRoot;
	
					contentEditableRoot	= getContentEditableRoot(e.target);
					if (contentEditableRoot) {
						if (isContentEditableFalse(contentEditableRoot)) {
							e.preventDefault();
							setContentEditableSelection(selectNode(contentEditableRoot));
						} else {
							clearContentEditableSelection();
	
							if (!isXYWithinRange(e.clientX, e.clientY, editor.selection.getRng())) {
								editor.selection.placeCaretAt(e.clientX, e.clientY);
							}
						}
					} else {
						clearContentEditableSelection();
						fakeCaret.hide();
	
						var caretInfo = LineUtils.closestCaret(rootNode, e.clientX, e.clientY);
						if (caretInfo) {
							if (!hasBetterMouseTarget(e.target, caretInfo.node)) {
								e.preventDefault();
								editor.getBody().focus();
								setRange(showCaret(1, caretInfo.node, caretInfo.before));
							}
						}
					}
				});
	
				editor.on('keydown', function(e) {
					if (VK.modifierPressed(e)) {
						return;
					}
	
					switch (e.keyCode) {
						case VK.RIGHT:
							override(e, right);
							break;
	
						case VK.DOWN:
							override(e, down);
							break;
	
						case VK.LEFT:
							override(e, left);
							break;
	
						case VK.UP:
							override(e, up);
							break;
	
						case VK.DELETE:
							override(e, deleteForward);
							break;
	
						case VK.BACKSPACE:
							override(e, backspace);
							break;
	
						default:
							if (isContentEditableFalse(editor.selection.getNode())) {
								e.preventDefault();
							}
							break;
					}
				});
	
				function paddEmptyContentEditableArea() {
					var br, ceRoot = getContentEditableRoot(editor.selection.getNode());
	
					if (isContentEditableTrue(ceRoot) && isBlock(ceRoot) && editor.dom.isEmpty(ceRoot)) {
						br = editor.dom.create('br', {"data-mce-bogus": "1"});
						editor.$(ceRoot).empty().append(br);
						editor.selection.setRng(CaretPosition.before(br).toRange());
					}
				}
	
				function handleBlockContainer(e) {
					var blockCaretContainer = getBlockCaretContainer();
	
					if (!blockCaretContainer) {
						return;
					}
	
					if (e.type == 'compositionstart') {
						e.preventDefault();
						e.stopPropagation();
						showBlockCaretContainer(blockCaretContainer);
						return;
					}
	
					if (blockCaretContainer.innerHTML != '&nbsp;') {
						showBlockCaretContainer(blockCaretContainer);
					}
				}
	
				function handleEmptyBackspaceDelete(e) {
					var prevent;
	
					switch (e.keyCode) {
						case VK.DELETE:
							prevent = paddEmptyContentEditableArea();
							break;
	
						case VK.BACKSPACE:
							prevent = paddEmptyContentEditableArea();
							break;
					}
	
					if (prevent) {
						e.preventDefault();
					}
				}
	
				// Must be added to "top" since undoManager needs to be executed after
				editor.on('keyup compositionstart', function(e) {
					handleBlockContainer(e);
					handleEmptyBackspaceDelete(e);
				}, true);
	
				editor.on('cut', function() {
					var node = editor.selection.getNode();
	
					if (isContentEditableFalse(node)) {
						Delay.setEditorTimeout(editor, function() {
							setRange(renderRangeCaret(deleteContentEditableNode(node)));
						});
					}
				});
	
				editor.on('getSelectionRange', function(e) {
					var rng = e.range;
	
					if (selectedContentEditableNode) {
						if (!selectedContentEditableNode.parentNode) {
							selectedContentEditableNode = null;
							return;
						}
	
						rng = rng.cloneRange();
						rng.selectNode(selectedContentEditableNode);
						e.range = rng;
					}
				});
	
				editor.on('setSelectionRange', function(e) {
					var rng;
	
					rng = setContentEditableSelection(e.range);
					if (rng) {
						e.range = rng;
					}
				});
	
				editor.on('focus', function() {
					// Make sure we have a proper fake caret on focus
					Delay.setEditorTimeout(editor, function() {
						editor.selection.setRng(renderRangeCaret(editor.selection.getRng()));
					}, 0);
				});
	
				DragDropOverrides.init(editor);
			}
	
			function addCss() {
				var styles = editor.contentStyles, rootClass = '.mce-content-body';
	
				styles.push(fakeCaret.getCss());
				styles.push(
					rootClass + ' .mce-offscreen-selection {' +
						'position: absolute;' +
						'left: -9999999999px;' +
						'width: 100px;' +
						'height: 100px;' +
					'}' +
					rootClass + ' *[contentEditable=false] {' +
						'cursor: default;' +
					'}' +
					rootClass + ' *[contentEditable=true] {' +
						'cursor: text;' +
					'}'
				);
			}
	
			function isRangeInCaretContainer(rng) {
				return CaretContainer.isCaretContainer(rng.startContainer) || CaretContainer.isCaretContainer(rng.endContainer);
			}
	
			function setContentEditableSelection(range) {
				var node, $ = editor.$, dom = editor.dom, $realSelectionContainer, sel,
					startContainer, startOffset, endOffset, e, caretPosition, targetClone, origTargetClone;
	
				if (!range) {
					clearContentEditableSelection();
					return null;
				}
	
				if (range.collapsed) {
					clearContentEditableSelection();
	
					if (!isRangeInCaretContainer(range)) {
						caretPosition = getNormalizedRangeEndPoint(1, range);
	
						if (isContentEditableFalse(caretPosition.getNode())) {
							return showCaret(1, caretPosition.getNode(), !caretPosition.isAtEnd());
						}
	
						if (isContentEditableFalse(caretPosition.getNode(true))) {
							return showCaret(1, caretPosition.getNode(true), false);
						}
					}
	
					return null;
				}
	
				startContainer = range.startContainer;
				startOffset = range.startOffset;
				endOffset = range.endOffset;
	
				// Normalizes <span cE=false>[</span>] to [<span cE=false></span>]
				if (startContainer.nodeType == 3 && startOffset == 0 && isContentEditableFalse(startContainer.parentNode)) {
					startContainer = startContainer.parentNode;
					startOffset = dom.nodeIndex(startContainer);
					startContainer = startContainer.parentNode;
				}
	
				if (startContainer.nodeType != 1) {
					clearContentEditableSelection();
					return null;
				}
	
				if (endOffset == startOffset + 1) {
					node = startContainer.childNodes[startOffset];
				}
	
				if (!isContentEditableFalse(node)) {
					clearContentEditableSelection();
					return null;
				}
	
				targetClone = origTargetClone = node.cloneNode(true);
				e = editor.fire('ObjectSelected', {target: node, targetClone: targetClone});
				if (e.isDefaultPrevented()) {
					clearContentEditableSelection();
					return null;
				}
	
				targetClone = e.targetClone;
				$realSelectionContainer = $('#' + realSelectionId);
				if ($realSelectionContainer.length === 0) {
					$realSelectionContainer = $(
						'<div data-mce-bogus="all" class="mce-offscreen-selection"></div>'
					).attr('id', realSelectionId);
	
					$realSelectionContainer.appendTo(editor.getBody());
				}
	
				range = editor.dom.createRng();
	
				// WHY is IE making things so hard! Copy on <i contentEditable="false">x</i> produces: <em>x</em>
				if (targetClone === origTargetClone && Env.ie) {
					$realSelectionContainer.empty().append(Zwsp.ZWSP).append(targetClone).append(Zwsp.ZWSP);
					range.setStart($realSelectionContainer[0].firstChild, 0);
					range.setEnd($realSelectionContainer[0].lastChild, 1);
				} else {
					$realSelectionContainer.empty().append('\u00a0').append(targetClone).append('\u00a0');
					range.setStart($realSelectionContainer[0].firstChild, 1);
					range.setEnd($realSelectionContainer[0].lastChild, 0);
				}
	
				$realSelectionContainer.css({
					top: dom.getPos(node, editor.getBody()).y
				});
	
				editor.getBody().focus();
				$realSelectionContainer[0].focus();
				sel = editor.selection.getSel();
				sel.removeAllRanges();
				sel.addRange(range);
	
				editor.$('*[data-mce-selected]').removeAttr('data-mce-selected');
				node.setAttribute('data-mce-selected', 1);
				selectedContentEditableNode = node;
	
				return range;
			}
	
			function clearContentEditableSelection() {
				if (selectedContentEditableNode) {
					selectedContentEditableNode.removeAttribute('data-mce-selected');
					editor.$('#' + realSelectionId).remove();
					selectedContentEditableNode = null;
				}
			}
	
			function destroy() {
				fakeCaret.destroy();
				selectedContentEditableNode = null;
			}
	
			if (Env.ceFalse) {
				registerEvents();
				addCss();
			}
	
			return {
				showBlockCaretContainer: showBlockCaretContainer,
				destroy: destroy
			};
		}
	
		return SelectionOverrides;
	});
	
	// Included from: js/tinymce/classes/Editor.js
	
	/**
	 * Editor.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/*jshint scripturl:true */
	
	/**
	 * Include the base event class documentation.
	 *
	 * @include ../../../tools/docs/tinymce.Event.js
	 */
	
	/**
	 * This class contains the core logic for a TinyMCE editor.
	 *
	 * @class tinymce.Editor
	 * @mixes tinymce.util.Observable
	 * @example
	 * // Add a class to all paragraphs in the editor.
	 * tinymce.activeEditor.dom.addClass(tinymce.activeEditor.dom.select('p'), 'someclass');
	 *
	 * // Gets the current editors selection as text
	 * tinymce.activeEditor.selection.getContent({format: 'text'});
	 *
	 * // Creates a new editor instance
	 * var ed = new tinymce.Editor('textareaid', {
	 *     some_setting: 1
	 * }, tinymce.EditorManager);
	 *
	 * // Select each item the user clicks on
	 * ed.on('click', function(e) {
	 *     ed.selection.select(e.target);
	 * });
	 *
	 * ed.render();
	 */
	define("tinymce/Editor", [
		"tinymce/dom/DOMUtils",
		"tinymce/dom/DomQuery",
		"tinymce/AddOnManager",
		"tinymce/NodeChange",
		"tinymce/html/Node",
		"tinymce/dom/Serializer",
		"tinymce/html/Serializer",
		"tinymce/dom/Selection",
		"tinymce/Formatter",
		"tinymce/UndoManager",
		"tinymce/EnterKey",
		"tinymce/ForceBlocks",
		"tinymce/EditorCommands",
		"tinymce/util/URI",
		"tinymce/dom/ScriptLoader",
		"tinymce/dom/EventUtils",
		"tinymce/WindowManager",
		"tinymce/NotificationManager",
		"tinymce/html/Schema",
		"tinymce/html/DomParser",
		"tinymce/util/Quirks",
		"tinymce/Env",
		"tinymce/util/Tools",
		"tinymce/util/Delay",
		"tinymce/EditorObservable",
		"tinymce/Mode",
		"tinymce/Shortcuts",
		"tinymce/EditorUpload",
		"tinymce/SelectionOverrides"
	], function(
		DOMUtils, DomQuery, AddOnManager, NodeChange, Node, DomSerializer, Serializer,
		Selection, Formatter, UndoManager, EnterKey, ForceBlocks, EditorCommands,
		URI, ScriptLoader, EventUtils, WindowManager, NotificationManager,
		Schema, DomParser, Quirks, Env, Tools, Delay, EditorObservable, Mode, Shortcuts, EditorUpload,
		SelectionOverrides
	) {
		// Shorten these names
		var DOM = DOMUtils.DOM, ThemeManager = AddOnManager.ThemeManager, PluginManager = AddOnManager.PluginManager;
		var extend = Tools.extend, each = Tools.each, explode = Tools.explode;
		var inArray = Tools.inArray, trim = Tools.trim, resolve = Tools.resolve;
		var Event = EventUtils.Event;
		var isGecko = Env.gecko, ie = Env.ie;
	
		/**
		 * Include documentation for all the events.
		 *
		 * @include ../../../tools/docs/tinymce.Editor.js
		 */
	
		/**
		 * Constructs a editor instance by id.
		 *
		 * @constructor
		 * @method Editor
		 * @param {String} id Unique id for the editor.
		 * @param {Object} settings Settings for the editor.
		 * @param {tinymce.EditorManager} editorManager EditorManager instance.
		 */
		function Editor(id, settings, editorManager) {
			var self = this, documentBaseUrl, baseUri, defaultSettings;
	
			documentBaseUrl = self.documentBaseUrl = editorManager.documentBaseURL;
			baseUri = editorManager.baseURI;
			defaultSettings = editorManager.defaultSettings;
	
			/**
			 * Name/value collection with editor settings.
			 *
			 * @property settings
			 * @type Object
			 * @example
			 * // Get the value of the theme setting
			 * tinymce.activeEditor.windowManager.alert("You are using the " + tinymce.activeEditor.settings.theme + " theme");
			 */
			settings = extend({
				id: id,
				theme: 'modern',
				delta_width: 0,
				delta_height: 0,
				popup_css: '',
				plugins: '',
				document_base_url: documentBaseUrl,
				add_form_submit_trigger: true,
				submit_patch: true,
				add_unload_trigger: true,
				convert_urls: true,
				relative_urls: true,
				remove_script_host: true,
				object_resizing: true,
				doctype: '<!DOCTYPE html>',
				visual: true,
				font_size_style_values: 'xx-small,x-small,small,medium,large,x-large,xx-large',
	
				// See: http://www.w3.org/TR/CSS2/fonts.html#propdef-font-size
				font_size_legacy_values: 'xx-small,small,medium,large,x-large,xx-large,300%',
				forced_root_block: 'p',
				hidden_input: true,
				padd_empty_editor: true,
				render_ui: true,
				indentation: '30px',
				inline_styles: true,
				convert_fonts_to_spans: true,
				indent: 'simple',
				indent_before: 'p,h1,h2,h3,h4,h5,h6,blockquote,div,title,style,pre,script,td,th,ul,ol,li,dl,dt,dd,area,table,thead,' +
					'tfoot,tbody,tr,section,article,hgroup,aside,figure,figcaption,option,optgroup,datalist',
				indent_after: 'p,h1,h2,h3,h4,h5,h6,blockquote,div,title,style,pre,script,td,th,ul,ol,li,dl,dt,dd,area,table,thead,' +
					'tfoot,tbody,tr,section,article,hgroup,aside,figure,figcaption,option,optgroup,datalist',
				validate: true,
				entity_encoding: 'named',
				url_converter: self.convertURL,
				url_converter_scope: self,
				ie7_compat: true
			}, defaultSettings, settings);
	
			// Merge external_plugins
			if (defaultSettings && defaultSettings.external_plugins && settings.external_plugins) {
				settings.external_plugins = extend({}, defaultSettings.external_plugins, settings.external_plugins);
			}
	
			self.settings = settings;
			AddOnManager.language = settings.language || 'en';
			AddOnManager.languageLoad = settings.language_load;
			AddOnManager.baseURL = editorManager.baseURL;
	
			/**
			 * Editor instance id, normally the same as the div/textarea that was replaced.
			 *
			 * @property id
			 * @type String
			 */
			self.id = settings.id = id;
	
			/**
			 * State to force the editor to return false on a isDirty call.
			 *
			 * @property isNotDirty
			 * @type Boolean
			 * @deprecated Use editor.setDirty instead.
			 */
			self.setDirty(false);
	
			/**
			 * Name/Value object containing plugin instances.
			 *
			 * @property plugins
			 * @type Object
			 * @example
			 * // Execute a method inside a plugin directly
			 * tinymce.activeEditor.plugins.someplugin.someMethod();
			 */
			self.plugins = {};
	
			/**
			 * URI object to document configured for the TinyMCE instance.
			 *
			 * @property documentBaseURI
			 * @type tinymce.util.URI
			 * @example
			 * // Get relative URL from the location of document_base_url
			 * tinymce.activeEditor.documentBaseURI.toRelative('/somedir/somefile.htm');
			 *
			 * // Get absolute URL from the location of document_base_url
			 * tinymce.activeEditor.documentBaseURI.toAbsolute('somefile.htm');
			 */
			self.documentBaseURI = new URI(settings.document_base_url || documentBaseUrl, {
				base_uri: baseUri
			});
	
			/**
			 * URI object to current document that holds the TinyMCE editor instance.
			 *
			 * @property baseURI
			 * @type tinymce.util.URI
			 * @example
			 * // Get relative URL from the location of the API
			 * tinymce.activeEditor.baseURI.toRelative('/somedir/somefile.htm');
			 *
			 * // Get absolute URL from the location of the API
			 * tinymce.activeEditor.baseURI.toAbsolute('somefile.htm');
			 */
			self.baseURI = baseUri;
	
			/**
			 * Array with CSS files to load into the iframe.
			 *
			 * @property contentCSS
			 * @type Array
			 */
			self.contentCSS = [];
	
			/**
			 * Array of CSS styles to add to head of document when the editor loads.
			 *
			 * @property contentStyles
			 * @type Array
			 */
			self.contentStyles = [];
	
			// Creates all events like onClick, onSetContent etc see Editor.Events.js for the actual logic
			self.shortcuts = new Shortcuts(self);
			self.loadedCSS = {};
			self.editorCommands = new EditorCommands(self);
	
			if (settings.target) {
				self.targetElm = settings.target;
			}
	
			self.suffix = editorManager.suffix;
			self.editorManager = editorManager;
			self.inline = settings.inline;
	
			if (settings.cache_suffix) {
				Env.cacheSuffix = settings.cache_suffix.replace(/^[\?\&]+/, '');
			}
	
			if (settings.override_viewport === false) {
				Env.overrideViewPort = false;
			}
	
			// Call setup
			editorManager.fire('SetupEditor', self);
			self.execCallback('setup', self);
	
			/**
			 * Dom query instance with default scope to the editor document and default element is the body of the editor.
			 *
			 * @property $
			 * @type tinymce.dom.DomQuery
			 * @example
			 * tinymce.activeEditor.$('p').css('color', 'red');
			 * tinymce.activeEditor.$().append('<p>new</p>');
			 */
			self.$ = DomQuery.overrideDefaults(function() {
				return {
					context: self.inline ? self.getBody() : self.getDoc(),
					element: self.getBody()
				};
			});
		}
	
		Editor.prototype = {
			/**
			 * Renders the editor/adds it to the page.
			 *
			 * @method render
			 */
			render: function() {
				var self = this, settings = self.settings, id = self.id, suffix = self.suffix;
	
				function readyHandler() {
					DOM.unbind(window, 'ready', readyHandler);
					self.render();
				}
	
				// Page is not loaded yet, wait for it
				if (!Event.domLoaded) {
					DOM.bind(window, 'ready', readyHandler);
					return;
				}
	
				// Element not found, then skip initialization
				if (!self.getElement()) {
					return;
				}
	
				// No editable support old iOS versions etc
				if (!Env.contentEditable) {
					return;
				}
	
				// Hide target element early to prevent content flashing
				if (!settings.inline) {
					self.orgVisibility = self.getElement().style.visibility;
					self.getElement().style.visibility = 'hidden';
				} else {
					self.inline = true;
				}
	
				var form = self.getElement().form || DOM.getParent(id, 'form');
				if (form) {
					self.formElement = form;
	
					// Add hidden input for non input elements inside form elements
					if (settings.hidden_input && !/TEXTAREA|INPUT/i.test(self.getElement().nodeName)) {
						DOM.insertAfter(DOM.create('input', {type: 'hidden', name: id}), id);
						self.hasHiddenInput = true;
					}
	
					// Pass submit/reset from form to editor instance
					self.formEventDelegate = function(e) {
						self.fire(e.type, e);
					};
	
					DOM.bind(form, 'submit reset', self.formEventDelegate);
	
					// Reset contents in editor when the form is reset
					self.on('reset', function() {
						self.setContent(self.startContent, {format: 'raw'});
					});
	
					// Check page uses id="submit" or name="submit" for it's submit button
					if (settings.submit_patch && !form.submit.nodeType && !form.submit.length && !form._mceOldSubmit) {
						form._mceOldSubmit = form.submit;
						form.submit = function() {
							self.editorManager.triggerSave();
							self.setDirty(false);
	
							return form._mceOldSubmit(form);
						};
					}
				}
	
				/**
				 * Window manager reference, use this to open new windows and dialogs.
				 *
				 * @property windowManager
				 * @type tinymce.WindowManager
				 * @example
				 * // Shows an alert message
				 * tinymce.activeEditor.windowManager.alert('Hello world!');
				 *
				 * // Opens a new dialog with the file.htm file and the size 320x240
				 * // It also adds a custom parameter this can be retrieved by using tinyMCEPopup.getWindowArg inside the dialog.
				 * tinymce.activeEditor.windowManager.open({
				 *    url: 'file.htm',
				 *    width: 320,
				 *    height: 240
				 * }, {
				 *    custom_param: 1
				 * });
				 */
				self.windowManager = new WindowManager(self);
	
				/**
				 * Notification manager reference, use this to open new windows and dialogs.
				 *
				 * @property notificationManager
				 * @type tinymce.NotificationManager
				 * @example
				 * // Shows a notification info message.
				 * tinymce.activeEditor.notificationManager.open({text: 'Hello world!', type: 'info'});
				 */
				self.notificationManager = new NotificationManager(self);
	
				if (settings.encoding == 'xml') {
					self.on('GetContent', function(e) {
						if (e.save) {
							e.content = DOM.encode(e.content);
						}
					});
				}
	
				if (settings.add_form_submit_trigger) {
					self.on('submit', function() {
						if (self.initialized) {
							self.save();
						}
					});
				}
	
				if (settings.add_unload_trigger) {
					self._beforeUnload = function() {
						if (self.initialized && !self.destroyed && !self.isHidden()) {
							self.save({format: 'raw', no_events: true, set_dirty: false});
						}
					};
	
					self.editorManager.on('BeforeUnload', self._beforeUnload);
				}
	
				// Load scripts
				function loadScripts() {
					var scriptLoader = ScriptLoader.ScriptLoader;
	
					if (settings.language && settings.language != 'en' && !settings.language_url) {
						settings.language_url = self.editorManager.baseURL + '/langs/' + settings.language + '.js';
					}
	
					if (settings.language_url) {
						scriptLoader.add(settings.language_url);
					}
	
					if (settings.theme && typeof settings.theme != "function" &&
						settings.theme.charAt(0) != '-' && !ThemeManager.urls[settings.theme]) {
						var themeUrl = settings.theme_url;
	
						if (themeUrl) {
							themeUrl = self.documentBaseURI.toAbsolute(themeUrl);
						} else {
							themeUrl = 'themes/' + settings.theme + '/theme' + suffix + '.js';
						}
	
						ThemeManager.load(settings.theme, themeUrl);
					}
	
					if (Tools.isArray(settings.plugins)) {
						settings.plugins = settings.plugins.join(' ');
					}
	
					each(settings.external_plugins, function(url, name) {
						PluginManager.load(name, url);
						settings.plugins += ' ' + name;
					});
	
					each(settings.plugins.split(/[ ,]/), function(plugin) {
						plugin = trim(plugin);
	
						if (plugin && !PluginManager.urls[plugin]) {
							if (plugin.charAt(0) == '-') {
								plugin = plugin.substr(1, plugin.length);
	
								var dependencies = PluginManager.dependencies(plugin);
	
								each(dependencies, function(dep) {
									var defaultSettings = {
										prefix: 'plugins/',
										resource: dep,
										suffix: '/plugin' + suffix + '.js'
									};
	
									dep = PluginManager.createUrl(defaultSettings, dep);
									PluginManager.load(dep.resource, dep);
								});
							} else {
								PluginManager.load(plugin, {
									prefix: 'plugins/',
									resource: plugin,
									suffix: '/plugin' + suffix + '.js'
								});
							}
						}
					});
	
					scriptLoader.loadQueue(function() {
						if (!self.removed) {
							self.init();
						}
					});
				}
	
				self.editorManager.add(self);
				loadScripts();
			},
	
			/**
			 * Initializes the editor this will be called automatically when
			 * all plugins/themes and language packs are loaded by the rendered method.
			 * This method will setup the iframe and create the theme and plugin instances.
			 *
			 * @method init
			 */
			init: function() {
				var self = this, settings = self.settings, elm = self.getElement();
				var w, h, minHeight, n, o, Theme, url, bodyId, bodyClass, re, i, initializedPlugins = [];
	
				this.editorManager.i18n.setCode(settings.language);
				self.rtl = settings.rtl_ui || this.editorManager.i18n.rtl;
	
				settings.aria_label = settings.aria_label || DOM.getAttrib(elm, 'aria-label', self.getLang('aria.rich_text_area'));
	
				/**
				 * Reference to the theme instance that was used to generate the UI.
				 *
				 * @property theme
				 * @type tinymce.Theme
				 * @example
				 * // Executes a method on the theme directly
				 * tinymce.activeEditor.theme.someMethod();
				 */
				if (settings.theme) {
					if (typeof settings.theme != "function") {
						settings.theme = settings.theme.replace(/-/, '');
						Theme = ThemeManager.get(settings.theme);
						self.theme = new Theme(self, ThemeManager.urls[settings.theme]);
	
						if (self.theme.init) {
							self.theme.init(self, ThemeManager.urls[settings.theme] || self.documentBaseUrl.replace(/\/$/, ''), self.$);
						}
					} else {
						self.theme = settings.theme;
					}
				}
	
				function initPlugin(plugin) {
					var Plugin = PluginManager.get(plugin), pluginUrl, pluginInstance;
	
					pluginUrl = PluginManager.urls[plugin] || self.documentBaseUrl.replace(/\/$/, '');
					plugin = trim(plugin);
					if (Plugin && inArray(initializedPlugins, plugin) === -1) {
						each(PluginManager.dependencies(plugin), function(dep) {
							initPlugin(dep);
						});
	
						if (self.plugins[plugin]) {
							return;
						}
	
						pluginInstance = new Plugin(self, pluginUrl, self.$);
	
						self.plugins[plugin] = pluginInstance;
	
						if (pluginInstance.init) {
							pluginInstance.init(self, pluginUrl);
							initializedPlugins.push(plugin);
						}
					}
				}
	
				// Create all plugins
				each(settings.plugins.replace(/\-/g, '').split(/[ ,]/), initPlugin);
	
				// Measure box
				if (settings.render_ui && self.theme) {
					self.orgDisplay = elm.style.display;
	
					if (typeof settings.theme != "function") {
						w = settings.width || elm.style.width || elm.offsetWidth;
						h = settings.height || elm.style.height || elm.offsetHeight;
						minHeight = settings.min_height || 100;
						re = /^[0-9\.]+(|px)$/i;
	
						if (re.test('' + w)) {
							w = Math.max(parseInt(w, 10), 100);
						}
	
						if (re.test('' + h)) {
							h = Math.max(parseInt(h, 10), minHeight);
						}
	
						// Render UI
						o = self.theme.renderUI({
							targetNode: elm,
							width: w,
							height: h,
							deltaWidth: settings.delta_width,
							deltaHeight: settings.delta_height
						});
	
						// Resize editor
						if (!settings.content_editable) {
							h = (o.iframeHeight || h) + (typeof h == 'number' ? (o.deltaHeight || 0) : '');
							if (h < minHeight) {
								h = minHeight;
							}
						}
					} else {
						o = settings.theme(self, elm);
	
						// Convert element type to id:s
						if (o.editorContainer.nodeType) {
							o.editorContainer = o.editorContainer.id = o.editorContainer.id || self.id + "_parent";
						}
	
						// Convert element type to id:s
						if (o.iframeContainer.nodeType) {
							o.iframeContainer = o.iframeContainer.id = o.iframeContainer.id || self.id + "_iframecontainer";
						}
	
						// Use specified iframe height or the targets offsetHeight
						h = o.iframeHeight || elm.offsetHeight;
					}
	
					self.editorContainer = o.editorContainer;
				}
	
				// Load specified content CSS last
				if (settings.content_css) {
					each(explode(settings.content_css), function(u) {
						self.contentCSS.push(self.documentBaseURI.toAbsolute(u));
					});
				}
	
				// Load specified content CSS last
				if (settings.content_style) {
					self.contentStyles.push(settings.content_style);
				}
	
				// Content editable mode ends here
				if (settings.content_editable) {
					elm = n = o = null; // Fix IE leak
					return self.initContentBody();
				}
	
				self.iframeHTML = settings.doctype + '<html><head>';
	
				// We only need to override paths if we have to
				// IE has a bug where it remove site absolute urls to relative ones if this is specified
				if (settings.document_base_url != self.documentBaseUrl) {
					self.iframeHTML += '<base href="' + self.documentBaseURI.getURI() + '" />';
				}
	
				// IE8 doesn't support carets behind images setting ie7_compat would force IE8+ to run in IE7 compat mode.
				if (!Env.caretAfter && settings.ie7_compat) {
					self.iframeHTML += '<meta http-equiv="X-UA-Compatible" content="IE=7" />';
				}
	
				self.iframeHTML += '<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />';
	
				// Load the CSS by injecting them into the HTML this will reduce "flicker"
				// However we can't do that on Chrome since # will scroll to the editor for some odd reason see #2427
				if (!/#$/.test(document.location.href)) {
					for (i = 0; i < self.contentCSS.length; i++) {
						var cssUrl = self.contentCSS[i];
						self.iframeHTML += (
							'<link type="text/css" ' +
								'rel="stylesheet" ' +
								'href="' + Tools._addCacheSuffix(cssUrl) + '" />'
						);
						self.loadedCSS[cssUrl] = true;
					}
				}
	
				bodyId = settings.body_id || 'tinymce';
				if (bodyId.indexOf('=') != -1) {
					bodyId = self.getParam('body_id', '', 'hash');
					bodyId = bodyId[self.id] || bodyId;
				}
	
				bodyClass = settings.body_class || '';
				if (bodyClass.indexOf('=') != -1) {
					bodyClass = self.getParam('body_class', '', 'hash');
					bodyClass = bodyClass[self.id] || '';
				}
	
				if (settings.content_security_policy) {
					self.iframeHTML += '<meta http-equiv="Content-Security-Policy" content="' + settings.content_security_policy + '" />';
				}
	
				self.iframeHTML += '</head><body id="' + bodyId +
					'" class="mce-content-body ' + bodyClass +
					'" data-id="' + self.id + '"><br></body></html>';
	
				/*eslint no-script-url:0 */
				var domainRelaxUrl = 'javascript:(function(){' +
					'document.open();document.domain="' + document.domain + '";' +
					'var ed = window.parent.tinymce.get("' + self.id + '");document.write(ed.iframeHTML);' +
					'document.close();ed.initContentBody(true);})()';
	
				// Domain relaxing is required since the user has messed around with document.domain
				if (document.domain != location.hostname) {
					// Edge seems to be able to handle domain relaxing
					if (Env.ie && Env.ie < 12) {
						url = domainRelaxUrl;
					}
				}
	
				// Create iframe
				// TODO: ACC add the appropriate description on this.
				var ifr = DOM.create('iframe', {
					id: self.id + "_ifr",
					//src: url || 'javascript:""', // Workaround for HTTPS warning in IE6/7
					frameBorder: '0',
					allowTransparency: "true",
					title: self.editorManager.translate(
							"Rich Text Area. Press ALT-F9 for menu. " +
							"Press ALT-F10 for toolbar. Press ALT-0 for help"
					),
					style: {
						width: '100%',
						height: h,
						display: 'block' // Important for Gecko to render the iframe correctly
					}
				});
	
				ifr.onload = function() {
					ifr.onload = null;
					self.fire("load");
				};
	
				DOM.setAttrib(ifr, "src", url || 'javascript:""');
	
				self.contentAreaContainer = o.iframeContainer;
				self.iframeElement = ifr;
	
				n = DOM.add(o.iframeContainer, ifr);
	
				// Try accessing the document this will fail on IE when document.domain is set to the same as location.hostname
				// Then we have to force domain relaxing using the domainRelaxUrl approach very ugly!!
				if (ie) {
					try {
						self.getDoc();
					} catch (e) {
						n.src = url = domainRelaxUrl;
					}
				}
	
				if (o.editorContainer) {
					DOM.get(o.editorContainer).style.display = self.orgDisplay;
					self.hidden = DOM.isHidden(o.editorContainer);
				}
	
				self.getElement().style.display = 'none';
				DOM.setAttrib(self.id, 'aria-hidden', true);
	
				if (!url) {
					self.initContentBody();
				}
	
				elm = n = o = null; // Cleanup
			},
	
			/**
			 * This method get called by the init method once the iframe is loaded.
			 * It will fill the iframe with contents, sets up DOM and selection objects for the iframe.
			 *
			 * @method initContentBody
			 * @private
			 */
			initContentBody: function(skipWrite) {
				var self = this, settings = self.settings, targetElm = self.getElement(), doc = self.getDoc(), body, contentCssText;
	
				// Restore visibility on target element
				if (!settings.inline) {
					self.getElement().style.visibility = self.orgVisibility;
				}
	
				// Setup iframe body
				if (!skipWrite && !settings.content_editable) {
					doc.open();
					doc.write(self.iframeHTML);
					doc.close();
				}
	
				if (settings.content_editable) {
					self.on('remove', function() {
						var bodyEl = this.getBody();
	
						DOM.removeClass(bodyEl, 'mce-content-body');
						DOM.removeClass(bodyEl, 'mce-edit-focus');
						DOM.setAttrib(bodyEl, 'contentEditable', null);
					});
	
					DOM.addClass(targetElm, 'mce-content-body');
					self.contentDocument = doc = settings.content_document || document;
					self.contentWindow = settings.content_window || window;
					self.bodyElement = targetElm;
	
					// Prevent leak in IE
					settings.content_document = settings.content_window = null;
	
					// TODO: Fix this
					settings.root_name = targetElm.nodeName.toLowerCase();
				}
	
				// It will not steal focus while setting contentEditable
				body = self.getBody();
				body.disabled = true;
				self.readonly = settings.readonly;
	
				if (!self.readonly) {
					if (self.inline && DOM.getStyle(body, 'position', true) == 'static') {
						body.style.position = 'relative';
					}
	
					body.contentEditable = self.getParam('content_editable_state', true);
				}
	
				body.disabled = false;
	
				self.editorUpload = new EditorUpload(self);
	
				/**
				 * Schema instance, enables you to validate elements and its children.
				 *
				 * @property schema
				 * @type tinymce.html.Schema
				 */
				self.schema = new Schema(settings);
	
				/**
				 * DOM instance for the editor.
				 *
				 * @property dom
				 * @type tinymce.dom.DOMUtils
				 * @example
				 * // Adds a class to all paragraphs within the editor
				 * tinymce.activeEditor.dom.addClass(tinymce.activeEditor.dom.select('p'), 'someclass');
				 */
				self.dom = new DOMUtils(doc, {
					keep_values: true,
					url_converter: self.convertURL,
					url_converter_scope: self,
					hex_colors: settings.force_hex_style_colors,
					class_filter: settings.class_filter,
					update_styles: true,
					root_element: self.inline ? self.getBody() : null,
					collect: settings.content_editable,
					schema: self.schema,
					onSetAttrib: function(e) {
						self.fire('SetAttrib', e);
					}
				});
	
				/**
				 * HTML parser will be used when contents is inserted into the editor.
				 *
				 * @property parser
				 * @type tinymce.html.DomParser
				 */
				self.parser = new DomParser(settings, self.schema);
	
				// Convert src and href into data-mce-src, data-mce-href and data-mce-style
				self.parser.addAttributeFilter('src,href,style,tabindex', function(nodes, name) {
					var i = nodes.length, node, dom = self.dom, value, internalName;
	
					while (i--) {
						node = nodes[i];
						value = node.attr(name);
						internalName = 'data-mce-' + name;
	
						// Add internal attribute if we need to we don't on a refresh of the document
						if (!node.attributes.map[internalName]) {
							// Don't duplicate these since they won't get modified by any browser
							if (value.indexOf('data:') === 0 || value.indexOf('blob:') === 0) {
								continue;
							}
	
							if (name === "style") {
								value = dom.serializeStyle(dom.parseStyle(value), node.name);
	
								if (!value.length) {
									value = null;
								}
	
								node.attr(internalName, value);
								node.attr(name, value);
							} else if (name === "tabindex") {
								node.attr(internalName, value);
								node.attr(name, null);
							} else {
								node.attr(internalName, self.convertURL(value, name, node.name));
							}
						}
					}
				});
	
				// Keep scripts from executing
				self.parser.addNodeFilter('script', function(nodes) {
					var i = nodes.length, node, type;
	
					while (i--) {
						node = nodes[i];
						type = node.attr('type') || 'no/type';
						if (type.indexOf('mce-') !== 0) {
							node.attr('type', 'mce-' + type);
						}
					}
				});
	
				self.parser.addNodeFilter('#cdata', function(nodes) {
					var i = nodes.length, node;
	
					while (i--) {
						node = nodes[i];
						node.type = 8;
						node.name = '#comment';
						node.value = '[CDATA[' + node.value + ']]';
					}
				});
	
				self.parser.addNodeFilter('p,h1,h2,h3,h4,h5,h6,div', function(nodes) {
					var i = nodes.length, node, nonEmptyElements = self.schema.getNonEmptyElements();
	
					while (i--) {
						node = nodes[i];
	
						if (node.isEmpty(nonEmptyElements)) {
							node.append(new Node('br', 1)).shortEnded = true;
						}
					}
				});
	
				/**
				 * DOM serializer for the editor. Will be used when contents is extracted from the editor.
				 *
				 * @property serializer
				 * @type tinymce.dom.Serializer
				 * @example
				 * // Serializes the first paragraph in the editor into a string
				 * tinymce.activeEditor.serializer.serialize(tinymce.activeEditor.dom.select('p')[0]);
				 */
				self.serializer = new DomSerializer(settings, self);
	
				/**
				 * Selection instance for the editor.
				 *
				 * @property selection
				 * @type tinymce.dom.Selection
				 * @example
				 * // Sets some contents to the current selection in the editor
				 * tinymce.activeEditor.selection.setContent('Some contents');
				 *
				 * // Gets the current selection
				 * alert(tinymce.activeEditor.selection.getContent());
				 *
				 * // Selects the first paragraph found
				 * tinymce.activeEditor.selection.select(tinymce.activeEditor.dom.select('p')[0]);
				 */
				self.selection = new Selection(self.dom, self.getWin(), self.serializer, self);
	
				/**
				 * Formatter instance.
				 *
				 * @property formatter
				 * @type tinymce.Formatter
				 */
				self.formatter = new Formatter(self);
	
				/**
				 * Undo manager instance, responsible for handling undo levels.
				 *
				 * @property undoManager
				 * @type tinymce.UndoManager
				 * @example
				 * // Undoes the last modification to the editor
				 * tinymce.activeEditor.undoManager.undo();
				 */
				self.undoManager = new UndoManager(self);
	
				self.forceBlocks = new ForceBlocks(self);
				self.enterKey = new EnterKey(self);
				self._nodeChangeDispatcher = new NodeChange(self);
				self._selectionOverrides = new SelectionOverrides(self);
	
				self.fire('PreInit');
	
				if (!settings.browser_spellcheck && !settings.gecko_spellcheck) {
					doc.body.spellcheck = false; // Gecko
					DOM.setAttrib(body, "spellcheck", "false");
				}
	
				self.quirks = new Quirks(self);
				self.fire('PostRender');
	
				if (settings.directionality) {
					body.dir = settings.directionality;
				}
	
				if (settings.nowrap) {
					body.style.whiteSpace = "nowrap";
				}
	
				if (settings.protect) {
					self.on('BeforeSetContent', function(e) {
						each(settings.protect, function(pattern) {
							e.content = e.content.replace(pattern, function(str) {
								return '<!--mce:protected ' + escape(str) + '-->';
							});
						});
					});
				}
	
				self.on('SetContent', function() {
					self.addVisual(self.getBody());
				});
	
				// Remove empty contents
				if (settings.padd_empty_editor) {
					self.on('PostProcess', function(e) {
						e.content = e.content.replace(/^(<p[^>]*>(&nbsp;|&#160;|\s|\u00a0|)<\/p>[\r\n]*|<br \/>[\r\n]*)$/, '');
					});
				}
	
				self.load({initial: true, format: 'html'});
				self.startContent = self.getContent({format: 'raw'});
	
				/**
				 * Is set to true after the editor instance has been initialized
				 *
				 * @property initialized
				 * @type Boolean
				 * @example
				 * function isEditorInitialized(editor) {
				 *     return editor && editor.initialized;
				 * }
				 */
				self.initialized = true;
				self.bindPendingEventDelegates();
	
				self.fire('init');
				self.focus(true);
				self.nodeChanged({initial: true});
				self.execCallback('init_instance_callback', self);
	
				self.on('compositionstart compositionend', function(e) {
					self.composing = e.type === 'compositionstart';
				});
	
				// Add editor specific CSS styles
				if (self.contentStyles.length > 0) {
					contentCssText = '';
	
					each(self.contentStyles, function(style) {
						contentCssText += style + "\r\n";
					});
	
					self.dom.addStyle(contentCssText);
				}
	
				// Load specified content CSS last
				each(self.contentCSS, function(cssUrl) {
					if (!self.loadedCSS[cssUrl]) {
						self.dom.loadCSS(cssUrl);
						self.loadedCSS[cssUrl] = true;
					}
				});
	
				// Handle auto focus
				if (settings.auto_focus) {
					Delay.setEditorTimeout(self, function() {
						var editor;
	
						if (settings.auto_focus === true) {
							editor = self;
						} else {
							editor = self.editorManager.get(settings.auto_focus);
						}
	
						if (!editor.destroyed) {
							editor.focus();
						}
					}, 100);
				}
	
				// Clean up references for IE
				targetElm = doc = body = null;
			},
	
			/**
			 * Focuses/activates the editor. This will set this editor as the activeEditor in the tinymce collection
			 * it will also place DOM focus inside the editor.
			 *
			 * @method focus
			 * @param {Boolean} skipFocus Skip DOM focus. Just set is as the active editor.
			 */
			focus: function(skipFocus) {
				var self = this, selection = self.selection, contentEditable = self.settings.content_editable, rng;
				var controlElm, doc = self.getDoc(), body = self.getBody(), contentEditableHost;
	
				function getContentEditableHost(node) {
					return self.dom.getParent(node, function(node) {
						return self.dom.getContentEditable(node) === "true";
					});
				}
	
				if (!skipFocus) {
					// Get selected control element
					rng = selection.getRng();
					if (rng.item) {
						controlElm = rng.item(0);
					}
	
					self.quirks.refreshContentEditable();
	
					// Move focus to contentEditable=true child if needed
					contentEditableHost = getContentEditableHost(selection.getNode());
					if (self.$.contains(body, contentEditableHost)) {
						contentEditableHost.focus();
						selection.normalize();
						self.editorManager.setActive(self);
						return;
					}
	
					// Focus the window iframe
					if (!contentEditable) {
						// WebKit needs this call to fire focusin event properly see #5948
						// But Opera pre Blink engine will produce an empty selection so skip Opera
						if (!Env.opera) {
							self.getBody().focus();
						}
	
						self.getWin().focus();
					}
	
					// Focus the body as well since it's contentEditable
					if (isGecko || contentEditable) {
						// Check for setActive since it doesn't scroll to the element
						if (body.setActive) {
							// IE 11 sometimes throws "Invalid function" then fallback to focus
							try {
								body.setActive();
							} catch (ex) {
								body.focus();
							}
						} else {
							body.focus();
						}
	
						if (contentEditable) {
							selection.normalize();
						}
					}
	
					// Restore selected control element
					// This is needed when for example an image is selected within a
					// layer a call to focus will then remove the control selection
					if (controlElm && controlElm.ownerDocument == doc) {
						rng = doc.body.createControlRange();
						rng.addElement(controlElm);
						rng.select();
					}
				}
	
				self.editorManager.setActive(self);
			},
	
			/**
			 * Executes a legacy callback. This method is useful to call old 2.x option callbacks.
			 * There new event model is a better way to add callback so this method might be removed in the future.
			 *
			 * @method execCallback
			 * @param {String} name Name of the callback to execute.
			 * @return {Object} Return value passed from callback function.
			 */
			execCallback: function(name) {
				var self = this, callback = self.settings[name], scope;
	
				if (!callback) {
					return;
				}
	
				// Look through lookup
				if (self.callbackLookup && (scope = self.callbackLookup[name])) {
					callback = scope.func;
					scope = scope.scope;
				}
	
				if (typeof callback === 'string') {
					scope = callback.replace(/\.\w+$/, '');
					scope = scope ? resolve(scope) : 0;
					callback = resolve(callback);
					self.callbackLookup = self.callbackLookup || {};
					self.callbackLookup[name] = {func: callback, scope: scope};
				}
	
				return callback.apply(scope || self, Array.prototype.slice.call(arguments, 1));
			},
	
			/**
			 * Translates the specified string by replacing variables with language pack items it will also check if there is
			 * a key matching the input.
			 *
			 * @method translate
			 * @param {String} text String to translate by the language pack data.
			 * @return {String} Translated string.
			 */
			translate: function(text) {
				var lang = this.settings.language || 'en', i18n = this.editorManager.i18n;
	
				if (!text) {
					return '';
				}
	
				text = i18n.data[lang + '.' + text] || text.replace(/\{\#([^\}]+)\}/g, function(a, b) {
					return i18n.data[lang + '.' + b] || '{#' + b + '}';
				});
	
				return this.editorManager.translate(text);
			},
	
			/**
			 * Returns a language pack item by name/key.
			 *
			 * @method getLang
			 * @param {String} name Name/key to get from the language pack.
			 * @param {String} defaultVal Optional default value to retrieve.
			 */
			getLang: function(name, defaultVal) {
				return (
					this.editorManager.i18n.data[(this.settings.language || 'en') + '.' + name] ||
					(defaultVal !== undefined ? defaultVal : '{#' + name + '}')
				);
			},
	
			/**
			 * Returns a configuration parameter by name.
			 *
			 * @method getParam
			 * @param {String} name Configruation parameter to retrieve.
			 * @param {String} defaultVal Optional default value to return.
			 * @param {String} type Optional type parameter.
			 * @return {String} Configuration parameter value or default value.
			 * @example
			 * // Returns a specific config value from the currently active editor
			 * var someval = tinymce.activeEditor.getParam('myvalue');
			 *
			 * // Returns a specific config value from a specific editor instance by id
			 * var someval2 = tinymce.get('my_editor').getParam('myvalue');
			 */
			getParam: function(name, defaultVal, type) {
				var value = name in this.settings ? this.settings[name] : defaultVal, output;
	
				if (type === 'hash') {
					output = {};
	
					if (typeof value === 'string') {
						each(value.indexOf('=') > 0 ? value.split(/[;,](?![^=;,]*(?:[;,]|$))/) : value.split(','), function(value) {
							value = value.split('=');
	
							if (value.length > 1) {
								output[trim(value[0])] = trim(value[1]);
							} else {
								output[trim(value[0])] = trim(value);
							}
						});
					} else {
						output = value;
					}
	
					return output;
				}
	
				return value;
			},
	
			/**
			 * Dispatches out a onNodeChange event to all observers. This method should be called when you
			 * need to update the UI states or element path etc.
			 *
			 * @method nodeChanged
			 * @param {Object} args Optional args to pass to NodeChange event handlers.
			 */
			nodeChanged: function(args) {
				this._nodeChangeDispatcher.nodeChanged(args);
			},
	
			/**
			 * Adds a button that later gets created by the theme in the editors toolbars.
			 *
			 * @method addButton
			 * @param {String} name Button name to add.
			 * @param {Object} settings Settings object with title, cmd etc.
			 * @example
			 * // Adds a custom button to the editor that inserts contents when clicked
			 * tinymce.init({
			 *    ...
			 *
			 *    toolbar: 'example'
			 *
			 *    setup: function(ed) {
			 *       ed.addButton('example', {
			 *          title: 'My title',
			 *          image: '../js/tinymce/plugins/example/img/example.gif',
			 *          onclick: function() {
			 *             ed.insertContent('Hello world!!');
			 *          }
			 *       });
			 *    }
			 * });
			 */
			addButton: function(name, settings) {
				var self = this;
	
				if (settings.cmd) {
					settings.onclick = function() {
						self.execCommand(settings.cmd);
					};
				}
	
				if (!settings.text && !settings.icon) {
					settings.icon = name;
				}
	
				self.buttons = self.buttons || {};
				settings.tooltip = settings.tooltip || settings.title;
				self.buttons[name] = settings;
			},
	
			/**
			 * Adds a menu item to be used in the menus of the theme. There might be multiple instances
			 * of this menu item for example it might be used in the main menus of the theme but also in
			 * the context menu so make sure that it's self contained and supports multiple instances.
			 *
			 * @method addMenuItem
			 * @param {String} name Menu item name to add.
			 * @param {Object} settings Settings object with title, cmd etc.
			 * @example
			 * // Adds a custom menu item to the editor that inserts contents when clicked
			 * // The context option allows you to add the menu item to an existing default menu
			 * tinymce.init({
			 *    ...
			 *
			 *    setup: function(ed) {
			 *       ed.addMenuItem('example', {
			 *          text: 'My menu item',
			 *          context: 'tools',
			 *          onclick: function() {
			 *             ed.insertContent('Hello world!!');
			 *          }
			 *       });
			 *    }
			 * });
			 */
			addMenuItem: function(name, settings) {
				var self = this;
	
				if (settings.cmd) {
					settings.onclick = function() {
						self.execCommand(settings.cmd);
					};
				}
	
				self.menuItems = self.menuItems || {};
				self.menuItems[name] = settings;
			},
	
			/**
			 * Adds a contextual toolbar to be rendered when the selector matches.
			 *
			 * @method addContextToolbar
			 * @param {function/string} predicate Predicate that needs to return true if provided strings get converted into CSS predicates.
			 * @param {String/Array} items String or array with items to add to the context toolbar.
			 */
			addContextToolbar: function(predicate, items) {
				var self = this, selector;
	
				self.contextToolbars = self.contextToolbars || [];
	
				// Convert selector to predicate
				if (typeof predicate == "string") {
					selector = predicate;
					predicate = function(elm) {
						return self.dom.is(elm, selector);
					};
				}
	
				self.contextToolbars.push({
					predicate: predicate,
					items: items
				});
			},
	
			/**
			 * Adds a custom command to the editor, you can also override existing commands with this method.
			 * The command that you add can be executed with execCommand.
			 *
			 * @method addCommand
			 * @param {String} name Command name to add/override.
			 * @param {addCommandCallback} callback Function to execute when the command occurs.
			 * @param {Object} scope Optional scope to execute the function in.
			 * @example
			 * // Adds a custom command that later can be executed using execCommand
			 * tinymce.init({
			 *    ...
			 *
			 *    setup: function(ed) {
			 *       // Register example command
			 *       ed.addCommand('mycommand', function(ui, v) {
			 *          ed.windowManager.alert('Hello world!! Selection: ' + ed.selection.getContent({format: 'text'}));
			 *       });
			 *    }
			 * });
			 */
			addCommand: function(name, callback, scope) {
				/**
				 * Callback function that gets called when a command is executed.
				 *
				 * @callback addCommandCallback
				 * @param {Boolean} ui Display UI state true/false.
				 * @param {Object} value Optional value for command.
				 * @return {Boolean} True/false state if the command was handled or not.
				 */
				this.editorCommands.addCommand(name, callback, scope);
			},
	
			/**
			 * Adds a custom query state command to the editor, you can also override existing commands with this method.
			 * The command that you add can be executed with queryCommandState function.
			 *
			 * @method addQueryStateHandler
			 * @param {String} name Command name to add/override.
			 * @param {addQueryStateHandlerCallback} callback Function to execute when the command state retrieval occurs.
			 * @param {Object} scope Optional scope to execute the function in.
			 */
			addQueryStateHandler: function(name, callback, scope) {
				/**
				 * Callback function that gets called when a queryCommandState is executed.
				 *
				 * @callback addQueryStateHandlerCallback
				 * @return {Boolean} True/false state if the command is enabled or not like is it bold.
				 */
				this.editorCommands.addQueryStateHandler(name, callback, scope);
			},
	
			/**
			 * Adds a custom query value command to the editor, you can also override existing commands with this method.
			 * The command that you add can be executed with queryCommandValue function.
			 *
			 * @method addQueryValueHandler
			 * @param {String} name Command name to add/override.
			 * @param {addQueryValueHandlerCallback} callback Function to execute when the command value retrieval occurs.
			 * @param {Object} scope Optional scope to execute the function in.
			 */
			addQueryValueHandler: function(name, callback, scope) {
				/**
				 * Callback function that gets called when a queryCommandValue is executed.
				 *
				 * @callback addQueryValueHandlerCallback
				 * @return {Object} Value of the command or undefined.
				 */
				this.editorCommands.addQueryValueHandler(name, callback, scope);
			},
	
			/**
			 * Adds a keyboard shortcut for some command or function.
			 *
			 * @method addShortcut
			 * @param {String} pattern Shortcut pattern. Like for example: ctrl+alt+o.
			 * @param {String} desc Text description for the command.
			 * @param {String/Function} cmdFunc Command name string or function to execute when the key is pressed.
			 * @param {Object} sc Optional scope to execute the function in.
			 * @return {Boolean} true/false state if the shortcut was added or not.
			 */
			addShortcut: function(pattern, desc, cmdFunc, scope) {
				this.shortcuts.add(pattern, desc, cmdFunc, scope);
			},
	
			/**
			 * Executes a command on the current instance. These commands can be TinyMCE internal commands prefixed with "mce" or
			 * they can be build in browser commands such as "Bold". A compleate list of browser commands is available on MSDN or Mozilla.org.
			 * This function will dispatch the execCommand function on each plugin, theme or the execcommand_callback option if none of these
			 * return true it will handle the command as a internal browser command.
			 *
			 * @method execCommand
			 * @param {String} cmd Command name to execute, for example mceLink or Bold.
			 * @param {Boolean} ui True/false state if a UI (dialog) should be presented or not.
			 * @param {mixed} value Optional command value, this can be anything.
			 * @param {Object} args Optional arguments object.
			 */
			execCommand: function(cmd, ui, value, args) {
				return this.editorCommands.execCommand(cmd, ui, value, args);
			},
	
			/**
			 * Returns a command specific state, for example if bold is enabled or not.
			 *
			 * @method queryCommandState
			 * @param {string} cmd Command to query state from.
			 * @return {Boolean} Command specific state, for example if bold is enabled or not.
			 */
			queryCommandState: function(cmd) {
				return this.editorCommands.queryCommandState(cmd);
			},
	
			/**
			 * Returns a command specific value, for example the current font size.
			 *
			 * @method queryCommandValue
			 * @param {string} cmd Command to query value from.
			 * @return {Object} Command specific value, for example the current font size.
			 */
			queryCommandValue: function(cmd) {
				return this.editorCommands.queryCommandValue(cmd);
			},
	
			/**
			 * Returns true/false if the command is supported or not.
			 *
			 * @method queryCommandSupported
			 * @param {String} cmd Command that we check support for.
			 * @return {Boolean} true/false if the command is supported or not.
			 */
			queryCommandSupported: function(cmd) {
				return this.editorCommands.queryCommandSupported(cmd);
			},
	
			/**
			 * Shows the editor and hides any textarea/div that the editor is supposed to replace.
			 *
			 * @method show
			 */
			show: function() {
				var self = this;
	
				if (self.hidden) {
					self.hidden = false;
	
					if (self.inline) {
						self.getBody().contentEditable = true;
					} else {
						DOM.show(self.getContainer());
						DOM.hide(self.id);
					}
	
					self.load();
					self.fire('show');
				}
			},
	
			/**
			 * Hides the editor and shows any textarea/div that the editor is supposed to replace.
			 *
			 * @method hide
			 */
			hide: function() {
				var self = this, doc = self.getDoc();
	
				if (!self.hidden) {
					// Fixed bug where IE has a blinking cursor left from the editor
					if (ie && doc && !self.inline) {
						doc.execCommand('SelectAll');
					}
	
					// We must save before we hide so Safari doesn't crash
					self.save();
	
					if (self.inline) {
						self.getBody().contentEditable = false;
	
						// Make sure the editor gets blurred
						if (self == self.editorManager.focusedEditor) {
							self.editorManager.focusedEditor = null;
						}
					} else {
						DOM.hide(self.getContainer());
						DOM.setStyle(self.id, 'display', self.orgDisplay);
					}
	
					self.hidden = true;
					self.fire('hide');
				}
			},
	
			/**
			 * Returns true/false if the editor is hidden or not.
			 *
			 * @method isHidden
			 * @return {Boolean} True/false if the editor is hidden or not.
			 */
			isHidden: function() {
				return !!this.hidden;
			},
	
			/**
			 * Sets the progress state, this will display a throbber/progess for the editor.
			 * This is ideal for asynchronous operations like an AJAX save call.
			 *
			 * @method setProgressState
			 * @param {Boolean} state Boolean state if the progress should be shown or hidden.
			 * @param {Number} time Optional time to wait before the progress gets shown.
			 * @return {Boolean} Same as the input state.
			 * @example
			 * // Show progress for the active editor
			 * tinymce.activeEditor.setProgressState(true);
			 *
			 * // Hide progress for the active editor
			 * tinymce.activeEditor.setProgressState(false);
			 *
			 * // Show progress after 3 seconds
			 * tinymce.activeEditor.setProgressState(true, 3000);
			 */
			setProgressState: function(state, time) {
				this.fire('ProgressState', {state: state, time: time});
			},
	
			/**
			 * Loads contents from the textarea or div element that got converted into an editor instance.
			 * This method will move the contents from that textarea or div into the editor by using setContent
			 * so all events etc that method has will get dispatched as well.
			 *
			 * @method load
			 * @param {Object} args Optional content object, this gets passed around through the whole load process.
			 * @return {String} HTML string that got set into the editor.
			 */
			load: function(args) {
				var self = this, elm = self.getElement(), html;
	
				if (elm) {
					args = args || {};
					args.load = true;
	
					html = self.setContent(elm.value !== undefined ? elm.value : elm.innerHTML, args);
					args.element = elm;
	
					if (!args.no_events) {
						self.fire('LoadContent', args);
					}
	
					args.element = elm = null;
	
					return html;
				}
			},
	
			/**
			 * Saves the contents from a editor out to the textarea or div element that got converted into an editor instance.
			 * This method will move the HTML contents from the editor into that textarea or div by getContent
			 * so all events etc that method has will get dispatched as well.
			 *
			 * @method save
			 * @param {Object} args Optional content object, this gets passed around through the whole save process.
			 * @return {String} HTML string that got set into the textarea/div.
			 */
			save: function(args) {
				var self = this, elm = self.getElement(), html, form;
	
				if (!elm || !self.initialized) {
					return;
				}
	
				args = args || {};
				args.save = true;
	
				args.element = elm;
				html = args.content = self.getContent(args);
	
				if (!args.no_events) {
					self.fire('SaveContent', args);
				}
	
				// Always run this internal event
				if (args.format == 'raw') {
					self.fire('RawSaveContent', args);
				}
	
				html = args.content;
	
				if (!/TEXTAREA|INPUT/i.test(elm.nodeName)) {
					// Update DIV element when not in inline mode
					if (!self.inline) {
						elm.innerHTML = html;
					}
	
					// Update hidden form element
					if ((form = DOM.getParent(self.id, 'form'))) {
						each(form.elements, function(elm) {
							if (elm.name == self.id) {
								elm.value = html;
								return false;
							}
						});
					}
				} else {
					elm.value = html;
				}
	
				args.element = elm = null;
	
				if (args.set_dirty !== false) {
					self.setDirty(false);
				}
	
				return html;
			},
	
			/**
			 * Sets the specified content to the editor instance, this will cleanup the content before it gets set using
			 * the different cleanup rules options.
			 *
			 * @method setContent
			 * @param {String} content Content to set to editor, normally HTML contents but can be other formats as well.
			 * @param {Object} args Optional content object, this gets passed around through the whole set process.
			 * @return {String} HTML string that got set into the editor.
			 * @example
			 * // Sets the HTML contents of the activeEditor editor
			 * tinymce.activeEditor.setContent('<span>some</span> html');
			 *
			 * // Sets the raw contents of the activeEditor editor
			 * tinymce.activeEditor.setContent('<span>some</span> html', {format: 'raw'});
			 *
			 * // Sets the content of a specific editor (my_editor in this example)
			 * tinymce.get('my_editor').setContent(data);
			 *
			 * // Sets the bbcode contents of the activeEditor editor if the bbcode plugin was added
			 * tinymce.activeEditor.setContent('[b]some[/b] html', {format: 'bbcode'});
			 */
			setContent: function(content, args) {
				var self = this, body = self.getBody(), forcedRootBlockName, padd;
	
				// Setup args object
				args = args || {};
				args.format = args.format || 'html';
				args.set = true;
				args.content = content;
	
				// Do preprocessing
				if (!args.no_events) {
					self.fire('BeforeSetContent', args);
				}
	
				content = args.content;
	
				// Padd empty content in Gecko and Safari. Commands will otherwise fail on the content
				// It will also be impossible to place the caret in the editor unless there is a BR element present
				if (content.length === 0 || /^\s+$/.test(content)) {
					padd = ie && ie < 11 ? '' : '<br data-mce-bogus="1">';
	
					// Todo: There is a lot more root elements that need special padding
					// so separate this and add all of them at some point.
					if (body.nodeName == 'TABLE') {
						content = '<tr><td>' + padd + '</td></tr>';
					} else if (/^(UL|OL)$/.test(body.nodeName)) {
						content = '<li>' + padd + '</li>';
					}
	
					forcedRootBlockName = self.settings.forced_root_block;
	
					// Check if forcedRootBlock is configured and that the block is a valid child of the body
					if (forcedRootBlockName && self.schema.isValidChild(body.nodeName.toLowerCase(), forcedRootBlockName.toLowerCase())) {
						// Padd with bogus BR elements on modern browsers and IE 7 and 8 since they don't render empty P tags properly
						content = padd;
						content = self.dom.createHTML(forcedRootBlockName, self.settings.forced_root_block_attrs, content);
					} else if (!ie && !content) {
						// We need to add a BR when forced_root_block is disabled on non IE browsers to place the caret
						content = '<br data-mce-bogus="1">';
					}
	
					self.dom.setHTML(body, content);
	
					self.fire('SetContent', args);
				} else {
					// Parse and serialize the html
					if (args.format !== 'raw') {
						content = new Serializer({
							validate: self.validate
						}, self.schema).serialize(
							self.parser.parse(content, {isRootContent: true})
						);
					}
	
					// Set the new cleaned contents to the editor
					args.content = trim(content);
					self.dom.setHTML(body, args.content);
	
					// Do post processing
					if (!args.no_events) {
						self.fire('SetContent', args);
					}
	
					// Don't normalize selection if the focused element isn't the body in
					// content editable mode since it will steal focus otherwise
					/*if (!self.settings.content_editable || document.activeElement === self.getBody()) {
						self.selection.normalize();
					}*/
				}
	
				return args.content;
			},
	
			/**
			 * Gets the content from the editor instance, this will cleanup the content before it gets returned using
			 * the different cleanup rules options.
			 *
			 * @method getContent
			 * @param {Object} args Optional content object, this gets passed around through the whole get process.
			 * @return {String} Cleaned content string, normally HTML contents.
			 * @example
			 * // Get the HTML contents of the currently active editor
			 * console.debug(tinymce.activeEditor.getContent());
			 *
			 * // Get the raw contents of the currently active editor
			 * tinymce.activeEditor.getContent({format: 'raw'});
			 *
			 * // Get content of a specific editor:
			 * tinymce.get('content id').getContent()
			 */
			getContent: function(args) {
				var self = this, content, body = self.getBody();
	
				// Setup args object
				args = args || {};
				args.format = args.format || 'html';
				args.get = true;
				args.getInner = true;
	
				// Do preprocessing
				if (!args.no_events) {
					self.fire('BeforeGetContent', args);
				}
	
				// Get raw contents or by default the cleaned contents
				if (args.format == 'raw') {
					content = self.serializer.getTrimmedContent();
				} else if (args.format == 'text') {
					content = body.innerText || body.textContent;
				} else {
					content = self.serializer.serialize(body, args);
				}
	
				// Trim whitespace in beginning/end of HTML
				if (args.format != 'text') {
					args.content = trim(content);
				} else {
					args.content = content;
				}
	
				// Do post processing
				if (!args.no_events) {
					self.fire('GetContent', args);
				}
	
				return args.content;
			},
	
			/**
			 * Inserts content at caret position.
			 *
			 * @method insertContent
			 * @param {String} content Content to insert.
			 * @param {Object} args Optional args to pass to insert call.
			 */
			insertContent: function(content, args) {
				if (args) {
					content = extend({content: content}, args);
				}
	
				this.execCommand('mceInsertContent', false, content);
			},
	
			/**
			 * Returns true/false if the editor is dirty or not. It will get dirty if the user has made modifications to the contents.
			 *
			 * The dirty state is automatically set to true if you do modifications to the content in other
			 * words when new undo levels is created or if you undo/redo to update the contents of the editor. It will also be set
			 * to false if you call editor.save().
			 *
			 * @method isDirty
			 * @return {Boolean} True/false if the editor is dirty or not. It will get dirty if the user has made modifications to the contents.
			 * @example
			 * if (tinymce.activeEditor.isDirty())
			 *     alert("You must save your contents.");
			 */
			isDirty: function() {
				return !this.isNotDirty;
			},
	
			/**
			 * Explicitly sets the dirty state. This will fire the dirty event if the editor dirty state is changed from false to true
			 * by invoking this method.
			 *
			 * @method setDirty
			 * @param {Boolean} state True/false if the editor is considered dirty.
			 * @example
			 * function ajaxSave() {
			 *     var editor = tinymce.get('elm1');
			 *
			 *     // Save contents using some XHR call
			 *     alert(editor.getContent());
			 *
			 *     editor.setDirty(false); // Force not dirty state
			 * }
			 */
			setDirty: function(state) {
				var oldState = !this.isNotDirty;
	
				this.isNotDirty = !state;
	
				if (state && state != oldState) {
					this.fire('dirty');
				}
			},
	
			/**
			 * Sets the editor mode. Mode can be for example "design", "code" or "readonly".
			 *
			 * @method setMode
			 * @param {String} mode Mode to set the editor in.
			 */
			setMode: function(mode) {
				Mode.setMode(this, mode);
			},
	
			/**
			 * Returns the editors container element. The container element wrappes in
			 * all the elements added to the page for the editor. Such as UI, iframe etc.
			 *
			 * @method getContainer
			 * @return {Element} HTML DOM element for the editor container.
			 */
			getContainer: function() {
				var self = this;
	
				if (!self.container) {
					self.container = DOM.get(self.editorContainer || self.id + '_parent');
				}
	
				return self.container;
			},
	
			/**
			 * Returns the editors content area container element. The this element is the one who
			 * holds the iframe or the editable element.
			 *
			 * @method getContentAreaContainer
			 * @return {Element} HTML DOM element for the editor area container.
			 */
			getContentAreaContainer: function() {
				return this.contentAreaContainer;
			},
	
			/**
			 * Returns the target element/textarea that got replaced with a TinyMCE editor instance.
			 *
			 * @method getElement
			 * @return {Element} HTML DOM element for the replaced element.
			 */
			getElement: function() {
				if (!this.targetElm) {
					this.targetElm = DOM.get(this.id);
				}
	
				return this.targetElm;
			},
	
			/**
			 * Returns the iframes window object.
			 *
			 * @method getWin
			 * @return {Window} Iframe DOM window object.
			 */
			getWin: function() {
				var self = this, elm;
	
				if (!self.contentWindow) {
					elm = self.iframeElement;
	
					if (elm) {
						self.contentWindow = elm.contentWindow;
					}
				}
	
				return self.contentWindow;
			},
	
			/**
			 * Returns the iframes document object.
			 *
			 * @method getDoc
			 * @return {Document} Iframe DOM document object.
			 */
			getDoc: function() {
				var self = this, win;
	
				if (!self.contentDocument) {
					win = self.getWin();
	
					if (win) {
						self.contentDocument = win.document;
					}
				}
	
				return self.contentDocument;
			},
	
			/**
			 * Returns the root element of the editable area.
			 * For a non-inline iframe-based editor, returns the iframe's body element.
			 *
			 * @method getBody
			 * @return {Element} The root element of the editable area.
			 */
			getBody: function() {
				return this.bodyElement || this.getDoc().body;
			},
	
			/**
			 * URL converter function this gets executed each time a user adds an img, a or
			 * any other element that has a URL in it. This will be called both by the DOM and HTML
			 * manipulation functions.
			 *
			 * @method convertURL
			 * @param {string} url URL to convert.
			 * @param {string} name Attribute name src, href etc.
			 * @param {string/HTMLElement} elm Tag name or HTML DOM element depending on HTML or DOM insert.
			 * @return {string} Converted URL string.
			 */
			convertURL: function(url, name, elm) {
				var self = this, settings = self.settings;
	
				// Use callback instead
				if (settings.urlconverter_callback) {
					return self.execCallback('urlconverter_callback', url, elm, true, name);
				}
	
				// Don't convert link href since thats the CSS files that gets loaded into the editor also skip local file URLs
				if (!settings.convert_urls || (elm && elm.nodeName == 'LINK') || url.indexOf('file:') === 0 || url.length === 0) {
					return url;
				}
	
				// Convert to relative
				if (settings.relative_urls) {
					return self.documentBaseURI.toRelative(url);
				}
	
				// Convert to absolute
				url = self.documentBaseURI.toAbsolute(url, settings.remove_script_host);
	
				return url;
			},
	
			/**
			 * Adds visual aid for tables, anchors etc so they can be more easily edited inside the editor.
			 *
			 * @method addVisual
			 * @param {Element} elm Optional root element to loop though to find tables etc that needs the visual aid.
			 */
			addVisual: function(elm) {
				var self = this, settings = self.settings, dom = self.dom, cls;
	
				elm = elm || self.getBody();
	
				if (self.hasVisual === undefined) {
					self.hasVisual = settings.visual;
				}
	
				each(dom.select('table,a', elm), function(elm) {
					var value;
	
					switch (elm.nodeName) {
						case 'TABLE':
							cls = settings.visual_table_class || 'mce-item-table';
							value = dom.getAttrib(elm, 'border');
	
							if ((!value || value == '0') && self.hasVisual) {
								dom.addClass(elm, cls);
							} else {
								dom.removeClass(elm, cls);
							}
	
							return;
	
						case 'A':
							if (!dom.getAttrib(elm, 'href', false)) {
								value = dom.getAttrib(elm, 'name') || elm.id;
								cls = settings.visual_anchor_class || 'mce-item-anchor';
	
								if (value && self.hasVisual) {
									dom.addClass(elm, cls);
								} else {
									dom.removeClass(elm, cls);
								}
							}
	
							return;
					}
				});
	
				self.fire('VisualAid', {element: elm, hasVisual: self.hasVisual});
			},
	
			/**
			 * Removes the editor from the dom and tinymce collection.
			 *
			 * @method remove
			 */
			remove: function() {
				var self = this;
	
				if (!self.removed) {
					self.save();
					self.removed = 1;
					self.unbindAllNativeEvents();
	
					// Remove any hidden input
					if (self.hasHiddenInput) {
						DOM.remove(self.getElement().nextSibling);
					}
	
					if (!self.inline) {
						// IE 9 has a bug where the selection stops working if you place the
						// caret inside the editor then remove the iframe
						if (ie && ie < 10) {
							self.getDoc().execCommand('SelectAll', false, null);
						}
	
						DOM.setStyle(self.id, 'display', self.orgDisplay);
						self.getBody().onload = null; // Prevent #6816
					}
	
					self.fire('remove');
	
					self.editorManager.remove(self);
					DOM.remove(self.getContainer());
					self._selectionOverrides.destroy();
					self.editorUpload.destroy();
					self.destroy();
				}
			},
	
			/**
			 * Destroys the editor instance by removing all events, element references or other resources
			 * that could leak memory. This method will be called automatically when the page is unloaded
			 * but you can also call it directly if you know what you are doing.
			 *
			 * @method destroy
			 * @param {Boolean} automatic Optional state if the destroy is an automatic destroy or user called one.
			 */
			destroy: function(automatic) {
				var self = this, form;
	
				// One time is enough
				if (self.destroyed) {
					return;
				}
	
				// If user manually calls destroy and not remove
				// Users seems to have logic that calls destroy instead of remove
				if (!automatic && !self.removed) {
					self.remove();
					return;
				}
	
				if (!automatic) {
					self.editorManager.off('beforeunload', self._beforeUnload);
	
					// Manual destroy
					if (self.theme && self.theme.destroy) {
						self.theme.destroy();
					}
	
					// Destroy controls, selection and dom
					self.selection.destroy();
					self.dom.destroy();
				}
	
				form = self.formElement;
				if (form) {
					if (form._mceOldSubmit) {
						form.submit = form._mceOldSubmit;
						form._mceOldSubmit = null;
					}
	
					DOM.unbind(form, 'submit reset', self.formEventDelegate);
				}
	
				self.contentAreaContainer = self.formElement = self.container = self.editorContainer = null;
				self.bodyElement = self.contentDocument = self.contentWindow = null;
				self.iframeElement = self.targetElm = null;
	
				if (self.selection) {
					self.selection = self.selection.win = self.selection.dom = self.selection.dom.doc = null;
				}
	
				self.destroyed = 1;
			},
	
			/**
			 * Uploads all data uri/blob uri images in the editor contents to server.
			 *
			 * @method uploadImages
			 * @param {function} callback Optional callback with images and status for each image.
			 * @return {tinymce.util.Promise} Promise instance.
			 */
			uploadImages: function(callback) {
				return this.editorUpload.uploadImages(callback);
			},
	
			// Internal functions
	
			_scanForImages: function() {
				return this.editorUpload.scanForImages();
			}
		};
	
		extend(Editor.prototype, EditorObservable);
	
		return Editor;
	});
	
	// Included from: js/tinymce/classes/util/I18n.js
	
	/**
	 * I18n.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * I18n class that handles translation of TinyMCE UI.
	 * Uses po style with csharp style parameters.
	 *
	 * @class tinymce.util.I18n
	 */
	define("tinymce/util/I18n", [], function() {
		"use strict";
	
		var data = {}, code = "en";
	
		return {
			/**
			 * Sets the current language code.
			 *
			 * @method setCode
			 * @param {String} newCode Current language code.
			 */
			setCode: function(newCode) {
				if (newCode) {
					code = newCode;
					this.rtl = this.data[newCode] ? this.data[newCode]._dir === 'rtl' : false;
				}
			},
	
			/**
			 * Returns the current language code.
			 *
			 * @method getCode
			 * @return {String} Current language code.
			 */
			getCode: function() {
				return code;
			},
	
			/**
			 * Property gets set to true if a RTL language pack was loaded.
			 *
			 * @property rtl
			 * @type Boolean
			 */
			rtl: false,
	
			/**
			 * Adds translations for a specific language code.
			 *
			 * @method add
			 * @param {String} code Language code like sv_SE.
			 * @param {Array} items Name/value array with English en_US to sv_SE.
			 */
			add: function(code, items) {
				var langData = data[code];
	
				if (!langData) {
					data[code] = langData = {};
				}
	
				for (var name in items) {
					langData[name] = items[name];
				}
	
				this.setCode(code);
			},
	
			/**
			 * Translates the specified text.
			 *
			 * It has a few formats:
			 * I18n.translate("Text");
			 * I18n.translate(["Text {0}/{1}", 0, 1]);
			 * I18n.translate({raw: "Raw string"});
			 *
			 * @method translate
			 * @param {String/Object/Array} text Text to translate.
			 * @return {String} String that got translated.
			 */
			translate: function(text) {
				var langData;
	
				langData = data[code];
				if (!langData) {
					langData = {};
				}
	
				if (typeof text == "undefined") {
					return text;
				}
	
				if (typeof text != "string" && text.raw) {
					return text.raw;
				}
	
				if (text.push) {
					var values = text.slice(1);
	
					text = (langData[text[0]] || text[0]).replace(/\{([0-9]+)\}/g, function(match1, match2) {
						return values[match2];
					});
				}
	
				return (langData[text] || text).replace(/{context:\w+}$/, '');
			},
	
			data: data
		};
	});
	
	// Included from: js/tinymce/classes/FocusManager.js
	
	/**
	 * FocusManager.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * This class manages the focus/blur state of the editor. This class is needed since some
	 * browsers fire false focus/blur states when the selection is moved to a UI dialog or similar.
	 *
	 * This class will fire two events focus and blur on the editor instances that got affected.
	 * It will also handle the restore of selection when the focus is lost and returned.
	 *
	 * @class tinymce.FocusManager
	 */
	define("tinymce/FocusManager", [
		"tinymce/dom/DOMUtils",
		"tinymce/util/Delay",
		"tinymce/Env"
	], function(DOMUtils, Delay, Env) {
		var selectionChangeHandler, documentFocusInHandler, documentMouseUpHandler, DOM = DOMUtils.DOM;
	
		/**
		 * Constructs a new focus manager instance.
		 *
		 * @constructor FocusManager
		 * @param {tinymce.EditorManager} editorManager Editor manager instance to handle focus for.
		 */
		function FocusManager(editorManager) {
			function getActiveElement() {
				try {
					return document.activeElement;
				} catch (ex) {
					// IE sometimes fails to get the activeElement when resizing table
					// TODO: Investigate this
					return document.body;
				}
			}
	
			// We can't store a real range on IE 11 since it gets mutated so we need to use a bookmark object
			// TODO: Move this to a separate range utils class since it's it's logic is present in Selection as well.
			function createBookmark(dom, rng) {
				if (rng && rng.startContainer) {
					// Verify that the range is within the root of the editor
					if (!dom.isChildOf(rng.startContainer, dom.getRoot()) || !dom.isChildOf(rng.endContainer, dom.getRoot())) {
						return;
					}
	
					return {
						startContainer: rng.startContainer,
						startOffset: rng.startOffset,
						endContainer: rng.endContainer,
						endOffset: rng.endOffset
					};
				}
	
				return rng;
			}
	
			function bookmarkToRng(editor, bookmark) {
				var rng;
	
				if (bookmark.startContainer) {
					rng = editor.getDoc().createRange();
					rng.setStart(bookmark.startContainer, bookmark.startOffset);
					rng.setEnd(bookmark.endContainer, bookmark.endOffset);
				} else {
					rng = bookmark;
				}
	
				return rng;
			}
	
			function isUIElement(elm) {
				return !!DOM.getParent(elm, FocusManager.isEditorUIElement);
			}
	
			function registerEvents(e) {
				var editor = e.editor;
	
				editor.on('init', function() {
					// Gecko/WebKit has ghost selections in iframes and IE only has one selection per browser tab
					if (editor.inline || Env.ie) {
						// Use the onbeforedeactivate event when available since it works better see #7023
						if ("onbeforedeactivate" in document && Env.ie < 9) {
							editor.dom.bind(editor.getBody(), 'beforedeactivate', function(e) {
								if (e.target != editor.getBody()) {
									return;
								}
	
								try {
									editor.lastRng = editor.selection.getRng();
								} catch (ex) {
									// IE throws "Unexcpected call to method or property access" some times so lets ignore it
								}
							});
						} else {
							// On other browsers take snapshot on nodechange in inline mode since they have Ghost selections for iframes
							editor.on('nodechange mouseup keyup', function(e) {
								var node = getActiveElement();
	
								// Only act on manual nodechanges
								if (e.type == 'nodechange' && e.selectionChange) {
									return;
								}
	
								// IE 11 reports active element as iframe not body of iframe
								if (node && node.id == editor.id + '_ifr') {
									node = editor.getBody();
								}
	
								if (editor.dom.isChildOf(node, editor.getBody())) {
									editor.lastRng = editor.selection.getRng();
								}
							});
						}
	
						// Handles the issue with WebKit not retaining selection within inline document
						// If the user releases the mouse out side the body since a mouse up event wont occur on the body
						if (Env.webkit && !selectionChangeHandler) {
							selectionChangeHandler = function() {
								var activeEditor = editorManager.activeEditor;
	
								if (activeEditor && activeEditor.selection) {
									var rng = activeEditor.selection.getRng();
	
									// Store when it's non collapsed
									if (rng && !rng.collapsed) {
										editor.lastRng = rng;
									}
								}
							};
	
							DOM.bind(document, 'selectionchange', selectionChangeHandler);
						}
					}
				});
	
				editor.on('setcontent', function() {
					editor.lastRng = null;
				});
	
				// Remove last selection bookmark on mousedown see #6305
				editor.on('mousedown', function() {
					editor.selection.lastFocusBookmark = null;
				});
	
				editor.on('focusin', function() {
					var focusedEditor = editorManager.focusedEditor, lastRng;
	
					if (editor.selection.lastFocusBookmark) {
						lastRng = bookmarkToRng(editor, editor.selection.lastFocusBookmark);
						editor.selection.lastFocusBookmark = null;
						editor.selection.setRng(lastRng);
					}
	
					if (focusedEditor != editor) {
						if (focusedEditor) {
							focusedEditor.fire('blur', {focusedEditor: editor});
						}
	
						editorManager.setActive(editor);
						editorManager.focusedEditor = editor;
						editor.fire('focus', {blurredEditor: focusedEditor});
						editor.focus(true);
					}
	
					editor.lastRng = null;
				});
	
				editor.on('focusout', function() {
					Delay.setEditorTimeout(editor, function() {
						var focusedEditor = editorManager.focusedEditor;
	
						// Still the same editor the blur was outside any editor UI
						if (!isUIElement(getActiveElement()) && focusedEditor == editor) {
							editor.fire('blur', {focusedEditor: null});
							editorManager.focusedEditor = null;
	
							// Make sure selection is valid could be invalid if the editor is blured and removed before the timeout occurs
							if (editor.selection) {
								editor.selection.lastFocusBookmark = null;
							}
						}
					});
				});
	
				// Check if focus is moved to an element outside the active editor by checking if the target node
				// isn't within the body of the activeEditor nor a UI element such as a dialog child control
				if (!documentFocusInHandler) {
					documentFocusInHandler = function(e) {
						var activeEditor = editorManager.activeEditor, target;
	
						target = e.target;
	
						if (activeEditor && target.ownerDocument == document) {
							// Check to make sure we have a valid selection don't update the bookmark if it's
							// a focusin to the body of the editor see #7025
							if (activeEditor.selection && target != activeEditor.getBody()) {
								activeEditor.selection.lastFocusBookmark = createBookmark(activeEditor.dom, activeEditor.lastRng);
							}
	
							// Fire a blur event if the element isn't a UI element
							if (target != document.body && !isUIElement(target) && editorManager.focusedEditor == activeEditor) {
								activeEditor.fire('blur', {focusedEditor: null});
								editorManager.focusedEditor = null;
							}
						}
					};
	
					DOM.bind(document, 'focusin', documentFocusInHandler);
				}
	
				// Handle edge case when user starts the selection inside the editor and releases
				// the mouse outside the editor producing a new selection. This weird workaround is needed since
				// Gecko doesn't have the "selectionchange" event we need to do this. Fixes: #6843
				if (editor.inline && !documentMouseUpHandler) {
					documentMouseUpHandler = function(e) {
						var activeEditor = editorManager.activeEditor;
	
						if (activeEditor.inline && !activeEditor.dom.isChildOf(e.target, activeEditor.getBody())) {
							var rng = activeEditor.selection.getRng();
	
							if (!rng.collapsed) {
								activeEditor.lastRng = rng;
							}
						}
					};
	
					DOM.bind(document, 'mouseup', documentMouseUpHandler);
				}
			}
	
			function unregisterDocumentEvents(e) {
				if (editorManager.focusedEditor == e.editor) {
					editorManager.focusedEditor = null;
				}
	
				if (!editorManager.activeEditor) {
					DOM.unbind(document, 'selectionchange', selectionChangeHandler);
					DOM.unbind(document, 'focusin', documentFocusInHandler);
					DOM.unbind(document, 'mouseup', documentMouseUpHandler);
					selectionChangeHandler = documentFocusInHandler = documentMouseUpHandler = null;
				}
			}
	
			editorManager.on('AddEditor', registerEvents);
			editorManager.on('RemoveEditor', unregisterDocumentEvents);
		}
	
		/**
		 * Returns true if the specified element is part of the UI for example an button or text input.
		 *
		 * @method isEditorUIElement
		 * @param  {Element} elm Element to check if it's part of the UI or not.
		 * @return {Boolean} True/false state if the element is part of the UI or not.
		 */
		FocusManager.isEditorUIElement = function(elm) {
			// Needs to be converted to string since svg can have focus: #6776
			return elm.className.toString().indexOf('mce-') !== -1;
		};
	
		return FocusManager;
	});
	
	// Included from: js/tinymce/classes/EditorManager.js
	
	/**
	 * EditorManager.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * This class used as a factory for manager for tinymce.Editor instances.
	 *
	 * @example
	 * tinymce.EditorManager.init({});
	 *
	 * @class tinymce.EditorManager
	 * @mixes tinymce.util.Observable
	 * @static
	 */
	define("tinymce/EditorManager", [
		"tinymce/Editor",
		"tinymce/dom/DomQuery",
		"tinymce/dom/DOMUtils",
		"tinymce/util/URI",
		"tinymce/Env",
		"tinymce/util/Tools",
		"tinymce/util/Promise",
		"tinymce/util/Observable",
		"tinymce/util/I18n",
		"tinymce/FocusManager"
	], function(Editor, $, DOMUtils, URI, Env, Tools, Promise, Observable, I18n, FocusManager) {
		var DOM = DOMUtils.DOM;
		var explode = Tools.explode, each = Tools.each, extend = Tools.extend;
		var instanceCounter = 0, beforeUnloadDelegate, EditorManager, boundGlobalEvents = false;
	
		function globalEventDelegate(e) {
			each(EditorManager.editors, function(editor) {
				if (e.type === 'scroll') {
					editor.fire('ScrollWindow', e);
				} else {
					editor.fire('ResizeWindow', e);
				}
			});
		}
	
		function toggleGlobalEvents(editors, state) {
			if (state !== boundGlobalEvents) {
				if (state) {
					$(window).on('resize scroll', globalEventDelegate);
				} else {
					$(window).off('resize scroll', globalEventDelegate);
				}
	
				boundGlobalEvents = state;
			}
		}
	
		function removeEditorFromList(editor) {
			var editors = EditorManager.editors, removedFromList;
	
			delete editors[editor.id];
	
			for (var i = 0; i < editors.length; i++) {
				if (editors[i] == editor) {
					editors.splice(i, 1);
					removedFromList = true;
					break;
				}
			}
	
			// Select another editor since the active one was removed
			if (EditorManager.activeEditor == editor) {
				EditorManager.activeEditor = editors[0];
			}
	
			// Clear focusedEditor if necessary, so that we don't try to blur the destroyed editor
			if (EditorManager.focusedEditor == editor) {
				EditorManager.focusedEditor = null;
			}
	
			return removedFromList;
		}
	
		function purgeDestroyedEditor(editor) {
			// User has manually destroyed the editor lets clean up the mess
			if (editor && editor.initialized && !(editor.getContainer() || editor.getBody()).parentNode) {
				removeEditorFromList(editor);
				editor.unbindAllNativeEvents();
				editor.destroy(true);
				editor.removed = true;
				editor = null;
			}
	
			return editor;
		}
	
		EditorManager = {
			/**
			 * Dom query instance.
			 *
			 * @property $
			 * @type tinymce.dom.DomQuery
			 */
			$: $,
	
			/**
			 * Major version of TinyMCE build.
			 *
			 * @property majorVersion
			 * @type String
			 */
			majorVersion: '4',
	
			/**
			 * Minor version of TinyMCE build.
			 *
			 * @property minorVersion
			 * @type String
			 */
			minorVersion: '3.13',
	
			/**
			 * Release date of TinyMCE build.
			 *
			 * @property releaseDate
			 * @type String
			 */
			releaseDate: '2016-06-08',
	
			/**
			 * Collection of editor instances.
			 *
			 * @property editors
			 * @type Object
			 * @example
			 * for (edId in tinymce.editors)
			 *     tinymce.editors[edId].save();
			 */
			editors: [],
	
			/**
			 * Collection of language pack data.
			 *
			 * @property i18n
			 * @type Object
			 */
			i18n: I18n,
	
			/**
			 * Currently active editor instance.
			 *
			 * @property activeEditor
			 * @type tinymce.Editor
			 * @example
			 * tinyMCE.activeEditor.selection.getContent();
			 * tinymce.EditorManager.activeEditor.selection.getContent();
			 */
			activeEditor: null,
	
			setup: function() {
				var self = this, baseURL, documentBaseURL, suffix = "", preInit, src;
	
				// Get base URL for the current document
				documentBaseURL = URI.getDocumentBaseUrl(document.location);
	
				// Check if the URL is a document based format like: http://site/dir/file and file:///
				// leave other formats like applewebdata://... intact
				if (/^[^:]+:\/\/\/?[^\/]+\//.test(documentBaseURL)) {
					documentBaseURL = documentBaseURL.replace(/[\?#].*$/, '').replace(/[\/\\][^\/]+$/, '');
	
					if (!/[\/\\]$/.test(documentBaseURL)) {
						documentBaseURL += '/';
					}
				}
	
				// If tinymce is defined and has a base use that or use the old tinyMCEPreInit
				preInit = window.tinymce || window.tinyMCEPreInit;
				if (preInit) {
					baseURL = preInit.base || preInit.baseURL;
					suffix = preInit.suffix;
				} else {
					// Get base where the tinymce script is located
					var scripts = document.getElementsByTagName('script');
					for (var i = 0; i < scripts.length; i++) {
						src = scripts[i].src;
	
						// Script types supported:
						// tinymce.js tinymce.min.js tinymce.dev.js
						// tinymce.jquery.js tinymce.jquery.min.js tinymce.jquery.dev.js
						// tinymce.full.js tinymce.full.min.js tinymce.full.dev.js
						var srcScript = src.substring(src.lastIndexOf('/'));
						if (/tinymce(\.full|\.jquery|)(\.min|\.dev|)\.js/.test(src)) {
							if (srcScript.indexOf('.min') != -1) {
								suffix = '.min';
							}
	
							baseURL = src.substring(0, src.lastIndexOf('/'));
							break;
						}
					}
	
					// We didn't find any baseURL by looking at the script elements
					// Try to use the document.currentScript as a fallback
					if (!baseURL && document.currentScript) {
						src = document.currentScript.src;
	
						if (src.indexOf('.min') != -1) {
							suffix = '.min';
						}
	
						baseURL = src.substring(0, src.lastIndexOf('/'));
					}
				}
	
				/**
				 * Base URL where the root directory if TinyMCE is located.
				 *
				 * @property baseURL
				 * @type String
				 */
				self.baseURL = new URI(documentBaseURL).toAbsolute(baseURL);
	
				/**
				 * Document base URL where the current document is located.
				 *
				 * @property documentBaseURL
				 * @type String
				 */
				self.documentBaseURL = documentBaseURL;
	
				/**
				 * Absolute baseURI for the installation path of TinyMCE.
				 *
				 * @property baseURI
				 * @type tinymce.util.URI
				 */
				self.baseURI = new URI(self.baseURL);
	
				/**
				 * Current suffix to add to each plugin/theme that gets loaded for example ".min".
				 *
				 * @property suffix
				 * @type String
				 */
				self.suffix = suffix;
	
				self.focusManager = new FocusManager(self);
			},
	
			/**
			 * Overrides the default settings for editor instances.
			 *
			 * @method overrideDefaults
			 * @param {Object} defaultSettings Defaults settings object.
			 */
			overrideDefaults: function(defaultSettings) {
				var baseUrl, suffix;
	
				baseUrl = defaultSettings.base_url;
				if (baseUrl) {
					this.baseURL = new URI(this.documentBaseURL).toAbsolute(baseUrl.replace(/\/+$/, ''));
					this.baseURI = new URI(this.baseURL);
				}
	
				suffix = defaultSettings.suffix;
				if (defaultSettings.suffix) {
					this.suffix = suffix;
				}
	
				this.defaultSettings = defaultSettings;
			},
	
			/**
			 * Initializes a set of editors. This method will create editors based on various settings.
			 *
			 * @method init
			 * @param {Object} settings Settings object to be passed to each editor instance.
			 * @return {tinymce.util.Promise} Promise that gets resolved with an array of editors when all editor instances are initialized.
			 * @example
			 * // Initializes a editor using the longer method
			 * tinymce.EditorManager.init({
			 *    some_settings : 'some value'
			 * });
			 *
			 * // Initializes a editor instance using the shorter version and with a promise
			 * tinymce.init({
			 *    some_settings : 'some value'
			 * }).then(function(editors) {
			 *    ...
			 * });
			 */
			init: function(settings) {
				var self = this, result;
	
				function createId(elm) {
					var id = elm.id;
	
					// Use element id, or unique name or generate a unique id
					if (!id) {
						id = elm.name;
	
						if (id && !DOM.get(id)) {
							id = elm.name;
						} else {
							// Generate unique name
							id = DOM.uniqueId();
						}
	
						elm.setAttribute('id', id);
					}
	
					return id;
				}
	
				function execCallback(name) {
					var callback = settings[name];
	
					if (!callback) {
						return;
					}
	
					return callback.apply(self, Array.prototype.slice.call(arguments, 2));
				}
	
				function hasClass(elm, className) {
					return className.constructor === RegExp ? className.test(elm.className) : DOM.hasClass(elm, className);
				}
	
				function findTargets(settings) {
					var l, targets = [];
	
					if (settings.types) {
						each(settings.types, function(type) {
							targets = targets.concat(DOM.select(type.selector));
						});
	
						return targets;
					} else if (settings.selector) {
						return DOM.select(settings.selector);
					} else if (settings.target) {
						return [settings.target];
					}
	
					// Fallback to old setting
					switch (settings.mode) {
						case "exact":
							l = settings.elements || '';
	
							if (l.length > 0) {
								each(explode(l), function(id) {
									var elm;
	
									if ((elm = DOM.get(id))) {
										targets.push(elm);
									} else {
										each(document.forms, function(f) {
											each(f.elements, function(e) {
												if (e.name === id) {
													id = 'mce_editor_' + instanceCounter++;
													DOM.setAttrib(e, 'id', id);
													targets.push(e);
												}
											});
										});
									}
								});
							}
							break;
	
						case "textareas":
						case "specific_textareas":
							each(DOM.select('textarea'), function(elm) {
								if (settings.editor_deselector && hasClass(elm, settings.editor_deselector)) {
									return;
								}
	
								if (!settings.editor_selector || hasClass(elm, settings.editor_selector)) {
									targets.push(elm);
								}
							});
							break;
					}
	
					return targets;
				}
	
				var provideResults = function(editors) {
					result = editors;
				};
	
				function initEditors() {
					var initCount = 0, editors = [], targets;
	
					function createEditor(id, settings, targetElm) {
						var editor = new Editor(id, settings, self);
	
						editors.push(editor);
	
						editor.on('init', function() {
							if (++initCount === targets.length) {
								provideResults(editors);
							}
						});
	
						editor.targetElm = editor.targetElm || targetElm;
						editor.render();
					}
	
					DOM.unbind(window, 'ready', initEditors);
					execCallback('onpageload');
	
					targets = $.unique(findTargets(settings));
	
					// TODO: Deprecate this one
					if (settings.types) {
						each(settings.types, function(type) {
							Tools.each(targets, function(elm) {
								if (DOM.is(elm, type.selector)) {
									createEditor(createId(elm), extend({}, settings, type), elm);
									return false;
								}
	
								return true;
							});
						});
	
						return;
					}
	
					Tools.each(targets, function(elm) {
						purgeDestroyedEditor(self.get(elm.id));
					});
	
					targets = Tools.grep(targets, function(elm) {
						return !self.get(elm.id);
					});
	
					each(targets, function(elm) {
						createEditor(createId(elm), settings, elm);
					});
				}
	
				self.settings = settings;
				DOM.bind(window, 'ready', initEditors);
	
				return new Promise(function(resolve) {
					if (result) {
						resolve(result);
					} else {
						provideResults = function(editors) {
							resolve(editors);
						};
					}
				});
			},
	
			/**
			 * Returns a editor instance by id.
			 *
			 * @method get
			 * @param {String/Number} id Editor instance id or index to return.
			 * @return {tinymce.Editor} Editor instance to return.
			 * @example
			 * // Adds an onclick event to an editor by id (shorter version)
			 * tinymce.get('mytextbox').on('click', function(e) {
			 *    ed.windowManager.alert('Hello world!');
			 * });
			 *
			 * // Adds an onclick event to an editor by id (longer version)
			 * tinymce.EditorManager.get('mytextbox').on('click', function(e) {
			 *    ed.windowManager.alert('Hello world!');
			 * });
			 */
			get: function(id) {
				if (!arguments.length) {
					return this.editors;
				}
	
				return id in this.editors ? this.editors[id] : null;
			},
	
			/**
			 * Adds an editor instance to the editor collection. This will also set it as the active editor.
			 *
			 * @method add
			 * @param {tinymce.Editor} editor Editor instance to add to the collection.
			 * @return {tinymce.Editor} The same instance that got passed in.
			 */
			add: function(editor) {
				var self = this, editors = self.editors;
	
				// Add named and index editor instance
				editors[editor.id] = editor;
				editors.push(editor);
	
				toggleGlobalEvents(editors, true);
	
				// Doesn't call setActive method since we don't want
				// to fire a bunch of activate/deactivate calls while initializing
				self.activeEditor = editor;
	
				/**
				 * Fires when an editor is added to the EditorManager collection.
				 *
				 * @event AddEditor
				 * @param {Object} e Event arguments.
				 */
				self.fire('AddEditor', {editor: editor});
	
				if (!beforeUnloadDelegate) {
					beforeUnloadDelegate = function() {
						self.fire('BeforeUnload');
					};
	
					DOM.bind(window, 'beforeunload', beforeUnloadDelegate);
				}
	
				return editor;
			},
	
			/**
			 * Creates an editor instance and adds it to the EditorManager collection.
			 *
			 * @method createEditor
			 * @param {String} id Instance id to use for editor.
			 * @param {Object} settings Editor instance settings.
			 * @return {tinymce.Editor} Editor instance that got created.
			 */
			createEditor: function(id, settings) {
				return this.add(new Editor(id, settings, this));
			},
	
			/**
			 * Removes a editor or editors form page.
			 *
			 * @example
			 * // Remove all editors bound to divs
			 * tinymce.remove('div');
			 *
			 * // Remove all editors bound to textareas
			 * tinymce.remove('textarea');
			 *
			 * // Remove all editors
			 * tinymce.remove();
			 *
			 * // Remove specific instance by id
			 * tinymce.remove('#id');
			 *
			 * @method remove
			 * @param {tinymce.Editor/String/Object} [selector] CSS selector or editor instance to remove.
			 * @return {tinymce.Editor} The editor that got passed in will be return if it was found otherwise null.
			 */
			remove: function(selector) {
				var self = this, i, editors = self.editors, editor;
	
				// Remove all editors
				if (!selector) {
					for (i = editors.length - 1; i >= 0; i--) {
						self.remove(editors[i]);
					}
	
					return;
				}
	
				// Remove editors by selector
				if (typeof selector == "string") {
					selector = selector.selector || selector;
	
					each(DOM.select(selector), function(elm) {
						editor = editors[elm.id];
	
						if (editor) {
							self.remove(editor);
						}
					});
	
					return;
				}
	
				// Remove specific editor
				editor = selector;
	
				// Not in the collection
				if (!editors[editor.id]) {
					return null;
				}
	
				/**
				 * Fires when an editor is removed from EditorManager collection.
				 *
				 * @event RemoveEditor
				 * @param {Object} e Event arguments.
				 */
				if (removeEditorFromList(editor)) {
					self.fire('RemoveEditor', {editor: editor});
				}
	
				if (!editors.length) {
					DOM.unbind(window, 'beforeunload', beforeUnloadDelegate);
				}
	
				editor.remove();
	
				toggleGlobalEvents(editors, editors.length > 0);
	
				return editor;
			},
	
			/**
			 * Executes a specific command on the currently active editor.
			 *
			 * @method execCommand
			 * @param {String} cmd Command to perform for example Bold.
			 * @param {Boolean} ui Optional boolean state if a UI should be presented for the command or not.
			 * @param {String} value Optional value parameter like for example an URL to a link.
			 * @return {Boolean} true/false if the command was executed or not.
			 */
			execCommand: function(cmd, ui, value) {
				var self = this, editor = self.get(value);
	
				// Manager commands
				switch (cmd) {
					case "mceAddEditor":
						if (!self.get(value)) {
							new Editor(value, self.settings, self).render();
						}
	
						return true;
	
					case "mceRemoveEditor":
						if (editor) {
							editor.remove();
						}
	
						return true;
	
					case 'mceToggleEditor':
						if (!editor) {
							self.execCommand('mceAddEditor', 0, value);
							return true;
						}
	
						if (editor.isHidden()) {
							editor.show();
						} else {
							editor.hide();
						}
	
						return true;
				}
	
				// Run command on active editor
				if (self.activeEditor) {
					return self.activeEditor.execCommand(cmd, ui, value);
				}
	
				return false;
			},
	
			/**
			 * Calls the save method on all editor instances in the collection. This can be useful when a form is to be submitted.
			 *
			 * @method triggerSave
			 * @example
			 * // Saves all contents
			 * tinyMCE.triggerSave();
			 */
			triggerSave: function() {
				each(this.editors, function(editor) {
					editor.save();
				});
			},
	
			/**
			 * Adds a language pack, this gets called by the loaded language files like en.js.
			 *
			 * @method addI18n
			 * @param {String} code Optional language code.
			 * @param {Object} items Name/value object with translations.
			 */
			addI18n: function(code, items) {
				I18n.add(code, items);
			},
	
			/**
			 * Translates the specified string using the language pack items.
			 *
			 * @method translate
			 * @param {String/Array/Object} text String to translate
			 * @return {String} Translated string.
			 */
			translate: function(text) {
				return I18n.translate(text);
			},
	
			/**
			 * Sets the active editor instance and fires the deactivate/activate events.
			 *
			 * @method setActive
			 * @param {tinymce.Editor} editor Editor instance to set as the active instance.
			 */
			setActive: function(editor) {
				var activeEditor = this.activeEditor;
	
				if (this.activeEditor != editor) {
					if (activeEditor) {
						activeEditor.fire('deactivate', {relatedTarget: editor});
					}
	
					editor.fire('activate', {relatedTarget: activeEditor});
				}
	
				this.activeEditor = editor;
			}
		};
	
		extend(EditorManager, Observable);
	
		EditorManager.setup();
	
		// Export EditorManager as tinymce/tinymce in global namespace
		window.tinymce = window.tinyMCE = EditorManager;
	
		return EditorManager;
	});
	
	// Included from: js/tinymce/classes/LegacyInput.js
	
	/**
	 * LegacyInput.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * Converts legacy input to modern HTML.
	 *
	 * @class tinymce.LegacyInput
	 * @private
	 */
	define("tinymce/LegacyInput", [
		"tinymce/EditorManager",
		"tinymce/util/Tools"
	], function(EditorManager, Tools) {
		var each = Tools.each, explode = Tools.explode;
	
		EditorManager.on('AddEditor', function(e) {
			var editor = e.editor;
	
			editor.on('preInit', function() {
				var filters, fontSizes, dom, settings = editor.settings;
	
				function replaceWithSpan(node, styles) {
					each(styles, function(value, name) {
						if (value) {
							dom.setStyle(node, name, value);
						}
					});
	
					dom.rename(node, 'span');
				}
	
				function convert(e) {
					dom = editor.dom;
	
					if (settings.convert_fonts_to_spans) {
						each(dom.select('font,u,strike', e.node), function(node) {
							filters[node.nodeName.toLowerCase()](dom, node);
						});
					}
				}
	
				if (settings.inline_styles) {
					fontSizes = explode(settings.font_size_legacy_values);
	
					filters = {
						font: function(dom, node) {
							replaceWithSpan(node, {
								backgroundColor: node.style.backgroundColor,
								color: node.color,
								fontFamily: node.face,
								fontSize: fontSizes[parseInt(node.size, 10) - 1]
							});
						},
	
						u: function(dom, node) {
							// HTML5 allows U element
							if (editor.settings.schema === "html4") {
								replaceWithSpan(node, {
									textDecoration: 'underline'
								});
							}
						},
	
						strike: function(dom, node) {
							replaceWithSpan(node, {
								textDecoration: 'line-through'
							});
						}
					};
	
					editor.on('PreProcess SetContent', convert);
				}
			});
		});
	});
	
	// Included from: js/tinymce/classes/util/XHR.js
	
	/**
	 * XHR.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * This class enables you to send XMLHTTPRequests cross browser.
	 * @class tinymce.util.XHR
	 * @mixes tinymce.util.Observable
	 * @static
	 * @example
	 * // Sends a low level Ajax request
	 * tinymce.util.XHR.send({
	 *    url: 'someurl',
	 *    success: function(text) {
	 *       console.debug(text);
	 *    }
	 * });
	 *
	 * // Add custom header to XHR request
	 * tinymce.util.XHR.on('beforeSend', function(e) {
	 *     e.xhr.setRequestHeader('X-Requested-With', 'Something');
	 * });
	 */
	define("tinymce/util/XHR", [
		"tinymce/util/Observable",
		"tinymce/util/Tools"
	], function(Observable, Tools) {
		var XHR = {
			/**
			 * Sends a XMLHTTPRequest.
			 * Consult the Wiki for details on what settings this method takes.
			 *
			 * @method send
			 * @param {Object} settings Object will target URL, callbacks and other info needed to make the request.
			 */
			send: function(settings) {
				var xhr, count = 0;
	
				function ready() {
					if (!settings.async || xhr.readyState == 4 || count++ > 10000) {
						if (settings.success && count < 10000 && xhr.status == 200) {
							settings.success.call(settings.success_scope, '' + xhr.responseText, xhr, settings);
						} else if (settings.error) {
							settings.error.call(settings.error_scope, count > 10000 ? 'TIMED_OUT' : 'GENERAL', xhr, settings);
						}
	
						xhr = null;
					} else {
						setTimeout(ready, 10);
					}
				}
	
				// Default settings
				settings.scope = settings.scope || this;
				settings.success_scope = settings.success_scope || settings.scope;
				settings.error_scope = settings.error_scope || settings.scope;
				settings.async = settings.async === false ? false : true;
				settings.data = settings.data || '';
	
				XHR.fire('beforeInitialize', {settings: settings});
	
				xhr = new XMLHttpRequest();
	
				if (xhr) {
					if (xhr.overrideMimeType) {
						xhr.overrideMimeType(settings.content_type);
					}
	
					xhr.open(settings.type || (settings.data ? 'POST' : 'GET'), settings.url, settings.async);
	
					if (settings.crossDomain) {
						xhr.withCredentials = true;
					}
	
					if (settings.content_type) {
						xhr.setRequestHeader('Content-Type', settings.content_type);
					}
	
					if (settings.requestheaders) {
						Tools.each(settings.requestheaders, function(header) {
							xhr.setRequestHeader(header.key, header.value);
						});
					}
	
					xhr.setRequestHeader('X-Requested-With', 'XMLHttpRequest');
	
					xhr = XHR.fire('beforeSend', {xhr: xhr, settings: settings}).xhr;
					xhr.send(settings.data);
	
					// Syncronous request
					if (!settings.async) {
						return ready();
					}
	
					// Wait for response, onReadyStateChange can not be used since it leaks memory in IE
					setTimeout(ready, 10);
				}
			}
		};
	
		Tools.extend(XHR, Observable);
	
		return XHR;
	});
	
	// Included from: js/tinymce/classes/util/JSON.js
	
	/**
	 * JSON.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * JSON parser and serializer class.
	 *
	 * @class tinymce.util.JSON
	 * @static
	 * @example
	 * // JSON parse a string into an object
	 * var obj = tinymce.util.JSON.parse(somestring);
	 *
	 * // JSON serialize a object into an string
	 * var str = tinymce.util.JSON.serialize(obj);
	 */
	define("tinymce/util/JSON", [], function() {
		function serialize(o, quote) {
			var i, v, t, name;
	
			quote = quote || '"';
	
			if (o === null) {
				return 'null';
			}
	
			t = typeof o;
	
			if (t == 'string') {
				v = '\bb\tt\nn\ff\rr\""\'\'\\\\';
	
				/*eslint no-control-regex:0 */
				return quote + o.replace(/([\u0080-\uFFFF\x00-\x1f\"\'\\])/g, function(a, b) {
					// Make sure single quotes never get encoded inside double quotes for JSON compatibility
					if (quote === '"' && a === "'") {
						return a;
					}
	
					i = v.indexOf(b);
	
					if (i + 1) {
						return '\\' + v.charAt(i + 1);
					}
	
					a = b.charCodeAt().toString(16);
	
					return '\\u' + '0000'.substring(a.length) + a;
				}) + quote;
			}
	
			if (t == 'object') {
				if (o.hasOwnProperty && Object.prototype.toString.call(o) === '[object Array]') {
					for (i = 0, v = '['; i < o.length; i++) {
						v += (i > 0 ? ',' : '') + serialize(o[i], quote);
					}
	
					return v + ']';
				}
	
				v = '{';
	
				for (name in o) {
					if (o.hasOwnProperty(name)) {
						v += typeof o[name] != 'function' ? (v.length > 1 ? ',' + quote : quote) + name +
							quote + ':' + serialize(o[name], quote) : '';
					}
				}
	
				return v + '}';
			}
	
			return '' + o;
		}
	
		return {
			/**
			 * Serializes the specified object as a JSON string.
			 *
			 * @method serialize
			 * @param {Object} obj Object to serialize as a JSON string.
			 * @param {String} quote Optional quote string defaults to ".
			 * @return {string} JSON string serialized from input.
			 */
			serialize: serialize,
	
			/**
			 * Unserializes/parses the specified JSON string into a object.
			 *
			 * @method parse
			 * @param {string} s JSON String to parse into a JavaScript object.
			 * @return {Object} Object from input JSON string or undefined if it failed.
			 */
			parse: function(text) {
				try {
					// Trick uglify JS
					return window[String.fromCharCode(101) + 'val']('(' + text + ')');
				} catch (ex) {
					// Ignore
				}
			}
	
			/**#@-*/
		};
	});
	
	// Included from: js/tinymce/classes/util/JSONRequest.js
	
	/**
	 * JSONRequest.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * This class enables you to use JSON-RPC to call backend methods.
	 *
	 * @class tinymce.util.JSONRequest
	 * @example
	 * var json = new tinymce.util.JSONRequest({
	 *     url: 'somebackend.php'
	 * });
	 *
	 * // Send RPC call 1
	 * json.send({
	 *     method: 'someMethod1',
	 *     params: ['a', 'b'],
	 *     success: function(result) {
	 *         console.dir(result);
	 *     }
	 * });
	 *
	 * // Send RPC call 2
	 * json.send({
	 *     method: 'someMethod2',
	 *     params: ['a', 'b'],
	 *     success: function(result) {
	 *         console.dir(result);
	 *     }
	 * });
	 */
	define("tinymce/util/JSONRequest", [
		"tinymce/util/JSON",
		"tinymce/util/XHR",
		"tinymce/util/Tools"
	], function(JSON, XHR, Tools) {
		var extend = Tools.extend;
	
		function JSONRequest(settings) {
			this.settings = extend({}, settings);
			this.count = 0;
		}
	
		/**
		 * Simple helper function to send a JSON-RPC request without the need to initialize an object.
		 * Consult the Wiki API documentation for more details on what you can pass to this function.
		 *
		 * @method sendRPC
		 * @static
		 * @param {Object} o Call object where there are three field id, method and params this object should also contain callbacks etc.
		 */
		JSONRequest.sendRPC = function(o) {
			return new JSONRequest().send(o);
		};
	
		JSONRequest.prototype = {
			/**
			 * Sends a JSON-RPC call. Consult the Wiki API documentation for more details on what you can pass to this function.
			 *
			 * @method send
			 * @param {Object} args Call object where there are three field id, method and params this object should also contain callbacks etc.
			 */
			send: function(args) {
				var ecb = args.error, scb = args.success;
	
				args = extend(this.settings, args);
	
				args.success = function(c, x) {
					c = JSON.parse(c);
	
					if (typeof c == 'undefined') {
						c = {
							error: 'JSON Parse error.'
						};
					}
	
					if (c.error) {
						ecb.call(args.error_scope || args.scope, c.error, x);
					} else {
						scb.call(args.success_scope || args.scope, c.result);
					}
				};
	
				args.error = function(ty, x) {
					if (ecb) {
						ecb.call(args.error_scope || args.scope, ty, x);
					}
				};
	
				args.data = JSON.serialize({
					id: args.id || 'c' + (this.count++),
					method: args.method,
					params: args.params
				});
	
				// JSON content type for Ruby on rails. Bug: #1883287
				args.content_type = 'application/json';
	
				XHR.send(args);
			}
		};
	
		return JSONRequest;
	});
	
	// Included from: js/tinymce/classes/util/JSONP.js
	
	/**
	 * JSONP.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	define("tinymce/util/JSONP", [
		"tinymce/dom/DOMUtils"
	], function(DOMUtils) {
		return {
			callbacks: {},
			count: 0,
	
			send: function(settings) {
				var self = this, dom = DOMUtils.DOM, count = settings.count !== undefined ? settings.count : self.count;
				var id = 'tinymce_jsonp_' + count;
	
				self.callbacks[count] = function(json) {
					dom.remove(id);
					delete self.callbacks[count];
	
					settings.callback(json);
				};
	
				dom.add(dom.doc.body, 'script', {
					id: id,
					src: settings.url,
					type: 'text/javascript'
				});
	
				self.count++;
			}
		};
	});
	
	// Included from: js/tinymce/classes/util/LocalStorage.js
	
	/**
	 * LocalStorage.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * This class will simulate LocalStorage on IE 7 and return the native version on modern browsers.
	 * Storage is done using userData on IE 7 and a special serialization format. The format is designed
	 * to be as small as possible by making sure that the keys and values doesn't need to be encoded. This
	 * makes it possible to store for example HTML data.
	 *
	 * Storage format for userData:
	 * <base 32 key length>,<key string>,<base 32 value length>,<value>,...
	 *
	 * For example this data key1=value1,key2=value2 would be:
	 * 4,key1,6,value1,4,key2,6,value2
	 *
	 * @class tinymce.util.LocalStorage
	 * @static
	 * @version 4.0
	 * @example
	 * tinymce.util.LocalStorage.setItem('key', 'value');
	 * var value = tinymce.util.LocalStorage.getItem('key');
	 */
	define("tinymce/util/LocalStorage", [], function() {
		var LocalStorage, storageElm, items, keys, userDataKey, hasOldIEDataSupport;
	
		// Check for native support
		try {
			if (window.localStorage) {
				return localStorage;
			}
		} catch (ex) {
			// Ignore
		}
	
		userDataKey = "tinymce";
		storageElm = document.documentElement;
		hasOldIEDataSupport = !!storageElm.addBehavior;
	
		if (hasOldIEDataSupport) {
			storageElm.addBehavior('#default#userData');
		}
	
		/**
		 * Gets the keys names and updates LocalStorage.length property. Since IE7 doesn't have any getters/setters.
		 */
		function updateKeys() {
			keys = [];
	
			for (var key in items) {
				keys.push(key);
			}
	
			LocalStorage.length = keys.length;
		}
	
		/**
		 * Loads the userData string and parses it into the items structure.
		 */
		function load() {
			var key, data, value, pos = 0;
	
			items = {};
	
			// localStorage can be disabled on WebKit/Gecko so make a dummy storage
			if (!hasOldIEDataSupport) {
				return;
			}
	
			function next(end) {
				var value, nextPos;
	
				nextPos = end !== undefined ? pos + end : data.indexOf(',', pos);
				if (nextPos === -1 || nextPos > data.length) {
					return null;
				}
	
				value = data.substring(pos, nextPos);
				pos = nextPos + 1;
	
				return value;
			}
	
			storageElm.load(userDataKey);
			data = storageElm.getAttribute(userDataKey) || '';
	
			do {
				var offset = next();
				if (offset === null) {
					break;
				}
	
				key = next(parseInt(offset, 32) || 0);
				if (key !== null) {
					offset = next();
					if (offset === null) {
						break;
					}
	
					value = next(parseInt(offset, 32) || 0);
	
					if (key) {
						items[key] = value;
					}
				}
			} while (key !== null);
	
			updateKeys();
		}
	
		/**
		 * Saves the items structure into a the userData format.
		 */
		function save() {
			var value, data = '';
	
			// localStorage can be disabled on WebKit/Gecko so make a dummy storage
			if (!hasOldIEDataSupport) {
				return;
			}
	
			for (var key in items) {
				value = items[key];
				data += (data ? ',' : '') + key.length.toString(32) + ',' + key + ',' + value.length.toString(32) + ',' + value;
			}
	
			storageElm.setAttribute(userDataKey, data);
	
			try {
				storageElm.save(userDataKey);
			} catch (ex) {
				// Ignore disk full
			}
	
			updateKeys();
		}
	
		LocalStorage = {
			/**
			 * Length of the number of items in storage.
			 *
			 * @property length
			 * @type Number
			 * @return {Number} Number of items in storage.
			 */
			//length:0,
	
			/**
			 * Returns the key name by index.
			 *
			 * @method key
			 * @param {Number} index Index of key to return.
			 * @return {String} Key value or null if it wasn't found.
			 */
			key: function(index) {
				return keys[index];
			},
	
			/**
			 * Returns the value if the specified key or null if it wasn't found.
			 *
			 * @method getItem
			 * @param {String} key Key of item to retrieve.
			 * @return {String} Value of the specified item or null if it wasn't found.
			 */
			getItem: function(key) {
				return key in items ? items[key] : null;
			},
	
			/**
			 * Sets the value of the specified item by it's key.
			 *
			 * @method setItem
			 * @param {String} key Key of the item to set.
			 * @param {String} value Value of the item to set.
			 */
			setItem: function(key, value) {
				items[key] = "" + value;
				save();
			},
	
			/**
			 * Removes the specified item by key.
			 *
			 * @method removeItem
			 * @param {String} key Key of item to remove.
			 */
			removeItem: function(key) {
				delete items[key];
				save();
			},
	
			/**
			 * Removes all items.
			 *
			 * @method clear
			 */
			clear: function() {
				items = {};
				save();
			}
		};
	
		load();
	
		return LocalStorage;
	});
	
	// Included from: js/tinymce/classes/Compat.js
	
	/**
	 * Compat.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * TinyMCE core class.
	 *
	 * @static
	 * @class tinymce
	 * @borrow-members tinymce.EditorManager
	 * @borrow-members tinymce.util.Tools
	 */
	define("tinymce/Compat", [
		"tinymce/dom/DOMUtils",
		"tinymce/dom/EventUtils",
		"tinymce/dom/ScriptLoader",
		"tinymce/AddOnManager",
		"tinymce/util/Tools",
		"tinymce/Env"
	], function(DOMUtils, EventUtils, ScriptLoader, AddOnManager, Tools, Env) {
		var tinymce = window.tinymce;
	
		/**
		 * @property {tinymce.dom.DOMUtils} DOM Global DOM instance.
		 * @property {tinymce.dom.ScriptLoader} ScriptLoader Global ScriptLoader instance.
		 * @property {tinymce.AddOnManager} PluginManager Global PluginManager instance.
		 * @property {tinymce.AddOnManager} ThemeManager Global ThemeManager instance.
		 */
		tinymce.DOM = DOMUtils.DOM;
		tinymce.ScriptLoader = ScriptLoader.ScriptLoader;
		tinymce.PluginManager = AddOnManager.PluginManager;
		tinymce.ThemeManager = AddOnManager.ThemeManager;
	
		tinymce.dom = tinymce.dom || {};
		tinymce.dom.Event = EventUtils.Event;
	
		Tools.each(Tools, function(func, key) {
			tinymce[key] = func;
		});
	
		Tools.each('isOpera isWebKit isIE isGecko isMac'.split(' '), function(name) {
			tinymce[name] = Env[name.substr(2).toLowerCase()];
		});
	
		return {};
	});
	
	// Describe the different namespaces
	
	/**
	 * Root level namespace this contains classes directly related to the TinyMCE editor.
	 *
	 * @namespace tinymce
	 */
	
	/**
	 * Contains classes for handling the browsers DOM.
	 *
	 * @namespace tinymce.dom
	 */
	
	/**
	 * Contains html parser and serializer logic.
	 *
	 * @namespace tinymce.html
	 */
	
	/**
	 * Contains the different UI types such as buttons, listboxes etc.
	 *
	 * @namespace tinymce.ui
	 */
	
	/**
	 * Contains various utility classes such as json parser, cookies etc.
	 *
	 * @namespace tinymce.util
	 */
	
	/**
	 * Contains modules to handle data binding.
	 *
	 * @namespace tinymce.data
	 */
	
	// Included from: js/tinymce/classes/ui/Layout.js
	
	/**
	 * Layout.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * Base layout manager class.
	 *
	 * @class tinymce.ui.Layout
	 */
	define("tinymce/ui/Layout", [
		"tinymce/util/Class",
		"tinymce/util/Tools"
	], function(Class, Tools) {
		"use strict";
	
		return Class.extend({
			Defaults: {
				firstControlClass: 'first',
				lastControlClass: 'last'
			},
	
			/**
			 * Constructs a layout instance with the specified settings.
			 *
			 * @constructor
			 * @param {Object} settings Name/value object with settings.
			 */
			init: function(settings) {
				this.settings = Tools.extend({}, this.Defaults, settings);
			},
	
			/**
			 * This method gets invoked before the layout renders the controls.
			 *
			 * @method preRender
			 * @param {tinymce.ui.Container} container Container instance to preRender.
			 */
			preRender: function(container) {
				container.bodyClasses.add(this.settings.containerClass);
			},
	
			/**
			 * Applies layout classes to the container.
			 *
			 * @private
			 */
			applyClasses: function(items) {
				var self = this, settings = self.settings, firstClass, lastClass, firstItem, lastItem;
	
				firstClass = settings.firstControlClass;
				lastClass = settings.lastControlClass;
	
				items.each(function(item) {
					item.classes.remove(firstClass).remove(lastClass).add(settings.controlClass);
	
					if (item.visible()) {
						if (!firstItem) {
							firstItem = item;
						}
	
						lastItem = item;
					}
				});
	
				if (firstItem) {
					firstItem.classes.add(firstClass);
				}
	
				if (lastItem) {
					lastItem.classes.add(lastClass);
				}
			},
	
			/**
			 * Renders the specified container and any layout specific HTML.
			 *
			 * @method renderHtml
			 * @param {tinymce.ui.Container} container Container to render HTML for.
			 */
			renderHtml: function(container) {
				var self = this, html = '';
	
				self.applyClasses(container.items());
	
				container.items().each(function(item) {
					html += item.renderHtml();
				});
	
				return html;
			},
	
			/**
			 * Recalculates the positions of the controls in the specified container.
			 *
			 * @method recalc
			 * @param {tinymce.ui.Container} container Container instance to recalc.
			 */
			recalc: function() {
			},
	
			/**
			 * This method gets invoked after the layout renders the controls.
			 *
			 * @method postRender
			 * @param {tinymce.ui.Container} container Container instance to postRender.
			 */
			postRender: function() {
			},
	
			isNative: function() {
				return false;
			}
		});
	});
	
	// Included from: js/tinymce/classes/ui/AbsoluteLayout.js
	
	/**
	 * AbsoluteLayout.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * LayoutManager for absolute positioning. This layout manager is more of
	 * a base class for other layouts but can be created and used directly.
	 *
	 * @-x-less AbsoluteLayout.less
	 * @class tinymce.ui.AbsoluteLayout
	 * @extends tinymce.ui.Layout
	 */
	define("tinymce/ui/AbsoluteLayout", [
		"tinymce/ui/Layout"
	], function(Layout) {
		"use strict";
	
		return Layout.extend({
			Defaults: {
				containerClass: 'abs-layout',
				controlClass: 'abs-layout-item'
			},
	
			/**
			 * Recalculates the positions of the controls in the specified container.
			 *
			 * @method recalc
			 * @param {tinymce.ui.Container} container Container instance to recalc.
			 */
			recalc: function(container) {
				container.items().filter(':visible').each(function(ctrl) {
					var settings = ctrl.settings;
	
					ctrl.layoutRect({
						x: settings.x,
						y: settings.y,
						w: settings.w,
						h: settings.h
					});
	
					if (ctrl.recalc) {
						ctrl.recalc();
					}
				});
			},
	
			/**
			 * Renders the specified container and any layout specific HTML.
			 *
			 * @method renderHtml
			 * @param {tinymce.ui.Container} container Container to render HTML for.
			 */
			renderHtml: function(container) {
				return '<div id="' + container._id + '-absend" class="' + container.classPrefix + 'abs-end"></div>' + this._super(container);
			}
		});
	});
	
	// Included from: js/tinymce/classes/ui/Button.js
	
	/**
	 * Button.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * This class is used to create buttons. You can create them directly or through the Factory.
	 *
	 * @example
	 * // Create and render a button to the body element
	 * tinymce.ui.Factory.create({
	 *     type: 'button',
	 *     text: 'My button'
	 * }).renderTo(document.body);
	 *
	 * @-x-less Button.less
	 * @class tinymce.ui.Button
	 * @extends tinymce.ui.Widget
	 */
	define("tinymce/ui/Button", [
		"tinymce/ui/Widget"
	], function(Widget) {
		"use strict";
	
		return Widget.extend({
			Defaults: {
				classes: "widget btn",
				role: "button"
			},
	
			/**
			 * Constructs a new button instance with the specified settings.
			 *
			 * @constructor
			 * @param {Object} settings Name/value object with settings.
			 * @setting {String} size Size of the button small|medium|large.
			 * @setting {String} image Image to use for icon.
			 * @setting {String} icon Icon to use for button.
			 */
			init: function(settings) {
				var self = this, size;
	
				self._super(settings);
				settings = self.settings;
	
				size = self.settings.size;
	
				self.on('click mousedown', function(e) {
					e.preventDefault();
				});
	
				self.on('touchstart', function(e) {
					self.fire('click', e);
					e.preventDefault();
				});
	
				if (settings.subtype) {
					self.classes.add(settings.subtype);
				}
	
				if (size) {
					self.classes.add('btn-' + size);
				}
	
				if (settings.icon) {
					self.icon(settings.icon);
				}
			},
	
			/**
			 * Sets/gets the current button icon.
			 *
			 * @method icon
			 * @param {String} [icon] New icon identifier.
			 * @return {String|tinymce.ui.MenuButton} Current icon or current MenuButton instance.
			 */
			icon: function(icon) {
				if (!arguments.length) {
					return this.state.get('icon');
				}
	
				this.state.set('icon', icon);
	
				return this;
			},
	
			/**
			 * Repaints the button for example after it's been resizes by a layout engine.
			 *
			 * @method repaint
			 */
			repaint: function() {
				var btnElm = this.getEl().firstChild,
					btnStyle;
	
				if (btnElm) {
					btnStyle = btnElm.style;
					btnStyle.width = btnStyle.height = "100%";
				}
	
				this._super();
			},
	
			/**
			 * Renders the control as a HTML string.
			 *
			 * @method renderHtml
			 * @return {String} HTML representing the control.
			 */
			renderHtml: function() {
				var self = this, id = self._id, prefix = self.classPrefix;
				var icon = self.state.get('icon'), image, text = self.state.get('text'), textHtml = '';
	
				image = self.settings.image;
				if (image) {
					icon = 'none';
	
					// Support for [high dpi, low dpi] image sources
					if (typeof image != "string") {
						image = window.getSelection ? image[0] : image[1];
					}
	
					image = ' style="background-image: url(\'' + image + '\')"';
				} else {
					image = '';
				}
	
				if (text) {
					self.classes.add('btn-has-text');
					textHtml = '<span class="' + prefix + 'txt">' + self.encode(text) + '</span>';
				}
	
				icon = self.settings.icon ? prefix + 'ico ' + prefix + 'i-' + icon : '';
	
				return (
					'<div id="' + id + '" class="' + self.classes + '" tabindex="-1" aria-labelledby="' + id + '">' +
						'<button role="presentation" type="button" tabindex="-1">' +
							(icon ? '<i class="' + icon + '"' + image + '></i>' : '') +
							textHtml +
						'</button>' +
					'</div>'
				);
			},
	
			bindStates: function() {
				var self = this, $ = self.$, textCls = self.classPrefix + 'txt';
	
				function setButtonText(text) {
					var $span = $('span.' + textCls, self.getEl());
	
					if (text) {
						if (!$span[0]) {
							$('button:first', self.getEl()).append('<span class="' + textCls + '"></span>');
							$span = $('span.' + textCls, self.getEl());
						}
	
						$span.html(self.encode(text));
					} else {
						$span.remove();
					}
	
					self.classes.toggle('btn-has-text', !!text);
				}
	
				self.state.on('change:text', function(e) {
					setButtonText(e.value);
				});
	
				self.state.on('change:icon', function(e) {
					var icon = e.value, prefix = self.classPrefix;
	
					self.settings.icon = icon;
					icon = icon ? prefix + 'ico ' + prefix + 'i-' + self.settings.icon : '';
	
					var btnElm = self.getEl().firstChild, iconElm = btnElm.getElementsByTagName('i')[0];
	
					if (icon) {
						if (!iconElm || iconElm != btnElm.firstChild) {
							iconElm = document.createElement('i');
							btnElm.insertBefore(iconElm, btnElm.firstChild);
						}
	
						iconElm.className = icon;
					} else if (iconElm) {
						btnElm.removeChild(iconElm);
					}
	
					setButtonText(self.state.get('text'));
				});
	
				return self._super();
			}
		});
	});
	
	// Included from: js/tinymce/classes/ui/ButtonGroup.js
	
	/**
	 * ButtonGroup.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * This control enables you to put multiple buttons into a group. This is
	 * useful when you want to combine similar toolbar buttons into a group.
	 *
	 * @example
	 * // Create and render a buttongroup with two buttons to the body element
	 * tinymce.ui.Factory.create({
	 *     type: 'buttongroup',
	 *     items: [
	 *         {text: 'Button A'},
	 *         {text: 'Button B'}
	 *     ]
	 * }).renderTo(document.body);
	 *
	 * @-x-less ButtonGroup.less
	 * @class tinymce.ui.ButtonGroup
	 * @extends tinymce.ui.Container
	 */
	define("tinymce/ui/ButtonGroup", [
		"tinymce/ui/Container"
	], function(Container) {
		"use strict";
	
		return Container.extend({
			Defaults: {
				defaultType: 'button',
				role: 'group'
			},
	
			/**
			 * Renders the control as a HTML string.
			 *
			 * @method renderHtml
			 * @return {String} HTML representing the control.
			 */
			renderHtml: function() {
				var self = this, layout = self._layout;
	
				self.classes.add('btn-group');
				self.preRender();
				layout.preRender(self);
	
				return (
					'<div id="' + self._id + '" class="' + self.classes + '">' +
						'<div id="' + self._id + '-body">' +
							(self.settings.html || '') + layout.renderHtml(self) +
						'</div>' +
					'</div>'
				);
			}
		});
	});
	
	// Included from: js/tinymce/classes/ui/Checkbox.js
	
	/**
	 * Checkbox.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * This control creates a custom checkbox.
	 *
	 * @example
	 * // Create and render a checkbox to the body element
	 * tinymce.ui.Factory.create({
	 *     type: 'checkbox',
	 *     checked: true,
	 *     text: 'My checkbox'
	 * }).renderTo(document.body);
	 *
	 * @-x-less Checkbox.less
	 * @class tinymce.ui.Checkbox
	 * @extends tinymce.ui.Widget
	 */
	define("tinymce/ui/Checkbox", [
		"tinymce/ui/Widget"
	], function(Widget) {
		"use strict";
	
		return Widget.extend({
			Defaults: {
				classes: "checkbox",
				role: "checkbox",
				checked: false
			},
	
			/**
			 * Constructs a new Checkbox instance with the specified settings.
			 *
			 * @constructor
			 * @param {Object} settings Name/value object with settings.
			 * @setting {Boolean} checked True if the checkbox should be checked by default.
			 */
			init: function(settings) {
				var self = this;
	
				self._super(settings);
	
				self.on('click mousedown', function(e) {
					e.preventDefault();
				});
	
				self.on('click', function(e) {
					e.preventDefault();
	
					if (!self.disabled()) {
						self.checked(!self.checked());
					}
				});
	
				self.checked(self.settings.checked);
			},
	
			/**
			 * Getter/setter function for the checked state.
			 *
			 * @method checked
			 * @param {Boolean} [state] State to be set.
			 * @return {Boolean|tinymce.ui.Checkbox} True/false or checkbox if it's a set operation.
			 */
			checked: function(state) {
				if (!arguments.length) {
					return this.state.get('checked');
				}
	
				this.state.set('checked', state);
	
				return this;
			},
	
			/**
			 * Getter/setter function for the value state.
			 *
			 * @method value
			 * @param {Boolean} [state] State to be set.
			 * @return {Boolean|tinymce.ui.Checkbox} True/false or checkbox if it's a set operation.
			 */
			value: function(state) {
				if (!arguments.length) {
					return this.checked();
				}
	
				return this.checked(state);
			},
	
			/**
			 * Renders the control as a HTML string.
			 *
			 * @method renderHtml
			 * @return {String} HTML representing the control.
			 */
			renderHtml: function() {
				var self = this, id = self._id, prefix = self.classPrefix;
	
				return (
					'<div id="' + id + '" class="' + self.classes + '" unselectable="on" aria-labelledby="' + id + '-al" tabindex="-1">' +
						'<i class="' + prefix + 'ico ' + prefix + 'i-checkbox"></i>' +
						'<span id="' + id + '-al" class="' + prefix + 'label">' + self.encode(self.state.get('text')) + '</span>' +
					'</div>'
				);
			},
	
			bindStates: function() {
				var self = this;
	
				function checked(state) {
					self.classes.toggle("checked", state);
					self.aria('checked', state);
				}
	
				self.state.on('change:text', function(e) {
					self.getEl('al').firstChild.data = self.translate(e.value);
				});
	
				self.state.on('change:checked change:value', function(e) {
					self.fire('change');
					checked(e.value);
				});
	
				self.state.on('change:icon', function(e) {
					var icon = e.value, prefix = self.classPrefix;
	
					if (typeof icon == 'undefined') {
						return self.settings.icon;
					}
	
					self.settings.icon = icon;
					icon = icon ? prefix + 'ico ' + prefix + 'i-' + self.settings.icon : '';
	
					var btnElm = self.getEl().firstChild, iconElm = btnElm.getElementsByTagName('i')[0];
	
					if (icon) {
						if (!iconElm || iconElm != btnElm.firstChild) {
							iconElm = document.createElement('i');
							btnElm.insertBefore(iconElm, btnElm.firstChild);
						}
	
						iconElm.className = icon;
					} else if (iconElm) {
						btnElm.removeChild(iconElm);
					}
				});
	
				if (self.state.get('checked')) {
					checked(true);
				}
	
				return self._super();
			}
		});
	});
	
	// Included from: js/tinymce/classes/ui/ComboBox.js
	
	/**
	 * ComboBox.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * This class creates a combobox control. Select box that you select a value from or
	 * type a value into.
	 *
	 * @-x-less ComboBox.less
	 * @class tinymce.ui.ComboBox
	 * @extends tinymce.ui.Widget
	 */
	define("tinymce/ui/ComboBox", [
		"tinymce/ui/Widget",
		"tinymce/ui/Factory",
		"tinymce/ui/DomUtils",
		"tinymce/dom/DomQuery"
	], function(Widget, Factory, DomUtils, $) {
		"use strict";
	
		return Widget.extend({
			/**
			 * Constructs a new control instance with the specified settings.
			 *
			 * @constructor
			 * @param {Object} settings Name/value object with settings.
			 * @setting {String} placeholder Placeholder text to display.
			 */
			init: function(settings) {
				var self = this;
	
				self._super(settings);
				settings = self.settings;
	
				self.classes.add('combobox');
				self.subinput = true;
				self.ariaTarget = 'inp'; // TODO: Figure out a better way
	
				settings.menu = settings.menu || settings.values;
	
				if (settings.menu) {
					settings.icon = 'caret';
				}
	
				self.on('click', function(e) {
					var elm = e.target, root = self.getEl();
	
					if (!$.contains(root, elm) && elm != root) {
						return;
					}
	
					while (elm && elm != root) {
						if (elm.id && elm.id.indexOf('-open') != -1) {
							self.fire('action');
	
							if (settings.menu) {
								self.showMenu();
	
								if (e.aria) {
									self.menu.items()[0].focus();
								}
							}
						}
	
						elm = elm.parentNode;
					}
				});
	
				// TODO: Rework this
				self.on('keydown', function(e) {
					if (e.target.nodeName == "INPUT" && e.keyCode == 13) {
						self.parents().reverse().each(function(ctrl) {
							var stateValue = self.state.get('value'), inputValue = self.getEl('inp').value;
	
							e.preventDefault();
	
							self.state.set('value', inputValue);
	
							if (stateValue != inputValue) {
								self.fire('change');
							}
	
							if (ctrl.hasEventListeners('submit') && ctrl.toJSON) {
								ctrl.fire('submit', {data: ctrl.toJSON()});
								return false;
							}
						});
					}
				});
	
				self.on('keyup', function(e) {
					if (e.target.nodeName == "INPUT") {
						self.state.set('value', e.target.value);
					}
				});
			},
	
			showMenu: function() {
				var self = this, settings = self.settings, menu;
	
				if (!self.menu) {
					menu = settings.menu || [];
	
					// Is menu array then auto constuct menu control
					if (menu.length) {
						menu = {
							type: 'menu',
							items: menu
						};
					} else {
						menu.type = menu.type || 'menu';
					}
	
					self.menu = Factory.create(menu).parent(self).renderTo(self.getContainerElm());
					self.fire('createmenu');
					self.menu.reflow();
					self.menu.on('cancel', function(e) {
						if (e.control === self.menu) {
							self.focus();
						}
					});
	
					self.menu.on('show hide', function(e) {
						e.control.items().each(function(ctrl) {
							ctrl.active(ctrl.value() == self.value());
						});
					}).fire('show');
	
					self.menu.on('select', function(e) {
						self.value(e.control.value());
					});
	
					self.on('focusin', function(e) {
						if (e.target.tagName.toUpperCase() == 'INPUT') {
							self.menu.hide();
						}
					});
	
					self.aria('expanded', true);
				}
	
				self.menu.show();
				self.menu.layoutRect({w: self.layoutRect().w});
				self.menu.moveRel(self.getEl(), self.isRtl() ? ['br-tr', 'tr-br'] : ['bl-tl', 'tl-bl']);
			},
	
			/**
			 * Focuses the input area of the control.
			 *
			 * @method focus
			 */
			focus: function() {
				this.getEl('inp').focus();
			},
	
			/**
			 * Repaints the control after a layout operation.
			 *
			 * @method repaint
			 */
			repaint: function() {
				var self = this, elm = self.getEl(), openElm = self.getEl('open'), rect = self.layoutRect();
				var width, lineHeight;
	
				if (openElm) {
					width = rect.w - DomUtils.getSize(openElm).width - 10;
				} else {
					width = rect.w - 10;
				}
	
				// Detect old IE 7+8 add lineHeight to align caret vertically in the middle
				var doc = document;
				if (doc.all && (!doc.documentMode || doc.documentMode <= 8)) {
					lineHeight = (self.layoutRect().h - 2) + 'px';
				}
	
				$(elm.firstChild).css({
					width: width,
					lineHeight: lineHeight
				});
	
				self._super();
	
				return self;
			},
	
			/**
			 * Post render method. Called after the control has been rendered to the target.
			 *
			 * @method postRender
			 * @return {tinymce.ui.ComboBox} Current combobox instance.
			 */
			postRender: function() {
				var self = this;
	
				$(this.getEl('inp')).on('change', function(e) {
					self.state.set('value', e.target.value);
					self.fire('change', e);
				});
	
				return self._super();
			},
	
			/**
			 * Renders the control as a HTML string.
			 *
			 * @method renderHtml
			 * @return {String} HTML representing the control.
			 */
			renderHtml: function() {
				var self = this, id = self._id, settings = self.settings, prefix = self.classPrefix;
				var value = self.state.get('value') || '';
				var icon, text, openBtnHtml = '', extraAttrs = '';
	
				if ("spellcheck" in settings) {
					extraAttrs += ' spellcheck="' + settings.spellcheck + '"';
				}
	
				if (settings.maxLength) {
					extraAttrs += ' maxlength="' + settings.maxLength + '"';
				}
	
				if (settings.size) {
					extraAttrs += ' size="' + settings.size + '"';
				}
	
				if (settings.subtype) {
					extraAttrs += ' type="' + settings.subtype + '"';
				}
	
				if (self.disabled()) {
					extraAttrs += ' disabled="disabled"';
				}
	
				icon = settings.icon;
				if (icon && icon != 'caret') {
					icon = prefix + 'ico ' + prefix + 'i-' + settings.icon;
				}
	
				text = self.state.get('text');
	
				if (icon || text) {
					openBtnHtml = (
						'<div id="' + id + '-open" class="' + prefix + 'btn ' + prefix + 'open" tabIndex="-1" role="button">' +
							'<button id="' + id + '-action" type="button" hidefocus="1" tabindex="-1">' +
								(icon != 'caret' ? '<i class="' + icon + '"></i>' : '<i class="' + prefix + 'caret"></i>') +
								(text ? (icon ? ' ' : '') + text : '') +
							'</button>' +
						'</div>'
					);
	
					self.classes.add('has-open');
				}
	
				return (
					'<div id="' + id + '" class="' + self.classes + '">' +
						'<input id="' + id + '-inp" class="' + prefix + 'textbox" value="' +
						self.encode(value, false) + '" hidefocus="1"' + extraAttrs + ' placeholder="' +
						self.encode(settings.placeholder) + '" />' +
						openBtnHtml +
					'</div>'
				);
			},
	
			value: function(value) {
				if (arguments.length) {
					this.state.set('value', value);
					return this;
				}
	
				// Make sure the real state is in sync
				if (this.state.get('rendered')) {
					this.state.set('value', this.getEl('inp').value);
				}
	
				return this.state.get('value');
			},
	
			bindStates: function() {
				var self = this;
	
				self.state.on('change:value', function(e) {
					if (self.getEl('inp').value != e.value) {
						self.getEl('inp').value = e.value;
					}
				});
	
				self.state.on('change:disabled', function(e) {
					self.getEl('inp').disabled = e.value;
				});
	
				return self._super();
			},
	
			remove: function() {
				$(this.getEl('inp')).off();
				this._super();
			}
		});
	});
	
	// Included from: js/tinymce/classes/ui/ColorBox.js
	
	/**
	 * ColorBox.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * This widget lets you enter colors and browse for colors by pressing the color button. It also displays
	 * a preview of the current color.
	 *
	 * @-x-less ColorBox.less
	 * @class tinymce.ui.ColorBox
	 * @extends tinymce.ui.ComboBox
	 */
	define("tinymce/ui/ColorBox", [
		"tinymce/ui/ComboBox"
	], function(ComboBox) {
		"use strict";
	
		return ComboBox.extend({
			/**
			 * Constructs a new control instance with the specified settings.
			 *
			 * @constructor
			 * @param {Object} settings Name/value object with settings.
			 */
			init: function(settings) {
				var self = this;
	
				settings.spellcheck = false;
	
				if (settings.onaction) {
					settings.icon = 'none';
				}
	
				self._super(settings);
	
				self.classes.add('colorbox');
				self.on('change keyup postrender', function() {
					self.repaintColor(self.value());
				});
			},
	
			repaintColor: function(value) {
				var elm = this.getEl().getElementsByTagName('i')[0];
	
				if (elm) {
					try {
						elm.style.background = value;
					} catch (ex) {
						// Ignore
					}
				}
			},
	
			bindStates: function() {
				var self = this;
	
				self.state.on('change:value', function(e) {
					if (self.state.get('rendered')) {
						self.repaintColor(e.value);
					}
				});
	
				return self._super();
			}
		});
	});
	
	// Included from: js/tinymce/classes/ui/PanelButton.js
	
	/**
	 * PanelButton.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * Creates a new panel button.
	 *
	 * @class tinymce.ui.PanelButton
	 * @extends tinymce.ui.Button
	 */
	define("tinymce/ui/PanelButton", [
		"tinymce/ui/Button",
		"tinymce/ui/FloatPanel"
	], function(Button, FloatPanel) {
		"use strict";
	
		return Button.extend({
			/**
			 * Shows the panel for the button.
			 *
			 * @method showPanel
			 */
			showPanel: function() {
				var self = this, settings = self.settings;
	
				self.active(true);
	
				if (!self.panel) {
					var panelSettings = settings.panel;
	
					// Wrap panel in grid layout if type if specified
					// This makes it possible to add forms or other containers directly in the panel option
					if (panelSettings.type) {
						panelSettings = {
							layout: 'grid',
							items: panelSettings
						};
					}
	
					panelSettings.role = panelSettings.role || 'dialog';
					panelSettings.popover = true;
					panelSettings.autohide = true;
					panelSettings.ariaRoot = true;
	
					self.panel = new FloatPanel(panelSettings).on('hide', function() {
						self.active(false);
					}).on('cancel', function(e) {
						e.stopPropagation();
						self.focus();
						self.hidePanel();
					}).parent(self).renderTo(self.getContainerElm());
	
					self.panel.fire('show');
					self.panel.reflow();
				} else {
					self.panel.show();
				}
	
				self.panel.moveRel(self.getEl(), settings.popoverAlign || (self.isRtl() ? ['bc-tr', 'bc-tc'] : ['bc-tl', 'bc-tc']));
			},
	
			/**
			 * Hides the panel for the button.
			 *
			 * @method hidePanel
			 */
			hidePanel: function() {
				var self = this;
	
				if (self.panel) {
					self.panel.hide();
				}
			},
	
			/**
			 * Called after the control has been rendered.
			 *
			 * @method postRender
			 */
			postRender: function() {
				var self = this;
	
				self.aria('haspopup', true);
	
				self.on('click', function(e) {
					if (e.control === self) {
						if (self.panel && self.panel.visible()) {
							self.hidePanel();
						} else {
							self.showPanel();
							self.panel.focus(!!e.aria);
						}
					}
				});
	
				return self._super();
			},
	
			remove: function() {
				if (this.panel) {
					this.panel.remove();
					this.panel = null;
				}
	
				return this._super();
			}
		});
	});
	
	// Included from: js/tinymce/classes/ui/ColorButton.js
	
	/**
	 * ColorButton.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * This class creates a color button control. This is a split button in which the main
	 * button has a visual representation of the currently selected color. When clicked
	 * the caret button displays a color picker, allowing the user to select a new color.
	 *
	 * @-x-less ColorButton.less
	 * @class tinymce.ui.ColorButton
	 * @extends tinymce.ui.PanelButton
	 */
	define("tinymce/ui/ColorButton", [
		"tinymce/ui/PanelButton",
		"tinymce/dom/DOMUtils"
	], function(PanelButton, DomUtils) {
		"use strict";
	
		var DOM = DomUtils.DOM;
	
		return PanelButton.extend({
			/**
			 * Constructs a new ColorButton instance with the specified settings.
			 *
			 * @constructor
			 * @param {Object} settings Name/value object with settings.
			 */
			init: function(settings) {
				this._super(settings);
				this.classes.add('colorbutton');
			},
	
			/**
			 * Getter/setter for the current color.
			 *
			 * @method color
			 * @param {String} [color] Color to set.
			 * @return {String|tinymce.ui.ColorButton} Current color or current instance.
			 */
			color: function(color) {
				if (color) {
					this._color = color;
					this.getEl('preview').style.backgroundColor = color;
					return this;
				}
	
				return this._color;
			},
	
			/**
			 * Resets the current color.
			 *
			 * @method resetColor
			 * @return {tinymce.ui.ColorButton} Current instance.
			 */
			resetColor: function() {
				this._color = null;
				this.getEl('preview').style.backgroundColor = null;
				return this;
			},
	
			/**
			 * Renders the control as a HTML string.
			 *
			 * @method renderHtml
			 * @return {String} HTML representing the control.
			 */
			renderHtml: function() {
				var self = this, id = self._id, prefix = self.classPrefix, text = self.state.get('text');
				var icon = self.settings.icon ? prefix + 'ico ' + prefix + 'i-' + self.settings.icon : '';
				var image = self.settings.image ? ' style="background-image: url(\'' + self.settings.image + '\')"' : '',
					textHtml = '';
	
				if (text) {
					self.classes.add('btn-has-text');
					textHtml = '<span class="' + prefix + 'txt">' + self.encode(text) + '</span>';
				}
	
				return (
					'<div id="' + id + '" class="' + self.classes + '" role="button" tabindex="-1" aria-haspopup="true">' +
						'<button role="presentation" hidefocus="1" type="button" tabindex="-1">' +
							(icon ? '<i class="' + icon + '"' + image + '></i>' : '') +
							'<span id="' + id + '-preview" class="' + prefix + 'preview"></span>' +
							textHtml +
						'</button>' +
						'<button type="button" class="' + prefix + 'open" hidefocus="1" tabindex="-1">' +
							' <i class="' + prefix + 'caret"></i>' +
						'</button>' +
					'</div>'
				);
			},
	
			/**
			 * Called after the control has been rendered.
			 *
			 * @method postRender
			 */
			postRender: function() {
				var self = this, onClickHandler = self.settings.onclick;
	
				self.on('click', function(e) {
					if (e.aria && e.aria.key == 'down') {
						return;
					}
	
					if (e.control == self && !DOM.getParent(e.target, '.' + self.classPrefix + 'open')) {
						e.stopImmediatePropagation();
						onClickHandler.call(self, e);
					}
				});
	
				delete self.settings.onclick;
	
				return self._super();
			}
		});
	});
	
	// Included from: js/tinymce/classes/util/Color.js
	
	/**
	 * Color.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * This class lets you parse/serialize colors and convert rgb/hsb.
	 *
	 * @class tinymce.util.Color
	 * @example
	 * var white = new tinymce.util.Color({r: 255, g: 255, b: 255});
	 * var red = new tinymce.util.Color('#FF0000');
	 *
	 * console.log(white.toHex(), red.toHsv());
	 */
	define("tinymce/util/Color", [], function() {
		var min = Math.min, max = Math.max, round = Math.round;
	
		/**
		 * Constructs a new color instance.
		 *
		 * @constructor
		 * @method Color
		 * @param {String} value Optional initial value to parse.
		 */
		function Color(value) {
			var self = this, r = 0, g = 0, b = 0;
	
			function rgb2hsv(r, g, b) {
				var h, s, v, d, minRGB, maxRGB;
	
				h = 0;
				s = 0;
				v = 0;
				r = r / 255;
				g = g / 255;
				b = b / 255;
	
				minRGB = min(r, min(g, b));
				maxRGB = max(r, max(g, b));
	
				if (minRGB == maxRGB) {
					v = minRGB;
	
					return {
						h: 0,
						s: 0,
						v: v * 100
					};
				}
	
				/*eslint no-nested-ternary:0 */
				d = (r == minRGB) ? g - b : ((b == minRGB) ? r - g : b - r);
				h = (r == minRGB) ? 3 : ((b == minRGB) ? 1 : 5);
				h = 60 * (h - d / (maxRGB - minRGB));
				s = (maxRGB - minRGB) / maxRGB;
				v = maxRGB;
	
				return {
					h: round(h),
					s: round(s * 100),
					v: round(v * 100)
				};
			}
	
			function hsvToRgb(hue, saturation, brightness) {
				var side, chroma, x, match;
	
				hue = (parseInt(hue, 10) || 0) % 360;
				saturation = parseInt(saturation, 10) / 100;
				brightness = parseInt(brightness, 10) / 100;
				saturation = max(0, min(saturation, 1));
				brightness = max(0, min(brightness, 1));
	
				if (saturation === 0) {
					r = g = b = round(255 * brightness);
					return;
				}
	
				side = hue / 60;
				chroma = brightness * saturation;
				x = chroma * (1 - Math.abs(side % 2 - 1));
				match = brightness - chroma;
	
				switch (Math.floor(side)) {
					case 0:
						r = chroma;
						g = x;
						b = 0;
						break;
	
					case 1:
						r = x;
						g = chroma;
						b = 0;
						break;
	
					case 2:
						r = 0;
						g = chroma;
						b = x;
						break;
	
					case 3:
						r = 0;
						g = x;
						b = chroma;
						break;
	
					case 4:
						r = x;
						g = 0;
						b = chroma;
						break;
	
					case 5:
						r = chroma;
						g = 0;
						b = x;
						break;
	
					default:
						r = g = b = 0;
				}
	
				r = round(255 * (r + match));
				g = round(255 * (g + match));
				b = round(255 * (b + match));
			}
	
			/**
			 * Returns the hex string of the current color. For example: #ff00ff
			 *
			 * @method toHex
			 * @return {String} Hex string of current color.
			 */
			function toHex() {
				function hex(val) {
					val = parseInt(val, 10).toString(16);
	
					return val.length > 1 ? val : '0' + val;
				}
	
				return '#' + hex(r) + hex(g) + hex(b);
			}
	
			/**
			 * Returns the r, g, b values of the color. Each channel has a range from 0-255.
			 *
			 * @method toRgb
			 * @return {Object} Object with r, g, b fields.
			 */
			function toRgb() {
				return {
					r: r,
					g: g,
					b: b
				};
			}
	
			/**
			 * Returns the h, s, v values of the color. Ranges: h=0-360, s=0-100, v=0-100.
			 *
			 * @method toHsv
			 * @return {Object} Object with h, s, v fields.
			 */
			function toHsv() {
				return rgb2hsv(r, g, b);
			}
	
			/**
			 * Parses the specified value and populates the color instance.
			 *
			 * Supported format examples:
			 *  * rbg(255,0,0)
			 *  * #ff0000
			 *  * #fff
			 *  * {r: 255, g: 0, b: 0}
			 *  * {h: 360, s: 100, v: 100}
			 *
			 * @method parse
			 * @param {Object/String} value Color value to parse.
			 * @return {tinymce.util.Color} Current color instance.
			 */
			function parse(value) {
				var matches;
	
				if (typeof value == 'object') {
					if ("r" in value) {
						r = value.r;
						g = value.g;
						b = value.b;
					} else if ("v" in value) {
						hsvToRgb(value.h, value.s, value.v);
					}
				} else {
					if ((matches = /rgb\s*\(\s*([0-9]+)\s*,\s*([0-9]+)\s*,\s*([0-9]+)[^\)]*\)/gi.exec(value))) {
						r = parseInt(matches[1], 10);
						g = parseInt(matches[2], 10);
						b = parseInt(matches[3], 10);
					} else if ((matches = /#([0-F]{2})([0-F]{2})([0-F]{2})/gi.exec(value))) {
						r = parseInt(matches[1], 16);
						g = parseInt(matches[2], 16);
						b = parseInt(matches[3], 16);
					} else if ((matches = /#([0-F])([0-F])([0-F])/gi.exec(value))) {
						r = parseInt(matches[1] + matches[1], 16);
						g = parseInt(matches[2] + matches[2], 16);
						b = parseInt(matches[3] + matches[3], 16);
					}
				}
	
				r = r < 0 ? 0 : (r > 255 ? 255 : r);
				g = g < 0 ? 0 : (g > 255 ? 255 : g);
				b = b < 0 ? 0 : (b > 255 ? 255 : b);
	
				return self;
			}
	
			if (value) {
				parse(value);
			}
	
			self.toRgb = toRgb;
			self.toHsv = toHsv;
			self.toHex = toHex;
			self.parse = parse;
		}
	
		return Color;
	});
	
	// Included from: js/tinymce/classes/ui/ColorPicker.js
	
	/**
	 * ColorPicker.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * Color picker widget lets you select colors.
	 *
	 * @-x-less ColorPicker.less
	 * @class tinymce.ui.ColorPicker
	 * @extends tinymce.ui.Widget
	 */
	define("tinymce/ui/ColorPicker", [
		"tinymce/ui/Widget",
		"tinymce/ui/DragHelper",
		"tinymce/ui/DomUtils",
		"tinymce/util/Color"
	], function(Widget, DragHelper, DomUtils, Color) {
		"use strict";
	
		return Widget.extend({
			Defaults: {
				classes: "widget colorpicker"
			},
	
			/**
			 * Constructs a new colorpicker instance with the specified settings.
			 *
			 * @constructor
			 * @param {Object} settings Name/value object with settings.
			 * @setting {String} color Initial color value.
			 */
			init: function(settings) {
				this._super(settings);
			},
	
			postRender: function() {
				var self = this, color = self.color(), hsv, hueRootElm, huePointElm, svRootElm, svPointElm;
	
				hueRootElm = self.getEl('h');
				huePointElm = self.getEl('hp');
				svRootElm = self.getEl('sv');
				svPointElm = self.getEl('svp');
	
				function getPos(elm, event) {
					var pos = DomUtils.getPos(elm), x, y;
	
					x = event.pageX - pos.x;
					y = event.pageY - pos.y;
	
					x = Math.max(0, Math.min(x / elm.clientWidth, 1));
					y = Math.max(0, Math.min(y / elm.clientHeight, 1));
	
					return {
						x: x,
						y: y
					};
				}
	
				function updateColor(hsv, hueUpdate) {
					var hue = (360 - hsv.h) / 360;
	
					DomUtils.css(huePointElm, {
						top: (hue * 100) + '%'
					});
	
					if (!hueUpdate) {
						DomUtils.css(svPointElm, {
							left: hsv.s + '%',
							top: (100 - hsv.v) + '%'
						});
					}
	
					svRootElm.style.background = new Color({s: 100, v: 100, h: hsv.h}).toHex();
					self.color().parse({s: hsv.s, v: hsv.v, h: hsv.h});
				}
	
				function updateSaturationAndValue(e) {
					var pos;
	
					pos = getPos(svRootElm, e);
					hsv.s = pos.x * 100;
					hsv.v = (1 - pos.y) * 100;
	
					updateColor(hsv);
					self.fire('change');
				}
	
				function updateHue(e) {
					var pos;
	
					pos = getPos(hueRootElm, e);
					hsv = color.toHsv();
					hsv.h = (1 - pos.y) * 360;
					updateColor(hsv, true);
					self.fire('change');
				}
	
				self._repaint = function() {
					hsv = color.toHsv();
					updateColor(hsv);
				};
	
				self._super();
	
				self._svdraghelper = new DragHelper(self._id + '-sv', {
					start: updateSaturationAndValue,
					drag: updateSaturationAndValue
				});
	
				self._hdraghelper = new DragHelper(self._id + '-h', {
					start: updateHue,
					drag: updateHue
				});
	
				self._repaint();
			},
	
			rgb: function() {
				return this.color().toRgb();
			},
	
			value: function(value) {
				var self = this;
	
				if (arguments.length) {
					self.color().parse(value);
	
					if (self._rendered) {
						self._repaint();
					}
				} else {
					return self.color().toHex();
				}
			},
	
			color: function() {
				if (!this._color) {
					this._color = new Color();
				}
	
				return this._color;
			},
	
			/**
			 * Renders the control as a HTML string.
			 *
			 * @method renderHtml
			 * @return {String} HTML representing the control.
			 */
			renderHtml: function() {
				var self = this, id = self._id, prefix = self.classPrefix, hueHtml;
				var stops = '#ff0000,#ff0080,#ff00ff,#8000ff,#0000ff,#0080ff,#00ffff,#00ff80,#00ff00,#80ff00,#ffff00,#ff8000,#ff0000';
	
				function getOldIeFallbackHtml() {
					var i, l, html = '', gradientPrefix, stopsList;
	
					gradientPrefix = 'filter:progid:DXImageTransform.Microsoft.gradient(GradientType=0,startColorstr=';
					stopsList = stops.split(',');
					for (i = 0, l = stopsList.length - 1; i < l; i++) {
						html += (
							'<div class="' + prefix + 'colorpicker-h-chunk" style="' +
								'height:' + (100 / l) + '%;' +
								gradientPrefix + stopsList[i] + ',endColorstr=' + stopsList[i + 1] + ');' +
								'-ms-' + gradientPrefix + stopsList[i] + ',endColorstr=' + stopsList[i + 1] + ')' +
							'"></div>'
						);
					}
	
					return html;
				}
	
				var gradientCssText = (
					'background: -ms-linear-gradient(top,' + stops + ');' +
					'background: linear-gradient(to bottom,' + stops + ');'
				);
	
				hueHtml = (
					'<div id="' + id + '-h" class="' + prefix + 'colorpicker-h" style="' + gradientCssText + '">' +
						getOldIeFallbackHtml() +
						'<div id="' + id + '-hp" class="' + prefix + 'colorpicker-h-marker"></div>' +
					'</div>'
				);
	
				return (
					'<div id="' + id + '" class="' + self.classes + '">' +
						'<div id="' + id + '-sv" class="' + prefix + 'colorpicker-sv">' +
							'<div class="' + prefix + 'colorpicker-overlay1">' +
								'<div class="' + prefix + 'colorpicker-overlay2">' +
									'<div id="' + id + '-svp" class="' + prefix + 'colorpicker-selector1">' +
										'<div class="' + prefix + 'colorpicker-selector2"></div>' +
									'</div>' +
								'</div>' +
							'</div>' +
						'</div>' +
						hueHtml +
					'</div>'
				);
			}
		});
	});
	
	// Included from: js/tinymce/classes/ui/Path.js
	
	/**
	 * Path.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * Creates a new path control.
	 *
	 * @-x-less Path.less
	 * @class tinymce.ui.Path
	 * @extends tinymce.ui.Widget
	 */
	define("tinymce/ui/Path", [
		"tinymce/ui/Widget"
	], function(Widget) {
		"use strict";
	
		return Widget.extend({
			/**
			 * Constructs a instance with the specified settings.
			 *
			 * @constructor
			 * @param {Object} settings Name/value object with settings.
			 * @setting {String} delimiter Delimiter to display between row in path.
			 */
			init: function(settings) {
				var self = this;
	
				if (!settings.delimiter) {
					settings.delimiter = '\u00BB';
				}
	
				self._super(settings);
				self.classes.add('path');
				self.canFocus = true;
	
				self.on('click', function(e) {
					var index, target = e.target;
	
					if ((index = target.getAttribute('data-index'))) {
						self.fire('select', {value: self.row()[index], index: index});
					}
				});
	
				self.row(self.settings.row);
			},
	
			/**
			 * Focuses the current control.
			 *
			 * @method focus
			 * @return {tinymce.ui.Control} Current control instance.
			 */
			focus: function() {
				var self = this;
	
				self.getEl().firstChild.focus();
	
				return self;
			},
	
			/**
			 * Sets/gets the data to be used for the path.
			 *
			 * @method row
			 * @param {Array} row Array with row name is rendered to path.
			 */
			row: function(row) {
				if (!arguments.length) {
					return this.state.get('row');
				}
	
				this.state.set('row', row);
	
				return this;
			},
	
			/**
			 * Renders the control as a HTML string.
			 *
			 * @method renderHtml
			 * @return {String} HTML representing the control.
			 */
			renderHtml: function() {
				var self = this;
	
				return (
					'<div id="' + self._id + '" class="' + self.classes + '">' +
						self._getDataPathHtml(self.state.get('row')) +
					'</div>'
				);
			},
	
			bindStates: function() {
				var self = this;
	
				self.state.on('change:row', function(e) {
					self.innerHtml(self._getDataPathHtml(e.value));
				});
	
				return self._super();
			},
	
			_getDataPathHtml: function(data) {
				var self = this, parts = data || [], i, l, html = '', prefix = self.classPrefix;
	
				for (i = 0, l = parts.length; i < l; i++) {
					html += (
						(i > 0 ? '<div class="' + prefix + 'divider" aria-hidden="true"> ' + self.settings.delimiter + ' </div>' : '') +
						'<div role="button" class="' + prefix + 'path-item' + (i == l - 1 ? ' ' + prefix + 'last' : '') + '" data-index="' +
						i + '" tabindex="-1" id="' + self._id + '-' + i + '" aria-level="' + i + '">' + parts[i].name + '</div>'
					);
				}
	
				if (!html) {
					html = '<div class="' + prefix + 'path-item">\u00a0</div>';
				}
	
				return html;
			}
		});
	});
	
	// Included from: js/tinymce/classes/ui/ElementPath.js
	
	/**
	 * ElementPath.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * This control creates an path for the current selections parent elements in TinyMCE.
	 *
	 * @class tinymce.ui.ElementPath
	 * @extends tinymce.ui.Path
	 */
	define("tinymce/ui/ElementPath", [
		"tinymce/ui/Path",
		"tinymce/EditorManager"
	], function(Path, EditorManager) {
		return Path.extend({
			/**
			 * Post render method. Called after the control has been rendered to the target.
			 *
			 * @method postRender
			 * @return {tinymce.ui.ElementPath} Current combobox instance.
			 */
			postRender: function() {
				var self = this, editor = EditorManager.activeEditor;
	
				function isHidden(elm) {
					if (elm.nodeType === 1) {
						if (elm.nodeName == "BR" || !!elm.getAttribute('data-mce-bogus')) {
							return true;
						}
	
						if (elm.getAttribute('data-mce-type') === 'bookmark') {
							return true;
						}
					}
	
					return false;
				}
	
				if (editor.settings.elementpath !== false) {
					self.on('select', function(e) {
						editor.focus();
						editor.selection.select(this.row()[e.index].element);
						editor.nodeChanged();
					});
	
					editor.on('nodeChange', function(e) {
						var outParents = [], parents = e.parents, i = parents.length;
	
						while (i--) {
							if (parents[i].nodeType == 1 && !isHidden(parents[i])) {
								var args = editor.fire('ResolveName', {
									name: parents[i].nodeName.toLowerCase(),
									target: parents[i]
								});
	
								if (!args.isDefaultPrevented()) {
									outParents.push({name: args.name, element: parents[i]});
								}
	
								if (args.isPropagationStopped()) {
									break;
								}
							}
						}
	
						self.row(outParents);
					});
				}
	
				return self._super();
			}
		});
	});
	
	// Included from: js/tinymce/classes/ui/FormItem.js
	
	/**
	 * FormItem.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * This class is a container created by the form element with
	 * a label and control item.
	 *
	 * @class tinymce.ui.FormItem
	 * @extends tinymce.ui.Container
	 * @setting {String} label Label to display for the form item.
	 */
	define("tinymce/ui/FormItem", [
		"tinymce/ui/Container"
	], function(Container) {
		"use strict";
	
		return Container.extend({
			Defaults: {
				layout: 'flex',
				align: 'center',
				defaults: {
					flex: 1
				}
			},
	
			/**
			 * Renders the control as a HTML string.
			 *
			 * @method renderHtml
			 * @return {String} HTML representing the control.
			 */
			renderHtml: function() {
				var self = this, layout = self._layout, prefix = self.classPrefix;
	
				self.classes.add('formitem');
				layout.preRender(self);
	
				return (
					'<div id="' + self._id + '" class="' + self.classes + '" hidefocus="1" tabindex="-1">' +
						(self.settings.title ? ('<div id="' + self._id + '-title" class="' + prefix + 'title">' +
							self.settings.title + '</div>') : '') +
						'<div id="' + self._id + '-body" class="' + self.bodyClasses + '">' +
							(self.settings.html || '') + layout.renderHtml(self) +
						'</div>' +
					'</div>'
				);
			}
		});
	});
	
	// Included from: js/tinymce/classes/ui/Form.js
	
	/**
	 * Form.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * This class creates a form container. A form container has the ability
	 * to automatically wrap items in tinymce.ui.FormItem instances.
	 *
	 * Each FormItem instance is a container for the label and the item.
	 *
	 * @example
	 * tinymce.ui.Factory.create({
	 *     type: 'form',
	 *     items: [
	 *         {type: 'textbox', label: 'My text box'}
	 *     ]
	 * }).renderTo(document.body);
	 *
	 * @class tinymce.ui.Form
	 * @extends tinymce.ui.Container
	 */
	define("tinymce/ui/Form", [
		"tinymce/ui/Container",
		"tinymce/ui/FormItem",
		"tinymce/util/Tools"
	], function(Container, FormItem, Tools) {
		"use strict";
	
		return Container.extend({
			Defaults: {
				containerCls: 'form',
				layout: 'flex',
				direction: 'column',
				align: 'stretch',
				flex: 1,
				padding: 20,
				labelGap: 30,
				spacing: 10,
				callbacks: {
					submit: function() {
						this.submit();
					}
				}
			},
	
			/**
			 * This method gets invoked before the control is rendered.
			 *
			 * @method preRender
			 */
			preRender: function() {
				var self = this, items = self.items();
	
				if (!self.settings.formItemDefaults) {
					self.settings.formItemDefaults = {
						layout: 'flex',
						autoResize: "overflow",
						defaults: {flex: 1}
					};
				}
	
				// Wrap any labeled items in FormItems
				items.each(function(ctrl) {
					var formItem, label = ctrl.settings.label;
	
					if (label) {
						formItem = new FormItem(Tools.extend({
							items: {
								type: 'label',
								id: ctrl._id + '-l',
								text: label,
								flex: 0,
								forId: ctrl._id,
								disabled: ctrl.disabled()
							}
						}, self.settings.formItemDefaults));
	
						formItem.type = 'formitem';
						ctrl.aria('labelledby', ctrl._id + '-l');
	
						if (typeof ctrl.settings.flex == "undefined") {
							ctrl.settings.flex = 1;
						}
	
						self.replace(ctrl, formItem);
						formItem.add(ctrl);
					}
				});
			},
	
			/**
			 * Fires a submit event with the serialized form.
			 *
			 * @method submit
			 * @return {Object} Event arguments object.
			 */
			submit: function() {
				return this.fire('submit', {data: this.toJSON()});
			},
	
			/**
			 * Post render method. Called after the control has been rendered to the target.
			 *
			 * @method postRender
			 * @return {tinymce.ui.ComboBox} Current combobox instance.
			 */
			postRender: function() {
				var self = this;
	
				self._super();
				self.fromJSON(self.settings.data);
			},
	
			bindStates: function() {
				var self = this;
	
				self._super();
	
				function recalcLabels() {
					var maxLabelWidth = 0, labels = [], i, labelGap, items;
	
					if (self.settings.labelGapCalc === false) {
						return;
					}
	
					if (self.settings.labelGapCalc == "children") {
						items = self.find('formitem');
					} else {
						items = self.items();
					}
	
					items.filter('formitem').each(function(item) {
						var labelCtrl = item.items()[0], labelWidth = labelCtrl.getEl().clientWidth;
	
						maxLabelWidth = labelWidth > maxLabelWidth ? labelWidth : maxLabelWidth;
						labels.push(labelCtrl);
					});
	
					labelGap = self.settings.labelGap || 0;
	
					i = labels.length;
					while (i--) {
						labels[i].settings.minWidth = maxLabelWidth + labelGap;
					}
				}
	
				self.on('show', recalcLabels);
				recalcLabels();
			}
		});
	});
	
	// Included from: js/tinymce/classes/ui/FieldSet.js
	
	/**
	 * FieldSet.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * This class creates fieldset containers.
	 *
	 * @-x-less FieldSet.less
	 * @class tinymce.ui.FieldSet
	 * @extends tinymce.ui.Form
	 */
	define("tinymce/ui/FieldSet", [
		"tinymce/ui/Form"
	], function(Form) {
		"use strict";
	
		return Form.extend({
			Defaults: {
				containerCls: 'fieldset',
				layout: 'flex',
				direction: 'column',
				align: 'stretch',
				flex: 1,
				padding: "25 15 5 15",
				labelGap: 30,
				spacing: 10,
				border: 1
			},
	
			/**
			 * Renders the control as a HTML string.
			 *
			 * @method renderHtml
			 * @return {String} HTML representing the control.
			 */
			renderHtml: function() {
				var self = this, layout = self._layout, prefix = self.classPrefix;
	
				self.preRender();
				layout.preRender(self);
	
				return (
					'<fieldset id="' + self._id + '" class="' + self.classes + '" hidefocus="1" tabindex="-1">' +
						(self.settings.title ? ('<legend id="' + self._id + '-title" class="' + prefix + 'fieldset-title">' +
							self.settings.title + '</legend>') : '') +
						'<div id="' + self._id + '-body" class="' + self.bodyClasses + '">' +
							(self.settings.html || '') + layout.renderHtml(self) +
						'</div>' +
					'</fieldset>'
				);
			}
		});
	});
	
	// Included from: js/tinymce/classes/ui/FilePicker.js
	
	/**
	 * FilePicker.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/*global tinymce:true */
	
	/**
	 * This class creates a file picker control.
	 *
	 * @class tinymce.ui.FilePicker
	 * @extends tinymce.ui.ComboBox
	 */
	define("tinymce/ui/FilePicker", [
		"tinymce/ui/ComboBox",
		"tinymce/util/Tools"
	], function(ComboBox, Tools) {
		"use strict";
	
		return ComboBox.extend({
			/**
			 * Constructs a new control instance with the specified settings.
			 *
			 * @constructor
			 * @param {Object} settings Name/value object with settings.
			 */
			init: function(settings) {
				var self = this, editor = tinymce.activeEditor, editorSettings = editor.settings;
				var actionCallback, fileBrowserCallback, fileBrowserCallbackTypes;
	
				settings.spellcheck = false;
	
				fileBrowserCallbackTypes = editorSettings.file_picker_types || editorSettings.file_browser_callback_types;
				if (fileBrowserCallbackTypes) {
					fileBrowserCallbackTypes = Tools.makeMap(fileBrowserCallbackTypes, /[, ]/);
				}
	
				if (!fileBrowserCallbackTypes || fileBrowserCallbackTypes[settings.filetype]) {
					fileBrowserCallback = editorSettings.file_picker_callback;
					if (fileBrowserCallback && (!fileBrowserCallbackTypes || fileBrowserCallbackTypes[settings.filetype])) {
						actionCallback = function() {
							var meta = self.fire('beforecall').meta;
	
							meta = Tools.extend({filetype: settings.filetype}, meta);
	
							// file_picker_callback(callback, currentValue, metaData)
							fileBrowserCallback.call(
								editor,
								function(value, meta) {
									self.value(value).fire('change', {meta: meta});
								},
								self.value(),
								meta
							);
						};
					} else {
						// Legacy callback: file_picker_callback(id, currentValue, filetype, window)
						fileBrowserCallback = editorSettings.file_browser_callback;
						if (fileBrowserCallback && (!fileBrowserCallbackTypes || fileBrowserCallbackTypes[settings.filetype])) {
							actionCallback = function() {
								fileBrowserCallback(
									self.getEl('inp').id,
									self.value(),
									settings.filetype,
									window
								);
							};
						}
					}
				}
	
				if (actionCallback) {
					settings.icon = 'browse';
					settings.onaction = actionCallback;
				}
	
				self._super(settings);
			}
		});
	});
	
	// Included from: js/tinymce/classes/ui/FitLayout.js
	
	/**
	 * FitLayout.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * This layout manager will resize the control to be the size of it's parent container.
	 * In other words width: 100% and height: 100%.
	 *
	 * @-x-less FitLayout.less
	 * @class tinymce.ui.FitLayout
	 * @extends tinymce.ui.AbsoluteLayout
	 */
	define("tinymce/ui/FitLayout", [
		"tinymce/ui/AbsoluteLayout"
	], function(AbsoluteLayout) {
		"use strict";
	
		return AbsoluteLayout.extend({
			/**
			 * Recalculates the positions of the controls in the specified container.
			 *
			 * @method recalc
			 * @param {tinymce.ui.Container} container Container instance to recalc.
			 */
			recalc: function(container) {
				var contLayoutRect = container.layoutRect(), paddingBox = container.paddingBox;
	
				container.items().filter(':visible').each(function(ctrl) {
					ctrl.layoutRect({
						x: paddingBox.left,
						y: paddingBox.top,
						w: contLayoutRect.innerW - paddingBox.right - paddingBox.left,
						h: contLayoutRect.innerH - paddingBox.top - paddingBox.bottom
					});
	
					if (ctrl.recalc) {
						ctrl.recalc();
					}
				});
			}
		});
	});
	
	// Included from: js/tinymce/classes/ui/FlexLayout.js
	
	/**
	 * FlexLayout.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * This layout manager works similar to the CSS flex box.
	 *
	 * @setting {String} direction row|row-reverse|column|column-reverse
	 * @setting {Number} flex A positive-number to flex by.
	 * @setting {String} align start|end|center|stretch
	 * @setting {String} pack start|end|justify
	 *
	 * @class tinymce.ui.FlexLayout
	 * @extends tinymce.ui.AbsoluteLayout
	 */
	define("tinymce/ui/FlexLayout", [
		"tinymce/ui/AbsoluteLayout"
	], function(AbsoluteLayout) {
		"use strict";
	
		return AbsoluteLayout.extend({
			/**
			 * Recalculates the positions of the controls in the specified container.
			 *
			 * @method recalc
			 * @param {tinymce.ui.Container} container Container instance to recalc.
			 */
			recalc: function(container) {
				// A ton of variables, needs to be in the same scope for performance
				var i, l, items, contLayoutRect, contPaddingBox, contSettings, align, pack, spacing, totalFlex, availableSpace, direction;
				var ctrl, ctrlLayoutRect, ctrlSettings, flex, maxSizeItems = [], size, maxSize, ratio, rect, pos, maxAlignEndPos;
				var sizeName, minSizeName, posName, maxSizeName, beforeName, innerSizeName, deltaSizeName, contentSizeName;
				var alignAxisName, alignInnerSizeName, alignSizeName, alignMinSizeName, alignBeforeName, alignAfterName;
				var alignDeltaSizeName, alignContentSizeName;
				var max = Math.max, min = Math.min;
	
				// Get container items, properties and settings
				items = container.items().filter(':visible');
				contLayoutRect = container.layoutRect();
				contPaddingBox = container.paddingBox;
				contSettings = container.settings;
				direction = container.isRtl() ? (contSettings.direction || 'row-reversed') : contSettings.direction;
				align = contSettings.align;
				pack = container.isRtl() ? (contSettings.pack || 'end') : contSettings.pack;
				spacing = contSettings.spacing || 0;
	
				if (direction == "row-reversed" || direction == "column-reverse") {
					items = items.set(items.toArray().reverse());
					direction = direction.split('-')[0];
				}
	
				// Setup axis variable name for row/column direction since the calculations is the same
				if (direction == "column") {
					posName = "y";
					sizeName = "h";
					minSizeName = "minH";
					maxSizeName = "maxH";
					innerSizeName = "innerH";
					beforeName = 'top';
					deltaSizeName = "deltaH";
					contentSizeName = "contentH";
	
					alignBeforeName = "left";
					alignSizeName = "w";
					alignAxisName = "x";
					alignInnerSizeName = "innerW";
					alignMinSizeName = "minW";
					alignAfterName = "right";
					alignDeltaSizeName = "deltaW";
					alignContentSizeName = "contentW";
				} else {
					posName = "x";
					sizeName = "w";
					minSizeName = "minW";
					maxSizeName = "maxW";
					innerSizeName = "innerW";
					beforeName = 'left';
					deltaSizeName = "deltaW";
					contentSizeName = "contentW";
	
					alignBeforeName = "top";
					alignSizeName = "h";
					alignAxisName = "y";
					alignInnerSizeName = "innerH";
					alignMinSizeName = "minH";
					alignAfterName = "bottom";
					alignDeltaSizeName = "deltaH";
					alignContentSizeName = "contentH";
				}
	
				// Figure out total flex, availableSpace and collect any max size elements
				availableSpace = contLayoutRect[innerSizeName] - contPaddingBox[beforeName] - contPaddingBox[beforeName];
				maxAlignEndPos = totalFlex = 0;
				for (i = 0, l = items.length; i < l; i++) {
					ctrl = items[i];
					ctrlLayoutRect = ctrl.layoutRect();
					ctrlSettings = ctrl.settings;
					flex = ctrlSettings.flex;
					availableSpace -= (i < l - 1 ? spacing : 0);
	
					if (flex > 0) {
						totalFlex += flex;
	
						// Flexed item has a max size then we need to check if we will hit that size
						if (ctrlLayoutRect[maxSizeName]) {
							maxSizeItems.push(ctrl);
						}
	
						ctrlLayoutRect.flex = flex;
					}
	
					availableSpace -= ctrlLayoutRect[minSizeName];
	
					// Calculate the align end position to be used to check for overflow/underflow
					size = contPaddingBox[alignBeforeName] + ctrlLayoutRect[alignMinSizeName] + contPaddingBox[alignAfterName];
					if (size > maxAlignEndPos) {
						maxAlignEndPos = size;
					}
				}
	
				// Calculate minW/minH
				rect = {};
				if (availableSpace < 0) {
					rect[minSizeName] = contLayoutRect[minSizeName] - availableSpace + contLayoutRect[deltaSizeName];
				} else {
					rect[minSizeName] = contLayoutRect[innerSizeName] - availableSpace + contLayoutRect[deltaSizeName];
				}
	
				rect[alignMinSizeName] = maxAlignEndPos + contLayoutRect[alignDeltaSizeName];
	
				rect[contentSizeName] = contLayoutRect[innerSizeName] - availableSpace;
				rect[alignContentSizeName] = maxAlignEndPos;
				rect.minW = min(rect.minW, contLayoutRect.maxW);
				rect.minH = min(rect.minH, contLayoutRect.maxH);
				rect.minW = max(rect.minW, contLayoutRect.startMinWidth);
				rect.minH = max(rect.minH, contLayoutRect.startMinHeight);
	
				// Resize container container if minSize was changed
				if (contLayoutRect.autoResize && (rect.minW != contLayoutRect.minW || rect.minH != contLayoutRect.minH)) {
					rect.w = rect.minW;
					rect.h = rect.minH;
	
					container.layoutRect(rect);
					this.recalc(container);
	
					// Forced recalc for example if items are hidden/shown
					if (container._lastRect === null) {
						var parentCtrl = container.parent();
						if (parentCtrl) {
							parentCtrl._lastRect = null;
							parentCtrl.recalc();
						}
					}
	
					return;
				}
	
				// Handle max size elements, check if they will become to wide with current options
				ratio = availableSpace / totalFlex;
				for (i = 0, l = maxSizeItems.length; i < l; i++) {
					ctrl = maxSizeItems[i];
					ctrlLayoutRect = ctrl.layoutRect();
					maxSize = ctrlLayoutRect[maxSizeName];
					size = ctrlLayoutRect[minSizeName] + ctrlLayoutRect.flex * ratio;
	
					if (size > maxSize) {
						availableSpace -= (ctrlLayoutRect[maxSizeName] - ctrlLayoutRect[minSizeName]);
						totalFlex -= ctrlLayoutRect.flex;
						ctrlLayoutRect.flex = 0;
						ctrlLayoutRect.maxFlexSize = maxSize;
					} else {
						ctrlLayoutRect.maxFlexSize = 0;
					}
				}
	
				// Setup new ratio, target layout rect, start position
				ratio = availableSpace / totalFlex;
				pos = contPaddingBox[beforeName];
				rect = {};
	
				// Handle pack setting moves the start position to end, center
				if (totalFlex === 0) {
					if (pack == "end") {
						pos = availableSpace + contPaddingBox[beforeName];
					} else if (pack == "center") {
						pos = Math.round(
							(contLayoutRect[innerSizeName] / 2) - ((contLayoutRect[innerSizeName] - availableSpace) / 2)
						) + contPaddingBox[beforeName];
	
						if (pos < 0) {
							pos = contPaddingBox[beforeName];
						}
					} else if (pack == "justify") {
						pos = contPaddingBox[beforeName];
						spacing = Math.floor(availableSpace / (items.length - 1));
					}
				}
	
				// Default aligning (start) the other ones needs to be calculated while doing the layout
				rect[alignAxisName] = contPaddingBox[alignBeforeName];
	
				// Start laying out controls
				for (i = 0, l = items.length; i < l; i++) {
					ctrl = items[i];
					ctrlLayoutRect = ctrl.layoutRect();
					size = ctrlLayoutRect.maxFlexSize || ctrlLayoutRect[minSizeName];
	
					// Align the control on the other axis
					if (align === "center") {
						rect[alignAxisName] = Math.round((contLayoutRect[alignInnerSizeName] / 2) - (ctrlLayoutRect[alignSizeName] / 2));
					} else if (align === "stretch") {
						rect[alignSizeName] = max(
							ctrlLayoutRect[alignMinSizeName] || 0,
							contLayoutRect[alignInnerSizeName] - contPaddingBox[alignBeforeName] - contPaddingBox[alignAfterName]
						);
						rect[alignAxisName] = contPaddingBox[alignBeforeName];
					} else if (align === "end") {
						rect[alignAxisName] = contLayoutRect[alignInnerSizeName] - ctrlLayoutRect[alignSizeName] - contPaddingBox.top;
					}
	
					// Calculate new size based on flex
					if (ctrlLayoutRect.flex > 0) {
						size += ctrlLayoutRect.flex * ratio;
					}
	
					rect[sizeName] = size;
					rect[posName] = pos;
					ctrl.layoutRect(rect);
	
					// Recalculate containers
					if (ctrl.recalc) {
						ctrl.recalc();
					}
	
					// Move x/y position
					pos += size + spacing;
				}
			}
		});
	});
	
	// Included from: js/tinymce/classes/ui/FlowLayout.js
	
	/**
	 * FlowLayout.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * This layout manager will place the controls by using the browsers native layout.
	 *
	 * @-x-less FlowLayout.less
	 * @class tinymce.ui.FlowLayout
	 * @extends tinymce.ui.Layout
	 */
	define("tinymce/ui/FlowLayout", [
		"tinymce/ui/Layout"
	], function(Layout) {
		return Layout.extend({
			Defaults: {
				containerClass: 'flow-layout',
				controlClass: 'flow-layout-item',
				endClass: 'break'
			},
	
			/**
			 * Recalculates the positions of the controls in the specified container.
			 *
			 * @method recalc
			 * @param {tinymce.ui.Container} container Container instance to recalc.
			 */
			recalc: function(container) {
				container.items().filter(':visible').each(function(ctrl) {
					if (ctrl.recalc) {
						ctrl.recalc();
					}
				});
			},
	
			isNative: function() {
				return true;
			}
		});
	});
	
	// Included from: js/tinymce/classes/ui/FormatControls.js
	
	/**
	 * FormatControls.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * Internal class containing all TinyMCE specific control types such as
	 * format listboxes, fontlist boxes, toolbar buttons etc.
	 *
	 * @class tinymce.ui.FormatControls
	 */
	define("tinymce/ui/FormatControls", [
		"tinymce/ui/Control",
		"tinymce/ui/Widget",
		"tinymce/ui/FloatPanel",
		"tinymce/util/Tools",
		"tinymce/EditorManager",
		"tinymce/Env"
	], function(Control, Widget, FloatPanel, Tools, EditorManager, Env) {
		var each = Tools.each;
	
		EditorManager.on('AddEditor', function(e) {
			if (e.editor.rtl) {
				Control.rtl = true;
			}
	
			registerControls(e.editor);
		});
	
		Control.translate = function(text) {
			return EditorManager.translate(text);
		};
	
		Widget.tooltips = !Env.iOS;
	
		function registerControls(editor) {
			var formatMenu;
	
			function createListBoxChangeHandler(items, formatName) {
				return function() {
					var self = this;
	
					editor.on('nodeChange', function(e) {
						var formatter = editor.formatter;
						var value = null;
	
						each(e.parents, function(node) {
							each(items, function(item) {
								if (formatName) {
									if (formatter.matchNode(node, formatName, {value: item.value})) {
										value = item.value;
									}
								} else {
									if (formatter.matchNode(node, item.value)) {
										value = item.value;
									}
								}
	
								if (value) {
									return false;
								}
							});
	
							if (value) {
								return false;
							}
						});
	
						self.value(value);
					});
				};
			}
	
			function createFormats(formats) {
				formats = formats.replace(/;$/, '').split(';');
	
				var i = formats.length;
				while (i--) {
					formats[i] = formats[i].split('=');
				}
	
				return formats;
			}
	
			function createFormatMenu() {
				var count = 0, newFormats = [];
	
				var defaultStyleFormats = [
					{title: 'Headings', items: [
						{title: 'Heading 1', format: 'h1'},
						{title: 'Heading 2', format: 'h2'},
						{title: 'Heading 3', format: 'h3'},
						{title: 'Heading 4', format: 'h4'},
						{title: 'Heading 5', format: 'h5'},
						{title: 'Heading 6', format: 'h6'}
					]},
	
					{title: 'Inline', items: [
						{title: 'Bold', icon: 'bold', format: 'bold'},
						{title: 'Italic', icon: 'italic', format: 'italic'},
						{title: 'Underline', icon: 'underline', format: 'underline'},
						{title: 'Strikethrough', icon: 'strikethrough', format: 'strikethrough'},
						{title: 'Superscript', icon: 'superscript', format: 'superscript'},
						{title: 'Subscript', icon: 'subscript', format: 'subscript'},
						{title: 'Code', icon: 'code', format: 'code'}
					]},
	
					{title: 'Blocks', items: [
						{title: 'Paragraph', format: 'p'},
						{title: 'Blockquote', format: 'blockquote'},
						{title: 'Div', format: 'div'},
						{title: 'Pre', format: 'pre'}
					]},
	
					{title: 'Alignment', items: [
						{title: 'Left', icon: 'alignleft', format: 'alignleft'},
						{title: 'Center', icon: 'aligncenter', format: 'aligncenter'},
						{title: 'Right', icon: 'alignright', format: 'alignright'},
						{title: 'Justify', icon: 'alignjustify', format: 'alignjustify'}
					]}
				];
	
				function createMenu(formats) {
					var menu = [];
	
					if (!formats) {
						return;
					}
	
					each(formats, function(format) {
						var menuItem = {
							text: format.title,
							icon: format.icon
						};
	
						if (format.items) {
							menuItem.menu = createMenu(format.items);
						} else {
							var formatName = format.format || "custom" + count++;
	
							if (!format.format) {
								format.name = formatName;
								newFormats.push(format);
							}
	
							menuItem.format = formatName;
							menuItem.cmd = format.cmd;
						}
	
						menu.push(menuItem);
					});
	
					return menu;
				}
	
				function createStylesMenu() {
					var menu;
	
					if (editor.settings.style_formats_merge) {
						if (editor.settings.style_formats) {
							menu = createMenu(defaultStyleFormats.concat(editor.settings.style_formats));
						} else {
							menu = createMenu(defaultStyleFormats);
						}
					} else {
						menu = createMenu(editor.settings.style_formats || defaultStyleFormats);
					}
	
					return menu;
				}
	
				editor.on('init', function() {
					each(newFormats, function(format) {
						editor.formatter.register(format.name, format);
					});
				});
	
				return {
					type: 'menu',
					items: createStylesMenu(),
					onPostRender: function(e) {
						editor.fire('renderFormatsMenu', {control: e.control});
					},
					itemDefaults: {
						preview: true,
	
						textStyle: function() {
							if (this.settings.format) {
								return editor.formatter.getCssText(this.settings.format);
							}
						},
	
						onPostRender: function() {
							var self = this;
	
							self.parent().on('show', function() {
								var formatName, command;
	
								formatName = self.settings.format;
								if (formatName) {
									self.disabled(!editor.formatter.canApply(formatName));
									self.active(editor.formatter.match(formatName));
								}
	
								command = self.settings.cmd;
								if (command) {
									self.active(editor.queryCommandState(command));
								}
							});
						},
	
						onclick: function() {
							if (this.settings.format) {
								toggleFormat(this.settings.format);
							}
	
							if (this.settings.cmd) {
								editor.execCommand(this.settings.cmd);
							}
						}
					}
				};
			}
	
			formatMenu = createFormatMenu();
	
			function initOnPostRender(name) {
				return function() {
					var self = this;
	
					// TODO: Fix this
					if (editor.formatter) {
						editor.formatter.formatChanged(name, function(state) {
							self.active(state);
						});
					} else {
						editor.on('init', function() {
							editor.formatter.formatChanged(name, function(state) {
								self.active(state);
							});
						});
					}
				};
			}
	
			// Simple format controls <control/format>:<UI text>
			each({
				bold: 'Bold',
				italic: 'Italic',
				underline: 'Underline',
				strikethrough: 'Strikethrough',
				subscript: 'Subscript',
				superscript: 'Superscript'
			}, function(text, name) {
				editor.addButton(name, {
					tooltip: text,
					onPostRender: initOnPostRender(name),
					onclick: function() {
						toggleFormat(name);
					}
				});
			});
	
			// Simple command controls <control>:[<UI text>,<Command>]
			each({
				outdent: ['Decrease indent', 'Outdent'],
				indent: ['Increase indent', 'Indent'],
				cut: ['Cut', 'Cut'],
				copy: ['Copy', 'Copy'],
				paste: ['Paste', 'Paste'],
				help: ['Help', 'mceHelp'],
				selectall: ['Select all', 'SelectAll'],
				removeformat: ['Clear formatting', 'RemoveFormat'],
				visualaid: ['Visual aids', 'mceToggleVisualAid'],
				newdocument: ['New document', 'mceNewDocument']
			}, function(item, name) {
				editor.addButton(name, {
					tooltip: item[0],
					cmd: item[1]
				});
			});
	
			// Simple command controls with format state
			each({
				blockquote: ['Blockquote', 'mceBlockQuote'],
				numlist: ['Numbered list', 'InsertOrderedList'],
				bullist: ['Bullet list', 'InsertUnorderedList'],
				subscript: ['Subscript', 'Subscript'],
				superscript: ['Superscript', 'Superscript'],
				alignleft: ['Align left', 'JustifyLeft'],
				aligncenter: ['Align center', 'JustifyCenter'],
				alignright: ['Align right', 'JustifyRight'],
				alignjustify: ['Justify', 'JustifyFull'],
				alignnone: ['No alignment', 'JustifyNone']
			}, function(item, name) {
				editor.addButton(name, {
					tooltip: item[0],
					cmd: item[1],
					onPostRender: initOnPostRender(name)
				});
			});
	
			function toggleUndoRedoState(type) {
				return function() {
					var self = this;
	
					type = type == 'redo' ? 'hasRedo' : 'hasUndo';
	
					function checkState() {
						return editor.undoManager ? editor.undoManager[type]() : false;
					}
	
					self.disabled(!checkState());
					editor.on('Undo Redo AddUndo TypingUndo ClearUndos SwitchMode', function() {
						self.disabled(editor.readonly || !checkState());
					});
				};
			}
	
			function toggleVisualAidState() {
				var self = this;
	
				editor.on('VisualAid', function(e) {
					self.active(e.hasVisual);
				});
	
				self.active(editor.hasVisual);
			}
	
			editor.addButton('undo', {
				tooltip: 'Undo',
				onPostRender: toggleUndoRedoState('undo'),
				cmd: 'undo'
			});
	
			editor.addButton('redo', {
				tooltip: 'Redo',
				onPostRender: toggleUndoRedoState('redo'),
				cmd: 'redo'
			});
	
			editor.addMenuItem('newdocument', {
				text: 'New document',
				icon: 'newdocument',
				cmd: 'mceNewDocument'
			});
	
			editor.addMenuItem('undo', {
				text: 'Undo',
				icon: 'undo',
				shortcut: 'Meta+Z',
				onPostRender: toggleUndoRedoState('undo'),
				cmd: 'undo'
			});
	
			editor.addMenuItem('redo', {
				text: 'Redo',
				icon: 'redo',
				shortcut: 'Meta+Y',
				onPostRender: toggleUndoRedoState('redo'),
				cmd: 'redo'
			});
	
			editor.addMenuItem('visualaid', {
				text: 'Visual aids',
				selectable: true,
				onPostRender: toggleVisualAidState,
				cmd: 'mceToggleVisualAid'
			});
	
			editor.addButton('remove', {
				tooltip: 'Remove',
				icon: 'remove',
				cmd: 'Delete'
			});
	
			each({
				cut: ['Cut', 'Cut', 'Meta+X'],
				copy: ['Copy', 'Copy', 'Meta+C'],
				paste: ['Paste', 'Paste', 'Meta+V'],
				selectall: ['Select all', 'SelectAll', 'Meta+A'],
				bold: ['Bold', 'Bold', 'Meta+B'],
				italic: ['Italic', 'Italic', 'Meta+I'],
				underline: ['Underline', 'Underline'],
				strikethrough: ['Strikethrough', 'Strikethrough'],
				subscript: ['Subscript', 'Subscript'],
				superscript: ['Superscript', 'Superscript'],
				removeformat: ['Clear formatting', 'RemoveFormat']
			}, function(item, name) {
				editor.addMenuItem(name, {
					text: item[0],
					icon: name,
					shortcut: item[2],
					cmd: item[1]
				});
			});
	
			editor.on('mousedown', function() {
				FloatPanel.hideAll();
			});
	
			function toggleFormat(fmt) {
				if (fmt.control) {
					fmt = fmt.control.value();
				}
	
				if (fmt) {
					editor.execCommand('mceToggleFormat', false, fmt);
				}
			}
	
			editor.addButton('styleselect', {
				type: 'menubutton',
				text: 'Formats',
				menu: formatMenu
			});
	
			editor.addButton('formatselect', function() {
				var items = [], blocks = createFormats(editor.settings.block_formats ||
					'Paragraph=p;' +
					'Heading 1=h1;' +
					'Heading 2=h2;' +
					'Heading 3=h3;' +
					'Heading 4=h4;' +
					'Heading 5=h5;' +
					'Heading 6=h6;' +
					'Preformatted=pre'
				);
	
				each(blocks, function(block) {
					items.push({
						text: block[0],
						value: block[1],
						textStyle: function() {
							return editor.formatter.getCssText(block[1]);
						}
					});
				});
	
				return {
					type: 'listbox',
					text: blocks[0][0],
					values: items,
					fixedWidth: true,
					onselect: toggleFormat,
					onPostRender: createListBoxChangeHandler(items)
				};
			});
	
			editor.addButton('fontselect', function() {
				var defaultFontsFormats =
					'Andale Mono=andale mono,monospace;' +
					'Arial=arial,helvetica,sans-serif;' +
					'Arial Black=arial black,sans-serif;' +
					'Book Antiqua=book antiqua,palatino,serif;' +
					'Comic Sans MS=comic sans ms,sans-serif;' +
					'Courier New=courier new,courier,monospace;' +
					'Georgia=georgia,palatino,serif;' +
					'Helvetica=helvetica,arial,sans-serif;' +
					'Impact=impact,sans-serif;' +
					'Symbol=symbol;' +
					'Tahoma=tahoma,arial,helvetica,sans-serif;' +
					'Terminal=terminal,monaco,monospace;' +
					'Times New Roman=times new roman,times,serif;' +
					'Trebuchet MS=trebuchet ms,geneva,sans-serif;' +
					'Verdana=verdana,geneva,sans-serif;' +
					'Webdings=webdings;' +
					'Wingdings=wingdings,zapf dingbats';
	
				var items = [], fonts = createFormats(editor.settings.font_formats || defaultFontsFormats);
	
				each(fonts, function(font) {
					items.push({
						text: {raw: font[0]},
						value: font[1],
						textStyle: font[1].indexOf('dings') == -1 ? 'font-family:' + font[1] : ''
					});
				});
	
				return {
					type: 'listbox',
					text: 'Font Family',
					tooltip: 'Font Family',
					values: items,
					fixedWidth: true,
					onPostRender: createListBoxChangeHandler(items, 'fontname'),
					onselect: function(e) {
						if (e.control.settings.value) {
							editor.execCommand('FontName', false, e.control.settings.value);
						}
					}
				};
			});
	
			editor.addButton('fontsizeselect', function() {
				var items = [], defaultFontsizeFormats = '8pt 10pt 12pt 14pt 18pt 24pt 36pt';
				var fontsize_formats = editor.settings.fontsize_formats || defaultFontsizeFormats;
	
				each(fontsize_formats.split(' '), function(item) {
					var text = item, value = item;
					// Allow text=value font sizes.
					var values = item.split('=');
					if (values.length > 1) {
						text = values[0];
						value = values[1];
					}
					items.push({text: text, value: value});
				});
	
				return {
					type: 'listbox',
					text: 'Font Sizes',
					tooltip: 'Font Sizes',
					values: items,
					fixedWidth: true,
					onPostRender: createListBoxChangeHandler(items, 'fontsize'),
					onclick: function(e) {
						if (e.control.settings.value) {
							editor.execCommand('FontSize', false, e.control.settings.value);
						}
					}
				};
			});
	
			editor.addMenuItem('formats', {
				text: 'Formats',
				menu: formatMenu
			});
		}
	});
	
	// Included from: js/tinymce/classes/ui/GridLayout.js
	
	/**
	 * GridLayout.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * This layout manager places controls in a grid.
	 *
	 * @setting {Number} spacing Spacing between controls.
	 * @setting {Number} spacingH Horizontal spacing between controls.
	 * @setting {Number} spacingV Vertical spacing between controls.
	 * @setting {Number} columns Number of columns to use.
	 * @setting {String/Array} alignH start|end|center|stretch or array of values for each column.
	 * @setting {String/Array} alignV start|end|center|stretch or array of values for each column.
	 * @setting {String} pack start|end
	 *
	 * @class tinymce.ui.GridLayout
	 * @extends tinymce.ui.AbsoluteLayout
	 */
	define("tinymce/ui/GridLayout", [
		"tinymce/ui/AbsoluteLayout"
	], function(AbsoluteLayout) {
		"use strict";
	
		return AbsoluteLayout.extend({
			/**
			 * Recalculates the positions of the controls in the specified container.
			 *
			 * @method recalc
			 * @param {tinymce.ui.Container} container Container instance to recalc.
			 */
			recalc: function(container) {
				var settings, rows, cols, items, contLayoutRect, width, height, rect,
					ctrlLayoutRect, ctrl, x, y, posX, posY, ctrlSettings, contPaddingBox, align, spacingH, spacingV, alignH, alignV, maxX, maxY,
					colWidths = [], rowHeights = [], ctrlMinWidth, ctrlMinHeight, availableWidth, availableHeight, reverseRows, idx;
	
				// Get layout settings
				settings = container.settings;
				items = container.items().filter(':visible');
				contLayoutRect = container.layoutRect();
				cols = settings.columns || Math.ceil(Math.sqrt(items.length));
				rows = Math.ceil(items.length / cols);
				spacingH = settings.spacingH || settings.spacing || 0;
				spacingV = settings.spacingV || settings.spacing || 0;
				alignH = settings.alignH || settings.align;
				alignV = settings.alignV || settings.align;
				contPaddingBox = container.paddingBox;
				reverseRows = 'reverseRows' in settings ? settings.reverseRows : container.isRtl();
	
				if (alignH && typeof alignH == "string") {
					alignH = [alignH];
				}
	
				if (alignV && typeof alignV == "string") {
					alignV = [alignV];
				}
	
				// Zero padd columnWidths
				for (x = 0; x < cols; x++) {
					colWidths.push(0);
				}
	
				// Zero padd rowHeights
				for (y = 0; y < rows; y++) {
					rowHeights.push(0);
				}
	
				// Calculate columnWidths and rowHeights
				for (y = 0; y < rows; y++) {
					for (x = 0; x < cols; x++) {
						ctrl = items[y * cols + x];
	
						// Out of bounds
						if (!ctrl) {
							break;
						}
	
						ctrlLayoutRect = ctrl.layoutRect();
						ctrlMinWidth = ctrlLayoutRect.minW;
						ctrlMinHeight = ctrlLayoutRect.minH;
	
						colWidths[x] = ctrlMinWidth > colWidths[x] ? ctrlMinWidth : colWidths[x];
						rowHeights[y] = ctrlMinHeight > rowHeights[y] ? ctrlMinHeight : rowHeights[y];
					}
				}
	
				// Calculate maxX
				availableWidth = contLayoutRect.innerW - contPaddingBox.left - contPaddingBox.right;
				for (maxX = 0, x = 0; x < cols; x++) {
					maxX += colWidths[x] + (x > 0 ? spacingH : 0);
					availableWidth -= (x > 0 ? spacingH : 0) + colWidths[x];
				}
	
				// Calculate maxY
				availableHeight = contLayoutRect.innerH - contPaddingBox.top - contPaddingBox.bottom;
				for (maxY = 0, y = 0; y < rows; y++) {
					maxY += rowHeights[y] + (y > 0 ? spacingV : 0);
					availableHeight -= (y > 0 ? spacingV : 0) + rowHeights[y];
				}
	
				maxX += contPaddingBox.left + contPaddingBox.right;
				maxY += contPaddingBox.top + contPaddingBox.bottom;
	
				// Calculate minW/minH
				rect = {};
				rect.minW = maxX + (contLayoutRect.w - contLayoutRect.innerW);
				rect.minH = maxY + (contLayoutRect.h - contLayoutRect.innerH);
	
				rect.contentW = rect.minW - contLayoutRect.deltaW;
				rect.contentH = rect.minH - contLayoutRect.deltaH;
				rect.minW = Math.min(rect.minW, contLayoutRect.maxW);
				rect.minH = Math.min(rect.minH, contLayoutRect.maxH);
				rect.minW = Math.max(rect.minW, contLayoutRect.startMinWidth);
				rect.minH = Math.max(rect.minH, contLayoutRect.startMinHeight);
	
				// Resize container container if minSize was changed
				if (contLayoutRect.autoResize && (rect.minW != contLayoutRect.minW || rect.minH != contLayoutRect.minH)) {
					rect.w = rect.minW;
					rect.h = rect.minH;
	
					container.layoutRect(rect);
					this.recalc(container);
	
					// Forced recalc for example if items are hidden/shown
					if (container._lastRect === null) {
						var parentCtrl = container.parent();
						if (parentCtrl) {
							parentCtrl._lastRect = null;
							parentCtrl.recalc();
						}
					}
	
					return;
				}
	
				// Update contentW/contentH so absEnd moves correctly
				if (contLayoutRect.autoResize) {
					rect = container.layoutRect(rect);
					rect.contentW = rect.minW - contLayoutRect.deltaW;
					rect.contentH = rect.minH - contLayoutRect.deltaH;
				}
	
				var flexV;
	
				if (settings.packV == 'start') {
					flexV = 0;
				} else {
					flexV = availableHeight > 0 ? Math.floor(availableHeight / rows) : 0;
				}
	
				// Calculate totalFlex
				var totalFlex = 0;
				var flexWidths = settings.flexWidths;
				if (flexWidths) {
					for (x = 0; x < flexWidths.length; x++) {
						totalFlex += flexWidths[x];
					}
				} else {
					totalFlex = cols;
				}
	
				// Calculate new column widths based on flex values
				var ratio = availableWidth / totalFlex;
				for (x = 0; x < cols; x++) {
					colWidths[x] += flexWidths ? flexWidths[x] * ratio : ratio;
				}
	
				// Move/resize controls
				posY = contPaddingBox.top;
				for (y = 0; y < rows; y++) {
					posX = contPaddingBox.left;
					height = rowHeights[y] + flexV;
	
					for (x = 0; x < cols; x++) {
						if (reverseRows) {
							idx = y * cols + cols - 1 - x;
						} else {
							idx = y * cols + x;
						}
	
						ctrl = items[idx];
	
						// No more controls to render then break
						if (!ctrl) {
							break;
						}
	
						// Get control settings and calculate x, y
						ctrlSettings = ctrl.settings;
						ctrlLayoutRect = ctrl.layoutRect();
						width = Math.max(colWidths[x], ctrlLayoutRect.startMinWidth);
						ctrlLayoutRect.x = posX;
						ctrlLayoutRect.y = posY;
	
						// Align control horizontal
						align = ctrlSettings.alignH || (alignH ? (alignH[x] || alignH[0]) : null);
						if (align == "center") {
							ctrlLayoutRect.x = posX + (width / 2) - (ctrlLayoutRect.w / 2);
						} else if (align == "right") {
							ctrlLayoutRect.x = posX + width - ctrlLayoutRect.w;
						} else if (align == "stretch") {
							ctrlLayoutRect.w = width;
						}
	
						// Align control vertical
						align = ctrlSettings.alignV || (alignV ? (alignV[x] || alignV[0]) : null);
						if (align == "center") {
							ctrlLayoutRect.y = posY + (height / 2) - (ctrlLayoutRect.h / 2);
						} else if (align == "bottom") {
							ctrlLayoutRect.y = posY + height - ctrlLayoutRect.h;
						} else if (align == "stretch") {
							ctrlLayoutRect.h = height;
						}
	
						ctrl.layoutRect(ctrlLayoutRect);
	
						posX += width + spacingH;
	
						if (ctrl.recalc) {
							ctrl.recalc();
						}
					}
	
					posY += height + spacingV;
				}
			}
		});
	});
	
	// Included from: js/tinymce/classes/ui/Iframe.js
	
	/**
	 * Iframe.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/*jshint scripturl:true */
	
	/**
	 * This class creates an iframe.
	 *
	 * @setting {String} url Url to open in the iframe.
	 *
	 * @-x-less Iframe.less
	 * @class tinymce.ui.Iframe
	 * @extends tinymce.ui.Widget
	 */
	define("tinymce/ui/Iframe", [
		"tinymce/ui/Widget",
		"tinymce/util/Delay"
	], function(Widget, Delay) {
		"use strict";
	
		return Widget.extend({
			/**
			 * Renders the control as a HTML string.
			 *
			 * @method renderHtml
			 * @return {String} HTML representing the control.
			 */
			renderHtml: function() {
				var self = this;
	
				self.classes.add('iframe');
				self.canFocus = false;
	
				/*eslint no-script-url:0 */
				return (
					'<iframe id="' + self._id + '" class="' + self.classes + '" tabindex="-1" src="' +
					(self.settings.url || "javascript:''") + '" frameborder="0"></iframe>'
				);
			},
	
			/**
			 * Setter for the iframe source.
			 *
			 * @method src
			 * @param {String} src Source URL for iframe.
			 */
			src: function(src) {
				this.getEl().src = src;
			},
	
			/**
			 * Inner HTML for the iframe.
			 *
			 * @method html
			 * @param {String} html HTML string to set as HTML inside the iframe.
			 * @param {function} callback Optional callback to execute when the iframe body is filled with contents.
			 * @return {tinymce.ui.Iframe} Current iframe control.
			 */
			html: function(html, callback) {
				var self = this, body = this.getEl().contentWindow.document.body;
	
				// Wait for iframe to initialize IE 10 takes time
				if (!body) {
					Delay.setTimeout(function() {
						self.html(html);
					});
				} else {
					body.innerHTML = html;
	
					if (callback) {
						callback();
					}
				}
	
				return this;
			}
		});
	});
	
	// Included from: js/tinymce/classes/ui/InfoBox.js
	
	/**
	 * InfoBox.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2016 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * ....
	 *
	 * @-x-less InfoBox.less
	 * @class tinymce.ui.InfoBox
	 * @extends tinymce.ui.Widget
	 */
	define("tinymce/ui/InfoBox", [
		"tinymce/ui/Widget"
	], function(Widget) {
		"use strict";
	
		return Widget.extend({
			/**
			 * Constructs a instance with the specified settings.
			 *
			 * @constructor
			 * @param {Object} settings Name/value object with settings.
			 * @setting {Boolean} multiline Multiline label.
			 */
			init: function(settings) {
				var self = this;
	
				self._super(settings);
				self.classes.add('widget').add('infobox');
				self.canFocus = false;
			},
	
			severity: function(level) {
				this.classes.remove('error');
				this.classes.remove('warning');
				this.classes.remove('success');
				this.classes.add(level);
			},
	
			help: function(state) {
				this.state.set('help', state);
			},
	
			/**
			 * Renders the control as a HTML string.
			 *
			 * @method renderHtml
			 * @return {String} HTML representing the control.
			 */
			renderHtml: function() {
				var self = this, prefix = self.classPrefix;
	
				return (
					'<div id="' + self._id + '" class="' + self.classes + '">' +
						'<div id="' + self._id + '-body">' +
							self.encode(self.state.get('text')) +
							'<button role="button" tabindex="-1">' +
								'<i class="' + prefix + 'ico ' + prefix + 'i-help"></i>' +
							'</button>' +
						'</div>' +
					'</div>'
				);
			},
	
			bindStates: function() {
				var self = this;
	
				self.state.on('change:text', function(e) {
					self.getEl('body').firstChild.data = self.encode(e.value);
	
					if (self.state.get('rendered')) {
						self.updateLayoutRect();
					}
				});
	
				self.state.on('change:help', function(e) {
					self.classes.toggle('has-help', e.value);
	
					if (self.state.get('rendered')) {
						self.updateLayoutRect();
					}
				});
	
				return self._super();
			}
		});
	});
	
	// Included from: js/tinymce/classes/ui/Label.js
	
	/**
	 * Label.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * This class creates a label element. A label is a simple text control
	 * that can be bound to other controls.
	 *
	 * @-x-less Label.less
	 * @class tinymce.ui.Label
	 * @extends tinymce.ui.Widget
	 */
	define("tinymce/ui/Label", [
		"tinymce/ui/Widget",
		"tinymce/ui/DomUtils"
	], function(Widget, DomUtils) {
		"use strict";
	
		return Widget.extend({
			/**
			 * Constructs a instance with the specified settings.
			 *
			 * @constructor
			 * @param {Object} settings Name/value object with settings.
			 * @setting {Boolean} multiline Multiline label.
			 */
			init: function(settings) {
				var self = this;
	
				self._super(settings);
				self.classes.add('widget').add('label');
				self.canFocus = false;
	
				if (settings.multiline) {
					self.classes.add('autoscroll');
				}
	
				if (settings.strong) {
					self.classes.add('strong');
				}
			},
	
			/**
			 * Initializes the current controls layout rect.
			 * This will be executed by the layout managers to determine the
			 * default minWidth/minHeight etc.
			 *
			 * @method initLayoutRect
			 * @return {Object} Layout rect instance.
			 */
			initLayoutRect: function() {
				var self = this, layoutRect = self._super();
	
				if (self.settings.multiline) {
					var size = DomUtils.getSize(self.getEl());
	
					// Check if the text fits within maxW if not then try word wrapping it
					if (size.width > layoutRect.maxW) {
						layoutRect.minW = layoutRect.maxW;
						self.classes.add('multiline');
					}
	
					self.getEl().style.width = layoutRect.minW + 'px';
					layoutRect.startMinH = layoutRect.h = layoutRect.minH = Math.min(layoutRect.maxH, DomUtils.getSize(self.getEl()).height);
				}
	
				return layoutRect;
			},
	
			/**
			 * Repaints the control after a layout operation.
			 *
			 * @method repaint
			 */
			repaint: function() {
				var self = this;
	
				if (!self.settings.multiline) {
					self.getEl().style.lineHeight = self.layoutRect().h + 'px';
				}
	
				return self._super();
			},
	
			severity: function(level) {
				this.classes.remove('error');
				this.classes.remove('warning');
				this.classes.remove('success');
				this.classes.add(level);
			},
	
			/**
			 * Renders the control as a HTML string.
			 *
			 * @method renderHtml
			 * @return {String} HTML representing the control.
			 */
			renderHtml: function() {
				var self = this, targetCtrl, forName, forId = self.settings.forId;
	
				if (!forId && (forName = self.settings.forName)) {
					targetCtrl = self.getRoot().find('#' + forName)[0];
	
					if (targetCtrl) {
						forId = targetCtrl._id;
					}
				}
	
				if (forId) {
					return (
						'<label id="' + self._id + '" class="' + self.classes + '"' + (forId ? ' for="' + forId + '"' : '') + '>' +
							self.encode(self.state.get('text')) +
						'</label>'
					);
				}
	
				return (
					'<span id="' + self._id + '" class="' + self.classes + '">' +
						self.encode(self.state.get('text')) +
					'</span>'
				);
			},
	
			bindStates: function() {
				var self = this;
	
				self.state.on('change:text', function(e) {
					self.innerHtml(self.encode(e.value));
	
					if (self.state.get('rendered')) {
						self.updateLayoutRect();
					}
				});
	
				return self._super();
			}
		});
	});
	
	// Included from: js/tinymce/classes/ui/Toolbar.js
	
	/**
	 * Toolbar.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * Creates a new toolbar.
	 *
	 * @class tinymce.ui.Toolbar
	 * @extends tinymce.ui.Container
	 */
	define("tinymce/ui/Toolbar", [
		"tinymce/ui/Container"
	], function(Container) {
		"use strict";
	
		return Container.extend({
			Defaults: {
				role: 'toolbar',
				layout: 'flow'
			},
	
			/**
			 * Constructs a instance with the specified settings.
			 *
			 * @constructor
			 * @param {Object} settings Name/value object with settings.
			 */
			init: function(settings) {
				var self = this;
	
				self._super(settings);
				self.classes.add('toolbar');
			},
	
			/**
			 * Called after the control has been rendered.
			 *
			 * @method postRender
			 */
			postRender: function() {
				var self = this;
	
				self.items().each(function(ctrl) {
					ctrl.classes.add('toolbar-item');
				});
	
				return self._super();
			}
		});
	});
	
	// Included from: js/tinymce/classes/ui/MenuBar.js
	
	/**
	 * MenuBar.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * Creates a new menubar.
	 *
	 * @-x-less MenuBar.less
	 * @class tinymce.ui.MenuBar
	 * @extends tinymce.ui.Container
	 */
	define("tinymce/ui/MenuBar", [
		"tinymce/ui/Toolbar"
	], function(Toolbar) {
		"use strict";
	
		return Toolbar.extend({
			Defaults: {
				role: 'menubar',
				containerCls: 'menubar',
				ariaRoot: true,
				defaults: {
					type: 'menubutton'
				}
			}
		});
	});
	
	// Included from: js/tinymce/classes/ui/MenuButton.js
	
	/**
	 * MenuButton.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * Creates a new menu button.
	 *
	 * @-x-less MenuButton.less
	 * @class tinymce.ui.MenuButton
	 * @extends tinymce.ui.Button
	 */
	define("tinymce/ui/MenuButton", [
		"tinymce/ui/Button",
		"tinymce/ui/Factory",
		"tinymce/ui/MenuBar"
	], function(Button, Factory, MenuBar) {
		"use strict";
	
		// TODO: Maybe add as some global function
		function isChildOf(node, parent) {
			while (node) {
				if (parent === node) {
					return true;
				}
	
				node = node.parentNode;
			}
	
			return false;
		}
	
		var MenuButton = Button.extend({
			/**
			 * Constructs a instance with the specified settings.
			 *
			 * @constructor
			 * @param {Object} settings Name/value object with settings.
			 */
			init: function(settings) {
				var self = this;
	
				self._renderOpen = true;
	
				self._super(settings);
				settings = self.settings;
	
				self.classes.add('menubtn');
	
				if (settings.fixedWidth) {
					self.classes.add('fixed-width');
				}
	
				self.aria('haspopup', true);
	
				self.state.set('menu', settings.menu || self.render());
			},
	
			/**
			 * Shows the menu for the button.
			 *
			 * @method showMenu
			 */
			showMenu: function() {
				var self = this, menu;
	
				if (self.menu && self.menu.visible()) {
					return self.hideMenu();
				}
	
				if (!self.menu) {
					menu = self.state.get('menu') || [];
	
					// Is menu array then auto constuct menu control
					if (menu.length) {
						menu = {
							type: 'menu',
							items: menu
						};
					} else {
						menu.type = menu.type || 'menu';
					}
	
					if (!menu.renderTo) {
						self.menu = Factory.create(menu).parent(self).renderTo();
					} else {
						self.menu = menu.parent(self).show().renderTo();
					}
	
					self.fire('createmenu');
					self.menu.reflow();
					self.menu.on('cancel', function(e) {
						if (e.control.parent() === self.menu) {
							e.stopPropagation();
							self.focus();
							self.hideMenu();
						}
					});
	
					// Move focus to button when a menu item is selected/clicked
					self.menu.on('select', function() {
						self.focus();
					});
	
					self.menu.on('show hide', function(e) {
						if (e.control == self.menu) {
							self.activeMenu(e.type == 'show');
						}
	
						self.aria('expanded', e.type == 'show');
					}).fire('show');
				}
	
				self.menu.show();
				self.menu.layoutRect({w: self.layoutRect().w});
				self.menu.moveRel(self.getEl(), self.isRtl() ? ['br-tr', 'tr-br'] : ['bl-tl', 'tl-bl']);
			},
	
			/**
			 * Hides the menu for the button.
			 *
			 * @method hideMenu
			 */
			hideMenu: function() {
				var self = this;
	
				if (self.menu) {
					self.menu.items().each(function(item) {
						if (item.hideMenu) {
							item.hideMenu();
						}
					});
	
					self.menu.hide();
				}
			},
	
			/**
			 * Sets the active menu state.
			 *
			 * @private
			 */
			activeMenu: function(state) {
				this.classes.toggle('active', state);
			},
	
			/**
			 * Renders the control as a HTML string.
			 *
			 * @method renderHtml
			 * @return {String} HTML representing the control.
			 */
			renderHtml: function() {
				var self = this, id = self._id, prefix = self.classPrefix;
				var icon = self.settings.icon, image, text = self.state.get('text'),
					textHtml = '';
	
				image = self.settings.image;
				if (image) {
					icon = 'none';
	
					// Support for [high dpi, low dpi] image sources
					if (typeof image != "string") {
						image = window.getSelection ? image[0] : image[1];
					}
	
					image = ' style="background-image: url(\'' + image + '\')"';
				} else {
					image = '';
				}
	
				if (text) {
					self.classes.add('btn-has-text');
					textHtml = '<span class="' + prefix + 'txt">' + self.encode(text) + '</span>';
				}
	
				icon = self.settings.icon ? prefix + 'ico ' + prefix + 'i-' + icon : '';
	
				self.aria('role', self.parent() instanceof MenuBar ? 'menuitem' : 'button');
	
				return (
					'<div id="' + id + '" class="' + self.classes + '" tabindex="-1" aria-labelledby="' + id + '">' +
						'<button id="' + id + '-open" role="presentation" type="button" tabindex="-1">' +
							(icon ? '<i class="' + icon + '"' + image + '></i>' : '') +
							textHtml +
							' <i class="' + prefix + 'caret"></i>' +
						'</button>' +
					'</div>'
				);
			},
	
			/**
			 * Gets invoked after the control has been rendered.
			 *
			 * @method postRender
			 */
			postRender: function() {
				var self = this;
	
				self.on('click', function(e) {
					if (e.control === self && isChildOf(e.target, self.getEl())) {
						self.showMenu();
	
						if (e.aria) {
							self.menu.items()[0].focus();
						}
					}
				});
	
				self.on('mouseenter', function(e) {
					var overCtrl = e.control, parent = self.parent(), hasVisibleSiblingMenu;
	
					if (overCtrl && parent && overCtrl instanceof MenuButton && overCtrl.parent() == parent) {
						parent.items().filter('MenuButton').each(function(ctrl) {
							if (ctrl.hideMenu && ctrl != overCtrl) {
								if (ctrl.menu && ctrl.menu.visible()) {
									hasVisibleSiblingMenu = true;
								}
	
								ctrl.hideMenu();
							}
						});
	
						if (hasVisibleSiblingMenu) {
							overCtrl.focus(); // Fix for: #5887
							overCtrl.showMenu();
						}
					}
				});
	
				return self._super();
			},
	
			bindStates: function() {
				var self = this;
	
				self.state.on('change:menu', function() {
					if (self.menu) {
						self.menu.remove();
					}
	
					self.menu = null;
				});
	
				return self._super();
			},
	
			/**
			 * Removes the control and it's menus.
			 *
			 * @method remove
			 */
			remove: function() {
				this._super();
	
				if (this.menu) {
					this.menu.remove();
				}
			}
		});
	
		return MenuButton;
	});
	
	// Included from: js/tinymce/classes/ui/MenuItem.js
	
	/**
	 * MenuItem.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * Creates a new menu item.
	 *
	 * @-x-less MenuItem.less
	 * @class tinymce.ui.MenuItem
	 * @extends tinymce.ui.Control
	 */
	define("tinymce/ui/MenuItem", [
		"tinymce/ui/Widget",
		"tinymce/ui/Factory",
		"tinymce/Env",
		"tinymce/util/Delay"
	], function(Widget, Factory, Env, Delay) {
		"use strict";
	
		return Widget.extend({
			Defaults: {
				border: 0,
				role: 'menuitem'
			},
	
			/**
			 * Constructs a instance with the specified settings.
			 *
			 * @constructor
			 * @param {Object} settings Name/value object with settings.
			 * @setting {Boolean} selectable Selectable menu.
			 * @setting {Array} menu Submenu array with items.
			 * @setting {String} shortcut Shortcut to display for menu item. Example: Ctrl+X
			 */
			init: function(settings) {
				var self = this, text;
	
				self._super(settings);
	
				settings = self.settings;
	
				self.classes.add('menu-item');
	
				if (settings.menu) {
					self.classes.add('menu-item-expand');
				}
	
				if (settings.preview) {
					self.classes.add('menu-item-preview');
				}
	
				text = self.state.get('text');
				if (text === '-' || text === '|') {
					self.classes.add('menu-item-sep');
					self.aria('role', 'separator');
					self.state.set('text', '-');
				}
	
				if (settings.selectable) {
					self.aria('role', 'menuitemcheckbox');
					self.classes.add('menu-item-checkbox');
					settings.icon = 'selected';
				}
	
				if (!settings.preview && !settings.selectable) {
					self.classes.add('menu-item-normal');
				}
	
				self.on('mousedown', function(e) {
					e.preventDefault();
				});
	
				if (settings.menu && !settings.ariaHideMenu) {
					self.aria('haspopup', true);
				}
			},
	
			/**
			 * Returns true/false if the menuitem has sub menu.
			 *
			 * @method hasMenus
			 * @return {Boolean} True/false state if it has submenu.
			 */
			hasMenus: function() {
				return !!this.settings.menu;
			},
	
			/**
			 * Shows the menu for the menu item.
			 *
			 * @method showMenu
			 */
			showMenu: function() {
				var self = this, settings = self.settings, menu, parent = self.parent();
	
				parent.items().each(function(ctrl) {
					if (ctrl !== self) {
						ctrl.hideMenu();
					}
				});
	
				if (settings.menu) {
					menu = self.menu;
	
					if (!menu) {
						menu = settings.menu;
	
						// Is menu array then auto constuct menu control
						if (menu.length) {
							menu = {
								type: 'menu',
								items: menu
							};
						} else {
							menu.type = menu.type || 'menu';
						}
	
						if (parent.settings.itemDefaults) {
							menu.itemDefaults = parent.settings.itemDefaults;
						}
	
						menu = self.menu = Factory.create(menu).parent(self).renderTo();
						menu.reflow();
						menu.on('cancel', function(e) {
							e.stopPropagation();
							self.focus();
							menu.hide();
						});
						menu.on('show hide', function(e) {
							e.control.items().each(function(ctrl) {
								ctrl.active(ctrl.settings.selected);
							});
						}).fire('show');
	
						menu.on('hide', function(e) {
							if (e.control === menu) {
								self.classes.remove('selected');
							}
						});
	
						menu.submenu = true;
					} else {
						menu.show();
					}
	
					menu._parentMenu = parent;
	
					menu.classes.add('menu-sub');
	
					var rel = menu.testMoveRel(
						self.getEl(),
						self.isRtl() ? ['tl-tr', 'bl-br', 'tr-tl', 'br-bl'] : ['tr-tl', 'br-bl', 'tl-tr', 'bl-br']
					);
	
					menu.moveRel(self.getEl(), rel);
					menu.rel = rel;
	
					rel = 'menu-sub-' + rel;
					menu.classes.remove(menu._lastRel).add(rel);
					menu._lastRel = rel;
	
					self.classes.add('selected');
					self.aria('expanded', true);
				}
			},
	
			/**
			 * Hides the menu for the menu item.
			 *
			 * @method hideMenu
			 */
			hideMenu: function() {
				var self = this;
	
				if (self.menu) {
					self.menu.items().each(function(item) {
						if (item.hideMenu) {
							item.hideMenu();
						}
					});
	
					self.menu.hide();
					self.aria('expanded', false);
				}
	
				return self;
			},
	
			/**
			 * Renders the control as a HTML string.
			 *
			 * @method renderHtml
			 * @return {String} HTML representing the control.
			 */
			renderHtml: function() {
				var self = this, id = self._id, settings = self.settings, prefix = self.classPrefix, text = self.encode(self.state.get('text'));
				var icon = self.settings.icon, image = '', shortcut = settings.shortcut;
	
				// Converts shortcut format to Mac/PC variants
				function convertShortcut(shortcut) {
					var i, value, replace = {};
	
					if (Env.mac) {
						replace = {
							alt: '&#x2325;',
							ctrl: '&#x2318;',
							shift: '&#x21E7;',
							meta: '&#x2318;'
						};
					} else {
						replace = {
							meta: 'Ctrl'
						};
					}
	
					shortcut = shortcut.split('+');
	
					for (i = 0; i < shortcut.length; i++) {
						value = replace[shortcut[i].toLowerCase()];
	
						if (value) {
							shortcut[i] = value;
						}
					}
	
					return shortcut.join('+');
				}
	
				if (icon) {
					self.parent().classes.add('menu-has-icons');
				}
	
				if (settings.image) {
					image = ' style="background-image: url(\'' + settings.image + '\')"';
				}
	
				if (shortcut) {
					shortcut = convertShortcut(shortcut);
				}
	
				icon = prefix + 'ico ' + prefix + 'i-' + (self.settings.icon || 'none');
	
				return (
					'<div id="' + id + '" class="' + self.classes + '" tabindex="-1">' +
						(text !== '-' ? '<i class="' + icon + '"' + image + '></i>\u00a0' : '') +
						(text !== '-' ? '<span id="' + id + '-text" class="' + prefix + 'text">' + text + '</span>' : '') +
						(shortcut ? '<div id="' + id + '-shortcut" class="' + prefix + 'menu-shortcut">' + shortcut + '</div>' : '') +
						(settings.menu ? '<div class="' + prefix + 'caret"></div>' : '') +
					'</div>'
				);
			},
	
			/**
			 * Gets invoked after the control has been rendered.
			 *
			 * @method postRender
			 */
			postRender: function() {
				var self = this, settings = self.settings;
	
				var textStyle = settings.textStyle;
				if (typeof textStyle == "function") {
					textStyle = textStyle.call(this);
				}
	
				if (textStyle) {
					var textElm = self.getEl('text');
					if (textElm) {
						textElm.setAttribute('style', textStyle);
					}
				}
	
				self.on('mouseenter click', function(e) {
					if (e.control === self) {
						if (!settings.menu && e.type === 'click') {
							self.fire('select');
	
							// Edge will crash if you stress it see #2660
							Delay.requestAnimationFrame(function() {
								self.parent().hideAll();
							});
						} else {
							self.showMenu();
	
							if (e.aria) {
								self.menu.focus(true);
							}
						}
					}
				});
	
				self._super();
	
				return self;
			},
	
			hover: function() {
				var self = this;
	
				self.parent().items().each(function(ctrl) {
					ctrl.classes.remove('selected');
				});
	
				self.classes.toggle('selected', true);
	
				return self;
			},
	
			active: function(state) {
				if (typeof state != "undefined") {
					this.aria('checked', state);
				}
	
				return this._super(state);
			},
	
			/**
			 * Removes the control and it's menus.
			 *
			 * @method remove
			 */
			remove: function() {
				this._super();
	
				if (this.menu) {
					this.menu.remove();
				}
			}
		});
	});
	
	// Included from: js/tinymce/classes/ui/Throbber.js
	
	/**
	 * Throbber.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * This class enables you to display a Throbber for any element.
	 *
	 * @-x-less Throbber.less
	 * @class tinymce.ui.Throbber
	 */
	define("tinymce/ui/Throbber", [
		"tinymce/dom/DomQuery",
		"tinymce/ui/Control",
		"tinymce/util/Delay"
	], function($, Control, Delay) {
		"use strict";
	
		/**
		 * Constructs a new throbber.
		 *
		 * @constructor
		 * @param {Element} elm DOM Html element to display throbber in.
		 * @param {Boolean} inline Optional true/false state if the throbber should be appended to end of element for infinite scroll.
		 */
		return function(elm, inline) {
			var self = this, state, classPrefix = Control.classPrefix, timer;
	
			/**
			 * Shows the throbber.
			 *
			 * @method show
			 * @param {Number} [time] Time to wait before showing.
			 * @param {function} [callback] Optional callback to execute when the throbber is shown.
			 * @return {tinymce.ui.Throbber} Current throbber instance.
			 */
			self.show = function(time, callback) {
				function render() {
						if (state) {
							$(elm).append(
								'<div class="' + classPrefix + 'throbber' + (inline ? ' ' + classPrefix + 'throbber-inline' : '') + '"></div>'
							);
	
							if (callback) {
								callback();
							}
						}
				}
	
				self.hide();
	
				state = true;
	
				if (time) {
					timer = Delay.setTimeout(render, time);
				} else {
					render();
				}
	
				return self;
			};
	
			/**
			 * Hides the throbber.
			 *
			 * @method hide
			 * @return {tinymce.ui.Throbber} Current throbber instance.
			 */
			self.hide = function() {
				var child = elm.lastChild;
	
				Delay.clearTimeout(timer);
	
				if (child && child.className.indexOf('throbber') != -1) {
					child.parentNode.removeChild(child);
				}
	
				state = false;
	
				return self;
			};
		};
	});
	
	// Included from: js/tinymce/classes/ui/Menu.js
	
	/**
	 * Menu.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * Creates a new menu.
	 *
	 * @-x-less Menu.less
	 * @class tinymce.ui.Menu
	 * @extends tinymce.ui.FloatPanel
	 */
	define("tinymce/ui/Menu", [
		"tinymce/ui/FloatPanel",
		"tinymce/ui/MenuItem",
		"tinymce/ui/Throbber",
		"tinymce/util/Tools"
	], function(FloatPanel, MenuItem, Throbber, Tools) {
		"use strict";
	
		return FloatPanel.extend({
			Defaults: {
				defaultType: 'menuitem',
				border: 1,
				layout: 'stack',
				role: 'application',
				bodyRole: 'menu',
				ariaRoot: true
			},
	
			/**
			 * Constructs a instance with the specified settings.
			 *
			 * @constructor
			 * @param {Object} settings Name/value object with settings.
			 */
			init: function(settings) {
				var self = this;
	
				settings.autohide = true;
				settings.constrainToViewport = true;
	
				if (typeof settings.items === 'function') {
					settings.itemsFactory = settings.items;
					settings.items = [];
				}
	
				if (settings.itemDefaults) {
					var items = settings.items, i = items.length;
	
					while (i--) {
						items[i] = Tools.extend({}, settings.itemDefaults, items[i]);
					}
				}
	
				self._super(settings);
				self.classes.add('menu');
			},
	
			/**
			 * Repaints the control after a layout operation.
			 *
			 * @method repaint
			 */
			repaint: function() {
				this.classes.toggle('menu-align', true);
	
				this._super();
	
				this.getEl().style.height = '';
				this.getEl('body').style.height = '';
	
				return this;
			},
	
			/**
			 * Hides/closes the menu.
			 *
			 * @method cancel
			 */
			cancel: function() {
				var self = this;
	
				self.hideAll();
				self.fire('select');
			},
	
			/**
			 * Loads new items from the factory items function.
			 *
			 * @method load
			 */
			load: function() {
				var self = this, time, factory;
	
				function hideThrobber() {
					if (self.throbber) {
						self.throbber.hide();
						self.throbber = null;
					}
				}
	
				factory = self.settings.itemsFactory;
				if (!factory) {
					return;
				}
	
				if (!self.throbber) {
					self.throbber = new Throbber(self.getEl('body'), true);
	
					if (self.items().length === 0) {
						self.throbber.show();
						self.fire('loading');
					} else {
						self.throbber.show(100, function() {
							self.items().remove();
							self.fire('loading');
						});
					}
	
					self.on('hide close', hideThrobber);
				}
	
				self.requestTime = time = new Date().getTime();
	
				self.settings.itemsFactory(function(items) {
					if (items.length === 0) {
						self.hide();
						return;
					}
	
					if (self.requestTime !== time) {
						return;
					}
	
					self.getEl().style.width = '';
					self.getEl('body').style.width = '';
	
					hideThrobber();
					self.items().remove();
					self.getEl('body').innerHTML = '';
	
					self.add(items);
					self.renderNew();
					self.fire('loaded');
				});
			},
	
			/**
			 * Hide menu and all sub menus.
			 *
			 * @method hideAll
			 */
			hideAll: function() {
				var self = this;
	
				this.find('menuitem').exec('hideMenu');
	
				return self._super();
			},
	
			/**
			 * Invoked before the menu is rendered.
			 *
			 * @method preRender
			 */
			preRender: function() {
				var self = this;
	
				self.items().each(function(ctrl) {
					var settings = ctrl.settings;
	
					if (settings.icon || settings.image || settings.selectable) {
						self._hasIcons = true;
						return false;
					}
				});
	
				if (self.settings.itemsFactory) {
					self.on('postrender', function() {
						if (self.settings.itemsFactory) {
							self.load();
						}
					});
				}
	
				return self._super();
			}
		});
	});
	
	// Included from: js/tinymce/classes/ui/ListBox.js
	
	/**
	 * ListBox.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * Creates a new list box control.
	 *
	 * @-x-less ListBox.less
	 * @class tinymce.ui.ListBox
	 * @extends tinymce.ui.MenuButton
	 */
	define("tinymce/ui/ListBox", [
		"tinymce/ui/MenuButton",
		"tinymce/ui/Menu"
	], function(MenuButton, Menu) {
		"use strict";
	
		return MenuButton.extend({
			/**
			 * Constructs a instance with the specified settings.
			 *
			 * @constructor
			 * @param {Object} settings Name/value object with settings.
			 * @setting {Array} values Array with values to add to list box.
			 */
			init: function(settings) {
				var self = this, values, selected, selectedText, lastItemCtrl;
	
				function setSelected(menuValues) {
					// Try to find a selected value
					for (var i = 0; i < menuValues.length; i++) {
						selected = menuValues[i].selected || settings.value === menuValues[i].value;
	
						if (selected) {
							selectedText = selectedText || menuValues[i].text;
							self.state.set('value', menuValues[i].value);
							return true;
						}
	
						// If the value has a submenu, try to find the selected values in that menu
						if (menuValues[i].menu) {
							if (setSelected(menuValues[i].menu)) {
								return true;
							}
						}
					}
				}
	
				self._super(settings);
				settings = self.settings;
	
				self._values = values = settings.values;
				if (values) {
					if (typeof settings.value != "undefined") {
						setSelected(values);
					}
	
					// Default with first item
					if (!selected && values.length > 0) {
						selectedText = values[0].text;
						self.state.set('value', values[0].value);
					}
	
					self.state.set('menu', values);
				}
	
				self.state.set('text', settings.text || selectedText);
	
				self.classes.add('listbox');
	
				self.on('select', function(e) {
					var ctrl = e.control;
	
					if (lastItemCtrl) {
						e.lastControl = lastItemCtrl;
					}
	
					if (settings.multiple) {
						ctrl.active(!ctrl.active());
					} else {
						self.value(e.control.value());
					}
	
					lastItemCtrl = ctrl;
				});
			},
	
			/**
			 * Getter/setter function for the control value.
			 *
			 * @method value
			 * @param {String} [value] Value to be set.
			 * @return {Boolean/tinymce.ui.ListBox} Value or self if it's a set operation.
			 */
			bindStates: function() {
				var self = this;
	
				function activateMenuItemsByValue(menu, value) {
					if (menu instanceof Menu) {
						menu.items().each(function(ctrl) {
							if (!ctrl.hasMenus()) {
								ctrl.active(ctrl.value() === value);
							}
						});
					}
				}
	
				function getSelectedItem(menuValues, value) {
					var selectedItem;
	
					if (!menuValues) {
						return;
					}
	
					for (var i = 0; i < menuValues.length; i++) {
						if (menuValues[i].value === value) {
							return menuValues[i];
						}
	
						if (menuValues[i].menu) {
							selectedItem = getSelectedItem(menuValues[i].menu, value);
							if (selectedItem) {
								return selectedItem;
							}
						}
					}
				}
	
				self.on('show', function(e) {
					activateMenuItemsByValue(e.control, self.value());
				});
	
				self.state.on('change:value', function(e) {
					var selectedItem = getSelectedItem(self.state.get('menu'), e.value);
	
					if (selectedItem) {
						self.text(selectedItem.text);
					} else {
						self.text(self.settings.text);
					}
				});
	
				return self._super();
			}
		});
	});
	
	// Included from: js/tinymce/classes/ui/Radio.js
	
	/**
	 * Radio.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * Creates a new radio button.
	 *
	 * @-x-less Radio.less
	 * @class tinymce.ui.Radio
	 * @extends tinymce.ui.Checkbox
	 */
	define("tinymce/ui/Radio", [
		"tinymce/ui/Checkbox"
	], function(Checkbox) {
		"use strict";
	
		return Checkbox.extend({
			Defaults: {
				classes: "radio",
				role: "radio"
			}
		});
	});
	
	// Included from: js/tinymce/classes/ui/ResizeHandle.js
	
	/**
	 * ResizeHandle.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * Renders a resize handle that fires ResizeStart, Resize and ResizeEnd events.
	 *
	 * @-x-less ResizeHandle.less
	 * @class tinymce.ui.ResizeHandle
	 * @extends tinymce.ui.Widget
	 */
	define("tinymce/ui/ResizeHandle", [
		"tinymce/ui/Widget",
		"tinymce/ui/DragHelper"
	], function(Widget, DragHelper) {
		"use strict";
	
		return Widget.extend({
			/**
			 * Renders the control as a HTML string.
			 *
			 * @method renderHtml
			 * @return {String} HTML representing the control.
			 */
			renderHtml: function() {
				var self = this, prefix = self.classPrefix;
	
				self.classes.add('resizehandle');
	
				if (self.settings.direction == "both") {
					self.classes.add('resizehandle-both');
				}
	
				self.canFocus = false;
	
				return (
					'<div id="' + self._id + '" class="' + self.classes + '">' +
						'<i class="' + prefix + 'ico ' + prefix + 'i-resize"></i>' +
					'</div>'
				);
			},
	
			/**
			 * Called after the control has been rendered.
			 *
			 * @method postRender
			 */
			postRender: function() {
				var self = this;
	
				self._super();
	
				self.resizeDragHelper = new DragHelper(this._id, {
					start: function() {
						self.fire('ResizeStart');
					},
	
					drag: function(e) {
						if (self.settings.direction != "both") {
							e.deltaX = 0;
						}
	
						self.fire('Resize', e);
					},
	
					stop: function() {
						self.fire('ResizeEnd');
					}
				});
			},
	
			remove: function() {
				if (this.resizeDragHelper) {
					this.resizeDragHelper.destroy();
				}
	
				return this._super();
			}
		});
	});
	
	// Included from: js/tinymce/classes/ui/SelectBox.js
	
	/**
	 * SelectBox.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * Creates a new select box control.
	 *
	 * @-x-less SelectBox.less
	 * @class tinymce.ui.SelectBox
	 * @extends tinymce.ui.Widget
	 */
	define("tinymce/ui/SelectBox", [
		"tinymce/ui/Widget"
	], function(Widget) {
		"use strict";
	
		function createOptions(options) {
			var strOptions = '';
			if (options) {
				for (var i = 0; i < options.length; i++) {
					strOptions += '<option value="' + options[i] + '">' + options[i] + '</option>';
				}
			}
			return strOptions;
		}
	
		return Widget.extend({
			Defaults: {
				classes: "selectbox",
				role: "selectbox",
				options: []
			},
			/**
			 * Constructs a instance with the specified settings.
			 *
			 * @constructor
			 * @param {Object} settings Name/value object with settings.
			 * @setting {Array} values Array with values to add to list box.
			 */
			init: function(settings) {
				var self = this;
	
				self._super(settings);
	
				if (self.settings.size) {
					self.size = self.settings.size;
				}
	
				if (self.settings.options) {
					self._options = self.settings.options;
				}
	
				self.on('keydown', function(e) {
					var rootControl;
	
					if (e.keyCode == 13) {
						e.preventDefault();
	
						// Find root control that we can do toJSON on
						self.parents().reverse().each(function(ctrl) {
							if (ctrl.toJSON) {
								rootControl = ctrl;
								return false;
							}
						});
	
						// Fire event on current text box with the serialized data of the whole form
						self.fire('submit', {data: rootControl.toJSON()});
					}
				});
			},
	
			/**
			 * Getter/setter function for the options state.
			 *
			 * @method options
			 * @param {Array} [state] State to be set.
			 * @return {Array|tinymce.ui.SelectBox} Array of string options.
			 */
			options: function(state) {
				if (!arguments.length) {
					return this.state.get('options');
				}
	
				this.state.set('options', state);
	
				return this;
			},
	
			renderHtml: function() {
				var self = this, options, size = '';
	
				options = createOptions(self._options);
	
				if (self.size) {
					size = ' size = "' + self.size + '"';
				}
	
				return (
					'<select id="' + self._id + '" class="' + self.classes + '"' + size + '>' +
						options +
					'</select>'
				);
			},
	
			bindStates: function() {
				var self = this;
	
				self.state.on('change:options', function(e) {
					self.getEl().innerHTML = createOptions(e.value);
				});
	
				return self._super();
			}
		});
	});
	
	// Included from: js/tinymce/classes/ui/Slider.js
	
	/**
	 * Slider.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * Slider control.
	 *
	 * @-x-less Slider.less
	 * @class tinymce.ui.Slider
	 * @extends tinymce.ui.Widget
	 */
	define("tinymce/ui/Slider", [
		"tinymce/ui/Widget",
		"tinymce/ui/DragHelper",
		"tinymce/ui/DomUtils"
	], function(Widget, DragHelper, DomUtils) {
		"use strict";
	
		function constrain(value, minVal, maxVal) {
			if (value < minVal) {
				value = minVal;
			}
	
			if (value > maxVal) {
				value = maxVal;
			}
	
			return value;
		}
	
		function setAriaProp(el, name, value) {
			el.setAttribute('aria-' + name, value);
		}
	
		function updateSliderHandle(ctrl, value) {
			var maxHandlePos, shortSizeName, sizeName, stylePosName, styleValue, handleEl;
	
			if (ctrl.settings.orientation == "v") {
				stylePosName = "top";
				sizeName = "height";
				shortSizeName = "h";
			} else {
				stylePosName = "left";
				sizeName = "width";
				shortSizeName = "w";
			}
	
			handleEl = ctrl.getEl('handle');
			maxHandlePos = (ctrl.layoutRect()[shortSizeName] || 100) - DomUtils.getSize(handleEl)[sizeName];
	
			styleValue = (maxHandlePos * ((value - ctrl._minValue) / (ctrl._maxValue - ctrl._minValue))) + 'px';
			handleEl.style[stylePosName] = styleValue;
			handleEl.style.height = ctrl.layoutRect().h + 'px';
	
			setAriaProp(handleEl, 'valuenow', value);
			setAriaProp(handleEl, 'valuetext', '' + ctrl.settings.previewFilter(value));
			setAriaProp(handleEl, 'valuemin', ctrl._minValue);
			setAriaProp(handleEl, 'valuemax', ctrl._maxValue);
		}
	
		return Widget.extend({
			init: function(settings) {
				var self = this;
	
				if (!settings.previewFilter) {
					settings.previewFilter = function(value) {
						return Math.round(value * 100) / 100.0;
					};
				}
	
				self._super(settings);
				self.classes.add('slider');
	
				if (settings.orientation == "v") {
					self.classes.add('vertical');
				}
	
				self._minValue = settings.minValue || 0;
				self._maxValue = settings.maxValue || 100;
				self._initValue = self.state.get('value');
			},
	
			renderHtml: function() {
				var self = this, id = self._id, prefix = self.classPrefix;
	
				return (
					'<div id="' + id + '" class="' + self.classes + '">' +
						'<div id="' + id + '-handle" class="' + prefix + 'slider-handle" role="slider" tabindex="-1"></div>' +
					'</div>'
				);
			},
	
			reset: function() {
				this.value(this._initValue).repaint();
			},
	
			postRender: function() {
				var self = this, minValue, maxValue, screenCordName,
						stylePosName, sizeName, shortSizeName;
	
				function toFraction(min, max, val) {
					return (val + min) / (max - min);
				}
	
				function fromFraction(min, max, val) {
					return (val * (max - min)) - min;
				}
	
				function handleKeyboard(minValue, maxValue) {
					function alter(delta) {
						var value;
	
						value = self.value();
						value = fromFraction(minValue, maxValue, toFraction(minValue, maxValue, value) + (delta * 0.05));
						value = constrain(value, minValue, maxValue);
	
						self.value(value);
	
						self.fire('dragstart', {value: value});
						self.fire('drag', {value: value});
						self.fire('dragend', {value: value});
					}
	
					self.on('keydown', function(e) {
						switch (e.keyCode) {
							case 37:
							case 38:
								alter(-1);
								break;
	
							case 39:
							case 40:
								alter(1);
								break;
						}
					});
				}
	
				function handleDrag(minValue, maxValue, handleEl) {
					var startPos, startHandlePos, maxHandlePos, handlePos, value;
	
					self._dragHelper = new DragHelper(self._id, {
						handle: self._id + "-handle",
	
						start: function(e) {
							startPos = e[screenCordName];
							startHandlePos = parseInt(self.getEl('handle').style[stylePosName], 10);
							maxHandlePos = (self.layoutRect()[shortSizeName] || 100) - DomUtils.getSize(handleEl)[sizeName];
							self.fire('dragstart', {value: value});
						},
	
						drag: function(e) {
							var delta = e[screenCordName] - startPos;
	
							handlePos = constrain(startHandlePos + delta, 0, maxHandlePos);
							handleEl.style[stylePosName] = handlePos + 'px';
	
							value = minValue + (handlePos / maxHandlePos) * (maxValue - minValue);
							self.value(value);
	
							self.tooltip().text('' + self.settings.previewFilter(value)).show().moveRel(handleEl, 'bc tc');
	
							self.fire('drag', {value: value});
						},
	
						stop: function() {
							self.tooltip().hide();
							self.fire('dragend', {value: value});
						}
					});
				}
	
				minValue = self._minValue;
				maxValue = self._maxValue;
	
				if (self.settings.orientation == "v") {
					screenCordName = "screenY";
					stylePosName = "top";
					sizeName = "height";
					shortSizeName = "h";
				} else {
					screenCordName = "screenX";
					stylePosName = "left";
					sizeName = "width";
					shortSizeName = "w";
				}
	
				self._super();
	
				handleKeyboard(minValue, maxValue, self.getEl('handle'));
				handleDrag(minValue, maxValue, self.getEl('handle'));
			},
	
			repaint: function() {
				this._super();
				updateSliderHandle(this, this.value());
			},
	
			bindStates: function() {
				var self = this;
	
				self.state.on('change:value', function(e) {
					updateSliderHandle(self, e.value);
				});
	
				return self._super();
			}
		});
	});
	
	// Included from: js/tinymce/classes/ui/Spacer.js
	
	/**
	 * Spacer.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * Creates a spacer. This control is used in flex layouts for example.
	 *
	 * @-x-less Spacer.less
	 * @class tinymce.ui.Spacer
	 * @extends tinymce.ui.Widget
	 */
	define("tinymce/ui/Spacer", [
		"tinymce/ui/Widget"
	], function(Widget) {
		"use strict";
	
		return Widget.extend({
			/**
			 * Renders the control as a HTML string.
			 *
			 * @method renderHtml
			 * @return {String} HTML representing the control.
			 */
			renderHtml: function() {
				var self = this;
	
				self.classes.add('spacer');
				self.canFocus = false;
	
				return '<div id="' + self._id + '" class="' + self.classes + '"></div>';
			}
		});
	});
	
	// Included from: js/tinymce/classes/ui/SplitButton.js
	
	/**
	 * SplitButton.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * Creates a split button.
	 *
	 * @-x-less SplitButton.less
	 * @class tinymce.ui.SplitButton
	 * @extends tinymce.ui.Button
	 */
	define("tinymce/ui/SplitButton", [
		"tinymce/ui/MenuButton",
		"tinymce/ui/DomUtils",
		"tinymce/dom/DomQuery"
	], function(MenuButton, DomUtils, $) {
		return MenuButton.extend({
			Defaults: {
				classes: "widget btn splitbtn",
				role: "button"
			},
	
			/**
			 * Repaints the control after a layout operation.
			 *
			 * @method repaint
			 */
			repaint: function() {
				var self = this, elm = self.getEl(), rect = self.layoutRect(), mainButtonElm, menuButtonElm;
	
				self._super();
	
				mainButtonElm = elm.firstChild;
				menuButtonElm = elm.lastChild;
	
				$(mainButtonElm).css({
					width: rect.w - DomUtils.getSize(menuButtonElm).width,
					height: rect.h - 2
				});
	
				$(menuButtonElm).css({
					height: rect.h - 2
				});
	
				return self;
			},
	
			/**
			 * Sets the active menu state.
			 *
			 * @private
			 */
			activeMenu: function(state) {
				var self = this;
	
				$(self.getEl().lastChild).toggleClass(self.classPrefix + 'active', state);
			},
	
			/**
			 * Renders the control as a HTML string.
			 *
			 * @method renderHtml
			 * @return {String} HTML representing the control.
			 */
			renderHtml: function() {
				var self = this, id = self._id, prefix = self.classPrefix, image;
				var icon = self.state.get('icon'), text = self.state.get('text'),
					textHtml = '';
	
				image = self.settings.image;
				if (image) {
					icon = 'none';
	
					// Support for [high dpi, low dpi] image sources
					if (typeof image != "string") {
						image = window.getSelection ? image[0] : image[1];
					}
	
					image = ' style="background-image: url(\'' + image + '\')"';
				} else {
					image = '';
				}
	
				icon = self.settings.icon ? prefix + 'ico ' + prefix + 'i-' + icon : '';
	
				if (text) {
					self.classes.add('btn-has-text');
					textHtml = '<span class="' + prefix + 'txt">' + self.encode(text) + '</span>';
				}
	
				return (
					'<div id="' + id + '" class="' + self.classes + '" role="button" tabindex="-1">' +
						'<button type="button" hidefocus="1" tabindex="-1">' +
							(icon ? '<i class="' + icon + '"' + image + '></i>' : '') +
							textHtml +
						'</button>' +
						'<button type="button" class="' + prefix + 'open" hidefocus="1" tabindex="-1">' +
							//(icon ? '<i class="' + icon + '"></i>' : '') +
							(self._menuBtnText ? (icon ? '\u00a0' : '') + self._menuBtnText : '') +
							' <i class="' + prefix + 'caret"></i>' +
						'</button>' +
					'</div>'
				);
			},
	
			/**
			 * Called after the control has been rendered.
			 *
			 * @method postRender
			 */
			postRender: function() {
				var self = this, onClickHandler = self.settings.onclick;
	
				self.on('click', function(e) {
					var node = e.target;
	
					if (e.control == this) {
						// Find clicks that is on the main button
						while (node) {
							if ((e.aria && e.aria.key != 'down') || (node.nodeName == 'BUTTON' && node.className.indexOf('open') == -1)) {
								e.stopImmediatePropagation();
	
								if (onClickHandler) {
									onClickHandler.call(this, e);
								}
	
								return;
							}
	
							node = node.parentNode;
						}
					}
				});
	
				delete self.settings.onclick;
	
				return self._super();
			}
		});
	});
	
	// Included from: js/tinymce/classes/ui/StackLayout.js
	
	/**
	 * StackLayout.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * This layout uses the browsers layout when the items are blocks.
	 *
	 * @-x-less StackLayout.less
	 * @class tinymce.ui.StackLayout
	 * @extends tinymce.ui.FlowLayout
	 */
	define("tinymce/ui/StackLayout", [
		"tinymce/ui/FlowLayout"
	], function(FlowLayout) {
		"use strict";
	
		return FlowLayout.extend({
			Defaults: {
				containerClass: 'stack-layout',
				controlClass: 'stack-layout-item',
				endClass: 'break'
			},
	
			isNative: function() {
				return true;
			}
		});
	});
	
	// Included from: js/tinymce/classes/ui/TabPanel.js
	
	/**
	 * TabPanel.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * Creates a tab panel control.
	 *
	 * @-x-less TabPanel.less
	 * @class tinymce.ui.TabPanel
	 * @extends tinymce.ui.Panel
	 *
	 * @setting {Number} activeTab Active tab index.
	 */
	define("tinymce/ui/TabPanel", [
		"tinymce/ui/Panel",
		"tinymce/dom/DomQuery",
		"tinymce/ui/DomUtils"
	], function(Panel, $, DomUtils) {
		"use strict";
	
		return Panel.extend({
			Defaults: {
				layout: 'absolute',
				defaults: {
					type: 'panel'
				}
			},
	
			/**
			 * Activates the specified tab by index.
			 *
			 * @method activateTab
			 * @param {Number} idx Index of the tab to activate.
			 */
			activateTab: function(idx) {
				var activeTabElm;
	
				if (this.activeTabId) {
					activeTabElm = this.getEl(this.activeTabId);
					$(activeTabElm).removeClass(this.classPrefix + 'active');
					activeTabElm.setAttribute('aria-selected', "false");
				}
	
				this.activeTabId = 't' + idx;
	
				activeTabElm = this.getEl('t' + idx);
				activeTabElm.setAttribute('aria-selected', "true");
				$(activeTabElm).addClass(this.classPrefix + 'active');
	
				this.items()[idx].show().fire('showtab');
				this.reflow();
	
				this.items().each(function(item, i) {
					if (idx != i) {
						item.hide();
					}
				});
			},
	
			/**
			 * Renders the control as a HTML string.
			 *
			 * @method renderHtml
			 * @return {String} HTML representing the control.
			 */
			renderHtml: function() {
				var self = this, layout = self._layout, tabsHtml = '', prefix = self.classPrefix;
	
				self.preRender();
				layout.preRender(self);
	
				self.items().each(function(ctrl, i) {
					var id = self._id + '-t' + i;
	
					ctrl.aria('role', 'tabpanel');
					ctrl.aria('labelledby', id);
	
					tabsHtml += (
						'<div id="' + id + '" class="' + prefix + 'tab" ' +
							'unselectable="on" role="tab" aria-controls="' + ctrl._id + '" aria-selected="false" tabIndex="-1">' +
							self.encode(ctrl.settings.title) +
						'</div>'
					);
				});
	
				return (
					'<div id="' + self._id + '" class="' + self.classes + '" hidefocus="1" tabindex="-1">' +
						'<div id="' + self._id + '-head" class="' + prefix + 'tabs" role="tablist">' +
							tabsHtml +
						'</div>' +
						'<div id="' + self._id + '-body" class="' + self.bodyClasses + '">' +
							layout.renderHtml(self) +
						'</div>' +
					'</div>'
				);
			},
	
			/**
			 * Called after the control has been rendered.
			 *
			 * @method postRender
			 */
			postRender: function() {
				var self = this;
	
				self._super();
	
				self.settings.activeTab = self.settings.activeTab || 0;
				self.activateTab(self.settings.activeTab);
	
				this.on('click', function(e) {
					var targetParent = e.target.parentNode;
	
					if (e.target.parentNode.id == self._id + '-head') {
						var i = targetParent.childNodes.length;
	
						while (i--) {
							if (targetParent.childNodes[i] == e.target) {
								self.activateTab(i);
							}
						}
					}
				});
			},
	
			/**
			 * Initializes the current controls layout rect.
			 * This will be executed by the layout managers to determine the
			 * default minWidth/minHeight etc.
			 *
			 * @method initLayoutRect
			 * @return {Object} Layout rect instance.
			 */
			initLayoutRect: function() {
				var self = this, rect, minW, minH;
	
				minW = DomUtils.getSize(self.getEl('head')).width;
				minW = minW < 0 ? 0 : minW;
				minH = 0;
	
				self.items().each(function(item) {
					minW = Math.max(minW, item.layoutRect().minW);
					minH = Math.max(minH, item.layoutRect().minH);
				});
	
				self.items().each(function(ctrl) {
					ctrl.settings.x = 0;
					ctrl.settings.y = 0;
					ctrl.settings.w = minW;
					ctrl.settings.h = minH;
	
					ctrl.layoutRect({
						x: 0,
						y: 0,
						w: minW,
						h: minH
					});
				});
	
				var headH = DomUtils.getSize(self.getEl('head')).height;
	
				self.settings.minWidth = minW;
				self.settings.minHeight = minH + headH;
	
				rect = self._super();
				rect.deltaH += headH;
				rect.innerH = rect.h - rect.deltaH;
	
				return rect;
			}
		});
	});
	
	// Included from: js/tinymce/classes/ui/TextBox.js
	
	/**
	 * TextBox.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * Creates a new textbox.
	 *
	 * @-x-less TextBox.less
	 * @class tinymce.ui.TextBox
	 * @extends tinymce.ui.Widget
	 */
	define("tinymce/ui/TextBox", [
		"tinymce/ui/Widget",
		"tinymce/util/Tools",
		"tinymce/ui/DomUtils"
	], function(Widget, Tools, DomUtils) {
		return Widget.extend({
			/**
			 * Constructs a instance with the specified settings.
			 *
			 * @constructor
			 * @param {Object} settings Name/value object with settings.
			 * @setting {Boolean} multiline True if the textbox is a multiline control.
			 * @setting {Number} maxLength Max length for the textbox.
			 * @setting {Number} size Size of the textbox in characters.
			 */
			init: function(settings) {
				var self = this;
	
				self._super(settings);
	
				self.classes.add('textbox');
	
				if (settings.multiline) {
					self.classes.add('multiline');
				} else {
					self.on('keydown', function(e) {
						var rootControl;
	
						if (e.keyCode == 13) {
							e.preventDefault();
	
							// Find root control that we can do toJSON on
							self.parents().reverse().each(function(ctrl) {
								if (ctrl.toJSON) {
									rootControl = ctrl;
									return false;
								}
							});
	
							// Fire event on current text box with the serialized data of the whole form
							self.fire('submit', {data: rootControl.toJSON()});
						}
					});
	
					self.on('keyup', function(e) {
						self.state.set('value', e.target.value);
					});
				}
			},
	
			/**
			 * Repaints the control after a layout operation.
			 *
			 * @method repaint
			 */
			repaint: function() {
				var self = this, style, rect, borderBox, borderW, borderH = 0, lastRepaintRect;
	
				style = self.getEl().style;
				rect = self._layoutRect;
				lastRepaintRect = self._lastRepaintRect || {};
	
				// Detect old IE 7+8 add lineHeight to align caret vertically in the middle
				var doc = document;
				if (!self.settings.multiline && doc.all && (!doc.documentMode || doc.documentMode <= 8)) {
					style.lineHeight = (rect.h - borderH) + 'px';
				}
	
				borderBox = self.borderBox;
				borderW = borderBox.left + borderBox.right + 8;
				borderH = borderBox.top + borderBox.bottom + (self.settings.multiline ? 8 : 0);
	
				if (rect.x !== lastRepaintRect.x) {
					style.left = rect.x + 'px';
					lastRepaintRect.x = rect.x;
				}
	
				if (rect.y !== lastRepaintRect.y) {
					style.top = rect.y + 'px';
					lastRepaintRect.y = rect.y;
				}
	
				if (rect.w !== lastRepaintRect.w) {
					style.width = (rect.w - borderW) + 'px';
					lastRepaintRect.w = rect.w;
				}
	
				if (rect.h !== lastRepaintRect.h) {
					style.height = (rect.h - borderH) + 'px';
					lastRepaintRect.h = rect.h;
				}
	
				self._lastRepaintRect = lastRepaintRect;
				self.fire('repaint', {}, false);
	
				return self;
			},
	
			/**
			 * Renders the control as a HTML string.
			 *
			 * @method renderHtml
			 * @return {String} HTML representing the control.
			 */
			renderHtml: function() {
				var self = this, settings = self.settings, attrs, elm;
	
				attrs = {
					id: self._id,
					hidefocus: '1'
				};
	
				Tools.each([
					'rows',	'spellcheck',	'maxLength', 'size', 'readonly', 'min',
					'max', 'step', 'list', 'pattern', 'placeholder', 'required', 'multiple'
				], function(name) {
					attrs[name] = settings[name];
				});
	
				if (self.disabled()) {
					attrs.disabled = 'disabled';
				}
	
				if (settings.subtype) {
					attrs.type = settings.subtype;
				}
	
				elm = DomUtils.create(settings.multiline ? 'textarea' : 'input', attrs);
				elm.value = self.state.get('value');
				elm.className = self.classes;
	
				return elm.outerHTML;
			},
	
			value: function(value) {
				if (arguments.length) {
					this.state.set('value', value);
					return this;
				}
	
				// Make sure the real state is in sync
				if (this.state.get('rendered')) {
					this.state.set('value', this.getEl().value);
				}
	
				return this.state.get('value');
			},
	
			/**
			 * Called after the control has been rendered.
			 *
			 * @method postRender
			 */
			postRender: function() {
				var self = this;
	
				self.getEl().value = self.state.get('value');
				self._super();
	
				self.$el.on('change', function(e) {
					self.state.set('value', e.target.value);
					self.fire('change', e);
				});
			},
	
			bindStates: function() {
				var self = this;
	
				self.state.on('change:value', function(e) {
					if (self.getEl().value != e.value) {
						self.getEl().value = e.value;
					}
				});
	
				self.state.on('change:disabled', function(e) {
					self.getEl().disabled = e.value;
				});
	
				return self._super();
			},
	
			remove: function() {
				this.$el.off();
				this._super();
			}
		});
	});
	
	// Included from: js/tinymce/classes/Register.js
	
	/**
	 * Register.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * This registers tinymce in common module loaders.
	 *
	 * @private
	 * @class tinymce.Register
	 */
	define("tinymce/Register", [
	], function() {
		/*eslint consistent-this: 0 */
		var context = this || window;
	
		var tinymce = function() {
			return context.tinymce;
		};
	
		if (typeof context.define === "function") {
			// Bolt
			if (!context.define.amd) {
				context.define("ephox/tinymce", [], tinymce);
			}
		}
	
		return {};
	});
	
	expose(["tinymce/geom/Rect","tinymce/util/Promise","tinymce/util/Delay","tinymce/Env","tinymce/dom/EventUtils","tinymce/dom/Sizzle","tinymce/util/Tools","tinymce/dom/DomQuery","tinymce/html/Styles","tinymce/dom/TreeWalker","tinymce/html/Entities","tinymce/dom/DOMUtils","tinymce/dom/ScriptLoader","tinymce/AddOnManager","tinymce/dom/RangeUtils","tinymce/html/Node","tinymce/html/Schema","tinymce/html/SaxParser","tinymce/html/DomParser","tinymce/html/Writer","tinymce/html/Serializer","tinymce/dom/Serializer","tinymce/util/VK","tinymce/dom/ControlSelection","tinymce/dom/BookmarkManager","tinymce/dom/Selection","tinymce/Formatter","tinymce/UndoManager","tinymce/EditorCommands","tinymce/util/URI","tinymce/util/Class","tinymce/util/EventDispatcher","tinymce/util/Observable","tinymce/ui/Selector","tinymce/ui/Collection","tinymce/ui/ReflowQueue","tinymce/ui/Control","tinymce/ui/Factory","tinymce/ui/KeyboardNavigation","tinymce/ui/Container","tinymce/ui/DragHelper","tinymce/ui/Scrollable","tinymce/ui/Panel","tinymce/ui/Movable","tinymce/ui/Resizable","tinymce/ui/FloatPanel","tinymce/ui/Window","tinymce/ui/MessageBox","tinymce/WindowManager","tinymce/ui/Tooltip","tinymce/ui/Widget","tinymce/ui/Progress","tinymce/ui/Notification","tinymce/NotificationManager","tinymce/EditorObservable","tinymce/Shortcuts","tinymce/Editor","tinymce/util/I18n","tinymce/FocusManager","tinymce/EditorManager","tinymce/util/XHR","tinymce/util/JSON","tinymce/util/JSONRequest","tinymce/util/JSONP","tinymce/util/LocalStorage","tinymce/Compat","tinymce/ui/Layout","tinymce/ui/AbsoluteLayout","tinymce/ui/Button","tinymce/ui/ButtonGroup","tinymce/ui/Checkbox","tinymce/ui/ComboBox","tinymce/ui/ColorBox","tinymce/ui/PanelButton","tinymce/ui/ColorButton","tinymce/util/Color","tinymce/ui/ColorPicker","tinymce/ui/Path","tinymce/ui/ElementPath","tinymce/ui/FormItem","tinymce/ui/Form","tinymce/ui/FieldSet","tinymce/ui/FilePicker","tinymce/ui/FitLayout","tinymce/ui/FlexLayout","tinymce/ui/FlowLayout","tinymce/ui/FormatControls","tinymce/ui/GridLayout","tinymce/ui/Iframe","tinymce/ui/InfoBox","tinymce/ui/Label","tinymce/ui/Toolbar","tinymce/ui/MenuBar","tinymce/ui/MenuButton","tinymce/ui/MenuItem","tinymce/ui/Throbber","tinymce/ui/Menu","tinymce/ui/ListBox","tinymce/ui/Radio","tinymce/ui/ResizeHandle","tinymce/ui/SelectBox","tinymce/ui/Slider","tinymce/ui/Spacer","tinymce/ui/SplitButton","tinymce/ui/StackLayout","tinymce/ui/TabPanel","tinymce/ui/TextBox"]);
	})(this);
	
	/*** EXPORTS FROM exports-loader ***/
	module.exports = window.tinymce;
	}.call(window));
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(24).setImmediate))

/***/ },
/* 24 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(setImmediate, clearImmediate) {var nextTick = __webpack_require__(25).nextTick;
	var apply = Function.prototype.apply;
	var slice = Array.prototype.slice;
	var immediateIds = {};
	var nextImmediateId = 0;
	
	// DOM APIs, for completeness
	
	exports.setTimeout = function() {
	  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
	};
	exports.setInterval = function() {
	  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
	};
	exports.clearTimeout =
	exports.clearInterval = function(timeout) { timeout.close(); };
	
	function Timeout(id, clearFn) {
	  this._id = id;
	  this._clearFn = clearFn;
	}
	Timeout.prototype.unref = Timeout.prototype.ref = function() {};
	Timeout.prototype.close = function() {
	  this._clearFn.call(window, this._id);
	};
	
	// Does not start the time, just sets up the members needed.
	exports.enroll = function(item, msecs) {
	  clearTimeout(item._idleTimeoutId);
	  item._idleTimeout = msecs;
	};
	
	exports.unenroll = function(item) {
	  clearTimeout(item._idleTimeoutId);
	  item._idleTimeout = -1;
	};
	
	exports._unrefActive = exports.active = function(item) {
	  clearTimeout(item._idleTimeoutId);
	
	  var msecs = item._idleTimeout;
	  if (msecs >= 0) {
	    item._idleTimeoutId = setTimeout(function onTimeout() {
	      if (item._onTimeout)
	        item._onTimeout();
	    }, msecs);
	  }
	};
	
	// That's not how node.js implements it but the exposed api is the same.
	exports.setImmediate = typeof setImmediate === "function" ? setImmediate : function(fn) {
	  var id = nextImmediateId++;
	  var args = arguments.length < 2 ? false : slice.call(arguments, 1);
	
	  immediateIds[id] = true;
	
	  nextTick(function onNextTick() {
	    if (immediateIds[id]) {
	      // fn.call() is faster so we optimize for the common use-case
	      // @see http://jsperf.com/call-apply-segu
	      if (args) {
	        fn.apply(null, args);
	      } else {
	        fn.call(null);
	      }
	      // Prevent ids from leaking
	      exports.clearImmediate(id);
	    }
	  });
	
	  return id;
	};
	
	exports.clearImmediate = typeof clearImmediate === "function" ? clearImmediate : function(id) {
	  delete immediateIds[id];
	};
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(24).setImmediate, __webpack_require__(24).clearImmediate))

/***/ },
/* 25 */
/***/ function(module, exports) {

	// shim for using process in browser
	
	var process = module.exports = {};
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;
	
	function cleanUpNextTick() {
	    if (!draining || !currentQueue) {
	        return;
	    }
	    draining = false;
	    if (currentQueue.length) {
	        queue = currentQueue.concat(queue);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue.length) {
	        drainQueue();
	    }
	}
	
	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = setTimeout(cleanUpNextTick);
	    draining = true;
	
	    var len = queue.length;
	    while(len) {
	        currentQueue = queue;
	        queue = [];
	        while (++queueIndex < len) {
	            if (currentQueue) {
	                currentQueue[queueIndex].run();
	            }
	        }
	        queueIndex = -1;
	        len = queue.length;
	    }
	    currentQueue = null;
	    draining = false;
	    clearTimeout(timeout);
	}
	
	process.nextTick = function (fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue.push(new Item(fun, args));
	    if (queue.length === 1 && !draining) {
	        setTimeout(drainQueue, 0);
	    }
	};
	
	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];
	process.version = ''; // empty string to avoid regexp issues
	process.versions = {};
	
	function noop() {}
	
	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;
	
	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	};
	
	process.cwd = function () { return '/' };
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};
	process.umask = function() { return 0; };


/***/ },
/* 26 */
/***/ function(module, exports) {

	/*** IMPORTS FROM imports-loader ***/
	(function() {
	
	/**
	 * theme.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/*global tinymce:true */
	
	tinymce.ThemeManager.add('modern', function(editor) {
		var self = this, settings = editor.settings, Factory = tinymce.ui.Factory,
			each = tinymce.each, DOM = tinymce.DOM, Rect = tinymce.geom.Rect, FloatPanel = tinymce.ui.FloatPanel;
	
		// Default menus
		var defaultMenus = {
			file: {title: 'File', items: 'newdocument'},
			edit: {title: 'Edit', items: 'undo redo | cut copy paste pastetext | selectall'},
			insert: {title: 'Insert', items: '|'},
			view: {title: 'View', items: 'visualaid |'},
			format: {title: 'Format', items: 'bold italic underline strikethrough superscript subscript | formats | removeformat'},
			table: {title: 'Table'},
			tools: {title: 'Tools'}
		};
	
		var defaultToolbar = "undo redo | styleselect | bold italic | alignleft aligncenter alignright alignjustify | " +
			"bullist numlist outdent indent | link image";
	
		function createToolbar(items, size) {
			var toolbarItems = [], buttonGroup;
	
			if (!items) {
				return;
			}
	
			each(items.split(/[ ,]/), function(item) {
				var itemName;
	
				function bindSelectorChanged() {
					var selection = editor.selection;
	
					function setActiveItem(name) {
						return function(state, args) {
							var nodeName, i = args.parents.length;
	
							while (i--) {
								nodeName = args.parents[i].nodeName;
								if (nodeName == "OL" || nodeName == "UL") {
									break;
								}
							}
	
							item.active(state && nodeName == name);
						};
					}
	
					if (itemName == "bullist") {
						selection.selectorChanged('ul > li', setActiveItem("UL"));
					}
	
					if (itemName == "numlist") {
						selection.selectorChanged('ol > li', setActiveItem("OL"));
					}
	
					if (item.settings.stateSelector) {
						selection.selectorChanged(item.settings.stateSelector, function(state) {
							item.active(state);
						}, true);
					}
	
					if (item.settings.disabledStateSelector) {
						selection.selectorChanged(item.settings.disabledStateSelector, function(state) {
							item.disabled(state);
						});
					}
				}
	
				if (item == "|") {
					buttonGroup = null;
				} else {
					if (Factory.has(item)) {
						item = {type: item, size: size};
						toolbarItems.push(item);
						buttonGroup = null;
					} else {
						if (!buttonGroup) {
							buttonGroup = {type: 'buttongroup', items: []};
							toolbarItems.push(buttonGroup);
						}
	
						if (editor.buttons[item]) {
							// TODO: Move control creation to some UI class
							itemName = item;
							item = editor.buttons[itemName];
	
							if (typeof item == "function") {
								item = item();
							}
	
							item.type = item.type || 'button';
							item.size = size;
	
							item = Factory.create(item);
							buttonGroup.items.push(item);
	
							if (editor.initialized) {
								bindSelectorChanged();
							} else {
								editor.on('init', bindSelectorChanged);
							}
						}
					}
				}
			});
	
			return {
				type: 'toolbar',
				layout: 'flow',
				items: toolbarItems
			};
		}
	
		/**
		 * Creates the toolbars from config and returns a toolbar array.
		 *
		 * @param {String} size Optional toolbar item size.
		 * @return {Array} Array with toolbars.
		 */
		function createToolbars(size) {
			var toolbars = [];
	
			function addToolbar(items) {
				if (items) {
					toolbars.push(createToolbar(items, size));
					return true;
				}
			}
	
			// Convert toolbar array to multiple options
			if (tinymce.isArray(settings.toolbar)) {
				// Empty toolbar array is the same as a disabled toolbar
				if (settings.toolbar.length === 0) {
					return;
				}
	
				tinymce.each(settings.toolbar, function(toolbar, i) {
					settings["toolbar" + (i + 1)] = toolbar;
				});
	
				delete settings.toolbar;
			}
	
			// Generate toolbar<n>
			for (var i = 1; i < 10; i++) {
				if (!addToolbar(settings["toolbar" + i])) {
					break;
				}
			}
	
			// Generate toolbar or default toolbar unless it's disabled
			if (!toolbars.length && settings.toolbar !== false) {
				addToolbar(settings.toolbar || defaultToolbar);
			}
	
			if (toolbars.length) {
				return {
					type: 'panel',
					layout: 'stack',
					classes: "toolbar-grp",
					ariaRoot: true,
					ariaRemember: true,
					items: toolbars
				};
			}
		}
	
		/**
		 * Creates the menu buttons based on config.
		 *
		 * @return {Array} Menu buttons array.
		 */
		function createMenuButtons() {
			var name, menuButtons = [];
	
			function createMenuItem(name) {
				var menuItem;
	
				if (name == '|') {
					return {text: '|'};
				}
	
				menuItem = editor.menuItems[name];
	
				return menuItem;
			}
	
			function createMenu(context) {
				var menuButton, menu, menuItems, isUserDefined, removedMenuItems;
	
				removedMenuItems = tinymce.makeMap((settings.removed_menuitems || '').split(/[ ,]/));
	
				// User defined menu
				if (settings.menu) {
					menu = settings.menu[context];
					isUserDefined = true;
				} else {
					menu = defaultMenus[context];
				}
	
				if (menu) {
					menuButton = {text: menu.title};
					menuItems = [];
	
					// Default/user defined items
					each((menu.items || '').split(/[ ,]/), function(item) {
						var menuItem = createMenuItem(item);
	
						if (menuItem && !removedMenuItems[item]) {
							menuItems.push(createMenuItem(item));
						}
					});
	
					// Added though context
					if (!isUserDefined) {
						each(editor.menuItems, function(menuItem) {
							if (menuItem.context == context) {
								if (menuItem.separator == 'before') {
									menuItems.push({text: '|'});
								}
	
								if (menuItem.prependToContext) {
									menuItems.unshift(menuItem);
								} else {
									menuItems.push(menuItem);
								}
	
								if (menuItem.separator == 'after') {
									menuItems.push({text: '|'});
								}
							}
						});
					}
	
					for (var i = 0; i < menuItems.length; i++) {
						if (menuItems[i].text == '|') {
							if (i === 0 || i == menuItems.length - 1) {
								menuItems.splice(i, 1);
							}
						}
					}
	
					menuButton.menu = menuItems;
	
					if (!menuButton.menu.length) {
						return null;
					}
				}
	
				return menuButton;
			}
	
			var defaultMenuBar = [];
			if (settings.menu) {
				for (name in settings.menu) {
					defaultMenuBar.push(name);
				}
			} else {
				for (name in defaultMenus) {
					defaultMenuBar.push(name);
				}
			}
	
			var enabledMenuNames = typeof settings.menubar == "string" ? settings.menubar.split(/[ ,]/) : defaultMenuBar;
			for (var i = 0; i < enabledMenuNames.length; i++) {
				var menu = enabledMenuNames[i];
				menu = createMenu(menu);
	
				if (menu) {
					menuButtons.push(menu);
				}
			}
	
			return menuButtons;
		}
	
		/**
		 * Adds accessibility shortcut keys to panel.
		 *
		 * @param {tinymce.ui.Panel} panel Panel to add focus to.
		 */
		function addAccessibilityKeys(panel) {
			function focus(type) {
				var item = panel.find(type)[0];
	
				if (item) {
					item.focus(true);
				}
			}
	
			editor.shortcuts.add('Alt+F9', '', function() {
				focus('menubar');
			});
	
			editor.shortcuts.add('Alt+F10', '', function() {
				focus('toolbar');
			});
	
			editor.shortcuts.add('Alt+F11', '', function() {
				focus('elementpath');
			});
	
			panel.on('cancel', function() {
				editor.focus();
			});
		}
	
		/**
		 * Resizes the editor to the specified width, height.
		 */
		function resizeTo(width, height) {
			var containerElm, iframeElm, containerSize, iframeSize;
	
			function getSize(elm) {
				return {
					width: elm.clientWidth,
					height: elm.clientHeight
				};
			}
	
			containerElm = editor.getContainer();
			iframeElm = editor.getContentAreaContainer().firstChild;
			containerSize = getSize(containerElm);
			iframeSize = getSize(iframeElm);
	
			if (width !== null) {
				width = Math.max(settings.min_width || 100, width);
				width = Math.min(settings.max_width || 0xFFFF, width);
	
				DOM.setStyle(containerElm, 'width', width + (containerSize.width - iframeSize.width));
				DOM.setStyle(iframeElm, 'width', width);
			}
	
			height = Math.max(settings.min_height || 100, height);
			height = Math.min(settings.max_height || 0xFFFF, height);
			DOM.setStyle(iframeElm, 'height', height);
	
			editor.fire('ResizeEditor');
		}
	
		function resizeBy(dw, dh) {
			var elm = editor.getContentAreaContainer();
			self.resizeTo(elm.clientWidth + dw, elm.clientHeight + dh);
		}
	
		/**
		 * Handles contextual toolbars.
		 */
		function addContextualToolbars() {
			var scrollContainer;
	
			function getContextToolbars() {
				return editor.contextToolbars || [];
			}
	
			function getElementRect(elm) {
				var pos, targetRect, root;
	
				pos = tinymce.DOM.getPos(editor.getContentAreaContainer());
				targetRect = editor.dom.getRect(elm);
				root = editor.dom.getRoot();
	
				// Adjust targetPos for scrolling in the editor
				if (root.nodeName == 'BODY') {
					targetRect.x -= root.ownerDocument.documentElement.scrollLeft || root.scrollLeft;
					targetRect.y -= root.ownerDocument.documentElement.scrollTop || root.scrollTop;
				}
	
				targetRect.x += pos.x;
				targetRect.y += pos.y;
	
				return targetRect;
			}
	
			function hideAllFloatingPanels() {
				each(editor.contextToolbars, function(toolbar) {
					if (toolbar.panel) {
						toolbar.panel.hide();
					}
				});
			}
	
			function togglePositionClass(panel, relPos, predicate) {
				relPos = relPos ? relPos.substr(0, 2) : '';
	
				each({
					t: 'down',
					b: 'up'
				}, function(cls, pos) {
					panel.classes.toggle('arrow-' + cls, predicate(pos, relPos.substr(0, 1)));
				});
	
				each({
					l: 'left',
					r: 'right'
				}, function(cls, pos) {
					panel.classes.toggle('arrow-' + cls, predicate(pos, relPos.substr(1, 1)));
				});
			}
	
			function toClientRect(geomRect) {
				return {
					left: geomRect.x,
					top: geomRect.y,
					width: geomRect.w,
					height: geomRect.h,
					right: geomRect.x + geomRect.w,
					bottom: geomRect.y + geomRect.h
				};
			}
	
			function userConstrain(x, y, elementRect, contentAreaRect, panelRect) {
					panelRect = toClientRect({x: x, y: y, w: panelRect.w, h: panelRect.h});
	
					if (settings.inline_toolbar_position_handler) {
						panelRect = settings.inline_toolbar_position_handler({
							elementRect: toClientRect(elementRect),
							contentAreaRect: toClientRect(contentAreaRect),
							panelRect: panelRect
						});
					}
	
					return panelRect;
			}
	
			function movePanelTo(panel, pos) {
				panel.moveTo(pos.left, pos.top);
			}
	
			function reposition(match) {
				var relPos, panelRect, elementRect, contentAreaRect, panel, relRect, testPositions;
	
				if (editor.removed) {
					return;
				}
	
				if (!match || !match.toolbar.panel) {
					hideAllFloatingPanels();
					return;
				}
	
				testPositions = [
					'bc-tc', 'tc-bc',
					'tl-bl', 'bl-tl',
					'tr-br', 'br-tr'
				];
	
				panel = match.toolbar.panel;
				panel.show();
	
				elementRect = getElementRect(match.element);
				panelRect = tinymce.DOM.getRect(panel.getEl());
				contentAreaRect = tinymce.DOM.getRect(editor.getContentAreaContainer() || editor.getBody());
	
				// We need to use these instead of the rect values since the style
				// size properites might not be the same as the real size for a table
				elementRect.w = match.element.clientWidth;
				elementRect.h = match.element.clientHeight;
	
				if (!editor.inline) {
					contentAreaRect.w = editor.getDoc().documentElement.offsetWidth;
				}
	
				// Inflate the elementRect so it doesn't get placed above resize handles
				if (editor.selection.controlSelection.isResizable(match.element)) {
					elementRect = Rect.inflate(elementRect, 0, 8);
				}
	
				relPos = Rect.findBestRelativePosition(panelRect, elementRect, contentAreaRect, testPositions);
				elementRect = Rect.clamp(elementRect, contentAreaRect);
	
				if (relPos) {
					relRect = Rect.relativePosition(panelRect, elementRect, relPos);
					movePanelTo(panel, userConstrain(relRect.x, relRect.y, elementRect, contentAreaRect, panelRect));
				} else {
					// Allow overflow below the editor to avoid placing toolbars ontop of tables
					contentAreaRect.h += 40;
	
					elementRect = Rect.intersect(contentAreaRect, elementRect);
					if (elementRect) {
						relPos = Rect.findBestRelativePosition(panelRect, elementRect, contentAreaRect, [
							'bc-tc', 'bl-tl', 'br-tr'
						]);
	
						if (relPos) {
							relRect = Rect.relativePosition(panelRect, elementRect, relPos);
							movePanelTo(panel, userConstrain(relRect.x, relRect.y, elementRect, contentAreaRect, panelRect));
						} else {
							movePanelTo(panel, userConstrain(elementRect.x, elementRect.y, elementRect, contentAreaRect, panelRect));
						}
					} else {
						panel.hide();
					}
				}
	
				togglePositionClass(panel, relPos, function(pos1, pos2) {
					return (!elementRect || elementRect.w > 40) && pos1 === pos2;
				});
	
				//drawRect(contentAreaRect, 'blue');
				//drawRect(elementRect, 'red');
				//drawRect(panelRect, 'green');
			}
	
			function repositionHandler() {
				function execute() {
					if (editor.selection) {
						reposition(findFrontMostMatch(editor.selection.getNode()));
					}
				}
	
				tinymce.util.Delay.requestAnimationFrame(execute);
			}
	
			function bindScrollEvent() {
				if (!scrollContainer) {
					scrollContainer = editor.selection.getScrollContainer() || editor.getWin();
					tinymce.$(scrollContainer).on('scroll', repositionHandler);
	
					editor.on('remove', function() {
						tinymce.$(scrollContainer).off('scroll');
					});
				}
			}
	
			function showContextToolbar(match) {
				var panel;
	
				if (match.toolbar.panel) {
					match.toolbar.panel.show();
					reposition(match);
					return;
				}
	
				bindScrollEvent();
	
				panel = Factory.create({
					type: 'floatpanel',
					role: 'dialog',
					classes: 'tinymce tinymce-inline arrow',
					ariaLabel: 'Inline toolbar',
					layout: 'flex',
					direction: 'column',
					align: 'stretch',
					autohide: false,
					autofix: true,
					fixed: true,
					border: 1,
					items: createToolbar(match.toolbar.items),
					oncancel: function() {
						editor.focus();
					}
				});
	
				match.toolbar.panel = panel;
				panel.renderTo(document.body).reflow();
				reposition(match);
			}
	
			function hideAllContextToolbars() {
				tinymce.each(getContextToolbars(), function(toolbar) {
					if (toolbar.panel) {
						toolbar.panel.hide();
					}
				});
			}
	
			function findFrontMostMatch(targetElm) {
				var i, y, parentsAndSelf, toolbars = getContextToolbars();
	
				parentsAndSelf = editor.$(targetElm).parents().add(targetElm);
				for (i = parentsAndSelf.length - 1; i >= 0; i--) {
					for (y = toolbars.length - 1; y >= 0; y--) {
						if (toolbars[y].predicate(parentsAndSelf[i])) {
							return {
								toolbar: toolbars[y],
								element: parentsAndSelf[i]
							};
						}
					}
				}
	
				return null;
			}
	
			editor.on('click keyup setContent', function(e) {
				// Only act on partial inserts
				if (e.type == 'setcontent' && !e.selection) {
					return;
				}
	
				// Needs to be delayed to avoid Chrome img focus out bug
				tinymce.util.Delay.setEditorTimeout(editor, function() {
					var match;
	
					match = findFrontMostMatch(editor.selection.getNode());
					if (match) {
						hideAllContextToolbars();
						showContextToolbar(match);
					} else {
						hideAllContextToolbars();
					}
				});
			});
	
			editor.on('blur hide', hideAllContextToolbars);
	
			editor.on('ObjectResizeStart', function() {
				var match = findFrontMostMatch(editor.selection.getNode());
	
				if (match && match.toolbar.panel) {
					match.toolbar.panel.hide();
				}
			});
	
			editor.on('nodeChange ResizeEditor ResizeWindow', repositionHandler);
	
			editor.on('remove', function() {
				tinymce.each(getContextToolbars(), function(toolbar) {
					if (toolbar.panel) {
						toolbar.panel.remove();
					}
				});
	
				editor.contextToolbars = {};
			});
	
			editor.shortcuts.add('ctrl+shift+e > ctrl+shift+p', '', function() {
				var match = findFrontMostMatch(editor.selection.getNode());
				if (match && match.toolbar.panel) {
					match.toolbar.panel.items()[0].focus();
				}
			});
		}
	
		function fireSkinLoaded(editor) {
			return function() {
				if (editor.initialized) {
					editor.fire('SkinLoaded');
				} else {
					editor.on('init', function() {
						editor.fire('SkinLoaded');
					});
				}
			};
		}
	
		/**
		 * Renders the inline editor UI.
		 *
		 * @return {Object} Name/value object with theme data.
		 */
		function renderInlineUI(args) {
			var panel, inlineToolbarContainer;
	
			if (settings.fixed_toolbar_container) {
				inlineToolbarContainer = DOM.select(settings.fixed_toolbar_container)[0];
			}
	
			function reposition() {
				if (panel && panel.moveRel && panel.visible() && !panel._fixed) {
					// TODO: This is kind of ugly and doesn't handle multiple scrollable elements
					var scrollContainer = editor.selection.getScrollContainer(), body = editor.getBody();
					var deltaX = 0, deltaY = 0;
	
					if (scrollContainer) {
						var bodyPos = DOM.getPos(body), scrollContainerPos = DOM.getPos(scrollContainer);
	
						deltaX = Math.max(0, scrollContainerPos.x - bodyPos.x);
						deltaY = Math.max(0, scrollContainerPos.y - bodyPos.y);
					}
	
					panel.fixed(false).moveRel(body, editor.rtl ? ['tr-br', 'br-tr'] : ['tl-bl', 'bl-tl', 'tr-br']).moveBy(deltaX, deltaY);
				}
			}
	
			function show() {
				if (panel) {
					panel.show();
					reposition();
					DOM.addClass(editor.getBody(), 'mce-edit-focus');
				}
			}
	
			function hide() {
				if (panel) {
					// We require two events as the inline float panel based toolbar does not have autohide=true
					panel.hide();
	
					// All other autohidden float panels will be closed below.
					FloatPanel.hideAll();
	
					DOM.removeClass(editor.getBody(), 'mce-edit-focus');
				}
			}
	
			function render() {
				if (panel) {
					if (!panel.visible()) {
						show();
					}
	
					return;
				}
	
				// Render a plain panel inside the inlineToolbarContainer if it's defined
				panel = self.panel = Factory.create({
					type: inlineToolbarContainer ? 'panel' : 'floatpanel',
					role: 'application',
					classes: 'tinymce tinymce-inline',
					layout: 'flex',
					direction: 'column',
					align: 'stretch',
					autohide: false,
					autofix: true,
					fixed: !!inlineToolbarContainer,
					border: 1,
					items: [
						settings.menubar === false ? null : {type: 'menubar', border: '0 0 1 0', items: createMenuButtons()},
						createToolbars(settings.toolbar_items_size)
					]
				});
	
				// Add statusbar
				/*if (settings.statusbar !== false) {
					panel.add({type: 'panel', classes: 'statusbar', layout: 'flow', border: '1 0 0 0', items: [
						{type: 'elementpath'}
					]});
				}*/
	
				editor.fire('BeforeRenderUI');
				panel.renderTo(inlineToolbarContainer || document.body).reflow();
	
				addAccessibilityKeys(panel);
				show();
				addContextualToolbars();
	
				editor.on('nodeChange', reposition);
				editor.on('activate', show);
				editor.on('deactivate', hide);
	
				editor.nodeChanged();
			}
	
			settings.content_editable = true;
	
			editor.on('focus', function() {
				// Render only when the CSS file has been loaded
				if (args.skinUiCss) {
					tinymce.DOM.styleSheetLoader.load(args.skinUiCss, render, render);
				} else {
					render();
				}
			});
	
			editor.on('blur hide', hide);
	
			// Remove the panel when the editor is removed
			editor.on('remove', function() {
				if (panel) {
					panel.remove();
					panel = null;
				}
			});
	
			// Preload skin css
			if (args.skinUiCss) {
				tinymce.DOM.styleSheetLoader.load(args.skinUiCss, fireSkinLoaded(editor));
			}
	
			return {};
		}
	
		/**
		 * Renders the iframe editor UI.
		 *
		 * @param {Object} args Details about target element etc.
		 * @return {Object} Name/value object with theme data.
		 */
		function renderIframeUI(args) {
			var panel, resizeHandleCtrl, startSize;
	
			function switchMode() {
				return function(e) {
					if (e.mode == 'readonly') {
						panel.find('*').disabled(true);
					} else {
						panel.find('*').disabled(false);
					}
				};
			}
	
			if (args.skinUiCss) {
				tinymce.DOM.styleSheetLoader.load(args.skinUiCss, fireSkinLoaded(editor));
			}
	
			// Basic UI layout
			panel = self.panel = Factory.create({
				type: 'panel',
				role: 'application',
				classes: 'tinymce',
				style: 'visibility: hidden',
				layout: 'stack',
				border: 1,
				items: [
					settings.menubar === false ? null : {type: 'menubar', border: '0 0 1 0', items: createMenuButtons()},
					createToolbars(settings.toolbar_items_size),
					{type: 'panel', name: 'iframe', layout: 'stack', classes: 'edit-area', html: '', border: '1 0 0 0'}
				]
			});
	
			if (settings.resize !== false) {
				resizeHandleCtrl = {
					type: 'resizehandle',
					direction: settings.resize,
	
					onResizeStart: function() {
						var elm = editor.getContentAreaContainer().firstChild;
	
						startSize = {
							width: elm.clientWidth,
							height: elm.clientHeight
						};
					},
	
					onResize: function(e) {
						if (settings.resize == 'both') {
							resizeTo(startSize.width + e.deltaX, startSize.height + e.deltaY);
						} else {
							resizeTo(null, startSize.height + e.deltaY);
						}
					}
				};
			}
	
			// Add statusbar if needed
			if (settings.statusbar !== false) {
				panel.add({type: 'panel', name: 'statusbar', classes: 'statusbar', layout: 'flow', border: '1 0 0 0', ariaRoot: true, items: [
					{type: 'elementpath'},
					resizeHandleCtrl
				]});
			}
	
			editor.fire('BeforeRenderUI');
			editor.on('SwitchMode', switchMode());
			panel.renderBefore(args.targetNode).reflow();
	
			if (settings.readonly) {
				editor.setMode('readonly');
			}
	
			if (settings.width) {
				tinymce.DOM.setStyle(panel.getEl(), 'width', settings.width);
			}
	
			// Remove the panel when the editor is removed
			editor.on('remove', function() {
				panel.remove();
				panel = null;
			});
	
			// Add accesibility shortcuts
			addAccessibilityKeys(panel);
			addContextualToolbars();
	
			return {
				iframeContainer: panel.find('#iframe')[0].getEl(),
				editorContainer: panel.getEl()
			};
		}
	
		/**
		 * Renders the UI for the theme. This gets called by the editor.
		 *
		 * @param {Object} args Details about target element etc.
		 * @return {Object} Theme UI data items.
		 */
		self.renderUI = function(args) {
			var skin = settings.skin !== false ? settings.skin || 'lightgray' : false;
	
			if (skin) {
				var skinUrl = settings.skin_url;
	
				if (skinUrl) {
					skinUrl = editor.documentBaseURI.toAbsolute(skinUrl);
				} else {
					skinUrl = tinymce.baseURL + '/skins/' + skin;
				}
	
				// Load special skin for IE7
				// TODO: Remove this when we drop IE7 support
				if (tinymce.Env.documentMode <= 7) {
					args.skinUiCss = skinUrl + '/skin.ie7.min.css';
				} else {
					args.skinUiCss = skinUrl + '/skin.min.css';
				}
	
				// Load content.min.css or content.inline.min.css
				editor.contentCSS.push(skinUrl + '/content' + (editor.inline ? '.inline' : '') + '.min.css');
			}
	
			// Handle editor setProgressState change
			editor.on('ProgressState', function(e) {
				self.throbber = self.throbber || new tinymce.ui.Throbber(self.panel.getEl('body'));
	
				if (e.state) {
					self.throbber.show(e.time);
				} else {
					self.throbber.hide();
				}
			});
	
			if (settings.inline) {
				return renderInlineUI(args);
			}
	
			return renderIframeUI(args);
		};
	
		self.resizeTo = resizeTo;
		self.resizeBy = resizeBy;
	});
	
	}.call(window));

/***/ },
/* 27 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 28 */,
/* 29 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "3ff9d5c11f2d051703ff2ac6adbd8ba6.eot";

/***/ },
/* 30 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "6b0c3754b1cd1f90566e174098fae8f8.woff";

/***/ },
/* 31 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "d7c3e1a86ee8b62a209d0f25537ca6aa.ttf";

/***/ },
/* 32 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "tinymce.svg";

/***/ },
/* 33 */,
/* 34 */,
/* 35 */,
/* 36 */,
/* 37 */
/***/ function(module, exports) {

	/*** IMPORTS FROM imports-loader ***/
	(function() {
	
	/**
	 * plugin.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/*global tinymce:true */
	
	tinymce.PluginManager.add('image', function(editor) {
		function getImageSize(url, callback) {
			var img = document.createElement('img');
	
			function done(width, height) {
				if (img.parentNode) {
					img.parentNode.removeChild(img);
				}
	
				callback({width: width, height: height});
			}
	
			img.onload = function() {
				done(Math.max(img.width, img.clientWidth), Math.max(img.height, img.clientHeight));
			};
	
			img.onerror = function() {
				done();
			};
	
			var style = img.style;
			style.visibility = 'hidden';
			style.position = 'fixed';
			style.bottom = style.left = 0;
			style.width = style.height = 'auto';
	
			document.body.appendChild(img);
			img.src = url;
		}
	
		function buildListItems(inputList, itemCallback, startItems) {
			function appendItems(values, output) {
				output = output || [];
	
				tinymce.each(values, function(item) {
					var menuItem = {text: item.text || item.title};
	
					if (item.menu) {
						menuItem.menu = appendItems(item.menu);
					} else {
						menuItem.value = item.value;
						itemCallback(menuItem);
					}
	
					output.push(menuItem);
				});
	
				return output;
			}
	
			return appendItems(inputList, startItems || []);
		}
	
		function createImageList(callback) {
			return function() {
				var imageList = editor.settings.image_list;
	
				if (typeof imageList == "string") {
					tinymce.util.XHR.send({
						url: imageList,
						success: function(text) {
							callback(tinymce.util.JSON.parse(text));
						}
					});
				} else if (typeof imageList == "function") {
					imageList(callback);
				} else {
					callback(imageList);
				}
			};
		}
	
		function showDialog(imageList) {
			var win, data = {}, dom = editor.dom, imgElm, figureElm;
			var width, height, imageListCtrl, classListCtrl, imageDimensions = editor.settings.image_dimensions !== false;
	
			function recalcSize() {
				var widthCtrl, heightCtrl, newWidth, newHeight;
	
				widthCtrl = win.find('#width')[0];
				heightCtrl = win.find('#height')[0];
	
				if (!widthCtrl || !heightCtrl) {
					return;
				}
	
				newWidth = widthCtrl.value();
				newHeight = heightCtrl.value();
	
				if (win.find('#constrain')[0].checked() && width && height && newWidth && newHeight) {
					if (width != newWidth) {
						newHeight = Math.round((newWidth / width) * newHeight);
	
						if (!isNaN(newHeight)) {
							heightCtrl.value(newHeight);
						}
					} else {
						newWidth = Math.round((newHeight / height) * newWidth);
	
						if (!isNaN(newWidth)) {
							widthCtrl.value(newWidth);
						}
					}
				}
	
				width = newWidth;
				height = newHeight;
			}
	
			function onSubmitForm() {
				var figureElm, oldImg;
	
				function waitLoad(imgElm) {
					function selectImage() {
						imgElm.onload = imgElm.onerror = null;
	
						if (editor.selection) {
							editor.selection.select(imgElm);
							editor.nodeChanged();
						}
					}
	
					imgElm.onload = function() {
						if (!data.width && !data.height && imageDimensions) {
							dom.setAttribs(imgElm, {
								width: imgElm.clientWidth,
								height: imgElm.clientHeight
							});
						}
	
						selectImage();
					};
	
					imgElm.onerror = selectImage;
				}
	
				updateStyle();
				recalcSize();
	
				data = tinymce.extend(data, win.toJSON());
	
				if (!data.alt) {
					data.alt = '';
				}
	
				if (!data.title) {
					data.title = '';
				}
	
				if (data.width === '') {
					data.width = null;
				}
	
				if (data.height === '') {
					data.height = null;
				}
	
				if (!data.style) {
					data.style = null;
				}
	
				// Setup new data excluding style properties
				/*eslint dot-notation: 0*/
				data = {
					src: data.src,
					alt: data.alt,
					title: data.title,
					width: data.width,
					height: data.height,
					style: data.style,
					caption: data.caption,
					"class": data["class"]
				};
	
				editor.undoManager.transact(function() {
					if (!data.src) {
						if (imgElm) {
							dom.remove(imgElm);
							editor.focus();
							editor.nodeChanged();
						}
	
						return;
					}
	
					if (data.title === "") {
						data.title = null;
					}
	
					if (!imgElm) {
						data.id = '__mcenew';
						editor.focus();
						editor.selection.setContent(dom.createHTML('img', data));
						imgElm = dom.get('__mcenew');
						dom.setAttrib(imgElm, 'id', null);
					} else {
						dom.setAttribs(imgElm, data);
					}
	
					editor.editorUpload.uploadImagesAuto();
	
					if (data.caption === false) {
						if (dom.is(imgElm.parentNode, 'figure.image')) {
							figureElm = imgElm.parentNode;
							dom.insertAfter(imgElm, figureElm);
							dom.remove(figureElm);
						}
					}
	
					function isTextBlock(node) {
						return editor.schema.getTextBlockElements()[node.nodeName];
					}
	
					if (data.caption === true) {
						if (!dom.is(imgElm.parentNode, 'figure.image')) {
							oldImg = imgElm;
							imgElm = imgElm.cloneNode(true);
							figureElm = dom.create('figure', {'class': 'image'});
							figureElm.appendChild(imgElm);
							figureElm.appendChild(dom.create('figcaption', {contentEditable: true}, 'Caption'));
							figureElm.contentEditable = false;
	
							var textBlock = dom.getParent(oldImg, isTextBlock);
							if (textBlock) {
								dom.split(textBlock, oldImg, figureElm);
							} else {
								dom.replace(figureElm, oldImg);
							}
	
							editor.selection.select(figureElm);
						}
	
						return;
					}
	
					waitLoad(imgElm);
				});
			}
	
			function removePixelSuffix(value) {
				if (value) {
					value = value.replace(/px$/, '');
				}
	
				return value;
			}
	
			function srcChange(e) {
				var srcURL, prependURL, absoluteURLPattern, meta = e.meta || {};
	
				if (imageListCtrl) {
					imageListCtrl.value(editor.convertURL(this.value(), 'src'));
				}
	
				tinymce.each(meta, function(value, key) {
					win.find('#' + key).value(value);
				});
	
				if (!meta.width && !meta.height) {
					srcURL = editor.convertURL(this.value(), 'src');
	
					// Pattern test the src url and make sure we haven't already prepended the url
					prependURL = editor.settings.image_prepend_url;
					absoluteURLPattern = new RegExp('^(?:[a-z]+:)?//', 'i');
					if (prependURL && !absoluteURLPattern.test(srcURL) && srcURL.substring(0, prependURL.length) !== prependURL) {
						srcURL = prependURL + srcURL;
					}
	
					this.value(srcURL);
	
					getImageSize(editor.documentBaseURI.toAbsolute(this.value()), function(data) {
						if (data.width && data.height && imageDimensions) {
							width = data.width;
							height = data.height;
	
							win.find('#width').value(width);
							win.find('#height').value(height);
						}
					});
				}
			}
	
			imgElm = editor.selection.getNode();
			figureElm = dom.getParent(imgElm, 'figure.image');
			if (figureElm) {
				imgElm = dom.select('img', figureElm)[0];
			}
	
			if (imgElm && (imgElm.nodeName != 'IMG' || imgElm.getAttribute('data-mce-object') || imgElm.getAttribute('data-mce-placeholder'))) {
				imgElm = null;
			}
	
			if (imgElm) {
				width = dom.getAttrib(imgElm, 'width');
				height = dom.getAttrib(imgElm, 'height');
	
				data = {
					src: dom.getAttrib(imgElm, 'src'),
					alt: dom.getAttrib(imgElm, 'alt'),
					title: dom.getAttrib(imgElm, 'title'),
					"class": dom.getAttrib(imgElm, 'class'),
					width: width,
					height: height,
					caption: !!figureElm
				};
			}
	
			if (imageList) {
				imageListCtrl = {
					type: 'listbox',
					label: 'Image list',
					values: buildListItems(
						imageList,
						function(item) {
							item.value = editor.convertURL(item.value || item.url, 'src');
						},
						[{text: 'None', value: ''}]
					),
					value: data.src && editor.convertURL(data.src, 'src'),
					onselect: function(e) {
						var altCtrl = win.find('#alt');
	
						if (!altCtrl.value() || (e.lastControl && altCtrl.value() == e.lastControl.text())) {
							altCtrl.value(e.control.text());
						}
	
						win.find('#src').value(e.control.value()).fire('change');
					},
					onPostRender: function() {
						/*eslint consistent-this: 0*/
						imageListCtrl = this;
					}
				};
			}
	
			if (editor.settings.image_class_list) {
				classListCtrl = {
					name: 'class',
					type: 'listbox',
					label: 'Class',
					values: buildListItems(
						editor.settings.image_class_list,
						function(item) {
							if (item.value) {
								item.textStyle = function() {
									return editor.formatter.getCssText({inline: 'img', classes: [item.value]});
								};
							}
						}
					)
				};
			}
	
			// General settings shared between simple and advanced dialogs
			var generalFormItems = [
				{
					name: 'src',
					type: 'filepicker',
					filetype: 'image',
					label: 'Source',
					autofocus: true,
					onchange: srcChange
				},
				imageListCtrl
			];
	
			if (editor.settings.image_description !== false) {
				generalFormItems.push({name: 'alt', type: 'textbox', label: 'Image description'});
			}
	
			if (editor.settings.image_title) {
				generalFormItems.push({name: 'title', type: 'textbox', label: 'Image Title'});
			}
	
			if (imageDimensions) {
				generalFormItems.push({
					type: 'container',
					label: 'Dimensions',
					layout: 'flex',
					direction: 'row',
					align: 'center',
					spacing: 5,
					items: [
						{name: 'width', type: 'textbox', maxLength: 5, size: 3, onchange: recalcSize, ariaLabel: 'Width'},
						{type: 'label', text: 'x'},
						{name: 'height', type: 'textbox', maxLength: 5, size: 3, onchange: recalcSize, ariaLabel: 'Height'},
						{name: 'constrain', type: 'checkbox', checked: true, text: 'Constrain proportions'}
					]
				});
			}
	
			generalFormItems.push(classListCtrl);
	
			if (editor.settings.image_caption && tinymce.Env.ceFalse) {
				generalFormItems.push({name: 'caption', type: 'checkbox', label: 'Caption'});
			}
	
			function mergeMargins(css) {
				if (css.margin) {
	
					var splitMargin = css.margin.split(" ");
	
					switch (splitMargin.length) {
						case 1: //margin: toprightbottomleft;
							css['margin-top'] = css['margin-top'] || splitMargin[0];
							css['margin-right'] = css['margin-right'] || splitMargin[0];
							css['margin-bottom'] = css['margin-bottom'] || splitMargin[0];
							css['margin-left'] = css['margin-left'] || splitMargin[0];
							break;
						case 2: //margin: topbottom rightleft;
							css['margin-top'] = css['margin-top'] || splitMargin[0];
							css['margin-right'] = css['margin-right'] || splitMargin[1];
							css['margin-bottom'] = css['margin-bottom'] || splitMargin[0];
							css['margin-left'] = css['margin-left'] || splitMargin[1];
							break;
						case 3: //margin: top rightleft bottom;
							css['margin-top'] = css['margin-top'] || splitMargin[0];
							css['margin-right'] = css['margin-right'] || splitMargin[1];
							css['margin-bottom'] = css['margin-bottom'] || splitMargin[2];
							css['margin-left'] = css['margin-left'] || splitMargin[1];
							break;
						case 4: //margin: top right bottom left;
							css['margin-top'] = css['margin-top'] || splitMargin[0];
							css['margin-right'] = css['margin-right'] || splitMargin[1];
							css['margin-bottom'] = css['margin-bottom'] || splitMargin[2];
							css['margin-left'] = css['margin-left'] || splitMargin[3];
					}
					delete css.margin;
				}
				return css;
			}
	
			function updateStyle() {
				function addPixelSuffix(value) {
					if (value.length > 0 && /^[0-9]+$/.test(value)) {
						value += 'px';
					}
	
					return value;
				}
	
				if (!editor.settings.image_advtab) {
					return;
				}
	
				var data = win.toJSON(),
					css = dom.parseStyle(data.style);
	
				css = mergeMargins(css);
	
				if (data.vspace) {
					css['margin-top'] = css['margin-bottom'] = addPixelSuffix(data.vspace);
				}
				if (data.hspace) {
					css['margin-left'] = css['margin-right'] = addPixelSuffix(data.hspace);
				}
				if (data.border) {
					css['border-width'] = addPixelSuffix(data.border);
				}
	
				win.find('#style').value(dom.serializeStyle(dom.parseStyle(dom.serializeStyle(css))));
			}
	
			function updateVSpaceHSpaceBorder() {
				if (!editor.settings.image_advtab) {
					return;
				}
	
				var data = win.toJSON(),
					css = dom.parseStyle(data.style);
	
				win.find('#vspace').value("");
				win.find('#hspace').value("");
	
				css = mergeMargins(css);
	
				//Move opposite equal margins to vspace/hspace field
				if ((css['margin-top'] && css['margin-bottom']) || (css['margin-right'] && css['margin-left'])) {
					if (css['margin-top'] === css['margin-bottom']) {
						win.find('#vspace').value(removePixelSuffix(css['margin-top']));
					} else {
						win.find('#vspace').value('');
					}
					if (css['margin-right'] === css['margin-left']) {
						win.find('#hspace').value(removePixelSuffix(css['margin-right']));
					} else {
						win.find('#hspace').value('');
					}
				}
	
				//Move border-width
				if (css['border-width']) {
					win.find('#border').value(removePixelSuffix(css['border-width']));
				}
	
				win.find('#style').value(dom.serializeStyle(dom.parseStyle(dom.serializeStyle(css))));
	
			}
	
			if (editor.settings.image_advtab) {
				// Parse styles from img
				if (imgElm) {
					if (imgElm.style.marginLeft && imgElm.style.marginRight && imgElm.style.marginLeft === imgElm.style.marginRight) {
						data.hspace = removePixelSuffix(imgElm.style.marginLeft);
					}
					if (imgElm.style.marginTop && imgElm.style.marginBottom && imgElm.style.marginTop === imgElm.style.marginBottom) {
						data.vspace = removePixelSuffix(imgElm.style.marginTop);
					}
					if (imgElm.style.borderWidth) {
						data.border = removePixelSuffix(imgElm.style.borderWidth);
					}
	
					data.style = editor.dom.serializeStyle(editor.dom.parseStyle(editor.dom.getAttrib(imgElm, 'style')));
				}
	
				// Advanced dialog shows general+advanced tabs
				win = editor.windowManager.open({
					title: 'Insert/edit image',
					data: data,
					bodyType: 'tabpanel',
					body: [
						{
							title: 'General',
							type: 'form',
							items: generalFormItems
						},
	
						{
							title: 'Advanced',
							type: 'form',
							pack: 'start',
							items: [
								{
									label: 'Style',
									name: 'style',
									type: 'textbox',
									onchange: updateVSpaceHSpaceBorder
								},
								{
									type: 'form',
									layout: 'grid',
									packV: 'start',
									columns: 2,
									padding: 0,
									alignH: ['left', 'right'],
									defaults: {
										type: 'textbox',
										maxWidth: 50,
										onchange: updateStyle
									},
									items: [
										{label: 'Vertical space', name: 'vspace'},
										{label: 'Horizontal space', name: 'hspace'},
										{label: 'Border', name: 'border'}
									]
								}
							]
						}
					],
					onSubmit: onSubmitForm
				});
			} else {
				// Simple default dialog
				win = editor.windowManager.open({
					title: 'Insert/edit image',
					data: data,
					body: generalFormItems,
					onSubmit: onSubmitForm
				});
			}
		}
	
		editor.on('preInit', function() {
			function hasImageClass(node) {
				var className = node.attr('class');
				return className && /\bimage\b/.test(className);
			}
	
			function toggleContentEditableState(state) {
				return function(nodes) {
					var i = nodes.length, node;
	
					function toggleContentEditable(node) {
						node.attr('contenteditable', state ? 'true' : null);
					}
	
					while (i--) {
						node = nodes[i];
	
						if (hasImageClass(node)) {
							node.attr('contenteditable', state ? 'false' : null);
							tinymce.each(node.getAll('figcaption'), toggleContentEditable);
						}
					}
				};
			}
	
			editor.parser.addNodeFilter('figure', toggleContentEditableState(true));
			editor.serializer.addNodeFilter('figure', toggleContentEditableState(false));
		});
	
		editor.addButton('image', {
			icon: 'image',
			tooltip: 'Insert/edit image',
			onclick: createImageList(showDialog),
			stateSelector: 'img:not([data-mce-object],[data-mce-placeholder]),figure.image'
		});
	
		editor.addMenuItem('image', {
			icon: 'image',
			text: 'Insert/edit image',
			onclick: createImageList(showDialog),
			context: 'insert',
			prependToContext: true
		});
	
		editor.addCommand('mceImage', createImageList(showDialog));
	});
	
	}.call(window));

/***/ },
/* 38 */
/***/ function(module, exports) {

	/*** IMPORTS FROM imports-loader ***/
	(function() {
	
	/**
	 * plugin.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/*jshint maxlen:255 */
	/*eslint max-len:0 */
	/*global tinymce:true */
	
	tinymce.PluginManager.add('media', function(editor, url) {
		var urlPatterns = [
			{regex: /youtu\.be\/([\w\-.]+)/, type: 'iframe', w: 560, h: 314, url: '//www.youtube.com/embed/$1', allowFullscreen: true},
			{regex: /youtube\.com(.+)v=([^&]+)/, type: 'iframe', w: 560, h: 314, url: '//www.youtube.com/embed/$2', allowFullscreen: true},
			{regex: /youtube.com\/embed\/([a-z0-9\-_]+(?:\?.+)?)/i, type: 'iframe', w: 560, h: 314, url: '//www.youtube.com/embed/$1', allowFullscreen: true},
			{regex: /vimeo\.com\/([0-9]+)/, type: 'iframe', w: 425, h: 350, url: '//player.vimeo.com/video/$1?title=0&byline=0&portrait=0&color=8dc7dc', allowfullscreen: true},
			{regex: /vimeo\.com\/(.*)\/([0-9]+)/, type: "iframe", w: 425, h: 350, url: "//player.vimeo.com/video/$2?title=0&amp;byline=0", allowfullscreen: true},
			{regex: /maps\.google\.([a-z]{2,3})\/maps\/(.+)msid=(.+)/, type: 'iframe', w: 425, h: 350, url: '//maps.google.com/maps/ms?msid=$2&output=embed"', allowFullscreen: false},
			{regex: /dailymotion\.com\/video\/([^_]+)/, type: 'iframe', w: 480, h: 270, url: '//www.dailymotion.com/embed/video/$1', allowFullscreen: true}
		];
	
		var embedChange = (tinymce.Env.ie && tinymce.Env.ie <= 8) ? 'onChange' : 'onInput';
	
		function guessMime(url) {
			url = url.toLowerCase();
	
			if (url.indexOf('.mp3') != -1) {
				return 'audio/mpeg';
			}
	
			if (url.indexOf('.wav') != -1) {
				return 'audio/wav';
			}
	
			if (url.indexOf('.mp4') != -1) {
				return 'video/mp4';
			}
	
			if (url.indexOf('.webm') != -1) {
				return 'video/webm';
			}
	
			if (url.indexOf('.ogg') != -1) {
				return 'video/ogg';
			}
	
			if (url.indexOf('.swf') != -1) {
				return 'application/x-shockwave-flash';
			}
	
			return '';
		}
	
		function getVideoScriptMatch(src) {
			var prefixes = editor.settings.media_scripts;
	
			if (prefixes) {
				for (var i = 0; i < prefixes.length; i++) {
					if (src.indexOf(prefixes[i].filter) !== -1) {
						return prefixes[i];
					}
				}
			}
		}
	
		function showDialog() {
			var win, width, height, data;
	
			var generalFormItems = [
				{
					name: 'source1',
					type: 'filepicker',
					filetype: 'media',
					size: 40,
					autofocus: true,
					label: 'Source',
					onchange: function(e) {
						tinymce.each(e.meta, function(value, key) {
							win.find('#' + key).value(value);
						});
					}
				}
			];
	
			function recalcSize(e) {
				var widthCtrl, heightCtrl, newWidth, newHeight;
	
				widthCtrl = win.find('#width')[0];
				heightCtrl = win.find('#height')[0];
	
				newWidth = widthCtrl.value();
				newHeight = heightCtrl.value();
	
				if (win.find('#constrain')[0].checked() && width && height && newWidth && newHeight) {
					if (e.control == widthCtrl) {
						newHeight = Math.round((newWidth / width) * newHeight);
	
						if (!isNaN(newHeight)) {
							heightCtrl.value(newHeight);
						}
					} else {
						newWidth = Math.round((newHeight / height) * newWidth);
	
						if (!isNaN(newWidth)) {
							widthCtrl.value(newWidth);
						}
					}
				}
	
				width = newWidth;
				height = newHeight;
			}
	
			if (editor.settings.media_alt_source !== false) {
				generalFormItems.push({name: 'source2', type: 'filepicker', filetype: 'media', size: 40, label: 'Alternative source'});
			}
	
			if (editor.settings.media_poster !== false) {
				generalFormItems.push({name: 'poster', type: 'filepicker', filetype: 'image', size: 40, label: 'Poster'});
			}
	
			if (editor.settings.media_dimensions !== false) {
				generalFormItems.push({
					type: 'container',
					label: 'Dimensions',
					layout: 'flex',
					align: 'center',
					spacing: 5,
					items: [
						{name: 'width', type: 'textbox', maxLength: 5, size: 3, onchange: recalcSize, ariaLabel: 'Width'},
						{type: 'label', text: 'x'},
						{name: 'height', type: 'textbox', maxLength: 5, size: 3, onchange: recalcSize, ariaLabel: 'Height'},
						{name: 'constrain', type: 'checkbox', checked: true, text: 'Constrain proportions'}
					]
				});
			}
	
			data = getData(editor.selection.getNode());
			width = data.width;
			height = data.height;
	
			var embedTextBox = {
				id: 'mcemediasource',
				type: 'textbox',
				flex: 1,
				name: 'embed',
				value: getSource(),
				multiline: true,
				label: 'Source'
			};
	
			function updateValueOnChange() {
				data = htmlToData(this.value());
				this.parent().parent().fromJSON(data);
			}
	
			embedTextBox[embedChange] = updateValueOnChange;
	
			win = editor.windowManager.open({
				title: 'Insert/edit video',
				data: data,
				bodyType: 'tabpanel',
				body: [
					{
						title: 'General',
						type: "form",
						onShowTab: function() {
							data = htmlToData(this.next().find('#embed').value());
							this.fromJSON(data);
						},
						items: generalFormItems
					},
	
					{
						title: 'Embed',
						type: "container",
						layout: 'flex',
						direction: 'column',
						align: 'stretch',
						padding: 10,
						spacing: 10,
						onShowTab: function() {
							this.find('#embed').value(dataToHtml(this.parent().toJSON()));
						},
						items: [
							{
								type: 'label',
								text: 'Paste your embed code below:',
								forId: 'mcemediasource'
							},
							embedTextBox
						]
					}
				],
				onSubmit: function() {
					var beforeObjects, afterObjects, i, y;
	
					beforeObjects = editor.dom.select('img[data-mce-object]');
					editor.insertContent(dataToHtml(this.toJSON()));
					afterObjects = editor.dom.select('img[data-mce-object]');
	
					// Find new image placeholder so we can select it
					for (i = 0; i < beforeObjects.length; i++) {
						for (y = afterObjects.length - 1; y >= 0; y--) {
							if (beforeObjects[i] == afterObjects[y]) {
								afterObjects.splice(y, 1);
							}
						}
					}
	
					editor.selection.select(afterObjects[0]);
					editor.nodeChanged();
				}
			});
		}
	
		function getSource() {
			var elm = editor.selection.getNode();
	
			if (elm.getAttribute('data-mce-object')) {
				return editor.selection.getContent();
			}
		}
	
		function dataToHtml(data) {
			var html = '';
	
			if (!data.source1) {
				tinymce.extend(data, htmlToData(data.embed));
				if (!data.source1) {
					return '';
				}
			}
	
			if (!data.source2) {
				data.source2 = '';
			}
	
			if (!data.poster) {
				data.poster = '';
			}
	
			data.source1 = editor.convertURL(data.source1, "source");
			data.source2 = editor.convertURL(data.source2, "source");
			data.source1mime = guessMime(data.source1);
			data.source2mime = guessMime(data.source2);
			data.poster = editor.convertURL(data.poster, "poster");
			data.flashPlayerUrl = editor.convertURL(url + '/moxieplayer.swf', "movie");
	
			tinymce.each(urlPatterns, function(pattern) {
				var match, i, url;
	
				if ((match = pattern.regex.exec(data.source1))) {
					url = pattern.url;
	
					for (i = 0; match[i]; i++) {
						/*jshint loopfunc:true*/
						/*eslint no-loop-func:0 */
						url = url.replace('$' + i, function() {
							return match[i];
						});
					}
	
					data.source1 = url;
					data.type = pattern.type;
					data.allowFullscreen = pattern.allowFullscreen;
					data.width = data.width || pattern.w;
					data.height = data.height || pattern.h;
				}
			});
	
			if (data.embed) {
				html = updateHtml(data.embed, data, true);
			} else {
				var videoScript = getVideoScriptMatch(data.source1);
				if (videoScript) {
					data.type = 'script';
					data.width = videoScript.width;
					data.height = videoScript.height;
				}
	
				data.width = data.width || 300;
				data.height = data.height || 150;
	
				tinymce.each(data, function(value, key) {
					data[key] = editor.dom.encode(value);
				});
	
				if (data.type == "iframe") {
					var allowFullscreen = data.allowFullscreen ? ' allowFullscreen="1"' : '';
					html += '<iframe src="' + data.source1 + '" width="' + data.width + '" height="' + data.height + '"' + allowFullscreen + '></iframe>';
				} else if (data.source1mime == "application/x-shockwave-flash") {
					html += '<object data="' + data.source1 + '" width="' + data.width + '" height="' + data.height + '" type="application/x-shockwave-flash">';
	
					if (data.poster) {
						html += '<img src="' + data.poster + '" width="' + data.width + '" height="' + data.height + '" />';
					}
	
					html += '</object>';
				} else if (data.source1mime.indexOf('audio') != -1) {
					if (editor.settings.audio_template_callback) {
						html = editor.settings.audio_template_callback(data);
					} else {
						html += (
							'<audio controls="controls" src="' + data.source1 + '">' +
								(data.source2 ? '\n<source src="' + data.source2 + '"' + (data.source2mime ? ' type="' + data.source2mime + '"' : '') + ' />\n' : '') +
							'</audio>'
						);
					}
				} else if (data.type == "script") {
					html += '<script src="' + data.source1 + '"></script>';
				} else {
					if (editor.settings.video_template_callback) {
						html = editor.settings.video_template_callback(data);
					} else {
						html = (
							'<video width="' + data.width + '" height="' + data.height + '"' + (data.poster ? ' poster="' + data.poster + '"' : '') + ' controls="controls">\n' +
								'<source src="' + data.source1 + '"' + (data.source1mime ? ' type="' + data.source1mime + '"' : '') + ' />\n' +
								(data.source2 ? '<source src="' + data.source2 + '"' + (data.source2mime ? ' type="' + data.source2mime + '"' : '') + ' />\n' : '') +
							'</video>'
						);
					}
				}
			}
	
			return html;
		}
	
		function htmlToData(html) {
			var data = {};
	
			new tinymce.html.SaxParser({
				validate: false,
				allow_conditional_comments: true,
				special: 'script,noscript',
				start: function(name, attrs) {
					if (!data.source1 && name == "param") {
						data.source1 = attrs.map.movie;
					}
	
					if (name == "iframe" || name == "object" || name == "embed" || name == "video" || name == "audio") {
						if (!data.type) {
							data.type = name;
						}
	
						data = tinymce.extend(attrs.map, data);
					}
	
					if (name == "script") {
						var videoScript = getVideoScriptMatch(attrs.map.src);
						if (!videoScript) {
							return;
						}
	
						data = {
							type: "script",
							source1: attrs.map.src,
							width: videoScript.width,
							height: videoScript.height
						};
					}
	
					if (name == "source") {
						if (!data.source1) {
							data.source1 = attrs.map.src;
						} else if (!data.source2) {
							data.source2 = attrs.map.src;
						}
					}
	
					if (name == "img" && !data.poster) {
						data.poster = attrs.map.src;
					}
				}
			}).parse(html);
	
			data.source1 = data.source1 || data.src || data.data;
			data.source2 = data.source2 || '';
			data.poster = data.poster || '';
	
			return data;
		}
	
		function getData(element) {
			if (element.getAttribute('data-mce-object')) {
				return htmlToData(editor.serializer.serialize(element, {selection: true}));
			}
	
			return {};
		}
	
		function sanitize(html) {
			if (editor.settings.media_filter_html === false) {
				return html;
			}
	
			var writer = new tinymce.html.Writer(), blocked;
	
			new tinymce.html.SaxParser({
				validate: false,
				allow_conditional_comments: false,
				special: 'script,noscript',
	
				comment: function(text) {
					writer.comment(text);
				},
	
				cdata: function(text) {
					writer.cdata(text);
				},
	
				text: function(text, raw) {
					writer.text(text, raw);
				},
	
				start: function(name, attrs, empty) {
					blocked = true;
	
					if (name == 'script' || name == 'noscript') {
						return;
					}
	
					for (var i = 0; i < attrs.length; i++) {
						if (attrs[i].name.indexOf('on') === 0) {
							return;
						}
	
						if (attrs[i].name == 'style') {
							attrs[i].value = editor.dom.serializeStyle(editor.dom.parseStyle(attrs[i].value), name);
						}
					}
	
					writer.start(name, attrs, empty);
					blocked = false;
				},
	
				end: function(name) {
					if (blocked) {
						return;
					}
	
					writer.end(name);
				}
			}, new tinymce.html.Schema({})).parse(html);
	
			return writer.getContent();
		}
	
		function updateHtml(html, data, updateAll) {
			var writer = new tinymce.html.Writer();
			var sourceCount = 0, hasImage;
	
			function setAttributes(attrs, updatedAttrs) {
				var name, i, value, attr;
	
				for (name in updatedAttrs) {
					value = "" + updatedAttrs[name];
	
					if (attrs.map[name]) {
						i = attrs.length;
						while (i--) {
							attr = attrs[i];
	
							if (attr.name == name) {
								if (value) {
									attrs.map[name] = value;
									attr.value = value;
								} else {
									delete attrs.map[name];
									attrs.splice(i, 1);
								}
							}
						}
					} else if (value) {
						attrs.push({
							name: name,
							value: value
						});
	
						attrs.map[name] = value;
					}
				}
			}
	
			new tinymce.html.SaxParser({
				validate: false,
				allow_conditional_comments: true,
				special: 'script,noscript',
	
				comment: function(text) {
					writer.comment(text);
				},
	
				cdata: function(text) {
					writer.cdata(text);
				},
	
				text: function(text, raw) {
					writer.text(text, raw);
				},
	
				start: function(name, attrs, empty) {
					switch (name) {
						case "video":
						case "object":
						case "embed":
						case "img":
						case "iframe":
							setAttributes(attrs, {
								width: data.width,
								height: data.height
							});
							break;
					}
	
					if (updateAll) {
						switch (name) {
							case "video":
								setAttributes(attrs, {
									poster: data.poster,
									src: ""
								});
	
								if (data.source2) {
									setAttributes(attrs, {
										src: ""
									});
								}
								break;
	
							case "iframe":
								setAttributes(attrs, {
									src: data.source1
								});
								break;
	
							case "source":
								sourceCount++;
	
								if (sourceCount <= 2) {
									setAttributes(attrs, {
										src: data["source" + sourceCount],
										type: data["source" + sourceCount + "mime"]
									});
	
									if (!data["source" + sourceCount]) {
										return;
									}
								}
								break;
	
							case "img":
								if (!data.poster) {
									return;
								}
	
								hasImage = true;
								break;
						}
					}
	
					writer.start(name, attrs, empty);
				},
	
				end: function(name) {
					if (name == "video" && updateAll) {
						for (var index = 1; index <= 2; index++) {
							if (data["source" + index]) {
								var attrs = [];
								attrs.map = {};
	
								if (sourceCount < index) {
									setAttributes(attrs, {
										src: data["source" + index],
										type: data["source" + index + "mime"]
									});
	
									writer.start("source", attrs, true);
								}
							}
						}
					}
	
					if (data.poster && name == "object" && updateAll && !hasImage) {
						var imgAttrs = [];
						imgAttrs.map = {};
	
						setAttributes(imgAttrs, {
							src: data.poster,
							width: data.width,
							height: data.height
						});
	
						writer.start("img", imgAttrs, true);
					}
	
					writer.end(name);
				}
			}, new tinymce.html.Schema({})).parse(html);
	
			return writer.getContent();
		}
	
		editor.on('ResolveName', function(e) {
			var name;
	
			if (e.target.nodeType == 1 && (name = e.target.getAttribute("data-mce-object"))) {
				e.name = name;
			}
		});
	
		function retainAttributesAndInnerHtml(sourceNode, targetNode) {
			var attrName, attrValue, attribs, ai, innerHtml;
	
			// Prefix all attributes except width, height and style since we
			// will add these to the placeholder
			attribs = sourceNode.attributes;
			ai = attribs.length;
			while (ai--) {
				attrName = attribs[ai].name;
				attrValue = attribs[ai].value;
	
				if (attrName !== "width" && attrName !== "height" && attrName !== "style") {
					if (attrName == "data" || attrName == "src") {
						attrValue = editor.convertURL(attrValue, attrName);
					}
	
					targetNode.attr('data-mce-p-' + attrName, attrValue);
				}
			}
	
			// Place the inner HTML contents inside an escaped attribute
			// This enables us to copy/paste the fake object
			innerHtml = sourceNode.firstChild && sourceNode.firstChild.value;
			if (innerHtml) {
				targetNode.attr("data-mce-html", escape(innerHtml));
				targetNode.firstChild = null;
			}
		}
	
		function createPlaceholderNode(node) {
			var placeHolder, name = node.name;
	
			placeHolder = new tinymce.html.Node('img', 1);
			placeHolder.shortEnded = true;
	
			retainAttributesAndInnerHtml(node, placeHolder);
	
			placeHolder.attr({
				width: node.attr('width') || "300",
				height: node.attr('height') || (name == "audio" ? "30" : "150"),
				style: node.attr('style'),
				src: tinymce.Env.transparentSrc,
				"data-mce-object": name,
				"class": "mce-object mce-object-" + name
			});
	
			return placeHolder;
		}
	
		function createPreviewNode(node) {
			var previewWrapper, previewNode, shimNode, name = node.name;
	
			previewWrapper = new tinymce.html.Node('span', 1);
			previewWrapper.attr({
				contentEditable: 'false',
				style: node.attr('style'),
				"data-mce-object": name,
				"class": "mce-preview-object mce-object-" + name
			});
	
			retainAttributesAndInnerHtml(node, previewWrapper);
	
			previewNode = new tinymce.html.Node(name, 1);
			previewNode.attr({
				src: node.attr('src'),
				allowfullscreen: node.attr('allowfullscreen'),
				width: node.attr('width') || "300",
				height: node.attr('height') || (name == "audio" ? "30" : "150"),
				frameborder: '0'
			});
	
			shimNode = new tinymce.html.Node('span', 1);
			shimNode.attr('class', 'mce-shim');
	
			previewWrapper.append(previewNode);
			previewWrapper.append(shimNode);
	
			return previewWrapper;
		}
	
		editor.on('preInit', function() {
			// Make sure that any messy HTML is retained inside these
			var specialElements = editor.schema.getSpecialElements();
			tinymce.each('video audio iframe object'.split(' '), function(name) {
				specialElements[name] = new RegExp('<\/' + name + '[^>]*>', 'gi');
			});
	
			// Allow elements
			//editor.schema.addValidElements('object[id|style|width|height|classid|codebase|*],embed[id|style|width|height|type|src|*],video[*],audio[*]');
	
			// Set allowFullscreen attribs as boolean
			var boolAttrs = editor.schema.getBoolAttrs();
			tinymce.each('webkitallowfullscreen mozallowfullscreen allowfullscreen'.split(' '), function(name) {
				boolAttrs[name] = {};
			});
	
			// Converts iframe, video etc into placeholder images
			editor.parser.addNodeFilter('iframe,video,audio,object,embed,script', function(nodes) {
				var i = nodes.length, node, placeHolder, videoScript;
	
				while (i--) {
					node = nodes[i];
					if (!node.parent) {
						continue;
					}
	
					if (node.parent.attr('data-mce-object')) {
						continue;
					}
	
					if (node.name == 'script') {
						videoScript = getVideoScriptMatch(node.attr('src'));
						if (!videoScript) {
							continue;
						}
					}
	
					if (videoScript) {
						if (videoScript.width) {
							node.attr('width', videoScript.width.toString());
						}
	
						if (videoScript.height) {
							node.attr('height', videoScript.height.toString());
						}
					}
	
					if (node.name == 'iframe' && editor.settings.media_live_embeds !== false && tinymce.Env.ceFalse) {
						placeHolder = createPreviewNode(node);
					} else {
						placeHolder = createPlaceholderNode(node);
					}
	
					node.replace(placeHolder);
				}
			});
	
			// Replaces placeholder images with real elements for video, object, iframe etc
			editor.serializer.addAttributeFilter('data-mce-object', function(nodes, name) {
				var i = nodes.length, node, realElm, ai, attribs, innerHtml, innerNode, realElmName, className;
	
				while (i--) {
					node = nodes[i];
					if (!node.parent) {
						continue;
					}
	
					realElmName = node.attr(name);
					realElm = new tinymce.html.Node(realElmName, 1);
	
					// Add width/height to everything but audio
					if (realElmName != "audio" && realElmName != "script") {
						className = node.attr('class');
						if (className && className.indexOf('mce-preview-object') !== -1) {
							realElm.attr({
								width: node.firstChild.attr('width'),
								height: node.firstChild.attr('height')
							});
						} else {
							realElm.attr({
								width: node.attr('width'),
								height: node.attr('height')
							});
						}
					}
	
					realElm.attr({
						style: node.attr('style')
					});
	
					// Unprefix all placeholder attributes
					attribs = node.attributes;
					ai = attribs.length;
					while (ai--) {
						var attrName = attribs[ai].name;
	
						if (attrName.indexOf('data-mce-p-') === 0) {
							realElm.attr(attrName.substr(11), attribs[ai].value);
						}
					}
	
					if (realElmName == "script") {
						realElm.attr('type', 'text/javascript');
					}
	
					// Inject innerhtml
					innerHtml = node.attr('data-mce-html');
					if (innerHtml) {
						innerNode = new tinymce.html.Node('#text', 3);
						innerNode.raw = true;
						innerNode.value = sanitize(unescape(innerHtml));
						realElm.append(innerNode);
					}
	
					node.replace(realElm);
				}
			});
		});
	
		editor.on('click keyup', function() {
			var selectedNode = editor.selection.getNode();
	
			if (selectedNode && editor.dom.hasClass(selectedNode, 'mce-preview-object')) {
				if (editor.dom.getAttrib(selectedNode, 'data-mce-selected')) {
					selectedNode.setAttribute('data-mce-selected', '2');
				}
			}
		});
	
		editor.on('ObjectSelected', function(e) {
			var objectType = e.target.getAttribute('data-mce-object');
	
			if (objectType == "audio" || objectType == "script") {
				e.preventDefault();
			}
		});
	
		editor.on('objectResized', function(e) {
			var target = e.target, html;
	
			if (target.getAttribute('data-mce-object')) {
				html = target.getAttribute('data-mce-html');
				if (html) {
					html = unescape(html);
					target.setAttribute('data-mce-html', escape(
						updateHtml(html, {
							width: e.width,
							height: e.height
						})
					));
				}
			}
		});
	
		editor.addButton('media', {
			tooltip: 'Insert/edit video',
			onclick: showDialog,
			stateSelector: ['img[data-mce-object]', 'span[data-mce-object]']
		});
	
		editor.addMenuItem('media', {
			icon: 'media',
			text: 'Insert/edit video',
			onclick: showDialog,
			context: 'insert',
			prependToContext: true
		});
	
		editor.on('setContent', function() {
			// TODO: This shouldn't be needed there should be a way to mark bogus
			// elements so they are never removed except external save
			editor.$('span.mce-preview-object').each(function(index, elm) {
				var $elm = editor.$(elm);
	
				if ($elm.find('span.mce-shim', elm).length === 0) {
					$elm.append('<span class="mce-shim"></span>');
				}
			});
		});
	
		editor.addCommand('mceMedia', showDialog);
	
		this.showDialog = showDialog;
	});
	
	}.call(window));

/***/ },
/* 39 */
/***/ function(module, exports) {

	/*** IMPORTS FROM imports-loader ***/
	(function() {
	
	/**
	 * plugin.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/*global tinymce:true */
	
	tinymce.PluginManager.add('fullpage', function(editor) {
		var each = tinymce.each, Node = tinymce.html.Node;
		var head, foot;
	
		function showDialog() {
			var data = htmlToData();
	
			editor.windowManager.open({
				title: 'Document properties',
				data: data,
				defaults: {type: 'textbox', size: 40},
				body: [
					{name: 'title', label: 'Title'},
					{name: 'keywords', label: 'Keywords'},
					{name: 'description', label: 'Description'},
					{name: 'robots', label: 'Robots'},
					{name: 'author', label: 'Author'},
					{name: 'docencoding', label: 'Encoding'}
				],
				onSubmit: function(e) {
					dataToHtml(tinymce.extend(data, e.data));
				}
			});
		}
	
		function htmlToData() {
			var headerFragment = parseHeader(), data = {}, elm, matches;
	
			function getAttr(elm, name) {
				var value = elm.attr(name);
	
				return value || '';
			}
	
			// Default some values
			data.fontface = editor.getParam("fullpage_default_fontface", "");
			data.fontsize = editor.getParam("fullpage_default_fontsize", "");
	
			// Parse XML PI
			elm = headerFragment.firstChild;
			if (elm.type == 7) {
				data.xml_pi = true;
				matches = /encoding="([^"]+)"/.exec(elm.value);
				if (matches) {
					data.docencoding = matches[1];
				}
			}
	
			// Parse doctype
			elm = headerFragment.getAll('#doctype')[0];
			if (elm) {
				data.doctype = '<!DOCTYPE' + elm.value + ">";
			}
	
			// Parse title element
			elm = headerFragment.getAll('title')[0];
			if (elm && elm.firstChild) {
				data.title = elm.firstChild.value;
			}
	
			// Parse meta elements
			each(headerFragment.getAll('meta'), function(meta) {
				var name = meta.attr('name'), httpEquiv = meta.attr('http-equiv'), matches;
	
				if (name) {
					data[name.toLowerCase()] = meta.attr('content');
				} else if (httpEquiv == "Content-Type") {
					matches = /charset\s*=\s*(.*)\s*/gi.exec(meta.attr('content'));
	
					if (matches) {
						data.docencoding = matches[1];
					}
				}
			});
	
			// Parse html attribs
			elm = headerFragment.getAll('html')[0];
			if (elm) {
				data.langcode = getAttr(elm, 'lang') || getAttr(elm, 'xml:lang');
			}
	
			// Parse stylesheets
			data.stylesheets = [];
			tinymce.each(headerFragment.getAll('link'), function(link) {
				if (link.attr('rel') == 'stylesheet') {
					data.stylesheets.push(link.attr('href'));
				}
			});
	
			// Parse body parts
			elm = headerFragment.getAll('body')[0];
			if (elm) {
				data.langdir = getAttr(elm, 'dir');
				data.style = getAttr(elm, 'style');
				data.visited_color = getAttr(elm, 'vlink');
				data.link_color = getAttr(elm, 'link');
				data.active_color = getAttr(elm, 'alink');
			}
	
			return data;
		}
	
		function dataToHtml(data) {
			var headerFragment, headElement, html, elm, value, dom = editor.dom;
	
			function setAttr(elm, name, value) {
				elm.attr(name, value ? value : undefined);
			}
	
			function addHeadNode(node) {
				if (headElement.firstChild) {
					headElement.insert(node, headElement.firstChild);
				} else {
					headElement.append(node);
				}
			}
	
			headerFragment = parseHeader();
			headElement = headerFragment.getAll('head')[0];
			if (!headElement) {
				elm = headerFragment.getAll('html')[0];
				headElement = new Node('head', 1);
	
				if (elm.firstChild) {
					elm.insert(headElement, elm.firstChild, true);
				} else {
					elm.append(headElement);
				}
			}
	
			// Add/update/remove XML-PI
			elm = headerFragment.firstChild;
			if (data.xml_pi) {
				value = 'version="1.0"';
	
				if (data.docencoding) {
					value += ' encoding="' + data.docencoding + '"';
				}
	
				if (elm.type != 7) {
					elm = new Node('xml', 7);
					headerFragment.insert(elm, headerFragment.firstChild, true);
				}
	
				elm.value = value;
			} else if (elm && elm.type == 7) {
				elm.remove();
			}
	
			// Add/update/remove doctype
			elm = headerFragment.getAll('#doctype')[0];
			if (data.doctype) {
				if (!elm) {
					elm = new Node('#doctype', 10);
	
					if (data.xml_pi) {
						headerFragment.insert(elm, headerFragment.firstChild);
					} else {
						addHeadNode(elm);
					}
				}
	
				elm.value = data.doctype.substring(9, data.doctype.length - 1);
			} else if (elm) {
				elm.remove();
			}
	
			// Add meta encoding
			elm = null;
			each(headerFragment.getAll('meta'), function(meta) {
				if (meta.attr('http-equiv') == 'Content-Type') {
					elm = meta;
				}
			});
	
			if (data.docencoding) {
				if (!elm) {
					elm = new Node('meta', 1);
					elm.attr('http-equiv', 'Content-Type');
					elm.shortEnded = true;
					addHeadNode(elm);
				}
	
				elm.attr('content', 'text/html; charset=' + data.docencoding);
			} else if (elm) {
				elm.remove();
			}
	
			// Add/update/remove title
			elm = headerFragment.getAll('title')[0];
			if (data.title) {
				if (!elm) {
					elm = new Node('title', 1);
					addHeadNode(elm);
				} else {
					elm.empty();
				}
	
				elm.append(new Node('#text', 3)).value = data.title;
			} else if (elm) {
				elm.remove();
			}
	
			// Add/update/remove meta
			each('keywords,description,author,copyright,robots'.split(','), function(name) {
				var nodes = headerFragment.getAll('meta'), i, meta, value = data[name];
	
				for (i = 0; i < nodes.length; i++) {
					meta = nodes[i];
	
					if (meta.attr('name') == name) {
						if (value) {
							meta.attr('content', value);
						} else {
							meta.remove();
						}
	
						return;
					}
				}
	
				if (value) {
					elm = new Node('meta', 1);
					elm.attr('name', name);
					elm.attr('content', value);
					elm.shortEnded = true;
	
					addHeadNode(elm);
				}
			});
	
			var currentStyleSheetsMap = {};
			tinymce.each(headerFragment.getAll('link'), function(stylesheet) {
				if (stylesheet.attr('rel') == 'stylesheet') {
					currentStyleSheetsMap[stylesheet.attr('href')] = stylesheet;
				}
			});
	
			// Add new
			tinymce.each(data.stylesheets, function(stylesheet) {
				if (!currentStyleSheetsMap[stylesheet]) {
					elm = new Node('link', 1);
					elm.attr({
						rel: 'stylesheet',
						text: 'text/css',
						href: stylesheet
					});
					elm.shortEnded = true;
					addHeadNode(elm);
				}
	
				delete currentStyleSheetsMap[stylesheet];
			});
	
			// Delete old
			tinymce.each(currentStyleSheetsMap, function(stylesheet) {
				stylesheet.remove();
			});
	
			// Update body attributes
			elm = headerFragment.getAll('body')[0];
			if (elm) {
				setAttr(elm, 'dir', data.langdir);
				setAttr(elm, 'style', data.style);
				setAttr(elm, 'vlink', data.visited_color);
				setAttr(elm, 'link', data.link_color);
				setAttr(elm, 'alink', data.active_color);
	
				// Update iframe body as well
				dom.setAttribs(editor.getBody(), {
					style: data.style,
					dir: data.dir,
					vLink: data.visited_color,
					link: data.link_color,
					aLink: data.active_color
				});
			}
	
			// Set html attributes
			elm = headerFragment.getAll('html')[0];
			if (elm) {
				setAttr(elm, 'lang', data.langcode);
				setAttr(elm, 'xml:lang', data.langcode);
			}
	
			// No need for a head element
			if (!headElement.firstChild) {
				headElement.remove();
			}
	
			// Serialize header fragment and crop away body part
			html = new tinymce.html.Serializer({
				validate: false,
				indent: true,
				apply_source_formatting: true,
				indent_before: 'head,html,body,meta,title,script,link,style',
				indent_after: 'head,html,body,meta,title,script,link,style'
			}).serialize(headerFragment);
	
			head = html.substring(0, html.indexOf('</body>'));
		}
	
		function parseHeader() {
			// Parse the contents with a DOM parser
			return new tinymce.html.DomParser({
				validate: false,
				root_name: '#document'
			}).parse(head);
		}
	
		function setContent(evt) {
			var startPos, endPos, content = evt.content, headerFragment, styles = '', dom = editor.dom, elm;
	
			if (evt.selection) {
				return;
			}
	
			function low(s) {
				return s.replace(/<\/?[A-Z]+/g, function(a) {
					return a.toLowerCase();
				});
			}
	
			// Ignore raw updated if we already have a head, this will fix issues with undo/redo keeping the head/foot separate
			if (evt.format == 'raw' && head) {
				return;
			}
	
			if (evt.source_view && editor.getParam('fullpage_hide_in_source_view')) {
				return;
			}
	
			// Fixed so new document/setContent('') doesn't remove existing header/footer except when it's in source code view
			if (content.length === 0 && !evt.source_view) {
				content = tinymce.trim(head) + '\n' + tinymce.trim(content) + '\n' + tinymce.trim(foot);
			}
	
			// Parse out head, body and footer
			content = content.replace(/<(\/?)BODY/gi, '<$1body');
			startPos = content.indexOf('<body');
	
			if (startPos != -1) {
				startPos = content.indexOf('>', startPos);
				head = low(content.substring(0, startPos + 1));
	
				endPos = content.indexOf('</body', startPos);
				if (endPos == -1) {
					endPos = content.length;
				}
	
				evt.content = content.substring(startPos + 1, endPos);
				foot = low(content.substring(endPos));
			} else {
				head = getDefaultHeader();
				foot = '\n</body>\n</html>';
			}
	
			// Parse header and update iframe
			headerFragment = parseHeader();
			each(headerFragment.getAll('style'), function(node) {
				if (node.firstChild) {
					styles += node.firstChild.value;
				}
			});
	
			elm = headerFragment.getAll('body')[0];
			if (elm) {
				dom.setAttribs(editor.getBody(), {
					style: elm.attr('style') || '',
					dir: elm.attr('dir') || '',
					vLink: elm.attr('vlink') || '',
					link: elm.attr('link') || '',
					aLink: elm.attr('alink') || ''
				});
			}
	
			dom.remove('fullpage_styles');
	
			var headElm = editor.getDoc().getElementsByTagName('head')[0];
	
			if (styles) {
				dom.add(headElm, 'style', {
					id: 'fullpage_styles'
				}, styles);
	
				// Needed for IE 6/7
				elm = dom.get('fullpage_styles');
				if (elm.styleSheet) {
					elm.styleSheet.cssText = styles;
				}
			}
	
			var currentStyleSheetsMap = {};
			tinymce.each(headElm.getElementsByTagName('link'), function(stylesheet) {
				if (stylesheet.rel == 'stylesheet' && stylesheet.getAttribute('data-mce-fullpage')) {
					currentStyleSheetsMap[stylesheet.href] = stylesheet;
				}
			});
	
			// Add new
			tinymce.each(headerFragment.getAll('link'), function(stylesheet) {
				var href = stylesheet.attr('href');
	
				if (!currentStyleSheetsMap[href] && stylesheet.attr('rel') == 'stylesheet') {
					dom.add(headElm, 'link', {
						rel: 'stylesheet',
						text: 'text/css',
						href: href,
						'data-mce-fullpage': '1'
					});
				}
	
				delete currentStyleSheetsMap[href];
			});
	
			// Delete old
			tinymce.each(currentStyleSheetsMap, function(stylesheet) {
				stylesheet.parentNode.removeChild(stylesheet);
			});
		}
	
		function getDefaultHeader() {
			var header = '', value, styles = '';
	
			if (editor.getParam('fullpage_default_xml_pi')) {
				header += '<?xml version="1.0" encoding="' + editor.getParam('fullpage_default_encoding', 'ISO-8859-1') + '" ?>\n';
			}
	
			header += editor.getParam('fullpage_default_doctype', '<!DOCTYPE html>');
			header += '\n<html>\n<head>\n';
	
			if ((value = editor.getParam('fullpage_default_title'))) {
				header += '<title>' + value + '</title>\n';
			}
	
			if ((value = editor.getParam('fullpage_default_encoding'))) {
				header += '<meta http-equiv="Content-Type" content="text/html; charset=' + value + '" />\n';
			}
	
			if ((value = editor.getParam('fullpage_default_font_family'))) {
				styles += 'font-family: ' + value + ';';
			}
	
			if ((value = editor.getParam('fullpage_default_font_size'))) {
				styles += 'font-size: ' + value + ';';
			}
	
			if ((value = editor.getParam('fullpage_default_text_color'))) {
				styles += 'color: ' + value + ';';
			}
	
			header += '</head>\n<body' + (styles ? ' style="' + styles + '"' : '') + '>\n';
	
			return header;
		}
	
		function getContent(evt) {
			if (!evt.selection && (!evt.source_view || !editor.getParam('fullpage_hide_in_source_view'))) {
				evt.content = tinymce.trim(head) + '\n' + tinymce.trim(evt.content) + '\n' + tinymce.trim(foot);
			}
		}
	
		editor.addCommand('mceFullPageProperties', showDialog);
	
		editor.addButton('fullpage', {
			title: 'Document properties',
			cmd: 'mceFullPageProperties'
		});
	
		editor.addMenuItem('fullpage', {
			text: 'Document properties',
			cmd: 'mceFullPageProperties',
			context: 'file'
		});
	
		editor.on('BeforeSetContent', setContent);
		editor.on('GetContent', getContent);
	});
	
	}.call(window));

/***/ },
/* 40 */
/***/ function(module, exports) {

	/*** IMPORTS FROM imports-loader ***/
	(function() {
	
	/**
	 * plugin.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/*global tinymce:true */
	
	tinymce.PluginManager.add('fullscreen', function(editor) {
		var fullscreenState = false, DOM = tinymce.DOM, iframeWidth, iframeHeight, resizeHandler;
		var containerWidth, containerHeight, scrollPos;
	
		if (editor.settings.inline) {
			return;
		}
	
		function getWindowSize() {
			var w, h, win = window, doc = document;
			var body = doc.body;
	
			// Old IE
			if (body.offsetWidth) {
				w = body.offsetWidth;
				h = body.offsetHeight;
			}
	
			// Modern browsers
			if (win.innerWidth && win.innerHeight) {
				w = win.innerWidth;
				h = win.innerHeight;
			}
	
			return {w: w, h: h};
		}
	
		function getScrollPos() {
			var vp = tinymce.DOM.getViewPort();
	
			return {
				x: vp.x,
				y: vp.y
			};
		}
	
		function setScrollPos(pos) {
			scrollTo(pos.x, pos.y);
		}
	
		function toggleFullscreen() {
			var body = document.body, documentElement = document.documentElement, editorContainerStyle;
			var editorContainer, iframe, iframeStyle;
	
			function resize() {
				DOM.setStyle(iframe, 'height', getWindowSize().h - (editorContainer.clientHeight - iframe.clientHeight));
			}
	
			fullscreenState = !fullscreenState;
	
			editorContainer = editor.getContainer();
			editorContainerStyle = editorContainer.style;
			iframe = editor.getContentAreaContainer().firstChild;
			iframeStyle = iframe.style;
	
			if (fullscreenState) {
				scrollPos = getScrollPos();
				iframeWidth = iframeStyle.width;
				iframeHeight = iframeStyle.height;
				iframeStyle.width = iframeStyle.height = '100%';
				containerWidth = editorContainerStyle.width;
				containerHeight = editorContainerStyle.height;
				editorContainerStyle.width = editorContainerStyle.height = '';
	
				DOM.addClass(body, 'mce-fullscreen');
				DOM.addClass(documentElement, 'mce-fullscreen');
				DOM.addClass(editorContainer, 'mce-fullscreen');
	
				DOM.bind(window, 'resize', resize);
				resize();
				resizeHandler = resize;
			} else {
				iframeStyle.width = iframeWidth;
				iframeStyle.height = iframeHeight;
	
				if (containerWidth) {
					editorContainerStyle.width = containerWidth;
				}
	
				if (containerHeight) {
					editorContainerStyle.height = containerHeight;
				}
	
				DOM.removeClass(body, 'mce-fullscreen');
				DOM.removeClass(documentElement, 'mce-fullscreen');
				DOM.removeClass(editorContainer, 'mce-fullscreen');
				DOM.unbind(window, 'resize', resizeHandler);
				setScrollPos(scrollPos);
			}
	
			editor.fire('FullscreenStateChanged', {state: fullscreenState});
		}
	
		editor.on('init', function() {
			editor.addShortcut('Ctrl+Shift+F', '', toggleFullscreen);
		});
	
		editor.on('remove', function() {
			if (resizeHandler) {
				DOM.unbind(window, 'resize', resizeHandler);
			}
		});
	
		editor.addCommand('mceFullScreen', toggleFullscreen);
	
		editor.addMenuItem('fullscreen', {
			text: 'Fullscreen',
			shortcut: 'Meta+Alt+F',
			selectable: true,
			onClick: function() {
				toggleFullscreen();
				editor.focus();
			},
			onPostRender: function() {
				var self = this;
	
				editor.on('FullscreenStateChanged', function(e) {
					self.active(e.state);
				});
			},
			context: 'view'
		});
	
		editor.addButton('fullscreen', {
			tooltip: 'Fullscreen',
			shortcut: 'Meta+Alt+F',
			onClick: toggleFullscreen,
			onPostRender: function() {
				var self = this;
	
				editor.on('FullscreenStateChanged', function(e) {
					self.active(e.state);
				});
			}
		});
	
		return {
			isFullscreen: function() {
				return fullscreenState;
			}
		};
	});
	
	}.call(window));

/***/ },
/* 41 */
/***/ function(module, exports) {

	/*** IMPORTS FROM imports-loader ***/
	(function() {
	
	/**
	 * plugin.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/*global tinymce:true */
	
	tinymce.PluginManager.add('template', function(editor) {
		var each = tinymce.each;
	
		function createTemplateList(callback) {
			return function() {
				var templateList = editor.settings.templates;
	
				if (typeof templateList == "function") {
					templateList(callback);
					return;
				}
	
				if (typeof templateList == "string") {
					tinymce.util.XHR.send({
						url: templateList,
						success: function(text) {
							callback(tinymce.util.JSON.parse(text));
						}
					});
				} else {
					callback(templateList);
				}
			};
		}
	
		function showDialog(templateList) {
			var win, values = [], templateHtml;
	
			if (!templateList || templateList.length === 0) {
				var message = editor.translate('No templates defined.');
				editor.notificationManager.open({text: message, type: 'info'});
				return;
			}
	
			tinymce.each(templateList, function(template) {
				values.push({
					selected: !values.length,
					text: template.title,
					value: {
						url: template.url,
						content: template.content,
						description: template.description
					}
				});
			});
	
			function onSelectTemplate(e) {
				var value = e.control.value();
	
				function insertIframeHtml(html) {
					if (html.indexOf('<html>') == -1) {
						var contentCssLinks = '';
	
						tinymce.each(editor.contentCSS, function(url) {
							contentCssLinks += '<link type="text/css" rel="stylesheet" href="' + editor.documentBaseURI.toAbsolute(url) + '">';
						});
	
						var bodyClass = editor.settings.body_class || '';
						if (bodyClass.indexOf('=') != -1) {
							bodyClass = editor.getParam('body_class', '', 'hash');
							bodyClass = bodyClass[editor.id] || '';
						}
	
						html = (
							'<!DOCTYPE html>' +
							'<html>' +
								'<head>' +
									contentCssLinks +
								'</head>' +
								'<body class="' + bodyClass + '">' +
									html +
								'</body>' +
							'</html>'
						);
					}
	
					html = replaceTemplateValues(html, 'template_preview_replace_values');
	
					var doc = win.find('iframe')[0].getEl().contentWindow.document;
					doc.open();
					doc.write(html);
					doc.close();
				}
	
				if (value.url) {
					tinymce.util.XHR.send({
						url: value.url,
						success: function(html) {
							templateHtml = html;
							insertIframeHtml(templateHtml);
						}
					});
				} else {
					templateHtml = value.content;
					insertIframeHtml(templateHtml);
				}
	
				win.find('#description')[0].text(e.control.value().description);
			}
	
			win = editor.windowManager.open({
				title: 'Insert template',
				layout: 'flex',
				direction: 'column',
				align: 'stretch',
				padding: 15,
				spacing: 10,
	
				items: [
					{type: 'form', flex: 0, padding: 0, items: [
						{type: 'container', label: 'Templates', items: {
							type: 'listbox', label: 'Templates', name: 'template', values: values, onselect: onSelectTemplate
						}}
					]},
					{type: 'label', name: 'description', label: 'Description', text: '\u00a0'},
					{type: 'iframe', flex: 1, border: 1}
				],
	
				onsubmit: function() {
					insertTemplate(false, templateHtml);
				},
	
				width: editor.getParam('template_popup_width', 600),
				height: editor.getParam('template_popup_height', 500)
			});
	
			win.find('listbox')[0].fire('select');
		}
	
		function getDateTime(fmt, date) {
			var daysShort = "Sun Mon Tue Wed Thu Fri Sat Sun".split(' ');
			var daysLong = "Sunday Monday Tuesday Wednesday Thursday Friday Saturday Sunday".split(' ');
			var monthsShort = "Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec".split(' ');
			var monthsLong = "January February March April May June July August September October November December".split(' ');
	
			function addZeros(value, len) {
				value = "" + value;
	
				if (value.length < len) {
					for (var i = 0; i < (len - value.length); i++) {
						value = "0" + value;
					}
				}
	
				return value;
			}
	
			date = date || new Date();
	
			fmt = fmt.replace("%D", "%m/%d/%Y");
			fmt = fmt.replace("%r", "%I:%M:%S %p");
			fmt = fmt.replace("%Y", "" + date.getFullYear());
			fmt = fmt.replace("%y", "" + date.getYear());
			fmt = fmt.replace("%m", addZeros(date.getMonth() + 1, 2));
			fmt = fmt.replace("%d", addZeros(date.getDate(), 2));
			fmt = fmt.replace("%H", "" + addZeros(date.getHours(), 2));
			fmt = fmt.replace("%M", "" + addZeros(date.getMinutes(), 2));
			fmt = fmt.replace("%S", "" + addZeros(date.getSeconds(), 2));
			fmt = fmt.replace("%I", "" + ((date.getHours() + 11) % 12 + 1));
			fmt = fmt.replace("%p", "" + (date.getHours() < 12 ? "AM" : "PM"));
			fmt = fmt.replace("%B", "" + editor.translate(monthsLong[date.getMonth()]));
			fmt = fmt.replace("%b", "" + editor.translate(monthsShort[date.getMonth()]));
			fmt = fmt.replace("%A", "" + editor.translate(daysLong[date.getDay()]));
			fmt = fmt.replace("%a", "" + editor.translate(daysShort[date.getDay()]));
			fmt = fmt.replace("%%", "%");
	
			return fmt;
		}
	
		function replaceVals(e) {
			var dom = editor.dom, vl = editor.getParam('template_replace_values');
	
			each(dom.select('*', e), function(e) {
				each(vl, function(v, k) {
					if (dom.hasClass(e, k)) {
						if (typeof vl[k] == 'function') {
							vl[k](e);
						}
					}
				});
			});
		}
	
		function replaceTemplateValues(html, templateValuesOptionName) {
			each(editor.getParam(templateValuesOptionName), function(v, k) {
				if (typeof v == 'function') {
					v = v(k);
				}
	
				html = html.replace(new RegExp('\\{\\$' + k + '\\}', 'g'), v);
			});
	
			return html;
		}
	
		function insertTemplate(ui, html) {
			var el, n, dom = editor.dom, sel = editor.selection.getContent();
	
			html = replaceTemplateValues(html, 'template_replace_values');
			el = dom.create('div', null, html);
	
			// Find template element within div
			n = dom.select('.mceTmpl', el);
			if (n && n.length > 0) {
				el = dom.create('div', null);
				el.appendChild(n[0].cloneNode(true));
			}
	
			function hasClass(n, c) {
				return new RegExp('\\b' + c + '\\b', 'g').test(n.className);
			}
	
			each(dom.select('*', el), function(n) {
				// Replace cdate
				if (hasClass(n, editor.getParam('template_cdate_classes', 'cdate').replace(/\s+/g, '|'))) {
					n.innerHTML = getDateTime(editor.getParam("template_cdate_format", editor.getLang("template.cdate_format")));
				}
	
				// Replace mdate
				if (hasClass(n, editor.getParam('template_mdate_classes', 'mdate').replace(/\s+/g, '|'))) {
					n.innerHTML = getDateTime(editor.getParam("template_mdate_format", editor.getLang("template.mdate_format")));
				}
	
				// Replace selection
				if (hasClass(n, editor.getParam('template_selected_content_classes', 'selcontent').replace(/\s+/g, '|'))) {
					n.innerHTML = sel;
				}
			});
	
			replaceVals(el);
	
			editor.execCommand('mceInsertContent', false, el.innerHTML);
			editor.addVisual();
		}
	
		editor.addCommand('mceInsertTemplate', insertTemplate);
	
		editor.addButton('template', {
			title: 'Insert template',
			onclick: createTemplateList(showDialog)
		});
	
		editor.addMenuItem('template', {
			text: 'Insert template',
			onclick: createTemplateList(showDialog),
			context: 'insert'
		});
	
		editor.on('PreProcess', function(o) {
			var dom = editor.dom;
	
			each(dom.select('div', o.node), function(e) {
				if (dom.hasClass(e, 'mceTmpl')) {
					each(dom.select('*', e), function(e) {
						if (dom.hasClass(e, editor.getParam('template_mdate_classes', 'mdate').replace(/\s+/g, '|'))) {
							e.innerHTML = getDateTime(editor.getParam("template_mdate_format", editor.getLang("template.mdate_format")));
						}
					});
	
					replaceVals(e);
				}
			});
		});
	});
	
	}.call(window));

/***/ },
/* 42 */
/***/ function(module, exports) {

	/*** IMPORTS FROM imports-loader ***/
	(function() {
	
	/**
	 * plugin.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/*global tinymce:true */
	
	tinymce.PluginManager.add('link', function(editor) {
		function createLinkList(callback) {
			return function() {
				var linkList = editor.settings.link_list;
	
				if (typeof linkList == "string") {
					tinymce.util.XHR.send({
						url: linkList,
						success: function(text) {
							callback(tinymce.util.JSON.parse(text));
						}
					});
				} else if (typeof linkList == "function") {
					linkList(callback);
				} else {
					callback(linkList);
				}
			};
		}
	
		function buildListItems(inputList, itemCallback, startItems) {
			function appendItems(values, output) {
				output = output || [];
	
				tinymce.each(values, function(item) {
					var menuItem = {text: item.text || item.title};
	
					if (item.menu) {
						menuItem.menu = appendItems(item.menu);
					} else {
						menuItem.value = item.value;
	
						if (itemCallback) {
							itemCallback(menuItem);
						}
					}
	
					output.push(menuItem);
				});
	
				return output;
			}
	
			return appendItems(inputList, startItems || []);
		}
	
		function showDialog(linkList) {
			var data = {}, selection = editor.selection, dom = editor.dom, selectedElm, anchorElm, initialText;
			var win, onlyText, textListCtrl, linkListCtrl, relListCtrl, targetListCtrl, classListCtrl, linkTitleCtrl, value;
	
			function linkListChangeHandler(e) {
				var textCtrl = win.find('#text');
	
				if (!textCtrl.value() || (e.lastControl && textCtrl.value() == e.lastControl.text())) {
					textCtrl.value(e.control.text());
				}
	
				win.find('#href').value(e.control.value());
			}
	
			function buildAnchorListControl(url) {
				var anchorList = [];
	
				tinymce.each(editor.dom.select('a:not([href])'), function(anchor) {
					var id = anchor.name || anchor.id;
	
					if (id) {
						anchorList.push({
							text: id,
							value: '#' + id,
							selected: url.indexOf('#' + id) != -1
						});
					}
				});
	
				if (anchorList.length) {
					anchorList.unshift({text: 'None', value: ''});
	
					return {
						name: 'anchor',
						type: 'listbox',
						label: 'Anchors',
						values: anchorList,
						onselect: linkListChangeHandler
					};
				}
			}
	
			function updateText() {
				if (!initialText && data.text.length === 0 && onlyText) {
					this.parent().parent().find('#text')[0].value(this.value());
				}
			}
	
			function urlChange(e) {
				var meta = e.meta || {};
	
				if (linkListCtrl) {
					linkListCtrl.value(editor.convertURL(this.value(), 'href'));
				}
	
				tinymce.each(e.meta, function(value, key) {
					win.find('#' + key).value(value);
				});
	
				if (!meta.text) {
					updateText.call(this);
				}
			}
	
			function isOnlyTextSelected(anchorElm) {
				var html = selection.getContent();
	
				// Partial html and not a fully selected anchor element
				if (/</.test(html) && (!/^<a [^>]+>[^<]+<\/a>$/.test(html) || html.indexOf('href=') == -1)) {
					return false;
				}
	
				if (anchorElm) {
					var nodes = anchorElm.childNodes, i;
	
					if (nodes.length === 0) {
						return false;
					}
	
					for (i = nodes.length - 1; i >= 0; i--) {
						if (nodes[i].nodeType != 3) {
							return false;
						}
					}
				}
	
				return true;
			}
	
			selectedElm = selection.getNode();
			anchorElm = dom.getParent(selectedElm, 'a[href]');
			onlyText = isOnlyTextSelected();
	
			data.text = initialText = anchorElm ? (anchorElm.innerText || anchorElm.textContent) : selection.getContent({format: 'text'});
			data.href = anchorElm ? dom.getAttrib(anchorElm, 'href') : '';
	
			if (anchorElm) {
				data.target = dom.getAttrib(anchorElm, 'target');
			} else if (editor.settings.default_link_target) {
				data.target = editor.settings.default_link_target;
			}
	
			if ((value = dom.getAttrib(anchorElm, 'rel'))) {
				data.rel = value;
			}
	
			if ((value = dom.getAttrib(anchorElm, 'class'))) {
				data['class'] = value;
			}
	
			if ((value = dom.getAttrib(anchorElm, 'title'))) {
				data.title = value;
			}
	
			if (onlyText) {
				textListCtrl = {
					name: 'text',
					type: 'textbox',
					size: 40,
					label: 'Text to display',
					onchange: function() {
						data.text = this.value();
					}
				};
			}
	
			if (linkList) {
				linkListCtrl = {
					type: 'listbox',
					label: 'Link list',
					values: buildListItems(
						linkList,
						function(item) {
							item.value = editor.convertURL(item.value || item.url, 'href');
						},
						[{text: 'None', value: ''}]
					),
					onselect: linkListChangeHandler,
					value: editor.convertURL(data.href, 'href'),
					onPostRender: function() {
						/*eslint consistent-this:0*/
						linkListCtrl = this;
					}
				};
			}
	
			if (editor.settings.target_list !== false) {
				if (!editor.settings.target_list) {
					editor.settings.target_list = [
						{text: 'None', value: ''},
						{text: 'New window', value: '_blank'}
					];
				}
	
				targetListCtrl = {
					name: 'target',
					type: 'listbox',
					label: 'Target',
					values: buildListItems(editor.settings.target_list)
				};
			}
	
			if (editor.settings.rel_list) {
				relListCtrl = {
					name: 'rel',
					type: 'listbox',
					label: 'Rel',
					values: buildListItems(editor.settings.rel_list)
				};
			}
	
			if (editor.settings.link_class_list) {
				classListCtrl = {
					name: 'class',
					type: 'listbox',
					label: 'Class',
					values: buildListItems(
						editor.settings.link_class_list,
						function(item) {
							if (item.value) {
								item.textStyle = function() {
									return editor.formatter.getCssText({inline: 'a', classes: [item.value]});
								};
							}
						}
					)
				};
			}
	
			if (editor.settings.link_title !== false) {
				linkTitleCtrl = {
					name: 'title',
					type: 'textbox',
					label: 'Title',
					value: data.title
				};
			}
	
			win = editor.windowManager.open({
				title: 'Insert link',
				data: data,
				body: [
					{
						name: 'href',
						type: 'filepicker',
						filetype: 'file',
						size: 40,
						autofocus: true,
						label: 'Url',
						onchange: urlChange,
						onkeyup: updateText
					},
					textListCtrl,
					linkTitleCtrl,
					buildAnchorListControl(data.href),
					linkListCtrl,
					relListCtrl,
					targetListCtrl,
					classListCtrl
				],
				onSubmit: function(e) {
					/*eslint dot-notation: 0*/
					var href;
	
					data = tinymce.extend(data, e.data);
					href = data.href;
	
					// Delay confirm since onSubmit will move focus
					function delayedConfirm(message, callback) {
						var rng = editor.selection.getRng();
	
						tinymce.util.Delay.setEditorTimeout(editor, function() {
							editor.windowManager.confirm(message, function(state) {
								editor.selection.setRng(rng);
								callback(state);
							});
						});
					}
	
					function insertLink() {
						var linkAttrs = {
							href: href,
							target: data.target ? data.target : null,
							rel: data.rel ? data.rel : null,
							"class": data["class"] ? data["class"] : null,
							title: data.title ? data.title : null
						};
	
						if (anchorElm) {
							editor.focus();
	
							if (onlyText && data.text != initialText) {
								if ("innerText" in anchorElm) {
									anchorElm.innerText = data.text;
								} else {
									anchorElm.textContent = data.text;
								}
							}
	
							dom.setAttribs(anchorElm, linkAttrs);
	
							selection.select(anchorElm);
							editor.undoManager.add();
						} else {
							if (onlyText) {
								editor.insertContent(dom.createHTML('a', linkAttrs, dom.encode(data.text)));
							} else {
								editor.execCommand('mceInsertLink', false, linkAttrs);
							}
						}
					}
	
					if (!href) {
						editor.execCommand('unlink');
						return;
					}
	
					// Is email and not //user@domain.com
					if (href.indexOf('@') > 0 && href.indexOf('//') == -1 && href.indexOf('mailto:') == -1) {
						delayedConfirm(
							'The URL you entered seems to be an email address. Do you want to add the required mailto: prefix?',
							function(state) {
								if (state) {
									href = 'mailto:' + href;
								}
	
								insertLink();
							}
						);
	
						return;
					}
	
					// Is not protocol prefixed
					if ((editor.settings.link_assume_external_targets && !/^\w+:/i.test(href)) ||
						(!editor.settings.link_assume_external_targets && /^\s*www[\.|\d\.]/i.test(href))) {
						delayedConfirm(
							'The URL you entered seems to be an external link. Do you want to add the required http:// prefix?',
							function(state) {
								if (state) {
									href = 'http://' + href;
								}
	
								insertLink();
							}
						);
	
						return;
					}
	
					insertLink();
				}
			});
		}
	
		editor.addButton('link', {
			icon: 'link',
			tooltip: 'Insert/edit link',
			shortcut: 'Meta+K',
			onclick: createLinkList(showDialog),
			stateSelector: 'a[href]'
		});
	
		editor.addButton('unlink', {
			icon: 'unlink',
			tooltip: 'Remove link',
			cmd: 'unlink',
			stateSelector: 'a[href]'
		});
	
		editor.addShortcut('Meta+K', '', createLinkList(showDialog));
		editor.addCommand('mceLink', createLinkList(showDialog));
	
		this.showDialog = showDialog;
	
		editor.addMenuItem('link', {
			icon: 'link',
			text: 'Insert/edit link',
			shortcut: 'Meta+K',
			onclick: createLinkList(showDialog),
			stateSelector: 'a[href]',
			context: 'insert',
			prependToContext: true
		});
	});
	
	}.call(window));

/***/ },
/* 43 */
/***/ function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {/*** IMPORTS FROM imports-loader ***/
	(function() {
	
	/**
	 * Compiled inline version. (Library mode)
	 */
	
	/*jshint smarttabs:true, undef:true, latedef:true, curly:true, bitwise:true, camelcase:true */
	/*globals $code */
	
	(function(exports, undefined) {
		"use strict";
	
		var modules = {};
	
		function require(ids, callback) {
			var module, defs = [];
	
			for (var i = 0; i < ids.length; ++i) {
				module = modules[ids[i]] || resolve(ids[i]);
				if (!module) {
					throw 'module definition dependecy not found: ' + ids[i];
				}
	
				defs.push(module);
			}
	
			callback.apply(null, defs);
		}
	
		function define(id, dependencies, definition) {
			if (typeof id !== 'string') {
				throw 'invalid module definition, module id must be defined and be a string';
			}
	
			if (dependencies === undefined) {
				throw 'invalid module definition, dependencies must be specified';
			}
	
			if (definition === undefined) {
				throw 'invalid module definition, definition function must be specified';
			}
	
			require(dependencies, function() {
				modules[id] = definition.apply(null, arguments);
			});
		}
	
		function defined(id) {
			return !!modules[id];
		}
	
		function resolve(id) {
			var target = exports;
			var fragments = id.split(/[.\/]/);
	
			for (var fi = 0; fi < fragments.length; ++fi) {
				if (!target[fragments[fi]]) {
					return;
				}
	
				target = target[fragments[fi]];
			}
	
			return target;
		}
	
		function expose(ids) {
			var i, target, id, fragments, privateModules;
	
			for (i = 0; i < ids.length; i++) {
				target = exports;
				id = ids[i];
				fragments = id.split(/[.\/]/);
	
				for (var fi = 0; fi < fragments.length - 1; ++fi) {
					if (target[fragments[fi]] === undefined) {
						target[fragments[fi]] = {};
					}
	
					target = target[fragments[fi]];
				}
	
				target[fragments[fragments.length - 1]] = modules[id];
			}
			
			// Expose private modules for unit tests
			if (exports.AMDLC_TESTS) {
				privateModules = exports.privateModules || {};
	
				for (id in modules) {
					privateModules[id] = modules[id];
				}
	
				for (i = 0; i < ids.length; i++) {
					delete privateModules[ids[i]];
				}
	
				exports.privateModules = privateModules;
			}
		}
	
	// Included from: js/tinymce/plugins/codesample/classes/Prism.js
	
	/**
	 * Prism.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 *
	 * Import of prism. Disabled DOMContentLoaded event listener.
	 */
	
	define("tinymce/codesampleplugin/Prism", [], function() {
	var window = {};
	// ------------------ Start wrap
	
	/* http://prismjs.com/download.html?themes=prism-dark&languages=markup+css+clike+javascript+c+csharp+cpp+java+php+python+ruby */
	var _self = (typeof window !== 'undefined')
		? window   // if in browser
		: (
			(typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope)
			? self // if in worker
			: {}   // if in node js
		);
	
	/**
	 * Prism: Lightweight, robust, elegant syntax highlighting
	 * MIT license http://www.opensource.org/licenses/mit-license.php/
	 * @author Lea Verou http://lea.verou.me
	 */
	
	var Prism = (function(){
	
	// Private helper vars
	var lang = /\blang(?:uage)?-(?!\*)(\w+)\b/i;
	
	var _ = _self.Prism = {
		util: {
			encode: function (tokens) {
				if (tokens instanceof Token) {
					return new Token(tokens.type, _.util.encode(tokens.content), tokens.alias);
				} else if (_.util.type(tokens) === 'Array') {
					return tokens.map(_.util.encode);
				} else {
					return tokens.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/\u00a0/g, ' ');
				}
			},
	
			type: function (o) {
				return Object.prototype.toString.call(o).match(/\[object (\w+)\]/)[1];
			},
	
			// Deep clone a language definition (e.g. to extend it)
			clone: function (o) {
				var type = _.util.type(o);
	
				switch (type) {
					case 'Object':
						var clone = {};
	
						for (var key in o) {
							if (o.hasOwnProperty(key)) {
								clone[key] = _.util.clone(o[key]);
							}
						}
	
						return clone;
	
					case 'Array':
						// Check for existence for IE8
						return o.map && o.map(function(v) { return _.util.clone(v); });
				}
	
				return o;
			}
		},
	
		languages: {
			extend: function (id, redef) {
				var lang = _.util.clone(_.languages[id]);
	
				for (var key in redef) {
					lang[key] = redef[key];
				}
	
				return lang;
			},
	
			/**
			 * Insert a token before another token in a language literal
			 * As this needs to recreate the object (we cannot actually insert before keys in object literals),
			 * we cannot just provide an object, we need anobject and a key.
			 * @param inside The key (or language id) of the parent
			 * @param before The key to insert before. If not provided, the function appends instead.
			 * @param insert Object with the key/value pairs to insert
			 * @param root The object that contains `inside`. If equal to Prism.languages, it can be omitted.
			 */
			insertBefore: function (inside, before, insert, root) {
				root = root || _.languages;
				var grammar = root[inside];
	
				if (arguments.length == 2) {
					insert = arguments[1];
	
					for (var newToken in insert) {
						if (insert.hasOwnProperty(newToken)) {
							grammar[newToken] = insert[newToken];
						}
					}
	
					return grammar;
				}
	
				var ret = {};
	
				for (var token in grammar) {
	
					if (grammar.hasOwnProperty(token)) {
	
						if (token == before) {
	
							for (var newToken in insert) {
	
								if (insert.hasOwnProperty(newToken)) {
									ret[newToken] = insert[newToken];
								}
							}
						}
	
						ret[token] = grammar[token];
					}
				}
	
				// Update references in other language definitions
				_.languages.DFS(_.languages, function(key, value) {
					if (value === root[inside] && key != inside) {
						this[key] = ret;
					}
				});
	
				return root[inside] = ret;
			},
	
			// Traverse a language definition with Depth First Search
			DFS: function(o, callback, type) {
				for (var i in o) {
					if (o.hasOwnProperty(i)) {
						callback.call(o, i, o[i], type || i);
	
						if (_.util.type(o[i]) === 'Object') {
							_.languages.DFS(o[i], callback);
						}
						else if (_.util.type(o[i]) === 'Array') {
							_.languages.DFS(o[i], callback, i);
						}
					}
				}
			}
		},
		plugins: {},
	
		highlightAll: function(async, callback) {
			var elements = document.querySelectorAll('code[class*="language-"], [class*="language-"] code, code[class*="lang-"], [class*="lang-"] code');
	
			for (var i=0, element; element = elements[i++];) {
				_.highlightElement(element, async === true, callback);
			}
		},
	
		highlightElement: function(element, async, callback) {
			// Find language
			var language, grammar, parent = element;
	
			while (parent && !lang.test(parent.className)) {
				parent = parent.parentNode;
			}
	
			if (parent) {
				language = (parent.className.match(lang) || [,''])[1];
				grammar = _.languages[language];
			}
	
			// Set language on the element, if not present
			element.className = element.className.replace(lang, '').replace(/\s+/g, ' ') + ' language-' + language;
	
			// Set language on the parent, for styling
			parent = element.parentNode;
	
			if (/pre/i.test(parent.nodeName)) {
				parent.className = parent.className.replace(lang, '').replace(/\s+/g, ' ') + ' language-' + language;
			}
	
			var code = element.textContent;
	
			var env = {
				element: element,
				language: language,
				grammar: grammar,
				code: code
			};
	
			if (!code || !grammar) {
				_.hooks.run('complete', env);
				return;
			}
	
			_.hooks.run('before-highlight', env);
	
			if (async && _self.Worker) {
				var worker = new Worker(_.filename);
	
				worker.onmessage = function(evt) {
					env.highlightedCode = evt.data;
	
					_.hooks.run('before-insert', env);
	
					env.element.innerHTML = env.highlightedCode;
	
					callback && callback.call(env.element);
					_.hooks.run('after-highlight', env);
					_.hooks.run('complete', env);
				};
	
				worker.postMessage(JSON.stringify({
					language: env.language,
					code: env.code,
					immediateClose: true
				}));
			}
			else {
				env.highlightedCode = _.highlight(env.code, env.grammar, env.language);
	
				_.hooks.run('before-insert', env);
	
				env.element.innerHTML = env.highlightedCode;
	
				callback && callback.call(element);
	
				_.hooks.run('after-highlight', env);
				_.hooks.run('complete', env);
			}
		},
	
		highlight: function (text, grammar, language) {
			var tokens = _.tokenize(text, grammar);
			return Token.stringify(_.util.encode(tokens), language);
		},
	
		tokenize: function(text, grammar, language) {
			var Token = _.Token;
	
			var strarr = [text];
	
			var rest = grammar.rest;
	
			if (rest) {
				for (var token in rest) {
					grammar[token] = rest[token];
				}
	
				delete grammar.rest;
			}
	
			tokenloop: for (var token in grammar) {
				if(!grammar.hasOwnProperty(token) || !grammar[token]) {
					continue;
				}
	
				var patterns = grammar[token];
				patterns = (_.util.type(patterns) === "Array") ? patterns : [patterns];
	
				for (var j = 0; j < patterns.length; ++j) {
					var pattern = patterns[j],
						inside = pattern.inside,
						lookbehind = !!pattern.lookbehind,
						lookbehindLength = 0,
						alias = pattern.alias;
	
					pattern = pattern.pattern || pattern;
	
					for (var i=0; i<strarr.length; i++) { // Donât cache length as it changes during the loop
	
						var str = strarr[i];
	
						if (strarr.length > text.length) {
							// Something went terribly wrong, ABORT, ABORT!
							break tokenloop;
						}
	
						if (str instanceof Token) {
							continue;
						}
	
						pattern.lastIndex = 0;
	
						var match = pattern.exec(str);
	
						if (match) {
							if(lookbehind) {
								lookbehindLength = match[1].length;
							}
	
							var from = match.index - 1 + lookbehindLength,
								match = match[0].slice(lookbehindLength),
								len = match.length,
								to = from + len,
								before = str.slice(0, from + 1),
								after = str.slice(to + 1);
	
							var args = [i, 1];
	
							if (before) {
								args.push(before);
							}
	
							var wrapped = new Token(token, inside? _.tokenize(match, inside) : match, alias);
	
							args.push(wrapped);
	
							if (after) {
								args.push(after);
							}
	
							Array.prototype.splice.apply(strarr, args);
						}
					}
				}
			}
	
			return strarr;
		},
	
		hooks: {
			all: {},
	
			add: function (name, callback) {
				var hooks = _.hooks.all;
	
				hooks[name] = hooks[name] || [];
	
				hooks[name].push(callback);
			},
	
			run: function (name, env) {
				var callbacks = _.hooks.all[name];
	
				if (!callbacks || !callbacks.length) {
					return;
				}
	
				for (var i=0, callback; callback = callbacks[i++];) {
					callback(env);
				}
			}
		}
	};
	
	var Token = _.Token = function(type, content, alias) {
		this.type = type;
		this.content = content;
		this.alias = alias;
	};
	
	Token.stringify = function(o, language, parent) {
		if (typeof o == 'string') {
			return o;
		}
	
		if (_.util.type(o) === 'Array') {
			return o.map(function(element) {
				return Token.stringify(element, language, o);
			}).join('');
		}
	
		var env = {
			type: o.type,
			content: Token.stringify(o.content, language, parent),
			tag: 'span',
			classes: ['token', o.type],
			attributes: {},
			language: language,
			parent: parent
		};
	
		if (env.type == 'comment') {
			env.attributes['spellcheck'] = 'true';
		}
	
		if (o.alias) {
			var aliases = _.util.type(o.alias) === 'Array' ? o.alias : [o.alias];
			Array.prototype.push.apply(env.classes, aliases);
		}
	
		_.hooks.run('wrap', env);
	
		var attributes = '';
	
		for (var name in env.attributes) {
			attributes += (attributes ? ' ' : '') + name + '="' + (env.attributes[name] || '') + '"';
		}
	
		return '<' + env.tag + ' class="' + env.classes.join(' ') + '" ' + attributes + '>' + env.content + '</' + env.tag + '>';
	
	};
	
	if (!_self.document) {
		if (!_self.addEventListener) {
			// in Node.js
			return _self.Prism;
		}
	 	// In worker
		_self.addEventListener('message', function(evt) {
			var message = JSON.parse(evt.data),
			    lang = message.language,
			    code = message.code,
			    immediateClose = message.immediateClose;
	
			_self.postMessage(_.highlight(code, _.languages[lang], lang));
			if (immediateClose) {
				_self.close();
			}
		}, false);
	
		return _self.Prism;
	}
	/*
	// Get current script and highlight
	var script = document.getElementsByTagName('script');
	
	script = script[script.length - 1];
	
	if (script) {
		_.filename = script.src;
	
		if (document.addEventListener && !script.hasAttribute('data-manual')) {
			document.addEventListener('DOMContentLoaded', _.highlightAll);
		}
	}
	
	return _self.Prism;
	*/
	})();
	
	if (typeof module !== 'undefined' && module.exports) {
		module.exports = Prism;
	}
	
	// hack for components to work correctly in node.js
	if (typeof global !== 'undefined') {
		global.Prism = Prism;
	}
	;
	Prism.languages.markup = {
		'comment': /<!--[\w\W]*?-->/,
		'prolog': /<\?[\w\W]+?\?>/,
		'doctype': /<!DOCTYPE[\w\W]+?>/,
		'cdata': /<!\[CDATA\[[\w\W]*?]]>/i,
		'tag': {
			pattern: /<\/?[^\s>\/=.]+(?:\s+[^\s>\/=]+(?:=(?:("|')(?:\\\1|\\?(?!\1)[\w\W])*\1|[^\s'">=]+))?)*\s*\/?>/i,
			inside: {
				'tag': {
					pattern: /^<\/?[^\s>\/]+/i,
					inside: {
						'punctuation': /^<\/?/,
						'namespace': /^[^\s>\/:]+:/
					}
				},
				'attr-value': {
					pattern: /=(?:('|")[\w\W]*?(\1)|[^\s>]+)/i,
					inside: {
						'punctuation': /[=>"']/
					}
				},
				'punctuation': /\/?>/,
				'attr-name': {
					pattern: /[^\s>\/]+/,
					inside: {
						'namespace': /^[^\s>\/:]+:/
					}
				}
	
			}
		},
		'entity': /&#?[\da-z]{1,8};/i
	};
	
	// Plugin to make entity title show the real entity, idea by Roman Komarov
	Prism.hooks.add('wrap', function(env) {
	
		if (env.type === 'entity') {
			env.attributes['title'] = env.content.replace(/&amp;/, '&');
		}
	});
	
	Prism.languages.xml = Prism.languages.markup;
	Prism.languages.html = Prism.languages.markup;
	Prism.languages.mathml = Prism.languages.markup;
	Prism.languages.svg = Prism.languages.markup;
	
	Prism.languages.css = {
		'comment': /\/\*[\w\W]*?\*\//,
		'atrule': {
			pattern: /@[\w-]+?.*?(;|(?=\s*\{))/i,
			inside: {
				'rule': /@[\w-]+/
				// See rest below
			}
		},
		'url': /url\((?:(["'])(\\(?:\r\n|[\w\W])|(?!\1)[^\\\r\n])*\1|.*?)\)/i,
		'selector': /[^\{\}\s][^\{\};]*?(?=\s*\{)/,
		'string': /("|')(\\(?:\r\n|[\w\W])|(?!\1)[^\\\r\n])*\1/,
		'property': /(\b|\B)[\w-]+(?=\s*:)/i,
		'important': /\B!important\b/i,
		'function': /[-a-z0-9]+(?=\()/i,
		'punctuation': /[(){};:]/
	};
	
	Prism.languages.css['atrule'].inside.rest = Prism.util.clone(Prism.languages.css);
	
	if (Prism.languages.markup) {
		Prism.languages.insertBefore('markup', 'tag', {
			'style': {
				pattern: /<style[\w\W]*?>[\w\W]*?<\/style>/i,
				inside: {
					'tag': {
						pattern: /<style[\w\W]*?>|<\/style>/i,
						inside: Prism.languages.markup.tag.inside
					},
					rest: Prism.languages.css
				},
				alias: 'language-css'
			}
		});
	
		Prism.languages.insertBefore('inside', 'attr-value', {
			'style-attr': {
				pattern: /\s*style=("|').*?\1/i,
				inside: {
					'attr-name': {
						pattern: /^\s*style/i,
						inside: Prism.languages.markup.tag.inside
					},
					'punctuation': /^\s*=\s*['"]|['"]\s*$/,
					'attr-value': {
						pattern: /.+/i,
						inside: Prism.languages.css
					}
				},
				alias: 'language-css'
			}
		}, Prism.languages.markup.tag);
	};
	Prism.languages.clike = {
		'comment': [
			{
				pattern: /(^|[^\\])\/\*[\w\W]*?\*\//,
				lookbehind: true
			},
			{
				pattern: /(^|[^\\:])\/\/.*/,
				lookbehind: true
			}
		],
		'string': /(["'])(\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
		'class-name': {
			pattern: /((?:\b(?:class|interface|extends|implements|trait|instanceof|new)\s+)|(?:catch\s+\())[a-z0-9_\.\\]+/i,
			lookbehind: true,
			inside: {
				punctuation: /(\.|\\)/
			}
		},
		'keyword': /\b(if|else|while|do|for|return|in|instanceof|function|new|try|throw|catch|finally|null|break|continue)\b/,
		'boolean': /\b(true|false)\b/,
		'function': /[a-z0-9_]+(?=\()/i,
		'number': /\b-?(?:0x[\da-f]+|\d*\.?\d+(?:e[+-]?\d+)?)\b/i,
		'operator': /--?|\+\+?|!=?=?|<=?|>=?|==?=?|&&?|\|\|?|\?|\*|\/|~|\^|%/,
		'punctuation': /[{}[\];(),.:]/
	};
	
	Prism.languages.javascript = Prism.languages.extend('clike', {
		'keyword': /\b(as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|false|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|true|try|typeof|var|void|while|with|yield)\b/,
		'number': /\b-?(0x[\dA-Fa-f]+|0b[01]+|0o[0-7]+|\d*\.?\d+([Ee][+-]?\d+)?|NaN|Infinity)\b/,
		// Allow for all non-ASCII characters (See http://stackoverflow.com/a/2008444)
		'function': /[_$a-zA-Z\xA0-\uFFFF][_$a-zA-Z0-9\xA0-\uFFFF]*(?=\()/i
	});
	
	Prism.languages.insertBefore('javascript', 'keyword', {
		'regex': {
			pattern: /(^|[^/])\/(?!\/)(\[.+?]|\\.|[^/\\\r\n])+\/[gimyu]{0,5}(?=\s*($|[\r\n,.;})]))/,
			lookbehind: true
		}
	});
	
	Prism.languages.insertBefore('javascript', 'class-name', {
		'template-string': {
			pattern: /`(?:\\`|\\?[^`])*`/,
			inside: {
				'interpolation': {
					pattern: /\$\{[^}]+\}/,
					inside: {
						'interpolation-punctuation': {
							pattern: /^\$\{|\}$/,
							alias: 'punctuation'
						},
						rest: Prism.languages.javascript
					}
				},
				'string': /[\s\S]+/
			}
		}
	});
	
	if (Prism.languages.markup) {
		Prism.languages.insertBefore('markup', 'tag', {
			'script': {
				pattern: /<script[\w\W]*?>[\w\W]*?<\/script>/i,
				inside: {
					'tag': {
						pattern: /<script[\w\W]*?>|<\/script>/i,
						inside: Prism.languages.markup.tag.inside
					},
					rest: Prism.languages.javascript
				},
				alias: 'language-javascript'
			}
		});
	}
	
	Prism.languages.js = Prism.languages.javascript;
	Prism.languages.c = Prism.languages.extend('clike', {
		'keyword': /\b(asm|typeof|inline|auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|int|long|register|return|short|signed|sizeof|static|struct|switch|typedef|union|unsigned|void|volatile|while)\b/,
		'operator': /\-[>-]?|\+\+?|!=?|<<?=?|>>?=?|==?|&&?|\|?\||[~^%?*\/]/,
		'number': /\b-?(?:0x[\da-f]+|\d*\.?\d+(?:e[+-]?\d+)?)[ful]*\b/i
	});
	
	Prism.languages.insertBefore('c', 'string', {
		'macro': {
			// allow for multiline macro definitions
			// spaces after the # character compile fine with gcc
			pattern: /(^\s*)#\s*[a-z]+([^\r\n\\]|\\.|\\(?:\r\n?|\n))*/im,
			lookbehind: true,
			alias: 'property',
			inside: {
				// highlight the path of the include statement as a string
				'string': {
					pattern: /(#\s*include\s*)(<.+?>|("|')(\\?.)+?\3)/,
					lookbehind: true
				}
			}
		}
	});
	
	delete Prism.languages.c['class-name'];
	delete Prism.languages.c['boolean'];
	
	Prism.languages.csharp = Prism.languages.extend('clike', {
		'keyword': /\b(abstract|as|async|await|base|bool|break|byte|case|catch|char|checked|class|const|continue|decimal|default|delegate|do|double|else|enum|event|explicit|extern|false|finally|fixed|float|for|foreach|goto|if|implicit|in|int|interface|internal|is|lock|long|namespace|new|null|object|operator|out|override|params|private|protected|public|readonly|ref|return|sbyte|sealed|short|sizeof|stackalloc|static|string|struct|switch|this|throw|true|try|typeof|uint|ulong|unchecked|unsafe|ushort|using|virtual|void|volatile|while|add|alias|ascending|async|await|descending|dynamic|from|get|global|group|into|join|let|orderby|partial|remove|select|set|value|var|where|yield)\b/,
		'string': [
			/@("|')(\1\1|\\\1|\\?(?!\1)[\s\S])*\1/,
			/("|')(\\?.)*?\1/
		],
		'number': /\b-?(0x[\da-f]+|\d*\.?\d+)\b/i
	});
	
	Prism.languages.insertBefore('csharp', 'keyword', {
		'preprocessor': {
			pattern: /(^\s*)#.*/m,
			lookbehind: true
		}
	});
	
	Prism.languages.cpp = Prism.languages.extend('c', {
		'keyword': /\b(alignas|alignof|asm|auto|bool|break|case|catch|char|char16_t|char32_t|class|compl|const|constexpr|const_cast|continue|decltype|default|delete|do|double|dynamic_cast|else|enum|explicit|export|extern|float|for|friend|goto|if|inline|int|long|mutable|namespace|new|noexcept|nullptr|operator|private|protected|public|register|reinterpret_cast|return|short|signed|sizeof|static|static_assert|static_cast|struct|switch|template|this|thread_local|throw|try|typedef|typeid|typename|union|unsigned|using|virtual|void|volatile|wchar_t|while)\b/,
		'boolean': /\b(true|false)\b/,
		'operator': /[-+]{1,2}|!=?|<{1,2}=?|>{1,2}=?|\->|:{1,2}|={1,2}|\^|~|%|&{1,2}|\|?\||\?|\*|\/|\b(and|and_eq|bitand|bitor|not|not_eq|or|or_eq|xor|xor_eq)\b/
	});
	
	Prism.languages.insertBefore('cpp', 'keyword', {
		'class-name': {
			pattern: /(class\s+)[a-z0-9_]+/i,
			lookbehind: true
		}
	});
	Prism.languages.java = Prism.languages.extend('clike', {
		'keyword': /\b(abstract|continue|for|new|switch|assert|default|goto|package|synchronized|boolean|do|if|private|this|break|double|implements|protected|throw|byte|else|import|public|throws|case|enum|instanceof|return|transient|catch|extends|int|short|try|char|final|interface|static|void|class|finally|long|strictfp|volatile|const|float|native|super|while)\b/,
		'number': /\b0b[01]+\b|\b0x[\da-f]*\.?[\da-fp\-]+\b|\b\d*\.?\d+(?:e[+-]?\d+)?[df]?\b/i,
		'operator': {
			pattern: /(^|[^.])(?:\+[+=]?|-[-=]?|!=?|<<?=?|>>?>?=?|==?|&[&=]?|\|[|=]?|\*=?|\/=?|%=?|\^=?|[?:~])/m,
			lookbehind: true
		}
	});
	/**
	 * Original by Aaron Harun: http://aahacreative.com/2012/07/31/php-syntax-highlighting-prism/
	 * Modified by Miles Johnson: http://milesj.me
	 *
	 * Supports the following:
	 * 		- Extends clike syntax
	 * 		- Support for PHP 5.3+ (namespaces, traits, generators, etc)
	 * 		- Smarter constant and function matching
	 *
	 * Adds the following new token classes:
	 * 		constant, delimiter, variable, function, package
	 */
	
	Prism.languages.php = Prism.languages.extend('clike', {
		'keyword': /\b(and|or|xor|array|as|break|case|cfunction|class|const|continue|declare|default|die|do|else|elseif|enddeclare|endfor|endforeach|endif|endswitch|endwhile|extends|for|foreach|function|include|include_once|global|if|new|return|static|switch|use|require|require_once|var|while|abstract|interface|public|implements|private|protected|parent|throw|null|echo|print|trait|namespace|final|yield|goto|instanceof|finally|try|catch)\b/i,
		'constant': /\b[A-Z0-9_]{2,}\b/,
		'comment': {
			pattern: /(^|[^\\])(?:\/\*[\w\W]*?\*\/|\/\/.*)/,
			lookbehind: true
		}
	});
	
	// Shell-like comments are matched after strings, because they are less
	// common than strings containing hashes...
	Prism.languages.insertBefore('php', 'class-name', {
		'shell-comment': {
			pattern: /(^|[^\\])#.*/,
			lookbehind: true,
			alias: 'comment'
		}
	});
	
	Prism.languages.insertBefore('php', 'keyword', {
		'delimiter': /\?>|<\?(?:php)?/i,
		'variable': /\$\w+\b/i,
		'package': {
			pattern: /(\\|namespace\s+|use\s+)[\w\\]+/,
			lookbehind: true,
			inside: {
				punctuation: /\\/
			}
		}
	});
	
	// Must be defined after the function pattern
	Prism.languages.insertBefore('php', 'operator', {
		'property': {
			pattern: /(->)[\w]+/,
			lookbehind: true
		}
	});
	
	// Add HTML support of the markup language exists
	if (Prism.languages.markup) {
	
		// Tokenize all inline PHP blocks that are wrapped in <?php ?>
		// This allows for easy PHP + markup highlighting
		Prism.hooks.add('before-highlight', function(env) {
			if (env.language !== 'php') {
				return;
			}
	
			env.tokenStack = [];
	
			env.backupCode = env.code;
			env.code = env.code.replace(/(?:<\?php|<\?)[\w\W]*?(?:\?>)/ig, function(match) {
				env.tokenStack.push(match);
	
				return '{{{PHP' + env.tokenStack.length + '}}}';
			});
		});
	
		// Restore env.code for other plugins (e.g. line-numbers)
		Prism.hooks.add('before-insert', function(env) {
			if (env.language === 'php') {
				env.code = env.backupCode;
				delete env.backupCode;
			}
		});
	
		// Re-insert the tokens after highlighting
		Prism.hooks.add('after-highlight', function(env) {
			if (env.language !== 'php') {
				return;
			}
	
			for (var i = 0, t; t = env.tokenStack[i]; i++) {
				// The replace prevents $$, $&, $`, $', $n, $nn from being interpreted as special patterns
				env.highlightedCode = env.highlightedCode.replace('{{{PHP' + (i + 1) + '}}}', Prism.highlight(t, env.grammar, 'php').replace(/\$/g, '$$$$'));
			}
	
			env.element.innerHTML = env.highlightedCode;
		});
	
		// Wrap tokens in classes that are missing them
		Prism.hooks.add('wrap', function(env) {
			if (env.language === 'php' && env.type === 'markup') {
				env.content = env.content.replace(/(\{\{\{PHP[0-9]+\}\}\})/g, "<span class=\"token php\">$1</span>");
			}
		});
	
		// Add the rules before all others
		Prism.languages.insertBefore('php', 'comment', {
			'markup': {
				pattern: /<[^?]\/?(.*?)>/,
				inside: Prism.languages.markup
			},
			'php': /\{\{\{PHP[0-9]+\}\}\}/
		});
	}
	;
	Prism.languages.python= {
		'comment': {
			pattern: /(^|[^\\])#.*/,
			lookbehind: true
		},
		'string': /"""[\s\S]+?"""|'''[\s\S]+?'''|("|')(?:\\?.)*?\1/,
		'function' : {
			pattern: /((?:^|\s)def[ \t]+)[a-zA-Z_][a-zA-Z0-9_]*(?=\()/g,
			lookbehind: true
		},
		'class-name': {
			pattern: /(\bclass\s+)[a-z0-9_]+/i,
			lookbehind: true
		},
		'keyword' : /\b(?:as|assert|async|await|break|class|continue|def|del|elif|else|except|exec|finally|for|from|global|if|import|in|is|lambda|pass|print|raise|return|try|while|with|yield)\b/,
		'boolean' : /\b(?:True|False)\b/,
		'number' : /\b-?(?:0[bo])?(?:(?:\d|0x[\da-f])[\da-f]*\.?\d*|\.\d+)(?:e[+-]?\d+)?j?\b/i,
		'operator' : /[-+%=]=?|!=|\*\*?=?|\/\/?=?|<[<=>]?|>[=>]?|[&|^~]|\b(?:or|and|not)\b/,
		'punctuation' : /[{}[\];(),.:]/
	};
	
	/**
	 * Original by Samuel Flores
	 *
	 * Adds the following new token classes:
	 * 		constant, builtin, variable, symbol, regex
	 */
	(function(Prism) {
		Prism.languages.ruby = Prism.languages.extend('clike', {
			'comment': /#(?!\{[^\r\n]*?\}).*/,
			'keyword': /\b(alias|and|BEGIN|begin|break|case|class|def|define_method|defined|do|each|else|elsif|END|end|ensure|false|for|if|in|module|new|next|nil|not|or|raise|redo|require|rescue|retry|return|self|super|then|throw|true|undef|unless|until|when|while|yield)\b/
		});
	
		var interpolation = {
			pattern: /#\{[^}]+\}/,
			inside: {
				'delimiter': {
					pattern: /^#\{|\}$/,
					alias: 'tag'
				},
				rest: Prism.util.clone(Prism.languages.ruby)
			}
		};
	
		Prism.languages.insertBefore('ruby', 'keyword', {
			'regex': [
				{
					pattern: /%r([^a-zA-Z0-9\s\{\(\[<])(?:[^\\]|\\[\s\S])*?\1[gim]{0,3}/,
					inside: {
						'interpolation': interpolation
					}
				},
				{
					pattern: /%r\((?:[^()\\]|\\[\s\S])*\)[gim]{0,3}/,
					inside: {
						'interpolation': interpolation
					}
				},
				{
					// Here we need to specifically allow interpolation
					pattern: /%r\{(?:[^#{}\\]|#(?:\{[^}]+\})?|\\[\s\S])*\}[gim]{0,3}/,
					inside: {
						'interpolation': interpolation
					}
				},
				{
					pattern: /%r\[(?:[^\[\]\\]|\\[\s\S])*\][gim]{0,3}/,
					inside: {
						'interpolation': interpolation
					}
				},
				{
					pattern: /%r<(?:[^<>\\]|\\[\s\S])*>[gim]{0,3}/,
					inside: {
						'interpolation': interpolation
					}
				},
				{
					pattern: /(^|[^/])\/(?!\/)(\[.+?]|\\.|[^/\r\n])+\/[gim]{0,3}(?=\s*($|[\r\n,.;})]))/,
					lookbehind: true
				}
			],
			'variable': /[@$]+[a-zA-Z_][a-zA-Z_0-9]*(?:[?!]|\b)/,
			'symbol': /:[a-zA-Z_][a-zA-Z_0-9]*(?:[?!]|\b)/
		});
	
		Prism.languages.insertBefore('ruby', 'number', {
			'builtin': /\b(Array|Bignum|Binding|Class|Continuation|Dir|Exception|FalseClass|File|Stat|File|Fixnum|Fload|Hash|Integer|IO|MatchData|Method|Module|NilClass|Numeric|Object|Proc|Range|Regexp|String|Struct|TMS|Symbol|ThreadGroup|Thread|Time|TrueClass)\b/,
			'constant': /\b[A-Z][a-zA-Z_0-9]*(?:[?!]|\b)/
		});
	
		Prism.languages.ruby.string = [
			{
				pattern: /%[qQiIwWxs]?([^a-zA-Z0-9\s\{\(\[<])(?:[^\\]|\\[\s\S])*?\1/,
				inside: {
					'interpolation': interpolation
				}
			},
			{
				pattern: /%[qQiIwWxs]?\((?:[^()\\]|\\[\s\S])*\)/,
				inside: {
					'interpolation': interpolation
				}
			},
			{
				// Here we need to specifically allow interpolation
				pattern: /%[qQiIwWxs]?\{(?:[^#{}\\]|#(?:\{[^}]+\})?|\\[\s\S])*\}/,
				inside: {
					'interpolation': interpolation
				}
			},
			{
				pattern: /%[qQiIwWxs]?\[(?:[^\[\]\\]|\\[\s\S])*\]/,
				inside: {
					'interpolation': interpolation
				}
			},
			{
				pattern: /%[qQiIwWxs]?<(?:[^<>\\]|\\[\s\S])*>/,
				inside: {
					'interpolation': interpolation
				}
			},
			{
				pattern: /("|')(#\{[^}]+\}|\\(?:\r?\n|\r)|\\?.)*?\1/,
				inside: {
					'interpolation': interpolation
				}
			}
		];
	}(Prism));
	
	// ------------------ End wrap
	return Prism;
	});
	
	// Included from: js/tinymce/plugins/codesample/classes/Utils.js
	
	/**
	 * Utils.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * Various utility functions.
	 *
	 * @class tinymce.codesample.Utils
	 * @private
	 */
	define("tinymce/codesampleplugin/Utils", [
	], function() {
		function isCodeSample(elm) {
			return elm && elm.nodeName == 'PRE' && elm.className.indexOf('language-') !== -1;
		}
	
		function trimArg(predicateFn) {
			return function(arg1, arg2) {
				return predicateFn(arg2);
			};
		}
	
		return {
			isCodeSample: isCodeSample,
			trimArg: trimArg
		};
	});
	
	// Included from: js/tinymce/plugins/codesample/classes/Dialog.js
	
	/**
	 * Dialog.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * Contains all dialog logic.
	 *
	 * @class tinymce.codesample.Dialog
	 * @private
	 */
	define("tinymce/codesampleplugin/Dialog", [
		"tinymce/dom/DOMUtils",
		"tinymce/codesampleplugin/Utils",
		"tinymce/codesampleplugin/Prism"
	], function(DOMUtils, Utils, Prism) {
		var DOM = DOMUtils.DOM;
	
		var languages = [
			{text: 'HTML/XML', value: 'markup'},
			{text: 'JavaScript', value: 'javascript'},
			{text: 'CSS', value: 'css'},
			{text: 'PHP', value: 'php'},
			{text: 'Ruby', value: 'ruby'},
			{text: 'Python', value: 'python'},
			{text: 'Java', value: 'java'},
			{text: 'C', value: 'c'},
			{text: 'C#', value: 'csharp'},
			{text: 'C++', value: 'cpp'}
		];
	
		function insertCodeSample(editor, language, code) {
			editor.undoManager.transact(function() {
				var node = getSelectedCodeSample(editor);
	
				code = DOM.encode(code);
	
				if (node) {
					editor.dom.setAttrib(node, 'class', 'language-' + language);
					node.innerHTML = code;
					Prism.highlightElement(node);
					editor.selection.select(node);
				} else {
					editor.insertContent('<pre id="__new" class="language-' + language + '">' + code + '</pre>');
					editor.selection.select(editor.$('#__new').removeAttr('id')[0]);
				}
			});
		}
	
		function getSelectedCodeSample(editor) {
			var node = editor.selection.getNode();
	
			if (Utils.isCodeSample(node)) {
				return node;
			}
	
			return null;
		}
	
		function getCurrentCode(editor) {
			var node = getSelectedCodeSample(editor);
	
			if (node) {
				return node.textContent;
			}
	
			return '';
		}
	
		function getCurrentLanguage(editor) {
			var matches, node = getSelectedCodeSample(editor);
	
			if (node) {
				matches = node.className.match(/language-(\w+)/);
				return matches ? matches[1] : '';
			}
	
			return '';
		}
	
		return {
			open: function(editor) {
				editor.windowManager.open({
					title: "Insert/Edit code sample",
					minWidth: Math.min(DOM.getViewPort().w, 800),
					minHeight: Math.min(DOM.getViewPort().h, 650),
					layout: 'fit',
					body: [
						{
							type: 'listbox',
							name: 'language',
							label: 'Language',
							maxWidth: 200,
							value: getCurrentLanguage(editor),
							values: languages
						},
	
						{
							type: 'textbox',
							name: 'code',
							multiline: true,
							spellcheck: false,
							ariaLabel: 'Code view',
							flex: 1,
							style: 'direction: ltr; text-align: left',
							classes: 'monospace',
							value: getCurrentCode(editor),
							autofocus: true
						}
					],
					onSubmit: function(e) {
						insertCodeSample(editor, e.data.language, e.data.code);
					}
				});
			}
		};
	});
	
	// Included from: js/tinymce/plugins/codesample/classes/Plugin.js
	
	/**
	 * Plugin.js
	 *
	 * Released under LGPL License.
	 * Copyright (c) 1999-2015 Ephox Corp. All rights reserved
	 *
	 * License: http://www.tinymce.com/license
	 * Contributing: http://www.tinymce.com/contributing
	 */
	
	/**
	 * Main plugin logic.
	 *
	 * @class tinymce.codesample.Plugin
	 * @private
	 */
	define("tinymce/codesampleplugin/Plugin", [
		"tinymce/Env",
		"tinymce/PluginManager",
		"tinymce/codesampleplugin/Prism",
		"tinymce/codesampleplugin/Dialog",
		"tinymce/codesampleplugin/Utils"
	], function(Env, PluginManager, Prism, Dialog, Utils) {
		var addedInlineCss, trimArg = Utils.trimArg;
	
		PluginManager.add('codesample', function(editor, pluginUrl) {
			var $ = editor.$, addedCss;
	
			if (!Env.ceFalse) {
				return;
			}
	
			// Todo: use a proper css loader here
			function loadCss() {
				var linkElm;
	
				if (editor.inline && addedInlineCss) {
					return;
				}
	
				if (!editor.inline && addedCss) {
					return;
				}
	
				if (editor.inline) {
					addedInlineCss = true;
				} else {
					addedCss = true;
				}
	
				linkElm = editor.dom.create('link', {
					rel: 'stylesheet',
					href: pluginUrl + '/css/prism.css'
				});
	
				editor.getDoc().getElementsByTagName('head')[0].appendChild(linkElm);
			}
	
			editor.on('PreProcess', function(e) {
				$('pre[contenteditable=false]', e.node).
					filter(trimArg(Utils.isCodeSample)).
					each(function(idx, elm) {
						var $elm = $(elm), code = elm.textContent;
	
						$elm.attr('class', $.trim($elm.attr('class')));
						$elm.removeAttr('contentEditable');
	
						$elm.empty().append($('<code></code>').each(function() {
							// Needs to be textContent since innerText produces BR:s
							this.textContent = code;
						}));
					});
			});
	
			editor.on('SetContent', function() {
				var unprocessedCodeSamples = $('pre').filter(trimArg(Utils.isCodeSample)).filter(function(idx, elm) {
					return elm.contentEditable !== "false";
				});
	
				if (unprocessedCodeSamples.length) {
					editor.undoManager.transact(function() {
						unprocessedCodeSamples.each(function(idx, elm) {
							$(elm).find('br').each(function(idx, elm) {
								elm.parentNode.replaceChild(editor.getDoc().createTextNode('\n'), elm);
							});
	
							elm.contentEditable = false;
							elm.innerHTML = editor.dom.encode(elm.textContent);
							Prism.highlightElement(elm);
							elm.className = $.trim(elm.className);
						});
					});
				}
			});
	
			editor.addCommand('codesample', function() {
				Dialog.open(editor);
			});
	
			editor.addButton('codesample', {
				cmd: 'codesample',
				title: 'Insert/Edit code sample'
			});
	
			editor.on('init', loadCss);
		});
	});
	
	expose(["tinymce/codesampleplugin/Prism","tinymce/codesampleplugin/Utils","tinymce/codesampleplugin/Dialog","tinymce/codesampleplugin/Plugin"]);
	})(this);
	}.call(window));
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 44 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 45 */,
/* 46 */,
/* 47 */,
/* 48 */,
/* 49 */,
/* 50 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(jQuery) {/*!
	 * Bootstrap v3.3.6 (http://getbootstrap.com)
	 * Copyright 2011-2015 Twitter, Inc.
	 * Licensed under the MIT license
	 */
	if("undefined"==typeof jQuery)throw new Error("Bootstrap's JavaScript requires jQuery");+function(a){"use strict";var b=a.fn.jquery.split(" ")[0].split(".");if(b[0]<2&&b[1]<9||1==b[0]&&9==b[1]&&b[2]<1||b[0]>2)throw new Error("Bootstrap's JavaScript requires jQuery version 1.9.1 or higher, but lower than version 3")}(jQuery),+function(a){"use strict";function b(){var a=document.createElement("bootstrap"),b={WebkitTransition:"webkitTransitionEnd",MozTransition:"transitionend",OTransition:"oTransitionEnd otransitionend",transition:"transitionend"};for(var c in b)if(void 0!==a.style[c])return{end:b[c]};return!1}a.fn.emulateTransitionEnd=function(b){var c=!1,d=this;a(this).one("bsTransitionEnd",function(){c=!0});var e=function(){c||a(d).trigger(a.support.transition.end)};return setTimeout(e,b),this},a(function(){a.support.transition=b(),a.support.transition&&(a.event.special.bsTransitionEnd={bindType:a.support.transition.end,delegateType:a.support.transition.end,handle:function(b){return a(b.target).is(this)?b.handleObj.handler.apply(this,arguments):void 0}})})}(jQuery),+function(a){"use strict";function b(b){return this.each(function(){var c=a(this),e=c.data("bs.alert");e||c.data("bs.alert",e=new d(this)),"string"==typeof b&&e[b].call(c)})}var c='[data-dismiss="alert"]',d=function(b){a(b).on("click",c,this.close)};d.VERSION="3.3.6",d.TRANSITION_DURATION=150,d.prototype.close=function(b){function c(){g.detach().trigger("closed.bs.alert").remove()}var e=a(this),f=e.attr("data-target");f||(f=e.attr("href"),f=f&&f.replace(/.*(?=#[^\s]*$)/,""));var g=a(f);b&&b.preventDefault(),g.length||(g=e.closest(".alert")),g.trigger(b=a.Event("close.bs.alert")),b.isDefaultPrevented()||(g.removeClass("in"),a.support.transition&&g.hasClass("fade")?g.one("bsTransitionEnd",c).emulateTransitionEnd(d.TRANSITION_DURATION):c())};var e=a.fn.alert;a.fn.alert=b,a.fn.alert.Constructor=d,a.fn.alert.noConflict=function(){return a.fn.alert=e,this},a(document).on("click.bs.alert.data-api",c,d.prototype.close)}(jQuery),+function(a){"use strict";function b(b){return this.each(function(){var d=a(this),e=d.data("bs.button"),f="object"==typeof b&&b;e||d.data("bs.button",e=new c(this,f)),"toggle"==b?e.toggle():b&&e.setState(b)})}var c=function(b,d){this.$element=a(b),this.options=a.extend({},c.DEFAULTS,d),this.isLoading=!1};c.VERSION="3.3.6",c.DEFAULTS={loadingText:"loading..."},c.prototype.setState=function(b){var c="disabled",d=this.$element,e=d.is("input")?"val":"html",f=d.data();b+="Text",null==f.resetText&&d.data("resetText",d[e]()),setTimeout(a.proxy(function(){d[e](null==f[b]?this.options[b]:f[b]),"loadingText"==b?(this.isLoading=!0,d.addClass(c).attr(c,c)):this.isLoading&&(this.isLoading=!1,d.removeClass(c).removeAttr(c))},this),0)},c.prototype.toggle=function(){var a=!0,b=this.$element.closest('[data-toggle="buttons"]');if(b.length){var c=this.$element.find("input");"radio"==c.prop("type")?(c.prop("checked")&&(a=!1),b.find(".active").removeClass("active"),this.$element.addClass("active")):"checkbox"==c.prop("type")&&(c.prop("checked")!==this.$element.hasClass("active")&&(a=!1),this.$element.toggleClass("active")),c.prop("checked",this.$element.hasClass("active")),a&&c.trigger("change")}else this.$element.attr("aria-pressed",!this.$element.hasClass("active")),this.$element.toggleClass("active")};var d=a.fn.button;a.fn.button=b,a.fn.button.Constructor=c,a.fn.button.noConflict=function(){return a.fn.button=d,this},a(document).on("click.bs.button.data-api",'[data-toggle^="button"]',function(c){var d=a(c.target);d.hasClass("btn")||(d=d.closest(".btn")),b.call(d,"toggle"),a(c.target).is('input[type="radio"]')||a(c.target).is('input[type="checkbox"]')||c.preventDefault()}).on("focus.bs.button.data-api blur.bs.button.data-api",'[data-toggle^="button"]',function(b){a(b.target).closest(".btn").toggleClass("focus",/^focus(in)?$/.test(b.type))})}(jQuery),+function(a){"use strict";function b(b){return this.each(function(){var d=a(this),e=d.data("bs.carousel"),f=a.extend({},c.DEFAULTS,d.data(),"object"==typeof b&&b),g="string"==typeof b?b:f.slide;e||d.data("bs.carousel",e=new c(this,f)),"number"==typeof b?e.to(b):g?e[g]():f.interval&&e.pause().cycle()})}var c=function(b,c){this.$element=a(b),this.$indicators=this.$element.find(".carousel-indicators"),this.options=c,this.paused=null,this.sliding=null,this.interval=null,this.$active=null,this.$items=null,this.options.keyboard&&this.$element.on("keydown.bs.carousel",a.proxy(this.keydown,this)),"hover"==this.options.pause&&!("ontouchstart"in document.documentElement)&&this.$element.on("mouseenter.bs.carousel",a.proxy(this.pause,this)).on("mouseleave.bs.carousel",a.proxy(this.cycle,this))};c.VERSION="3.3.6",c.TRANSITION_DURATION=600,c.DEFAULTS={interval:5e3,pause:"hover",wrap:!0,keyboard:!0},c.prototype.keydown=function(a){if(!/input|textarea/i.test(a.target.tagName)){switch(a.which){case 37:this.prev();break;case 39:this.next();break;default:return}a.preventDefault()}},c.prototype.cycle=function(b){return b||(this.paused=!1),this.interval&&clearInterval(this.interval),this.options.interval&&!this.paused&&(this.interval=setInterval(a.proxy(this.next,this),this.options.interval)),this},c.prototype.getItemIndex=function(a){return this.$items=a.parent().children(".item"),this.$items.index(a||this.$active)},c.prototype.getItemForDirection=function(a,b){var c=this.getItemIndex(b),d="prev"==a&&0===c||"next"==a&&c==this.$items.length-1;if(d&&!this.options.wrap)return b;var e="prev"==a?-1:1,f=(c+e)%this.$items.length;return this.$items.eq(f)},c.prototype.to=function(a){var b=this,c=this.getItemIndex(this.$active=this.$element.find(".item.active"));return a>this.$items.length-1||0>a?void 0:this.sliding?this.$element.one("slid.bs.carousel",function(){b.to(a)}):c==a?this.pause().cycle():this.slide(a>c?"next":"prev",this.$items.eq(a))},c.prototype.pause=function(b){return b||(this.paused=!0),this.$element.find(".next, .prev").length&&a.support.transition&&(this.$element.trigger(a.support.transition.end),this.cycle(!0)),this.interval=clearInterval(this.interval),this},c.prototype.next=function(){return this.sliding?void 0:this.slide("next")},c.prototype.prev=function(){return this.sliding?void 0:this.slide("prev")},c.prototype.slide=function(b,d){var e=this.$element.find(".item.active"),f=d||this.getItemForDirection(b,e),g=this.interval,h="next"==b?"left":"right",i=this;if(f.hasClass("active"))return this.sliding=!1;var j=f[0],k=a.Event("slide.bs.carousel",{relatedTarget:j,direction:h});if(this.$element.trigger(k),!k.isDefaultPrevented()){if(this.sliding=!0,g&&this.pause(),this.$indicators.length){this.$indicators.find(".active").removeClass("active");var l=a(this.$indicators.children()[this.getItemIndex(f)]);l&&l.addClass("active")}var m=a.Event("slid.bs.carousel",{relatedTarget:j,direction:h});return a.support.transition&&this.$element.hasClass("slide")?(f.addClass(b),f[0].offsetWidth,e.addClass(h),f.addClass(h),e.one("bsTransitionEnd",function(){f.removeClass([b,h].join(" ")).addClass("active"),e.removeClass(["active",h].join(" ")),i.sliding=!1,setTimeout(function(){i.$element.trigger(m)},0)}).emulateTransitionEnd(c.TRANSITION_DURATION)):(e.removeClass("active"),f.addClass("active"),this.sliding=!1,this.$element.trigger(m)),g&&this.cycle(),this}};var d=a.fn.carousel;a.fn.carousel=b,a.fn.carousel.Constructor=c,a.fn.carousel.noConflict=function(){return a.fn.carousel=d,this};var e=function(c){var d,e=a(this),f=a(e.attr("data-target")||(d=e.attr("href"))&&d.replace(/.*(?=#[^\s]+$)/,""));if(f.hasClass("carousel")){var g=a.extend({},f.data(),e.data()),h=e.attr("data-slide-to");h&&(g.interval=!1),b.call(f,g),h&&f.data("bs.carousel").to(h),c.preventDefault()}};a(document).on("click.bs.carousel.data-api","[data-slide]",e).on("click.bs.carousel.data-api","[data-slide-to]",e),a(window).on("load",function(){a('[data-ride="carousel"]').each(function(){var c=a(this);b.call(c,c.data())})})}(jQuery),+function(a){"use strict";function b(b){var c,d=b.attr("data-target")||(c=b.attr("href"))&&c.replace(/.*(?=#[^\s]+$)/,"");return a(d)}function c(b){return this.each(function(){var c=a(this),e=c.data("bs.collapse"),f=a.extend({},d.DEFAULTS,c.data(),"object"==typeof b&&b);!e&&f.toggle&&/show|hide/.test(b)&&(f.toggle=!1),e||c.data("bs.collapse",e=new d(this,f)),"string"==typeof b&&e[b]()})}var d=function(b,c){this.$element=a(b),this.options=a.extend({},d.DEFAULTS,c),this.$trigger=a('[data-toggle="collapse"][href="#'+b.id+'"],[data-toggle="collapse"][data-target="#'+b.id+'"]'),this.transitioning=null,this.options.parent?this.$parent=this.getParent():this.addAriaAndCollapsedClass(this.$element,this.$trigger),this.options.toggle&&this.toggle()};d.VERSION="3.3.6",d.TRANSITION_DURATION=350,d.DEFAULTS={toggle:!0},d.prototype.dimension=function(){var a=this.$element.hasClass("width");return a?"width":"height"},d.prototype.show=function(){if(!this.transitioning&&!this.$element.hasClass("in")){var b,e=this.$parent&&this.$parent.children(".panel").children(".in, .collapsing");if(!(e&&e.length&&(b=e.data("bs.collapse"),b&&b.transitioning))){var f=a.Event("show.bs.collapse");if(this.$element.trigger(f),!f.isDefaultPrevented()){e&&e.length&&(c.call(e,"hide"),b||e.data("bs.collapse",null));var g=this.dimension();this.$element.removeClass("collapse").addClass("collapsing")[g](0).attr("aria-expanded",!0),this.$trigger.removeClass("collapsed").attr("aria-expanded",!0),this.transitioning=1;var h=function(){this.$element.removeClass("collapsing").addClass("collapse in")[g](""),this.transitioning=0,this.$element.trigger("shown.bs.collapse")};if(!a.support.transition)return h.call(this);var i=a.camelCase(["scroll",g].join("-"));this.$element.one("bsTransitionEnd",a.proxy(h,this)).emulateTransitionEnd(d.TRANSITION_DURATION)[g](this.$element[0][i])}}}},d.prototype.hide=function(){if(!this.transitioning&&this.$element.hasClass("in")){var b=a.Event("hide.bs.collapse");if(this.$element.trigger(b),!b.isDefaultPrevented()){var c=this.dimension();this.$element[c](this.$element[c]())[0].offsetHeight,this.$element.addClass("collapsing").removeClass("collapse in").attr("aria-expanded",!1),this.$trigger.addClass("collapsed").attr("aria-expanded",!1),this.transitioning=1;var e=function(){this.transitioning=0,this.$element.removeClass("collapsing").addClass("collapse").trigger("hidden.bs.collapse")};return a.support.transition?void this.$element[c](0).one("bsTransitionEnd",a.proxy(e,this)).emulateTransitionEnd(d.TRANSITION_DURATION):e.call(this)}}},d.prototype.toggle=function(){this[this.$element.hasClass("in")?"hide":"show"]()},d.prototype.getParent=function(){return a(this.options.parent).find('[data-toggle="collapse"][data-parent="'+this.options.parent+'"]').each(a.proxy(function(c,d){var e=a(d);this.addAriaAndCollapsedClass(b(e),e)},this)).end()},d.prototype.addAriaAndCollapsedClass=function(a,b){var c=a.hasClass("in");a.attr("aria-expanded",c),b.toggleClass("collapsed",!c).attr("aria-expanded",c)};var e=a.fn.collapse;a.fn.collapse=c,a.fn.collapse.Constructor=d,a.fn.collapse.noConflict=function(){return a.fn.collapse=e,this},a(document).on("click.bs.collapse.data-api",'[data-toggle="collapse"]',function(d){var e=a(this);e.attr("data-target")||d.preventDefault();var f=b(e),g=f.data("bs.collapse"),h=g?"toggle":e.data();c.call(f,h)})}(jQuery),+function(a){"use strict";function b(b){var c=b.attr("data-target");c||(c=b.attr("href"),c=c&&/#[A-Za-z]/.test(c)&&c.replace(/.*(?=#[^\s]*$)/,""));var d=c&&a(c);return d&&d.length?d:b.parent()}function c(c){c&&3===c.which||(a(e).remove(),a(f).each(function(){var d=a(this),e=b(d),f={relatedTarget:this};e.hasClass("open")&&(c&&"click"==c.type&&/input|textarea/i.test(c.target.tagName)&&a.contains(e[0],c.target)||(e.trigger(c=a.Event("hide.bs.dropdown",f)),c.isDefaultPrevented()||(d.attr("aria-expanded","false"),e.removeClass("open").trigger(a.Event("hidden.bs.dropdown",f)))))}))}function d(b){return this.each(function(){var c=a(this),d=c.data("bs.dropdown");d||c.data("bs.dropdown",d=new g(this)),"string"==typeof b&&d[b].call(c)})}var e=".dropdown-backdrop",f='[data-toggle="dropdown"]',g=function(b){a(b).on("click.bs.dropdown",this.toggle)};g.VERSION="3.3.6",g.prototype.toggle=function(d){var e=a(this);if(!e.is(".disabled, :disabled")){var f=b(e),g=f.hasClass("open");if(c(),!g){"ontouchstart"in document.documentElement&&!f.closest(".navbar-nav").length&&a(document.createElement("div")).addClass("dropdown-backdrop").insertAfter(a(this)).on("click",c);var h={relatedTarget:this};if(f.trigger(d=a.Event("show.bs.dropdown",h)),d.isDefaultPrevented())return;e.trigger("focus").attr("aria-expanded","true"),f.toggleClass("open").trigger(a.Event("shown.bs.dropdown",h))}return!1}},g.prototype.keydown=function(c){if(/(38|40|27|32)/.test(c.which)&&!/input|textarea/i.test(c.target.tagName)){var d=a(this);if(c.preventDefault(),c.stopPropagation(),!d.is(".disabled, :disabled")){var e=b(d),g=e.hasClass("open");if(!g&&27!=c.which||g&&27==c.which)return 27==c.which&&e.find(f).trigger("focus"),d.trigger("click");var h=" li:not(.disabled):visible a",i=e.find(".dropdown-menu"+h);if(i.length){var j=i.index(c.target);38==c.which&&j>0&&j--,40==c.which&&j<i.length-1&&j++,~j||(j=0),i.eq(j).trigger("focus")}}}};var h=a.fn.dropdown;a.fn.dropdown=d,a.fn.dropdown.Constructor=g,a.fn.dropdown.noConflict=function(){return a.fn.dropdown=h,this},a(document).on("click.bs.dropdown.data-api",c).on("click.bs.dropdown.data-api",".dropdown form",function(a){a.stopPropagation()}).on("click.bs.dropdown.data-api",f,g.prototype.toggle).on("keydown.bs.dropdown.data-api",f,g.prototype.keydown).on("keydown.bs.dropdown.data-api",".dropdown-menu",g.prototype.keydown)}(jQuery),+function(a){"use strict";function b(b,d){return this.each(function(){var e=a(this),f=e.data("bs.modal"),g=a.extend({},c.DEFAULTS,e.data(),"object"==typeof b&&b);f||e.data("bs.modal",f=new c(this,g)),"string"==typeof b?f[b](d):g.show&&f.show(d)})}var c=function(b,c){this.options=c,this.$body=a(document.body),this.$element=a(b),this.$dialog=this.$element.find(".modal-dialog"),this.$backdrop=null,this.isShown=null,this.originalBodyPad=null,this.scrollbarWidth=0,this.ignoreBackdropClick=!1,this.options.remote&&this.$element.find(".modal-content").load(this.options.remote,a.proxy(function(){this.$element.trigger("loaded.bs.modal")},this))};c.VERSION="3.3.6",c.TRANSITION_DURATION=300,c.BACKDROP_TRANSITION_DURATION=150,c.DEFAULTS={backdrop:!0,keyboard:!0,show:!0},c.prototype.toggle=function(a){return this.isShown?this.hide():this.show(a)},c.prototype.show=function(b){var d=this,e=a.Event("show.bs.modal",{relatedTarget:b});this.$element.trigger(e),this.isShown||e.isDefaultPrevented()||(this.isShown=!0,this.checkScrollbar(),this.setScrollbar(),this.$body.addClass("modal-open"),this.escape(),this.resize(),this.$element.on("click.dismiss.bs.modal",'[data-dismiss="modal"]',a.proxy(this.hide,this)),this.$dialog.on("mousedown.dismiss.bs.modal",function(){d.$element.one("mouseup.dismiss.bs.modal",function(b){a(b.target).is(d.$element)&&(d.ignoreBackdropClick=!0)})}),this.backdrop(function(){var e=a.support.transition&&d.$element.hasClass("fade");d.$element.parent().length||d.$element.appendTo(d.$body),d.$element.show().scrollTop(0),d.adjustDialog(),e&&d.$element[0].offsetWidth,d.$element.addClass("in"),d.enforceFocus();var f=a.Event("shown.bs.modal",{relatedTarget:b});e?d.$dialog.one("bsTransitionEnd",function(){d.$element.trigger("focus").trigger(f)}).emulateTransitionEnd(c.TRANSITION_DURATION):d.$element.trigger("focus").trigger(f)}))},c.prototype.hide=function(b){b&&b.preventDefault(),b=a.Event("hide.bs.modal"),this.$element.trigger(b),this.isShown&&!b.isDefaultPrevented()&&(this.isShown=!1,this.escape(),this.resize(),a(document).off("focusin.bs.modal"),this.$element.removeClass("in").off("click.dismiss.bs.modal").off("mouseup.dismiss.bs.modal"),this.$dialog.off("mousedown.dismiss.bs.modal"),a.support.transition&&this.$element.hasClass("fade")?this.$element.one("bsTransitionEnd",a.proxy(this.hideModal,this)).emulateTransitionEnd(c.TRANSITION_DURATION):this.hideModal())},c.prototype.enforceFocus=function(){a(document).off("focusin.bs.modal").on("focusin.bs.modal",a.proxy(function(a){this.$element[0]===a.target||this.$element.has(a.target).length||this.$element.trigger("focus")},this))},c.prototype.escape=function(){this.isShown&&this.options.keyboard?this.$element.on("keydown.dismiss.bs.modal",a.proxy(function(a){27==a.which&&this.hide()},this)):this.isShown||this.$element.off("keydown.dismiss.bs.modal")},c.prototype.resize=function(){this.isShown?a(window).on("resize.bs.modal",a.proxy(this.handleUpdate,this)):a(window).off("resize.bs.modal")},c.prototype.hideModal=function(){var a=this;this.$element.hide(),this.backdrop(function(){a.$body.removeClass("modal-open"),a.resetAdjustments(),a.resetScrollbar(),a.$element.trigger("hidden.bs.modal")})},c.prototype.removeBackdrop=function(){this.$backdrop&&this.$backdrop.remove(),this.$backdrop=null},c.prototype.backdrop=function(b){var d=this,e=this.$element.hasClass("fade")?"fade":"";if(this.isShown&&this.options.backdrop){var f=a.support.transition&&e;if(this.$backdrop=a(document.createElement("div")).addClass("modal-backdrop "+e).appendTo(this.$body),this.$element.on("click.dismiss.bs.modal",a.proxy(function(a){return this.ignoreBackdropClick?void(this.ignoreBackdropClick=!1):void(a.target===a.currentTarget&&("static"==this.options.backdrop?this.$element[0].focus():this.hide()))},this)),f&&this.$backdrop[0].offsetWidth,this.$backdrop.addClass("in"),!b)return;f?this.$backdrop.one("bsTransitionEnd",b).emulateTransitionEnd(c.BACKDROP_TRANSITION_DURATION):b()}else if(!this.isShown&&this.$backdrop){this.$backdrop.removeClass("in");var g=function(){d.removeBackdrop(),b&&b()};a.support.transition&&this.$element.hasClass("fade")?this.$backdrop.one("bsTransitionEnd",g).emulateTransitionEnd(c.BACKDROP_TRANSITION_DURATION):g()}else b&&b()},c.prototype.handleUpdate=function(){this.adjustDialog()},c.prototype.adjustDialog=function(){var a=this.$element[0].scrollHeight>document.documentElement.clientHeight;this.$element.css({paddingLeft:!this.bodyIsOverflowing&&a?this.scrollbarWidth:"",paddingRight:this.bodyIsOverflowing&&!a?this.scrollbarWidth:""})},c.prototype.resetAdjustments=function(){this.$element.css({paddingLeft:"",paddingRight:""})},c.prototype.checkScrollbar=function(){var a=window.innerWidth;if(!a){var b=document.documentElement.getBoundingClientRect();a=b.right-Math.abs(b.left)}this.bodyIsOverflowing=document.body.clientWidth<a,this.scrollbarWidth=this.measureScrollbar()},c.prototype.setScrollbar=function(){var a=parseInt(this.$body.css("padding-right")||0,10);this.originalBodyPad=document.body.style.paddingRight||"",this.bodyIsOverflowing&&this.$body.css("padding-right",a+this.scrollbarWidth)},c.prototype.resetScrollbar=function(){this.$body.css("padding-right",this.originalBodyPad)},c.prototype.measureScrollbar=function(){var a=document.createElement("div");a.className="modal-scrollbar-measure",this.$body.append(a);var b=a.offsetWidth-a.clientWidth;return this.$body[0].removeChild(a),b};var d=a.fn.modal;a.fn.modal=b,a.fn.modal.Constructor=c,a.fn.modal.noConflict=function(){return a.fn.modal=d,this},a(document).on("click.bs.modal.data-api",'[data-toggle="modal"]',function(c){var d=a(this),e=d.attr("href"),f=a(d.attr("data-target")||e&&e.replace(/.*(?=#[^\s]+$)/,"")),g=f.data("bs.modal")?"toggle":a.extend({remote:!/#/.test(e)&&e},f.data(),d.data());d.is("a")&&c.preventDefault(),f.one("show.bs.modal",function(a){a.isDefaultPrevented()||f.one("hidden.bs.modal",function(){d.is(":visible")&&d.trigger("focus")})}),b.call(f,g,this)})}(jQuery),+function(a){"use strict";function b(b){return this.each(function(){var d=a(this),e=d.data("bs.tooltip"),f="object"==typeof b&&b;(e||!/destroy|hide/.test(b))&&(e||d.data("bs.tooltip",e=new c(this,f)),"string"==typeof b&&e[b]())})}var c=function(a,b){this.type=null,this.options=null,this.enabled=null,this.timeout=null,this.hoverState=null,this.$element=null,this.inState=null,this.init("tooltip",a,b)};c.VERSION="3.3.6",c.TRANSITION_DURATION=150,c.DEFAULTS={animation:!0,placement:"top",selector:!1,template:'<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>',trigger:"hover focus",title:"",delay:0,html:!1,container:!1,viewport:{selector:"body",padding:0}},c.prototype.init=function(b,c,d){if(this.enabled=!0,this.type=b,this.$element=a(c),this.options=this.getOptions(d),this.$viewport=this.options.viewport&&a(a.isFunction(this.options.viewport)?this.options.viewport.call(this,this.$element):this.options.viewport.selector||this.options.viewport),this.inState={click:!1,hover:!1,focus:!1},this.$element[0]instanceof document.constructor&&!this.options.selector)throw new Error("`selector` option must be specified when initializing "+this.type+" on the window.document object!");for(var e=this.options.trigger.split(" "),f=e.length;f--;){var g=e[f];if("click"==g)this.$element.on("click."+this.type,this.options.selector,a.proxy(this.toggle,this));else if("manual"!=g){var h="hover"==g?"mouseenter":"focusin",i="hover"==g?"mouseleave":"focusout";this.$element.on(h+"."+this.type,this.options.selector,a.proxy(this.enter,this)),this.$element.on(i+"."+this.type,this.options.selector,a.proxy(this.leave,this))}}this.options.selector?this._options=a.extend({},this.options,{trigger:"manual",selector:""}):this.fixTitle()},c.prototype.getDefaults=function(){return c.DEFAULTS},c.prototype.getOptions=function(b){return b=a.extend({},this.getDefaults(),this.$element.data(),b),b.delay&&"number"==typeof b.delay&&(b.delay={show:b.delay,hide:b.delay}),b},c.prototype.getDelegateOptions=function(){var b={},c=this.getDefaults();return this._options&&a.each(this._options,function(a,d){c[a]!=d&&(b[a]=d)}),b},c.prototype.enter=function(b){var c=b instanceof this.constructor?b:a(b.currentTarget).data("bs."+this.type);return c||(c=new this.constructor(b.currentTarget,this.getDelegateOptions()),a(b.currentTarget).data("bs."+this.type,c)),b instanceof a.Event&&(c.inState["focusin"==b.type?"focus":"hover"]=!0),c.tip().hasClass("in")||"in"==c.hoverState?void(c.hoverState="in"):(clearTimeout(c.timeout),c.hoverState="in",c.options.delay&&c.options.delay.show?void(c.timeout=setTimeout(function(){"in"==c.hoverState&&c.show()},c.options.delay.show)):c.show())},c.prototype.isInStateTrue=function(){for(var a in this.inState)if(this.inState[a])return!0;return!1},c.prototype.leave=function(b){var c=b instanceof this.constructor?b:a(b.currentTarget).data("bs."+this.type);return c||(c=new this.constructor(b.currentTarget,this.getDelegateOptions()),a(b.currentTarget).data("bs."+this.type,c)),b instanceof a.Event&&(c.inState["focusout"==b.type?"focus":"hover"]=!1),c.isInStateTrue()?void 0:(clearTimeout(c.timeout),c.hoverState="out",c.options.delay&&c.options.delay.hide?void(c.timeout=setTimeout(function(){"out"==c.hoverState&&c.hide()},c.options.delay.hide)):c.hide())},c.prototype.show=function(){var b=a.Event("show.bs."+this.type);if(this.hasContent()&&this.enabled){this.$element.trigger(b);var d=a.contains(this.$element[0].ownerDocument.documentElement,this.$element[0]);if(b.isDefaultPrevented()||!d)return;var e=this,f=this.tip(),g=this.getUID(this.type);this.setContent(),f.attr("id",g),this.$element.attr("aria-describedby",g),this.options.animation&&f.addClass("fade");var h="function"==typeof this.options.placement?this.options.placement.call(this,f[0],this.$element[0]):this.options.placement,i=/\s?auto?\s?/i,j=i.test(h);j&&(h=h.replace(i,"")||"top"),f.detach().css({top:0,left:0,display:"block"}).addClass(h).data("bs."+this.type,this),this.options.container?f.appendTo(this.options.container):f.insertAfter(this.$element),this.$element.trigger("inserted.bs."+this.type);var k=this.getPosition(),l=f[0].offsetWidth,m=f[0].offsetHeight;if(j){var n=h,o=this.getPosition(this.$viewport);h="bottom"==h&&k.bottom+m>o.bottom?"top":"top"==h&&k.top-m<o.top?"bottom":"right"==h&&k.right+l>o.width?"left":"left"==h&&k.left-l<o.left?"right":h,f.removeClass(n).addClass(h)}var p=this.getCalculatedOffset(h,k,l,m);this.applyPlacement(p,h);var q=function(){var a=e.hoverState;e.$element.trigger("shown.bs."+e.type),e.hoverState=null,"out"==a&&e.leave(e)};a.support.transition&&this.$tip.hasClass("fade")?f.one("bsTransitionEnd",q).emulateTransitionEnd(c.TRANSITION_DURATION):q()}},c.prototype.applyPlacement=function(b,c){var d=this.tip(),e=d[0].offsetWidth,f=d[0].offsetHeight,g=parseInt(d.css("margin-top"),10),h=parseInt(d.css("margin-left"),10);isNaN(g)&&(g=0),isNaN(h)&&(h=0),b.top+=g,b.left+=h,a.offset.setOffset(d[0],a.extend({using:function(a){d.css({top:Math.round(a.top),left:Math.round(a.left)})}},b),0),d.addClass("in");var i=d[0].offsetWidth,j=d[0].offsetHeight;"top"==c&&j!=f&&(b.top=b.top+f-j);var k=this.getViewportAdjustedDelta(c,b,i,j);k.left?b.left+=k.left:b.top+=k.top;var l=/top|bottom/.test(c),m=l?2*k.left-e+i:2*k.top-f+j,n=l?"offsetWidth":"offsetHeight";d.offset(b),this.replaceArrow(m,d[0][n],l)},c.prototype.replaceArrow=function(a,b,c){this.arrow().css(c?"left":"top",50*(1-a/b)+"%").css(c?"top":"left","")},c.prototype.setContent=function(){var a=this.tip(),b=this.getTitle();a.find(".tooltip-inner")[this.options.html?"html":"text"](b),a.removeClass("fade in top bottom left right")},c.prototype.hide=function(b){function d(){"in"!=e.hoverState&&f.detach(),e.$element.removeAttr("aria-describedby").trigger("hidden.bs."+e.type),b&&b()}var e=this,f=a(this.$tip),g=a.Event("hide.bs."+this.type);return this.$element.trigger(g),g.isDefaultPrevented()?void 0:(f.removeClass("in"),a.support.transition&&f.hasClass("fade")?f.one("bsTransitionEnd",d).emulateTransitionEnd(c.TRANSITION_DURATION):d(),this.hoverState=null,this)},c.prototype.fixTitle=function(){var a=this.$element;(a.attr("title")||"string"!=typeof a.attr("data-original-title"))&&a.attr("data-original-title",a.attr("title")||"").attr("title","")},c.prototype.hasContent=function(){return this.getTitle()},c.prototype.getPosition=function(b){b=b||this.$element;var c=b[0],d="BODY"==c.tagName,e=c.getBoundingClientRect();null==e.width&&(e=a.extend({},e,{width:e.right-e.left,height:e.bottom-e.top}));var f=d?{top:0,left:0}:b.offset(),g={scroll:d?document.documentElement.scrollTop||document.body.scrollTop:b.scrollTop()},h=d?{width:a(window).width(),height:a(window).height()}:null;return a.extend({},e,g,h,f)},c.prototype.getCalculatedOffset=function(a,b,c,d){return"bottom"==a?{top:b.top+b.height,left:b.left+b.width/2-c/2}:"top"==a?{top:b.top-d,left:b.left+b.width/2-c/2}:"left"==a?{top:b.top+b.height/2-d/2,left:b.left-c}:{top:b.top+b.height/2-d/2,left:b.left+b.width}},c.prototype.getViewportAdjustedDelta=function(a,b,c,d){var e={top:0,left:0};if(!this.$viewport)return e;var f=this.options.viewport&&this.options.viewport.padding||0,g=this.getPosition(this.$viewport);if(/right|left/.test(a)){var h=b.top-f-g.scroll,i=b.top+f-g.scroll+d;h<g.top?e.top=g.top-h:i>g.top+g.height&&(e.top=g.top+g.height-i)}else{var j=b.left-f,k=b.left+f+c;j<g.left?e.left=g.left-j:k>g.right&&(e.left=g.left+g.width-k)}return e},c.prototype.getTitle=function(){var a,b=this.$element,c=this.options;return a=b.attr("data-original-title")||("function"==typeof c.title?c.title.call(b[0]):c.title)},c.prototype.getUID=function(a){do a+=~~(1e6*Math.random());while(document.getElementById(a));return a},c.prototype.tip=function(){if(!this.$tip&&(this.$tip=a(this.options.template),1!=this.$tip.length))throw new Error(this.type+" `template` option must consist of exactly 1 top-level element!");return this.$tip},c.prototype.arrow=function(){return this.$arrow=this.$arrow||this.tip().find(".tooltip-arrow")},c.prototype.enable=function(){this.enabled=!0},c.prototype.disable=function(){this.enabled=!1},c.prototype.toggleEnabled=function(){this.enabled=!this.enabled},c.prototype.toggle=function(b){var c=this;b&&(c=a(b.currentTarget).data("bs."+this.type),c||(c=new this.constructor(b.currentTarget,this.getDelegateOptions()),a(b.currentTarget).data("bs."+this.type,c))),b?(c.inState.click=!c.inState.click,c.isInStateTrue()?c.enter(c):c.leave(c)):c.tip().hasClass("in")?c.leave(c):c.enter(c)},c.prototype.destroy=function(){var a=this;clearTimeout(this.timeout),this.hide(function(){a.$element.off("."+a.type).removeData("bs."+a.type),a.$tip&&a.$tip.detach(),a.$tip=null,a.$arrow=null,a.$viewport=null})};var d=a.fn.tooltip;a.fn.tooltip=b,a.fn.tooltip.Constructor=c,a.fn.tooltip.noConflict=function(){return a.fn.tooltip=d,this}}(jQuery),+function(a){"use strict";function b(b){return this.each(function(){var d=a(this),e=d.data("bs.popover"),f="object"==typeof b&&b;(e||!/destroy|hide/.test(b))&&(e||d.data("bs.popover",e=new c(this,f)),"string"==typeof b&&e[b]())})}var c=function(a,b){this.init("popover",a,b)};if(!a.fn.tooltip)throw new Error("Popover requires tooltip.js");c.VERSION="3.3.6",c.DEFAULTS=a.extend({},a.fn.tooltip.Constructor.DEFAULTS,{placement:"right",trigger:"click",content:"",template:'<div class="popover" role="tooltip"><div class="arrow"></div><h3 class="popover-title"></h3><div class="popover-content"></div></div>'}),c.prototype=a.extend({},a.fn.tooltip.Constructor.prototype),c.prototype.constructor=c,c.prototype.getDefaults=function(){return c.DEFAULTS},c.prototype.setContent=function(){var a=this.tip(),b=this.getTitle(),c=this.getContent();a.find(".popover-title")[this.options.html?"html":"text"](b),a.find(".popover-content").children().detach().end()[this.options.html?"string"==typeof c?"html":"append":"text"](c),a.removeClass("fade top bottom left right in"),a.find(".popover-title").html()||a.find(".popover-title").hide()},c.prototype.hasContent=function(){return this.getTitle()||this.getContent()},c.prototype.getContent=function(){var a=this.$element,b=this.options;return a.attr("data-content")||("function"==typeof b.content?b.content.call(a[0]):b.content)},c.prototype.arrow=function(){return this.$arrow=this.$arrow||this.tip().find(".arrow")};var d=a.fn.popover;a.fn.popover=b,a.fn.popover.Constructor=c,a.fn.popover.noConflict=function(){return a.fn.popover=d,this}}(jQuery),+function(a){"use strict";function b(c,d){this.$body=a(document.body),this.$scrollElement=a(a(c).is(document.body)?window:c),this.options=a.extend({},b.DEFAULTS,d),this.selector=(this.options.target||"")+" .nav li > a",this.offsets=[],this.targets=[],this.activeTarget=null,this.scrollHeight=0,this.$scrollElement.on("scroll.bs.scrollspy",a.proxy(this.process,this)),this.refresh(),this.process()}function c(c){return this.each(function(){var d=a(this),e=d.data("bs.scrollspy"),f="object"==typeof c&&c;e||d.data("bs.scrollspy",e=new b(this,f)),"string"==typeof c&&e[c]()})}b.VERSION="3.3.6",b.DEFAULTS={offset:10},b.prototype.getScrollHeight=function(){return this.$scrollElement[0].scrollHeight||Math.max(this.$body[0].scrollHeight,document.documentElement.scrollHeight)},b.prototype.refresh=function(){var b=this,c="offset",d=0;this.offsets=[],this.targets=[],this.scrollHeight=this.getScrollHeight(),a.isWindow(this.$scrollElement[0])||(c="position",d=this.$scrollElement.scrollTop()),this.$body.find(this.selector).map(function(){var b=a(this),e=b.data("target")||b.attr("href"),f=/^#./.test(e)&&a(e);return f&&f.length&&f.is(":visible")&&[[f[c]().top+d,e]]||null}).sort(function(a,b){return a[0]-b[0]}).each(function(){b.offsets.push(this[0]),b.targets.push(this[1])})},b.prototype.process=function(){var a,b=this.$scrollElement.scrollTop()+this.options.offset,c=this.getScrollHeight(),d=this.options.offset+c-this.$scrollElement.height(),e=this.offsets,f=this.targets,g=this.activeTarget;if(this.scrollHeight!=c&&this.refresh(),b>=d)return g!=(a=f[f.length-1])&&this.activate(a);if(g&&b<e[0])return this.activeTarget=null,this.clear();for(a=e.length;a--;)g!=f[a]&&b>=e[a]&&(void 0===e[a+1]||b<e[a+1])&&this.activate(f[a])},b.prototype.activate=function(b){this.activeTarget=b,this.clear();var c=this.selector+'[data-target="'+b+'"],'+this.selector+'[href="'+b+'"]',d=a(c).parents("li").addClass("active");
	d.parent(".dropdown-menu").length&&(d=d.closest("li.dropdown").addClass("active")),d.trigger("activate.bs.scrollspy")},b.prototype.clear=function(){a(this.selector).parentsUntil(this.options.target,".active").removeClass("active")};var d=a.fn.scrollspy;a.fn.scrollspy=c,a.fn.scrollspy.Constructor=b,a.fn.scrollspy.noConflict=function(){return a.fn.scrollspy=d,this},a(window).on("load.bs.scrollspy.data-api",function(){a('[data-spy="scroll"]').each(function(){var b=a(this);c.call(b,b.data())})})}(jQuery),+function(a){"use strict";function b(b){return this.each(function(){var d=a(this),e=d.data("bs.tab");e||d.data("bs.tab",e=new c(this)),"string"==typeof b&&e[b]()})}var c=function(b){this.element=a(b)};c.VERSION="3.3.6",c.TRANSITION_DURATION=150,c.prototype.show=function(){var b=this.element,c=b.closest("ul:not(.dropdown-menu)"),d=b.data("target");if(d||(d=b.attr("href"),d=d&&d.replace(/.*(?=#[^\s]*$)/,"")),!b.parent("li").hasClass("active")){var e=c.find(".active:last a"),f=a.Event("hide.bs.tab",{relatedTarget:b[0]}),g=a.Event("show.bs.tab",{relatedTarget:e[0]});if(e.trigger(f),b.trigger(g),!g.isDefaultPrevented()&&!f.isDefaultPrevented()){var h=a(d);this.activate(b.closest("li"),c),this.activate(h,h.parent(),function(){e.trigger({type:"hidden.bs.tab",relatedTarget:b[0]}),b.trigger({type:"shown.bs.tab",relatedTarget:e[0]})})}}},c.prototype.activate=function(b,d,e){function f(){g.removeClass("active").find("> .dropdown-menu > .active").removeClass("active").end().find('[data-toggle="tab"]').attr("aria-expanded",!1),b.addClass("active").find('[data-toggle="tab"]').attr("aria-expanded",!0),h?(b[0].offsetWidth,b.addClass("in")):b.removeClass("fade"),b.parent(".dropdown-menu").length&&b.closest("li.dropdown").addClass("active").end().find('[data-toggle="tab"]').attr("aria-expanded",!0),e&&e()}var g=d.find("> .active"),h=e&&a.support.transition&&(g.length&&g.hasClass("fade")||!!d.find("> .fade").length);g.length&&h?g.one("bsTransitionEnd",f).emulateTransitionEnd(c.TRANSITION_DURATION):f(),g.removeClass("in")};var d=a.fn.tab;a.fn.tab=b,a.fn.tab.Constructor=c,a.fn.tab.noConflict=function(){return a.fn.tab=d,this};var e=function(c){c.preventDefault(),b.call(a(this),"show")};a(document).on("click.bs.tab.data-api",'[data-toggle="tab"]',e).on("click.bs.tab.data-api",'[data-toggle="pill"]',e)}(jQuery),+function(a){"use strict";function b(b){return this.each(function(){var d=a(this),e=d.data("bs.affix"),f="object"==typeof b&&b;e||d.data("bs.affix",e=new c(this,f)),"string"==typeof b&&e[b]()})}var c=function(b,d){this.options=a.extend({},c.DEFAULTS,d),this.$target=a(this.options.target).on("scroll.bs.affix.data-api",a.proxy(this.checkPosition,this)).on("click.bs.affix.data-api",a.proxy(this.checkPositionWithEventLoop,this)),this.$element=a(b),this.affixed=null,this.unpin=null,this.pinnedOffset=null,this.checkPosition()};c.VERSION="3.3.6",c.RESET="affix affix-top affix-bottom",c.DEFAULTS={offset:0,target:window},c.prototype.getState=function(a,b,c,d){var e=this.$target.scrollTop(),f=this.$element.offset(),g=this.$target.height();if(null!=c&&"top"==this.affixed)return c>e?"top":!1;if("bottom"==this.affixed)return null!=c?e+this.unpin<=f.top?!1:"bottom":a-d>=e+g?!1:"bottom";var h=null==this.affixed,i=h?e:f.top,j=h?g:b;return null!=c&&c>=e?"top":null!=d&&i+j>=a-d?"bottom":!1},c.prototype.getPinnedOffset=function(){if(this.pinnedOffset)return this.pinnedOffset;this.$element.removeClass(c.RESET).addClass("affix");var a=this.$target.scrollTop(),b=this.$element.offset();return this.pinnedOffset=b.top-a},c.prototype.checkPositionWithEventLoop=function(){setTimeout(a.proxy(this.checkPosition,this),1)},c.prototype.checkPosition=function(){if(this.$element.is(":visible")){var b=this.$element.height(),d=this.options.offset,e=d.top,f=d.bottom,g=Math.max(a(document).height(),a(document.body).height());"object"!=typeof d&&(f=e=d),"function"==typeof e&&(e=d.top(this.$element)),"function"==typeof f&&(f=d.bottom(this.$element));var h=this.getState(g,b,e,f);if(this.affixed!=h){null!=this.unpin&&this.$element.css("top","");var i="affix"+(h?"-"+h:""),j=a.Event(i+".bs.affix");if(this.$element.trigger(j),j.isDefaultPrevented())return;this.affixed=h,this.unpin="bottom"==h?this.getPinnedOffset():null,this.$element.removeClass(c.RESET).addClass(i).trigger(i.replace("affix","affixed")+".bs.affix")}"bottom"==h&&this.$element.offset({top:g-b-f})}};var d=a.fn.affix;a.fn.affix=b,a.fn.affix.Constructor=c,a.fn.affix.noConflict=function(){return a.fn.affix=d,this},a(window).on("load",function(){a('[data-spy="affix"]').each(function(){var c=a(this),d=c.data();d.offset=d.offset||{},null!=d.offsetBottom&&(d.offset.bottom=d.offsetBottom),null!=d.offsetTop&&(d.offset.top=d.offsetTop),b.call(c,d)})})}(jQuery);
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 51 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 52 */,
/* 53 */,
/* 54 */,
/* 55 */,
/* 56 */,
/* 57 */,
/* 58 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 59 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function($) {__webpack_require__(60);
	__webpack_require__(61);
	
	// ------------------------------------------------------------------------------------
	// Application logic
	// ------------------------------------------------------------------------------------
	
	// Close form alert
	
	$(document).ready(function() {
	    $('#form-close').on('click', function(e) {
	        e.preventDefault();
	        var redirectUrl = e.target.dataset.redirect;
	
	        if(confirm('Do you really want to close this form?')) {
	            window.location.href = redirectUrl;
	        }
	    })
	});
	
	// Handle here AJAX requests to the server
	
	$.ajaxSetup({
	    headers: {
	        'X-CSRF-TOKEN': $('meta[name="csrf-token"]').attr('content')
	    }
	});
	
	$(document).on('click', 'a.jquery-postback', function(e) {
	    e.preventDefault(); // does not go through with the link.
	
	    var $this = $(this);
	    var redirect = $this.attr('data-redirect');
	
	    $.post({
	        type: $this.data('method'),
	        url: $this.attr('href'),
	        redirect: redirect
	    }).done(function (data) {
	        if (data.result === true) {
	            window.location.href = redirect;
	        } else {
	            alert('The document can not be deleted.');
	        }
	    });
	});
	
	// ------------------------------------------------------------------------------------
	// Chosen
	// ------------------------------------------------------------------------------------
	
	$("#categories").chosen({width:"95%"});
	
	// ------------------------------------------------------------------------------------
	// Datatables
	// ------------------------------------------------------------------------------------
	
	// Configuration for datatables can be found on the server in config/app.php file ..
	
	var table = $('#dt-articles').DataTable(
	    {
	        // Enable the select plugin
	        select: true,
	
	        dom: 'Blfrtip',
	
	        buttons: [
	            {
	                text: 'Trash all',
	                action: function ( e, dt, node, config ) {
	                    dt.rows();
	                }
	            }
	        ],
	
	        columnDefs: [ {
	            orderable: false,
	            className: 'select-checkbox',
	            targets:   0
	        } ],
	
	        select: {
	            style:    'os',
	            selector: 'td:first-child'
	        },
	
	        // Add the select selectboxes at the bottom of the Datatables table ..
	        "initComplete": function () {
	            this.api().columns(datatables_filterColumnsIndexes).every( function () {
	                var column = this;
	                var select = $('<select><option value=""></option></select>')
	                    .appendTo( $(column.footer()).empty())
	                    .on( 'change', function () {
	                        var val = $.fn.dataTable.util.escapeRegex(
	                            $(this).val()
	                        );
	
	                        column
	                            .search( val ? '^'+val+'$' : '', true, false )
	                            .draw();
	                    } );
	
	                column.data().unique().sort().each( function ( d, j ) {
	                    select.append( '<option value="'+d+'">'+d+'</option>' )
	                } );
	            } );
	        },
	
	        // TODO Text to icon conversion not working ..
	
	        "fnRowCallback": function( nRow, aData, iDisplayIndex, iDisplayIndexFull ) {
	            if (aData[datatables_articleStatusColumnIndex] === '1') {
	                $('td:eq('+datatables_articleStatusColumnIndex+')', nRow).html( '<i class="fa fa-check-circle-o text-success"></i>' );
	            } else {
	                $('td:eq('+datatables_articleStatusColumnIndex+')', nRow).html( '<i class="fa fa-close text-danger"></i>' );
	            }
	        },
	
	        order: [[datatables_articleSortColumnIndex,'desc']]
	    }
	);
	$('#dt-articles').show();
	
	// Categories datatables
	
	$('#dt-categories').DataTable({
	    order: [[datatables_categorySortColumnIndex,'desc']]
	});
	$('#dt-categories').show();
	
	// Trash datatables
	
	$('#dt-trash').DataTable();
	$('#dt-trash').show();
	
	// Init select all
	
	$('th.select-checkbox').on('click', function(){
	    var table = $('#dt-articles').DataTable();
	    // var cells = table.cells().select();
	    table.cell( ':eq(0)', null, {page: 'current'} ).select();
	    // $( cells ).find(':checkbox').prop('checked', $(this).is(':checked'));
	});
	
	// ------------------------------------------------------------------------------------
	// Datepickers
	// ------------------------------------------------------------------------------------
	
	// Datepicker
	$('.datepicker').datepicker();
	
	// ------------------------------------------------------------------------------------
	// Version number
	// ------------------------------------------------------------------------------------
	
	var package_json = __webpack_require__(62);
	$('#version').html(package_json.version);
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 60 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(__webpack_provided_window_dot_jQuery) {/* =========================================================
	 * bootstrap-datepicker.js
	 * Repo: https://github.com/eternicode/bootstrap-datepicker/
	 * Demo: http://eternicode.github.io/bootstrap-datepicker/
	 * Docs: http://bootstrap-datepicker.readthedocs.org/
	 * Forked from http://www.eyecon.ro/bootstrap-datepicker
	 * =========================================================
	 * Started by Stefan Petre; improvements by Andrew Rowls + contributors
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 * http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 * ========================================================= */
	
	(function($, undefined){
	
		var $window = $(window);
	
		function UTCDate(){
			return new Date(Date.UTC.apply(Date, arguments));
		}
		function UTCToday(){
			var today = new Date();
			return UTCDate(today.getFullYear(), today.getMonth(), today.getDate());
		}
		function alias(method){
			return function(){
				return this[method].apply(this, arguments);
			};
		}
	
		var DateArray = (function(){
			var extras = {
				get: function(i){
					return this.slice(i)[0];
				},
				contains: function(d){
					// Array.indexOf is not cross-browser;
					// $.inArray doesn't work with Dates
					var val = d && d.valueOf();
					for (var i=0, l=this.length; i < l; i++)
						if (this[i].valueOf() === val)
							return i;
					return -1;
				},
				remove: function(i){
					this.splice(i,1);
				},
				replace: function(new_array){
					if (!new_array)
						return;
					if (!$.isArray(new_array))
						new_array = [new_array];
					this.clear();
					this.push.apply(this, new_array);
				},
				clear: function(){
					this.splice(0);
				},
				copy: function(){
					var a = new DateArray();
					a.replace(this);
					return a;
				}
			};
	
			return function(){
				var a = [];
				a.push.apply(a, arguments);
				$.extend(a, extras);
				return a;
			};
		})();
	
	
		// Picker object
	
		var Datepicker = function(element, options){
			this.dates = new DateArray();
			this.viewDate = UTCToday();
			this.focusDate = null;
	
			this._process_options(options);
	
			this.element = $(element);
			this.isInline = false;
			this.isInput = this.element.is('input');
			this.component = this.element.is('.date') ? this.element.find('.add-on, .input-group-addon, .btn') : false;
			this.hasInput = this.component && this.element.find('input').length;
			if (this.component && this.component.length === 0)
				this.component = false;
	
			this.picker = $(DPGlobal.template);
			this._buildEvents();
			this._attachEvents();
	
			if (this.isInline){
				this.picker.addClass('datepicker-inline').appendTo(this.element);
			}
			else {
				this.picker.addClass('datepicker-dropdown dropdown-menu');
			}
	
			if (this.o.rtl){
				this.picker.addClass('datepicker-rtl');
			}
	
			this.viewMode = this.o.startView;
	
			if (this.o.calendarWeeks)
				this.picker.find('tfoot th.today')
							.attr('colspan', function(i, val){
								return parseInt(val) + 1;
							});
	
			this._allow_update = false;
	
			this.setStartDate(this._o.startDate);
			this.setEndDate(this._o.endDate);
			this.setDaysOfWeekDisabled(this.o.daysOfWeekDisabled);
	
			this.fillDow();
			this.fillMonths();
	
			this._allow_update = true;
	
			this.update();
			this.showMode();
	
			if (this.isInline){
				this.show();
			}
		};
	
		Datepicker.prototype = {
			constructor: Datepicker,
	
			_process_options: function(opts){
				// Store raw options for reference
				this._o = $.extend({}, this._o, opts);
				// Processed options
				var o = this.o = $.extend({}, this._o);
	
				// Check if "de-DE" style date is available, if not language should
				// fallback to 2 letter code eg "de"
				var lang = o.language;
				if (!dates[lang]){
					lang = lang.split('-')[0];
					if (!dates[lang])
						lang = defaults.language;
				}
				o.language = lang;
	
				switch (o.startView){
					case 2:
					case 'decade':
						o.startView = 2;
						break;
					case 1:
					case 'year':
						o.startView = 1;
						break;
					default:
						o.startView = 0;
				}
	
				switch (o.minViewMode){
					case 1:
					case 'months':
						o.minViewMode = 1;
						break;
					case 2:
					case 'years':
						o.minViewMode = 2;
						break;
					default:
						o.minViewMode = 0;
				}
	
				o.startView = Math.max(o.startView, o.minViewMode);
	
				// true, false, or Number > 0
				if (o.multidate !== true){
					o.multidate = Number(o.multidate) || false;
					if (o.multidate !== false)
						o.multidate = Math.max(0, o.multidate);
					else
						o.multidate = 1;
				}
				o.multidateSeparator = String(o.multidateSeparator);
	
				o.weekStart %= 7;
				o.weekEnd = ((o.weekStart + 6) % 7);
	
				var format = DPGlobal.parseFormat(o.format);
				if (o.startDate !== -Infinity){
					if (!!o.startDate){
						if (o.startDate instanceof Date)
							o.startDate = this._local_to_utc(this._zero_time(o.startDate));
						else
							o.startDate = DPGlobal.parseDate(o.startDate, format, o.language);
					}
					else {
						o.startDate = -Infinity;
					}
				}
				if (o.endDate !== Infinity){
					if (!!o.endDate){
						if (o.endDate instanceof Date)
							o.endDate = this._local_to_utc(this._zero_time(o.endDate));
						else
							o.endDate = DPGlobal.parseDate(o.endDate, format, o.language);
					}
					else {
						o.endDate = Infinity;
					}
				}
	
				o.daysOfWeekDisabled = o.daysOfWeekDisabled||[];
				if (!$.isArray(o.daysOfWeekDisabled))
					o.daysOfWeekDisabled = o.daysOfWeekDisabled.split(/[,\s]*/);
				o.daysOfWeekDisabled = $.map(o.daysOfWeekDisabled, function(d){
					return parseInt(d, 10);
				});
	
				var plc = String(o.orientation).toLowerCase().split(/\s+/g),
					_plc = o.orientation.toLowerCase();
				plc = $.grep(plc, function(word){
					return (/^auto|left|right|top|bottom$/).test(word);
				});
				o.orientation = {x: 'auto', y: 'auto'};
				if (!_plc || _plc === 'auto')
					; // no action
				else if (plc.length === 1){
					switch (plc[0]){
						case 'top':
						case 'bottom':
							o.orientation.y = plc[0];
							break;
						case 'left':
						case 'right':
							o.orientation.x = plc[0];
							break;
					}
				}
				else {
					_plc = $.grep(plc, function(word){
						return (/^left|right$/).test(word);
					});
					o.orientation.x = _plc[0] || 'auto';
	
					_plc = $.grep(plc, function(word){
						return (/^top|bottom$/).test(word);
					});
					o.orientation.y = _plc[0] || 'auto';
				}
			},
			_events: [],
			_secondaryEvents: [],
			_applyEvents: function(evs){
				for (var i=0, el, ch, ev; i < evs.length; i++){
					el = evs[i][0];
					if (evs[i].length === 2){
						ch = undefined;
						ev = evs[i][1];
					}
					else if (evs[i].length === 3){
						ch = evs[i][1];
						ev = evs[i][2];
					}
					el.on(ev, ch);
				}
			},
			_unapplyEvents: function(evs){
				for (var i=0, el, ev, ch; i < evs.length; i++){
					el = evs[i][0];
					if (evs[i].length === 2){
						ch = undefined;
						ev = evs[i][1];
					}
					else if (evs[i].length === 3){
						ch = evs[i][1];
						ev = evs[i][2];
					}
					el.off(ev, ch);
				}
			},
			_buildEvents: function(){
				if (this.isInput){ // single input
					this._events = [
						[this.element, {
							focus: $.proxy(this.show, this),
							keyup: $.proxy(function(e){
								if ($.inArray(e.keyCode, [27,37,39,38,40,32,13,9]) === -1)
									this.update();
							}, this),
							keydown: $.proxy(this.keydown, this)
						}]
					];
				}
				else if (this.component && this.hasInput){ // component: input + button
					this._events = [
						// For components that are not readonly, allow keyboard nav
						[this.element.find('input'), {
							focus: $.proxy(this.show, this),
							keyup: $.proxy(function(e){
								if ($.inArray(e.keyCode, [27,37,39,38,40,32,13,9]) === -1)
									this.update();
							}, this),
							keydown: $.proxy(this.keydown, this)
						}],
						[this.component, {
							click: $.proxy(this.show, this)
						}]
					];
				}
				else if (this.element.is('div')){  // inline datepicker
					this.isInline = true;
				}
				else {
					this._events = [
						[this.element, {
							click: $.proxy(this.show, this)
						}]
					];
				}
				this._events.push(
					// Component: listen for blur on element descendants
					[this.element, '*', {
						blur: $.proxy(function(e){
							this._focused_from = e.target;
						}, this)
					}],
					// Input: listen for blur on element
					[this.element, {
						blur: $.proxy(function(e){
							this._focused_from = e.target;
						}, this)
					}]
				);
	
				this._secondaryEvents = [
					[this.picker, {
						click: $.proxy(this.click, this)
					}],
					[$(window), {
						resize: $.proxy(this.place, this)
					}],
					[$(document), {
						'mousedown touchstart': $.proxy(function(e){
							// Clicked outside the datepicker, hide it
							if (!(
								this.element.is(e.target) ||
								this.element.find(e.target).length ||
								this.picker.is(e.target) ||
								this.picker.find(e.target).length
							)){
								this.hide();
							}
						}, this)
					}]
				];
			},
			_attachEvents: function(){
				this._detachEvents();
				this._applyEvents(this._events);
			},
			_detachEvents: function(){
				this._unapplyEvents(this._events);
			},
			_attachSecondaryEvents: function(){
				this._detachSecondaryEvents();
				this._applyEvents(this._secondaryEvents);
			},
			_detachSecondaryEvents: function(){
				this._unapplyEvents(this._secondaryEvents);
			},
			_trigger: function(event, altdate){
				var date = altdate || this.dates.get(-1),
					local_date = this._utc_to_local(date);
	
				this.element.trigger({
					type: event,
					date: local_date,
					dates: $.map(this.dates, this._utc_to_local),
					format: $.proxy(function(ix, format){
						if (arguments.length === 0){
							ix = this.dates.length - 1;
							format = this.o.format;
						}
						else if (typeof ix === 'string'){
							format = ix;
							ix = this.dates.length - 1;
						}
						format = format || this.o.format;
						var date = this.dates.get(ix);
						return DPGlobal.formatDate(date, format, this.o.language);
					}, this)
				});
			},
	
			show: function(){
				if (!this.isInline)
					this.picker.appendTo('body');
				this.picker.show();
				this.place();
				this._attachSecondaryEvents();
				this._trigger('show');
			},
	
			hide: function(){
				if (this.isInline)
					return;
				if (!this.picker.is(':visible'))
					return;
				this.focusDate = null;
				this.picker.hide().detach();
				this._detachSecondaryEvents();
				this.viewMode = this.o.startView;
				this.showMode();
	
				if (
					this.o.forceParse &&
					(
						this.isInput && this.element.val() ||
						this.hasInput && this.element.find('input').val()
					)
				)
					this.setValue();
				this._trigger('hide');
			},
	
			remove: function(){
				this.hide();
				this._detachEvents();
				this._detachSecondaryEvents();
				this.picker.remove();
				delete this.element.data().datepicker;
				if (!this.isInput){
					delete this.element.data().date;
				}
			},
	
			_utc_to_local: function(utc){
				return utc && new Date(utc.getTime() + (utc.getTimezoneOffset()*60000));
			},
			_local_to_utc: function(local){
				return local && new Date(local.getTime() - (local.getTimezoneOffset()*60000));
			},
			_zero_time: function(local){
				return local && new Date(local.getFullYear(), local.getMonth(), local.getDate());
			},
			_zero_utc_time: function(utc){
				return utc && new Date(Date.UTC(utc.getUTCFullYear(), utc.getUTCMonth(), utc.getUTCDate()));
			},
	
			getDates: function(){
				return $.map(this.dates, this._utc_to_local);
			},
	
			getUTCDates: function(){
				return $.map(this.dates, function(d){
					return new Date(d);
				});
			},
	
			getDate: function(){
				return this._utc_to_local(this.getUTCDate());
			},
	
			getUTCDate: function(){
				return new Date(this.dates.get(-1));
			},
	
			setDates: function(){
				var args = $.isArray(arguments[0]) ? arguments[0] : arguments;
				this.update.apply(this, args);
				this._trigger('changeDate');
				this.setValue();
			},
	
			setUTCDates: function(){
				var args = $.isArray(arguments[0]) ? arguments[0] : arguments;
				this.update.apply(this, $.map(args, this._utc_to_local));
				this._trigger('changeDate');
				this.setValue();
			},
	
			setDate: alias('setDates'),
			setUTCDate: alias('setUTCDates'),
	
			setValue: function(){
				var formatted = this.getFormattedDate();
				if (!this.isInput){
					if (this.component){
						this.element.find('input').val(formatted).change();
					}
				}
				else {
					this.element.val(formatted).change();
				}
			},
	
			getFormattedDate: function(format){
				if (format === undefined)
					format = this.o.format;
	
				var lang = this.o.language;
				return $.map(this.dates, function(d){
					return DPGlobal.formatDate(d, format, lang);
				}).join(this.o.multidateSeparator);
			},
	
			setStartDate: function(startDate){
				this._process_options({startDate: startDate});
				this.update();
				this.updateNavArrows();
			},
	
			setEndDate: function(endDate){
				this._process_options({endDate: endDate});
				this.update();
				this.updateNavArrows();
			},
	
			setDaysOfWeekDisabled: function(daysOfWeekDisabled){
				this._process_options({daysOfWeekDisabled: daysOfWeekDisabled});
				this.update();
				this.updateNavArrows();
			},
	
			place: function(){
				if (this.isInline)
					return;
				var calendarWidth = this.picker.outerWidth(),
					calendarHeight = this.picker.outerHeight(),
					visualPadding = 10,
					windowWidth = $window.width(),
					windowHeight = $window.height(),
					scrollTop = $window.scrollTop();
	
				var zIndex = parseInt(this.element.parents().filter(function(){
						return $(this).css('z-index') !== 'auto';
					}).first().css('z-index'))+10;
				var offset = this.component ? this.component.parent().offset() : this.element.offset();
				var height = this.component ? this.component.outerHeight(true) : this.element.outerHeight(false);
				var width = this.component ? this.component.outerWidth(true) : this.element.outerWidth(false);
				var left = offset.left,
					top = offset.top;
	
				this.picker.removeClass(
					'datepicker-orient-top datepicker-orient-bottom '+
					'datepicker-orient-right datepicker-orient-left'
				);
	
				if (this.o.orientation.x !== 'auto'){
					this.picker.addClass('datepicker-orient-' + this.o.orientation.x);
					if (this.o.orientation.x === 'right')
						left -= calendarWidth - width;
				}
				// auto x orientation is best-placement: if it crosses a window
				// edge, fudge it sideways
				else {
					// Default to left
					this.picker.addClass('datepicker-orient-left');
					if (offset.left < 0)
						left -= offset.left - visualPadding;
					else if (offset.left + calendarWidth > windowWidth)
						left = windowWidth - calendarWidth - visualPadding;
				}
	
				// auto y orientation is best-situation: top or bottom, no fudging,
				// decision based on which shows more of the calendar
				var yorient = this.o.orientation.y,
					top_overflow, bottom_overflow;
				if (yorient === 'auto'){
					top_overflow = -scrollTop + offset.top - calendarHeight;
					bottom_overflow = scrollTop + windowHeight - (offset.top + height + calendarHeight);
					if (Math.max(top_overflow, bottom_overflow) === bottom_overflow)
						yorient = 'top';
					else
						yorient = 'bottom';
				}
				this.picker.addClass('datepicker-orient-' + yorient);
				if (yorient === 'top')
					top += height;
				else
					top -= calendarHeight + parseInt(this.picker.css('padding-top'));
	
				this.picker.css({
					top: top,
					left: left,
					zIndex: zIndex
				});
			},
	
			_allow_update: true,
			update: function(){
				if (!this._allow_update)
					return;
	
				var oldDates = this.dates.copy(),
					dates = [],
					fromArgs = false;
				if (arguments.length){
					$.each(arguments, $.proxy(function(i, date){
						if (date instanceof Date)
							date = this._local_to_utc(date);
						dates.push(date);
					}, this));
					fromArgs = true;
				}
				else {
					dates = this.isInput
							? this.element.val()
							: this.element.data('date') || this.element.find('input').val();
					if (dates && this.o.multidate)
						dates = dates.split(this.o.multidateSeparator);
					else
						dates = [dates];
					delete this.element.data().date;
				}
	
				dates = $.map(dates, $.proxy(function(date){
					return DPGlobal.parseDate(date, this.o.format, this.o.language);
				}, this));
				dates = $.grep(dates, $.proxy(function(date){
					return (
						date < this.o.startDate ||
						date > this.o.endDate ||
						!date
					);
				}, this), true);
				this.dates.replace(dates);
	
				if (this.dates.length)
					this.viewDate = new Date(this.dates.get(-1));
				else if (this.viewDate < this.o.startDate)
					this.viewDate = new Date(this.o.startDate);
				else if (this.viewDate > this.o.endDate)
					this.viewDate = new Date(this.o.endDate);
	
				if (fromArgs){
					// setting date by clicking
					this.setValue();
				}
				else if (dates.length){
					// setting date by typing
					if (String(oldDates) !== String(this.dates))
						this._trigger('changeDate');
				}
				if (!this.dates.length && oldDates.length)
					this._trigger('clearDate');
	
				this.fill();
			},
	
			fillDow: function(){
				var dowCnt = this.o.weekStart,
					html = '<tr>';
				if (this.o.calendarWeeks){
					var cell = '<th class="cw">&nbsp;</th>';
					html += cell;
					this.picker.find('.datepicker-days thead tr:first-child').prepend(cell);
				}
				while (dowCnt < this.o.weekStart + 7){
					html += '<th class="dow">'+dates[this.o.language].daysMin[(dowCnt++)%7]+'</th>';
				}
				html += '</tr>';
				this.picker.find('.datepicker-days thead').append(html);
			},
	
			fillMonths: function(){
				var html = '',
				i = 0;
				while (i < 12){
					html += '<span class="month">'+dates[this.o.language].monthsShort[i++]+'</span>';
				}
				this.picker.find('.datepicker-months td').html(html);
			},
	
			setRange: function(range){
				if (!range || !range.length)
					delete this.range;
				else
					this.range = $.map(range, function(d){
						return d.valueOf();
					});
				this.fill();
			},
	
			getClassNames: function(date){
				var cls = [],
					year = this.viewDate.getUTCFullYear(),
					month = this.viewDate.getUTCMonth(),
					today = new Date();
				if (date.getUTCFullYear() < year || (date.getUTCFullYear() === year && date.getUTCMonth() < month)){
					cls.push('old');
				}
				else if (date.getUTCFullYear() > year || (date.getUTCFullYear() === year && date.getUTCMonth() > month)){
					cls.push('new');
				}
				if (this.focusDate && date.valueOf() === this.focusDate.valueOf())
					cls.push('focused');
				// Compare internal UTC date with local today, not UTC today
				if (this.o.todayHighlight &&
					date.getUTCFullYear() === today.getFullYear() &&
					date.getUTCMonth() === today.getMonth() &&
					date.getUTCDate() === today.getDate()){
					cls.push('today');
				}
				if (this.dates.contains(date) !== -1)
					cls.push('active');
				if (date.valueOf() < this.o.startDate || date.valueOf() > this.o.endDate ||
					$.inArray(date.getUTCDay(), this.o.daysOfWeekDisabled) !== -1){
					cls.push('disabled');
				}
				if (this.range){
					if (date > this.range[0] && date < this.range[this.range.length-1]){
						cls.push('range');
					}
					if ($.inArray(date.valueOf(), this.range) !== -1){
						cls.push('selected');
					}
				}
				return cls;
			},
	
			fill: function(){
				var d = new Date(this.viewDate),
					year = d.getUTCFullYear(),
					month = d.getUTCMonth(),
					startYear = this.o.startDate !== -Infinity ? this.o.startDate.getUTCFullYear() : -Infinity,
					startMonth = this.o.startDate !== -Infinity ? this.o.startDate.getUTCMonth() : -Infinity,
					endYear = this.o.endDate !== Infinity ? this.o.endDate.getUTCFullYear() : Infinity,
					endMonth = this.o.endDate !== Infinity ? this.o.endDate.getUTCMonth() : Infinity,
					todaytxt = dates[this.o.language].today || dates['en'].today || '',
					cleartxt = dates[this.o.language].clear || dates['en'].clear || '',
					tooltip;
				this.picker.find('.datepicker-days thead th.datepicker-switch')
							.text(dates[this.o.language].months[month]+' '+year);
				this.picker.find('tfoot th.today')
							.text(todaytxt)
							.toggle(this.o.todayBtn !== false);
				this.picker.find('tfoot th.clear')
							.text(cleartxt)
							.toggle(this.o.clearBtn !== false);
				this.updateNavArrows();
				this.fillMonths();
				var prevMonth = UTCDate(year, month-1, 28),
					day = DPGlobal.getDaysInMonth(prevMonth.getUTCFullYear(), prevMonth.getUTCMonth());
				prevMonth.setUTCDate(day);
				prevMonth.setUTCDate(day - (prevMonth.getUTCDay() - this.o.weekStart + 7)%7);
				var nextMonth = new Date(prevMonth);
				nextMonth.setUTCDate(nextMonth.getUTCDate() + 42);
				nextMonth = nextMonth.valueOf();
				var html = [];
				var clsName;
				while (prevMonth.valueOf() < nextMonth){
					if (prevMonth.getUTCDay() === this.o.weekStart){
						html.push('<tr>');
						if (this.o.calendarWeeks){
							// ISO 8601: First week contains first thursday.
							// ISO also states week starts on Monday, but we can be more abstract here.
							var
								// Start of current week: based on weekstart/current date
								ws = new Date(+prevMonth + (this.o.weekStart - prevMonth.getUTCDay() - 7) % 7 * 864e5),
								// Thursday of this week
								th = new Date(Number(ws) + (7 + 4 - ws.getUTCDay()) % 7 * 864e5),
								// First Thursday of year, year from thursday
								yth = new Date(Number(yth = UTCDate(th.getUTCFullYear(), 0, 1)) + (7 + 4 - yth.getUTCDay())%7*864e5),
								// Calendar week: ms between thursdays, div ms per day, div 7 days
								calWeek =  (th - yth) / 864e5 / 7 + 1;
							html.push('<td class="cw">'+ calWeek +'</td>');
	
						}
					}
					clsName = this.getClassNames(prevMonth);
					clsName.push('day');
	
					if (this.o.beforeShowDay !== $.noop){
						var before = this.o.beforeShowDay(this._utc_to_local(prevMonth));
						if (before === undefined)
							before = {};
						else if (typeof(before) === 'boolean')
							before = {enabled: before};
						else if (typeof(before) === 'string')
							before = {classes: before};
						if (before.enabled === false)
							clsName.push('disabled');
						if (before.classes)
							clsName = clsName.concat(before.classes.split(/\s+/));
						if (before.tooltip)
							tooltip = before.tooltip;
					}
	
					clsName = $.unique(clsName);
					html.push('<td class="'+clsName.join(' ')+'"' + (tooltip ? ' title="'+tooltip+'"' : '') + '>'+prevMonth.getUTCDate() + '</td>');
					if (prevMonth.getUTCDay() === this.o.weekEnd){
						html.push('</tr>');
					}
					prevMonth.setUTCDate(prevMonth.getUTCDate()+1);
				}
				this.picker.find('.datepicker-days tbody').empty().append(html.join(''));
	
				var months = this.picker.find('.datepicker-months')
							.find('th:eq(1)')
								.text(year)
								.end()
							.find('span').removeClass('active');
	
				$.each(this.dates, function(i, d){
					if (d.getUTCFullYear() === year)
						months.eq(d.getUTCMonth()).addClass('active');
				});
	
				if (year < startYear || year > endYear){
					months.addClass('disabled');
				}
				if (year === startYear){
					months.slice(0, startMonth).addClass('disabled');
				}
				if (year === endYear){
					months.slice(endMonth+1).addClass('disabled');
				}
	
				html = '';
				year = parseInt(year/10, 10) * 10;
				var yearCont = this.picker.find('.datepicker-years')
									.find('th:eq(1)')
										.text(year + '-' + (year + 9))
										.end()
									.find('td');
				year -= 1;
				var years = $.map(this.dates, function(d){
						return d.getUTCFullYear();
					}),
					classes;
				for (var i = -1; i < 11; i++){
					classes = ['year'];
					if (i === -1)
						classes.push('old');
					else if (i === 10)
						classes.push('new');
					if ($.inArray(year, years) !== -1)
						classes.push('active');
					if (year < startYear || year > endYear)
						classes.push('disabled');
					html += '<span class="' + classes.join(' ') + '">'+year+'</span>';
					year += 1;
				}
				yearCont.html(html);
			},
	
			updateNavArrows: function(){
				if (!this._allow_update)
					return;
	
				var d = new Date(this.viewDate),
					year = d.getUTCFullYear(),
					month = d.getUTCMonth();
				switch (this.viewMode){
					case 0:
						if (this.o.startDate !== -Infinity && year <= this.o.startDate.getUTCFullYear() && month <= this.o.startDate.getUTCMonth()){
							this.picker.find('.prev').css({visibility: 'hidden'});
						}
						else {
							this.picker.find('.prev').css({visibility: 'visible'});
						}
						if (this.o.endDate !== Infinity && year >= this.o.endDate.getUTCFullYear() && month >= this.o.endDate.getUTCMonth()){
							this.picker.find('.next').css({visibility: 'hidden'});
						}
						else {
							this.picker.find('.next').css({visibility: 'visible'});
						}
						break;
					case 1:
					case 2:
						if (this.o.startDate !== -Infinity && year <= this.o.startDate.getUTCFullYear()){
							this.picker.find('.prev').css({visibility: 'hidden'});
						}
						else {
							this.picker.find('.prev').css({visibility: 'visible'});
						}
						if (this.o.endDate !== Infinity && year >= this.o.endDate.getUTCFullYear()){
							this.picker.find('.next').css({visibility: 'hidden'});
						}
						else {
							this.picker.find('.next').css({visibility: 'visible'});
						}
						break;
				}
			},
	
			click: function(e){
				e.preventDefault();
				var target = $(e.target).closest('span, td, th'),
					year, month, day;
				if (target.length === 1){
					switch (target[0].nodeName.toLowerCase()){
						case 'th':
							switch (target[0].className){
								case 'datepicker-switch':
									this.showMode(1);
									break;
								case 'prev':
								case 'next':
									var dir = DPGlobal.modes[this.viewMode].navStep * (target[0].className === 'prev' ? -1 : 1);
									switch (this.viewMode){
										case 0:
											this.viewDate = this.moveMonth(this.viewDate, dir);
											this._trigger('changeMonth', this.viewDate);
											break;
										case 1:
										case 2:
											this.viewDate = this.moveYear(this.viewDate, dir);
											if (this.viewMode === 1)
												this._trigger('changeYear', this.viewDate);
											break;
									}
									this.fill();
									break;
								case 'today':
									var date = new Date();
									date = UTCDate(date.getFullYear(), date.getMonth(), date.getDate(), 0, 0, 0);
	
									this.showMode(-2);
									var which = this.o.todayBtn === 'linked' ? null : 'view';
									this._setDate(date, which);
									break;
								case 'clear':
									var element;
									if (this.isInput)
										element = this.element;
									else if (this.component)
										element = this.element.find('input');
									if (element)
										element.val("").change();
									this.update();
									this._trigger('changeDate');
									if (this.o.autoclose)
										this.hide();
									break;
							}
							break;
						case 'span':
							if (!target.is('.disabled')){
								this.viewDate.setUTCDate(1);
								if (target.is('.month')){
									day = 1;
									month = target.parent().find('span').index(target);
									year = this.viewDate.getUTCFullYear();
									this.viewDate.setUTCMonth(month);
									this._trigger('changeMonth', this.viewDate);
									if (this.o.minViewMode === 1){
										this._setDate(UTCDate(year, month, day));
									}
								}
								else {
									day = 1;
									month = 0;
									year = parseInt(target.text(), 10)||0;
									this.viewDate.setUTCFullYear(year);
									this._trigger('changeYear', this.viewDate);
									if (this.o.minViewMode === 2){
										this._setDate(UTCDate(year, month, day));
									}
								}
								this.showMode(-1);
								this.fill();
							}
							break;
						case 'td':
							if (target.is('.day') && !target.is('.disabled')){
								day = parseInt(target.text(), 10)||1;
								year = this.viewDate.getUTCFullYear();
								month = this.viewDate.getUTCMonth();
								if (target.is('.old')){
									if (month === 0){
										month = 11;
										year -= 1;
									}
									else {
										month -= 1;
									}
								}
								else if (target.is('.new')){
									if (month === 11){
										month = 0;
										year += 1;
									}
									else {
										month += 1;
									}
								}
								this._setDate(UTCDate(year, month, day));
							}
							break;
					}
				}
				if (this.picker.is(':visible') && this._focused_from){
					$(this._focused_from).focus();
				}
				delete this._focused_from;
			},
	
			_toggle_multidate: function(date){
				var ix = this.dates.contains(date);
				if (!date){
					this.dates.clear();
				}
				else if (ix !== -1){
					this.dates.remove(ix);
				}
				else {
					this.dates.push(date);
				}
				if (typeof this.o.multidate === 'number')
					while (this.dates.length > this.o.multidate)
						this.dates.remove(0);
			},
	
			_setDate: function(date, which){
				if (!which || which === 'date')
					this._toggle_multidate(date && new Date(date));
				if (!which || which  === 'view')
					this.viewDate = date && new Date(date);
	
				this.fill();
				this.setValue();
				this._trigger('changeDate');
				var element;
				if (this.isInput){
					element = this.element;
				}
				else if (this.component){
					element = this.element.find('input');
				}
				if (element){
					element.change();
				}
				if (this.o.autoclose && (!which || which === 'date')){
					this.hide();
				}
			},
	
			moveMonth: function(date, dir){
				if (!date)
					return undefined;
				if (!dir)
					return date;
				var new_date = new Date(date.valueOf()),
					day = new_date.getUTCDate(),
					month = new_date.getUTCMonth(),
					mag = Math.abs(dir),
					new_month, test;
				dir = dir > 0 ? 1 : -1;
				if (mag === 1){
					test = dir === -1
						// If going back one month, make sure month is not current month
						// (eg, Mar 31 -> Feb 31 == Feb 28, not Mar 02)
						? function(){
							return new_date.getUTCMonth() === month;
						}
						// If going forward one month, make sure month is as expected
						// (eg, Jan 31 -> Feb 31 == Feb 28, not Mar 02)
						: function(){
							return new_date.getUTCMonth() !== new_month;
						};
					new_month = month + dir;
					new_date.setUTCMonth(new_month);
					// Dec -> Jan (12) or Jan -> Dec (-1) -- limit expected date to 0-11
					if (new_month < 0 || new_month > 11)
						new_month = (new_month + 12) % 12;
				}
				else {
					// For magnitudes >1, move one month at a time...
					for (var i=0; i < mag; i++)
						// ...which might decrease the day (eg, Jan 31 to Feb 28, etc)...
						new_date = this.moveMonth(new_date, dir);
					// ...then reset the day, keeping it in the new month
					new_month = new_date.getUTCMonth();
					new_date.setUTCDate(day);
					test = function(){
						return new_month !== new_date.getUTCMonth();
					};
				}
				// Common date-resetting loop -- if date is beyond end of month, make it
				// end of month
				while (test()){
					new_date.setUTCDate(--day);
					new_date.setUTCMonth(new_month);
				}
				return new_date;
			},
	
			moveYear: function(date, dir){
				return this.moveMonth(date, dir*12);
			},
	
			dateWithinRange: function(date){
				return date >= this.o.startDate && date <= this.o.endDate;
			},
	
			keydown: function(e){
				if (this.picker.is(':not(:visible)')){
					if (e.keyCode === 27) // allow escape to hide and re-show picker
						this.show();
					return;
				}
				var dateChanged = false,
					dir, newDate, newViewDate,
					focusDate = this.focusDate || this.viewDate;
				switch (e.keyCode){
					case 27: // escape
						if (this.focusDate){
							this.focusDate = null;
							this.viewDate = this.dates.get(-1) || this.viewDate;
							this.fill();
						}
						else
							this.hide();
						e.preventDefault();
						break;
					case 37: // left
					case 39: // right
						if (!this.o.keyboardNavigation)
							break;
						dir = e.keyCode === 37 ? -1 : 1;
						if (e.ctrlKey){
							newDate = this.moveYear(this.dates.get(-1) || UTCToday(), dir);
							newViewDate = this.moveYear(focusDate, dir);
							this._trigger('changeYear', this.viewDate);
						}
						else if (e.shiftKey){
							newDate = this.moveMonth(this.dates.get(-1) || UTCToday(), dir);
							newViewDate = this.moveMonth(focusDate, dir);
							this._trigger('changeMonth', this.viewDate);
						}
						else {
							newDate = new Date(this.dates.get(-1) || UTCToday());
							newDate.setUTCDate(newDate.getUTCDate() + dir);
							newViewDate = new Date(focusDate);
							newViewDate.setUTCDate(focusDate.getUTCDate() + dir);
						}
						if (this.dateWithinRange(newDate)){
							this.focusDate = this.viewDate = newViewDate;
							this.setValue();
							this.fill();
							e.preventDefault();
						}
						break;
					case 38: // up
					case 40: // down
						if (!this.o.keyboardNavigation)
							break;
						dir = e.keyCode === 38 ? -1 : 1;
						if (e.ctrlKey){
							newDate = this.moveYear(this.dates.get(-1) || UTCToday(), dir);
							newViewDate = this.moveYear(focusDate, dir);
							this._trigger('changeYear', this.viewDate);
						}
						else if (e.shiftKey){
							newDate = this.moveMonth(this.dates.get(-1) || UTCToday(), dir);
							newViewDate = this.moveMonth(focusDate, dir);
							this._trigger('changeMonth', this.viewDate);
						}
						else {
							newDate = new Date(this.dates.get(-1) || UTCToday());
							newDate.setUTCDate(newDate.getUTCDate() + dir * 7);
							newViewDate = new Date(focusDate);
							newViewDate.setUTCDate(focusDate.getUTCDate() + dir * 7);
						}
						if (this.dateWithinRange(newDate)){
							this.focusDate = this.viewDate = newViewDate;
							this.setValue();
							this.fill();
							e.preventDefault();
						}
						break;
					case 32: // spacebar
						// Spacebar is used in manually typing dates in some formats.
						// As such, its behavior should not be hijacked.
						break;
					case 13: // enter
						focusDate = this.focusDate || this.dates.get(-1) || this.viewDate;
						this._toggle_multidate(focusDate);
						dateChanged = true;
						this.focusDate = null;
						this.viewDate = this.dates.get(-1) || this.viewDate;
						this.setValue();
						this.fill();
						if (this.picker.is(':visible')){
							e.preventDefault();
							if (this.o.autoclose)
								this.hide();
						}
						break;
					case 9: // tab
						this.focusDate = null;
						this.viewDate = this.dates.get(-1) || this.viewDate;
						this.fill();
						this.hide();
						break;
				}
				if (dateChanged){
					if (this.dates.length)
						this._trigger('changeDate');
					else
						this._trigger('clearDate');
					var element;
					if (this.isInput){
						element = this.element;
					}
					else if (this.component){
						element = this.element.find('input');
					}
					if (element){
						element.change();
					}
				}
			},
	
			showMode: function(dir){
				if (dir){
					this.viewMode = Math.max(this.o.minViewMode, Math.min(2, this.viewMode + dir));
				}
				this.picker
					.find('>div')
					.hide()
					.filter('.datepicker-'+DPGlobal.modes[this.viewMode].clsName)
						.css('display', 'block');
				this.updateNavArrows();
			}
		};
	
		var DateRangePicker = function(element, options){
			this.element = $(element);
			this.inputs = $.map(options.inputs, function(i){
				return i.jquery ? i[0] : i;
			});
			delete options.inputs;
	
			$(this.inputs)
				.datepicker(options)
				.bind('changeDate', $.proxy(this.dateUpdated, this));
	
			this.pickers = $.map(this.inputs, function(i){
				return $(i).data('datepicker');
			});
			this.updateDates();
		};
		DateRangePicker.prototype = {
			updateDates: function(){
				this.dates = $.map(this.pickers, function(i){
					return i.getUTCDate();
				});
				this.updateRanges();
			},
			updateRanges: function(){
				var range = $.map(this.dates, function(d){
					return d.valueOf();
				});
				$.each(this.pickers, function(i, p){
					p.setRange(range);
				});
			},
			dateUpdated: function(e){
				// `this.updating` is a workaround for preventing infinite recursion
				// between `changeDate` triggering and `setUTCDate` calling.  Until
				// there is a better mechanism.
				if (this.updating)
					return;
				this.updating = true;
	
				var dp = $(e.target).data('datepicker'),
					new_date = dp.getUTCDate(),
					i = $.inArray(e.target, this.inputs),
					l = this.inputs.length;
				if (i === -1)
					return;
	
				$.each(this.pickers, function(i, p){
					if (!p.getUTCDate())
						p.setUTCDate(new_date);
				});
	
				if (new_date < this.dates[i]){
					// Date being moved earlier/left
					while (i >= 0 && new_date < this.dates[i]){
						this.pickers[i--].setUTCDate(new_date);
					}
				}
				else if (new_date > this.dates[i]){
					// Date being moved later/right
					while (i < l && new_date > this.dates[i]){
						this.pickers[i++].setUTCDate(new_date);
					}
				}
				this.updateDates();
	
				delete this.updating;
			},
			remove: function(){
				$.map(this.pickers, function(p){ p.remove(); });
				delete this.element.data().datepicker;
			}
		};
	
		function opts_from_el(el, prefix){
			// Derive options from element data-attrs
			var data = $(el).data(),
				out = {}, inkey,
				replace = new RegExp('^' + prefix.toLowerCase() + '([A-Z])');
			prefix = new RegExp('^' + prefix.toLowerCase());
			function re_lower(_,a){
				return a.toLowerCase();
			}
			for (var key in data)
				if (prefix.test(key)){
					inkey = key.replace(replace, re_lower);
					out[inkey] = data[key];
				}
			return out;
		}
	
		function opts_from_locale(lang){
			// Derive options from locale plugins
			var out = {};
			// Check if "de-DE" style date is available, if not language should
			// fallback to 2 letter code eg "de"
			if (!dates[lang]){
				lang = lang.split('-')[0];
				if (!dates[lang])
					return;
			}
			var d = dates[lang];
			$.each(locale_opts, function(i,k){
				if (k in d)
					out[k] = d[k];
			});
			return out;
		}
	
		var old = $.fn.datepicker;
		$.fn.datepicker = function(option){
			var args = Array.apply(null, arguments);
			args.shift();
			var internal_return;
			this.each(function(){
				var $this = $(this),
					data = $this.data('datepicker'),
					options = typeof option === 'object' && option;
				if (!data){
					var elopts = opts_from_el(this, 'date'),
						// Preliminary otions
						xopts = $.extend({}, defaults, elopts, options),
						locopts = opts_from_locale(xopts.language),
						// Options priority: js args, data-attrs, locales, defaults
						opts = $.extend({}, defaults, locopts, elopts, options);
					if ($this.is('.input-daterange') || opts.inputs){
						var ropts = {
							inputs: opts.inputs || $this.find('input').toArray()
						};
						$this.data('datepicker', (data = new DateRangePicker(this, $.extend(opts, ropts))));
					}
					else {
						$this.data('datepicker', (data = new Datepicker(this, opts)));
					}
				}
				if (typeof option === 'string' && typeof data[option] === 'function'){
					internal_return = data[option].apply(data, args);
					if (internal_return !== undefined)
						return false;
				}
			});
			if (internal_return !== undefined)
				return internal_return;
			else
				return this;
		};
	
		var defaults = $.fn.datepicker.defaults = {
			autoclose: false,
			beforeShowDay: $.noop,
			calendarWeeks: false,
			clearBtn: false,
			daysOfWeekDisabled: [],
			endDate: Infinity,
			forceParse: true,
			format: 'mm/dd/yyyy',
			keyboardNavigation: true,
			language: 'en',
			minViewMode: 0,
			multidate: false,
			multidateSeparator: ',',
			orientation: "auto",
			rtl: false,
			startDate: -Infinity,
			startView: 0,
			todayBtn: false,
			todayHighlight: false,
			weekStart: 0
		};
		var locale_opts = $.fn.datepicker.locale_opts = [
			'format',
			'rtl',
			'weekStart'
		];
		$.fn.datepicker.Constructor = Datepicker;
		var dates = $.fn.datepicker.dates = {
			en: {
				days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"],
				daysShort: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"],
				daysMin: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa", "Su"],
				months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
				monthsShort: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
				today: "Today",
				clear: "Clear"
			}
		};
	
		var DPGlobal = {
			modes: [
				{
					clsName: 'days',
					navFnc: 'Month',
					navStep: 1
				},
				{
					clsName: 'months',
					navFnc: 'FullYear',
					navStep: 1
				},
				{
					clsName: 'years',
					navFnc: 'FullYear',
					navStep: 10
			}],
			isLeapYear: function(year){
				return (((year % 4 === 0) && (year % 100 !== 0)) || (year % 400 === 0));
			},
			getDaysInMonth: function(year, month){
				return [31, (DPGlobal.isLeapYear(year) ? 29 : 28), 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][month];
			},
			validParts: /dd?|DD?|mm?|MM?|yy(?:yy)?/g,
			nonpunctuation: /[^ -\/:-@\[\u3400-\u9fff-`{-~\t\n\r]+/g,
			parseFormat: function(format){
				// IE treats \0 as a string end in inputs (truncating the value),
				// so it's a bad format delimiter, anyway
				var separators = format.replace(this.validParts, '\0').split('\0'),
					parts = format.match(this.validParts);
				if (!separators || !separators.length || !parts || parts.length === 0){
					throw new Error("Invalid date format.");
				}
				return {separators: separators, parts: parts};
			},
			parseDate: function(date, format, language){
				if (!date)
					return undefined;
				if (date instanceof Date)
					return date;
				if (typeof format === 'string')
					format = DPGlobal.parseFormat(format);
				var part_re = /([\-+]\d+)([dmwy])/,
					parts = date.match(/([\-+]\d+)([dmwy])/g),
					part, dir, i;
				if (/^[\-+]\d+[dmwy]([\s,]+[\-+]\d+[dmwy])*$/.test(date)){
					date = new Date();
					for (i=0; i < parts.length; i++){
						part = part_re.exec(parts[i]);
						dir = parseInt(part[1]);
						switch (part[2]){
							case 'd':
								date.setUTCDate(date.getUTCDate() + dir);
								break;
							case 'm':
								date = Datepicker.prototype.moveMonth.call(Datepicker.prototype, date, dir);
								break;
							case 'w':
								date.setUTCDate(date.getUTCDate() + dir * 7);
								break;
							case 'y':
								date = Datepicker.prototype.moveYear.call(Datepicker.prototype, date, dir);
								break;
						}
					}
					return UTCDate(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate(), 0, 0, 0);
				}
				parts = date && date.match(this.nonpunctuation) || [];
				date = new Date();
				var parsed = {},
					setters_order = ['yyyy', 'yy', 'M', 'MM', 'm', 'mm', 'd', 'dd'],
					setters_map = {
						yyyy: function(d,v){
							return d.setUTCFullYear(v);
						},
						yy: function(d,v){
							return d.setUTCFullYear(2000+v);
						},
						m: function(d,v){
							if (isNaN(d))
								return d;
							v -= 1;
							while (v < 0) v += 12;
							v %= 12;
							d.setUTCMonth(v);
							while (d.getUTCMonth() !== v)
								d.setUTCDate(d.getUTCDate()-1);
							return d;
						},
						d: function(d,v){
							return d.setUTCDate(v);
						}
					},
					val, filtered;
				setters_map['M'] = setters_map['MM'] = setters_map['mm'] = setters_map['m'];
				setters_map['dd'] = setters_map['d'];
				date = UTCDate(date.getFullYear(), date.getMonth(), date.getDate(), 0, 0, 0);
				var fparts = format.parts.slice();
				// Remove noop parts
				if (parts.length !== fparts.length){
					fparts = $(fparts).filter(function(i,p){
						return $.inArray(p, setters_order) !== -1;
					}).toArray();
				}
				// Process remainder
				function match_part(){
					var m = this.slice(0, parts[i].length),
						p = parts[i].slice(0, m.length);
					return m === p;
				}
				if (parts.length === fparts.length){
					var cnt;
					for (i=0, cnt = fparts.length; i < cnt; i++){
						val = parseInt(parts[i], 10);
						part = fparts[i];
						if (isNaN(val)){
							switch (part){
								case 'MM':
									filtered = $(dates[language].months).filter(match_part);
									val = $.inArray(filtered[0], dates[language].months) + 1;
									break;
								case 'M':
									filtered = $(dates[language].monthsShort).filter(match_part);
									val = $.inArray(filtered[0], dates[language].monthsShort) + 1;
									break;
							}
						}
						parsed[part] = val;
					}
					var _date, s;
					for (i=0; i < setters_order.length; i++){
						s = setters_order[i];
						if (s in parsed && !isNaN(parsed[s])){
							_date = new Date(date);
							setters_map[s](_date, parsed[s]);
							if (!isNaN(_date))
								date = _date;
						}
					}
				}
				return date;
			},
			formatDate: function(date, format, language){
				if (!date)
					return '';
				if (typeof format === 'string')
					format = DPGlobal.parseFormat(format);
				var val = {
					d: date.getUTCDate(),
					D: dates[language].daysShort[date.getUTCDay()],
					DD: dates[language].days[date.getUTCDay()],
					m: date.getUTCMonth() + 1,
					M: dates[language].monthsShort[date.getUTCMonth()],
					MM: dates[language].months[date.getUTCMonth()],
					yy: date.getUTCFullYear().toString().substring(2),
					yyyy: date.getUTCFullYear()
				};
				val.dd = (val.d < 10 ? '0' : '') + val.d;
				val.mm = (val.m < 10 ? '0' : '') + val.m;
				date = [];
				var seps = $.extend([], format.separators);
				for (var i=0, cnt = format.parts.length; i <= cnt; i++){
					if (seps.length)
						date.push(seps.shift());
					date.push(val[format.parts[i]]);
				}
				return date.join('');
			},
			headTemplate: '<thead>'+
								'<tr>'+
									'<th class="prev">&laquo;</th>'+
									'<th colspan="5" class="datepicker-switch"></th>'+
									'<th class="next">&raquo;</th>'+
								'</tr>'+
							'</thead>',
			contTemplate: '<tbody><tr><td colspan="7"></td></tr></tbody>',
			footTemplate: '<tfoot>'+
								'<tr>'+
									'<th colspan="7" class="today"></th>'+
								'</tr>'+
								'<tr>'+
									'<th colspan="7" class="clear"></th>'+
								'</tr>'+
							'</tfoot>'
		};
		DPGlobal.template = '<div class="datepicker">'+
								'<div class="datepicker-days">'+
									'<table class="table table-condensed">'+
										DPGlobal.headTemplate+
										'<tbody></tbody>'+
										DPGlobal.footTemplate+
									'</table>'+
								'</div>'+
								'<div class="datepicker-months">'+
									'<table class="table table-condensed">'+
										DPGlobal.headTemplate+
										DPGlobal.contTemplate+
										DPGlobal.footTemplate+
									'</table>'+
								'</div>'+
								'<div class="datepicker-years">'+
									'<table class="table table-condensed">'+
										DPGlobal.headTemplate+
										DPGlobal.contTemplate+
										DPGlobal.footTemplate+
									'</table>'+
								'</div>'+
							'</div>';
	
		$.fn.datepicker.DPGlobal = DPGlobal;
	
	
		/* DATEPICKER NO CONFLICT
		* =================== */
	
		$.fn.datepicker.noConflict = function(){
			$.fn.datepicker = old;
			return this;
		};
	
	
		/* DATEPICKER DATA-API
		* ================== */
	
		$(document).on(
			'focus.datepicker.data-api click.datepicker.data-api',
			'[data-provide="datepicker"]',
			function(e){
				var $this = $(this);
				if ($this.data('datepicker'))
					return;
				e.preventDefault();
				// component click requires us to explicitly show it
				$this.datepicker('show');
			}
		);
		$(function(){
			$('[data-provide="datepicker-inline"]').datepicker();
		});
	
	}(__webpack_provided_window_dot_jQuery));
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 61 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 62 */
/***/ function(module, exports) {

	module.exports = {
		"private": true,
		"scripts": {
			"prod": "gulp --production",
			"dev": "gulp watch",
			"gulp": "gulp",
			"build": "webpack"
		},
		"browserify": {
			"transform": [
				"browserify-shim"
			]
		},
		"browser": {
			"jquery": "./node_modules/jquery/dist/jquery.min.js",
			"bootstrap": "./node_modules/admin-lte/dist/js/app.min.js",
			"admin-lte": "./node_modules/bootstrap/dist/js/bootstrap.min.js"
		},
		"browserify-shim": {
			"jquery": "$",
			"admin-lte": {
				"depends": [
					"jquery:$",
					"bootstrap"
				]
			}
		},
		"devDependencies": {
			"bootstrap-sass": "^3.0.0",
			"browserify-shim": "^3.8.12",
			"chosen-npm": "^1.4.2",
			"css-loader": "^0.23.1",
			"exports-loader": "^0.6.3",
			"expose-loader": "^0.7.1",
			"extract-text-webpack-plugin": "^1.0.1",
			"font-awesome": "^4.6.3",
			"font-awesome-webpack": "0.0.4",
			"image-webpack-loader": "^1.8.0",
			"imports-loader": "^0.6.5",
			"less": "^2.7.1",
			"less-loader": "^2.2.3",
			"node-sass": "^3.7.0",
			"normalize.css": "^4.1.1",
			"sass-loader": "^3.2.0",
			"script-loader": "^0.7.0",
			"style-loader": "^0.13.1",
			"tinymce": "^4.3.13",
			"url-loader": "^0.5.7",
			"webpack": "^1.13.1",
			"webpack-stream": "^3.2.0"
		},
		"dependencies": {
			"admin-lte": "^2.3.3",
			"bootstrap": "^3.3.6",
			"codemirror": "^5.15.2",
			"datatables.net": "^1.10.12",
			"datatables.net-bs": "^1.10.12",
			"datatables.net-dt": "^1.10.12",
			"font-awesome": "^4.6.1",
			"jquery": "^2.2.3",
			"json-loader": "^0.5.4",
			"merge-stream": "^1.0.0",
			"scriptjs": "^2.5.8",
			"wow.js": "^1.2.1"
		},
		"version": "0.2.2"
	};

/***/ },
/* 63 */
/***/ function(module, exports) {

	// TinyMCE config
	
	var ed = tinymce.init({
	    selector: '#article_text',
	    skin: false,
	    plugins: ['image','media', 'fullscreen','template', 'filemanager', 'link', 'codesample'],
	    toolbar: ' forecolor backcolor bold italic underline removeformat | alignleft aligncenter alignright | copy paste | bullist numlist | link | template | codesample image | fullscreen',
	    height: 400,
	    content_css : '/public/assets/admin.all.css',
	    templates: [
	        {title: 'Readmore', description: 'Insert readmore article section', content: '<hr/>'},
	    ],
	    external_filemanager_path:"/plugins/filemanager/filemanager/",
	    filemanager_title:"Responsive Filemanager" ,
	    external_plugins: { "filemanager" : "/plugins/filemanager/filemanager/plugin.min.js"},
	    convert_urls: false
	
	});
	
	function onFileChosen(event,callback)
	{
	    // //Detach any current submit handlers
	    // $("#fileUploadForm").unbind("submit");
	    // $("#fileUploadForm").submit(function(e) {
	    //
	    //     e.stopPropagation(); // Stop stuff happening
	    //     e.preventDefault(); // Totally stop stuff happening
	    //
	    //     //Prepare file in form for transmission via ajax call
	    //     var formData = new FormData();
	    //     $.each(event.target.files, function(i, file) {
	    //         formData.append('file-'+i, file);
	    //     });
	    //
	    //     // Add the token to the request
	    //     formData.append('_token', $('input[name=_token]').val());
	    //
	    //     //The url that will handle the file upload
	    //     var url = "/administrator/media/upload"
	    //
	    //     //Do ajax call
	    //     $.ajax({
	    //         type: 'POST',
	    //         url: url,
	    //         data: formData,
	    //         cache: false,
	    //         contentType: false,
	    //         processData: false,
	    //         dataType: 'json',
	    //     }).done(function(data) {
	    //         if(data.result === true)
	    //         {
	    //             //This is the important part. This callback will tell TinyMCE the path of the uploaded image
	    //             // TODO Hardcoded URL
	    //             callback('/administrator/media/download?path='+ data.newPath, {});
	    //         }
	    //         else{
	    //             alert("The image upload was not successful. Reason:" + data.status);
	    //         }
	    //     }).fail(function(data) {
	    //         alert('An error occured while uploading an image into the repository')
	    //     });
	    //
	    // });
	    // $("#fileUploadForm").submit();
	}

/***/ },
/* 64 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "dots.png";

/***/ },
/* 65 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function($, jQuery) {/*! AdminLTE app.js
	 * ================
	 * Main JS application file for AdminLTE v2. This file
	 * should be included in all pages. It controls some layout
	 * options and implements exclusive AdminLTE plugins.
	 *
	 * @Author  Almsaeed Studio
	 * @Support <http://www.almsaeedstudio.com>
	 * @Email   <support@almsaeedstudio.com>
	 * @version 2.3.3
	 * @license MIT <http://opensource.org/licenses/MIT>
	 */
	function _init(){"use strict";$.AdminLTE.layout={activate:function(){var a=this;a.fix(),a.fixSidebar(),$(window,".wrapper").resize(function(){a.fix(),a.fixSidebar()})},fix:function(){var a=$(".main-header").outerHeight()+$(".main-footer").outerHeight(),b=$(window).height(),c=$(".sidebar").height();if($("body").hasClass("fixed"))$(".content-wrapper, .right-side").css("min-height",b-$(".main-footer").outerHeight());else{var d;b>=c?($(".content-wrapper, .right-side").css("min-height",b-a),d=b-a):($(".content-wrapper, .right-side").css("min-height",c),d=c);var e=$($.AdminLTE.options.controlSidebarOptions.selector);"undefined"!=typeof e&&e.height()>d&&$(".content-wrapper, .right-side").css("min-height",e.height())}},fixSidebar:function(){return $("body").hasClass("fixed")?("undefined"==typeof $.fn.slimScroll&&window.console&&window.console.error("Error: the fixed layout requires the slimscroll plugin!"),void($.AdminLTE.options.sidebarSlimScroll&&"undefined"!=typeof $.fn.slimScroll&&($(".sidebar").slimScroll({destroy:!0}).height("auto"),$(".sidebar").slimscroll({height:$(window).height()-$(".main-header").height()+"px",color:"rgba(0,0,0,0.2)",size:"3px"})))):void("undefined"!=typeof $.fn.slimScroll&&$(".sidebar").slimScroll({destroy:!0}).height("auto"))}},$.AdminLTE.pushMenu={activate:function(a){var b=$.AdminLTE.options.screenSizes;$(document).on("click",a,function(a){a.preventDefault(),$(window).width()>b.sm-1?$("body").hasClass("sidebar-collapse")?$("body").removeClass("sidebar-collapse").trigger("expanded.pushMenu"):$("body").addClass("sidebar-collapse").trigger("collapsed.pushMenu"):$("body").hasClass("sidebar-open")?$("body").removeClass("sidebar-open").removeClass("sidebar-collapse").trigger("collapsed.pushMenu"):$("body").addClass("sidebar-open").trigger("expanded.pushMenu")}),$(".content-wrapper").click(function(){$(window).width()<=b.sm-1&&$("body").hasClass("sidebar-open")&&$("body").removeClass("sidebar-open")}),($.AdminLTE.options.sidebarExpandOnHover||$("body").hasClass("fixed")&&$("body").hasClass("sidebar-mini"))&&this.expandOnHover()},expandOnHover:function(){var a=this,b=$.AdminLTE.options.screenSizes.sm-1;$(".main-sidebar").hover(function(){$("body").hasClass("sidebar-mini")&&$("body").hasClass("sidebar-collapse")&&$(window).width()>b&&a.expand()},function(){$("body").hasClass("sidebar-mini")&&$("body").hasClass("sidebar-expanded-on-hover")&&$(window).width()>b&&a.collapse()})},expand:function(){$("body").removeClass("sidebar-collapse").addClass("sidebar-expanded-on-hover")},collapse:function(){$("body").hasClass("sidebar-expanded-on-hover")&&$("body").removeClass("sidebar-expanded-on-hover").addClass("sidebar-collapse")}},$.AdminLTE.tree=function(a){var b=this,c=$.AdminLTE.options.animationSpeed;$(document).on("click",a+" li a",function(a){var d=$(this),e=d.next();if(e.is(".treeview-menu")&&e.is(":visible")&&!$("body").hasClass("sidebar-collapse"))e.slideUp(c,function(){e.removeClass("menu-open")}),e.parent("li").removeClass("active");else if(e.is(".treeview-menu")&&!e.is(":visible")){var f=d.parents("ul").first(),g=f.find("ul:visible").slideUp(c);g.removeClass("menu-open");var h=d.parent("li");e.slideDown(c,function(){e.addClass("menu-open"),f.find("li.active").removeClass("active"),h.addClass("active"),b.layout.fix()})}e.is(".treeview-menu")&&a.preventDefault()})},$.AdminLTE.controlSidebar={activate:function(){var a=this,b=$.AdminLTE.options.controlSidebarOptions,c=$(b.selector),d=$(b.toggleBtnSelector);d.on("click",function(d){d.preventDefault(),c.hasClass("control-sidebar-open")||$("body").hasClass("control-sidebar-open")?a.close(c,b.slide):a.open(c,b.slide)});var e=$(".control-sidebar-bg");a._fix(e),$("body").hasClass("fixed")?a._fixForFixed(c):$(".content-wrapper, .right-side").height()<c.height()&&a._fixForContent(c)},open:function(a,b){b?a.addClass("control-sidebar-open"):$("body").addClass("control-sidebar-open")},close:function(a,b){b?a.removeClass("control-sidebar-open"):$("body").removeClass("control-sidebar-open")},_fix:function(a){var b=this;$("body").hasClass("layout-boxed")?(a.css("position","absolute"),a.height($(".wrapper").height()),$(window).resize(function(){b._fix(a)})):a.css({position:"fixed",height:"auto"})},_fixForFixed:function(a){a.css({position:"fixed","max-height":"100%",overflow:"auto","padding-bottom":"50px"})},_fixForContent:function(a){$(".content-wrapper, .right-side").css("min-height",a.height())}},$.AdminLTE.boxWidget={selectors:$.AdminLTE.options.boxWidgetOptions.boxWidgetSelectors,icons:$.AdminLTE.options.boxWidgetOptions.boxWidgetIcons,animationSpeed:$.AdminLTE.options.animationSpeed,activate:function(a){var b=this;a||(a=document),$(a).on("click",b.selectors.collapse,function(a){a.preventDefault(),b.collapse($(this))}),$(a).on("click",b.selectors.remove,function(a){a.preventDefault(),b.remove($(this))})},collapse:function(a){var b=this,c=a.parents(".box").first(),d=c.find("> .box-body, > .box-footer, > form  >.box-body, > form > .box-footer");c.hasClass("collapsed-box")?(a.children(":first").removeClass(b.icons.open).addClass(b.icons.collapse),d.slideDown(b.animationSpeed,function(){c.removeClass("collapsed-box")})):(a.children(":first").removeClass(b.icons.collapse).addClass(b.icons.open),d.slideUp(b.animationSpeed,function(){c.addClass("collapsed-box")}))},remove:function(a){var b=a.parents(".box").first();b.slideUp(this.animationSpeed)}}}if("undefined"==typeof jQuery)throw new Error("AdminLTE requires jQuery");$.AdminLTE={},$.AdminLTE.options={navbarMenuSlimscroll:!0,navbarMenuSlimscrollWidth:"3px",navbarMenuHeight:"200px",animationSpeed:500,sidebarToggleSelector:"[data-toggle='offcanvas']",sidebarPushMenu:!0,sidebarSlimScroll:!0,sidebarExpandOnHover:!1,enableBoxRefresh:!0,enableBSToppltip:!0,BSTooltipSelector:"[data-toggle='tooltip']",enableFastclick:!0,enableControlSidebar:!0,controlSidebarOptions:{toggleBtnSelector:"[data-toggle='control-sidebar']",selector:".control-sidebar",slide:!0},enableBoxWidget:!0,boxWidgetOptions:{boxWidgetIcons:{collapse:"fa-minus",open:"fa-plus",remove:"fa-times"},boxWidgetSelectors:{remove:'[data-widget="remove"]',collapse:'[data-widget="collapse"]'}},directChat:{enable:!0,contactToggleSelector:'[data-widget="chat-pane-toggle"]'},colors:{lightBlue:"#3c8dbc",red:"#f56954",green:"#00a65a",aqua:"#00c0ef",yellow:"#f39c12",blue:"#0073b7",navy:"#001F3F",teal:"#39CCCC",olive:"#3D9970",lime:"#01FF70",orange:"#FF851B",fuchsia:"#F012BE",purple:"#8E24AA",maroon:"#D81B60",black:"#222222",gray:"#d2d6de"},screenSizes:{xs:480,sm:768,md:992,lg:1200}},$(function(){"use strict";$("body").removeClass("hold-transition"),"undefined"!=typeof AdminLTEOptions&&$.extend(!0,$.AdminLTE.options,AdminLTEOptions);var a=$.AdminLTE.options;_init(),$.AdminLTE.layout.activate(),$.AdminLTE.tree(".sidebar"),a.enableControlSidebar&&$.AdminLTE.controlSidebar.activate(),a.navbarMenuSlimscroll&&"undefined"!=typeof $.fn.slimscroll&&$(".navbar .menu").slimscroll({height:a.navbarMenuHeight,alwaysVisible:!1,size:a.navbarMenuSlimscrollWidth}).css("width","100%"),a.sidebarPushMenu&&$.AdminLTE.pushMenu.activate(a.sidebarToggleSelector),a.enableBSToppltip&&$("body").tooltip({selector:a.BSTooltipSelector}),a.enableBoxWidget&&$.AdminLTE.boxWidget.activate(),a.enableFastclick&&"undefined"!=typeof FastClick&&FastClick.attach(document.body),a.directChat.enable&&$(document).on("click",a.directChat.contactToggleSelector,function(){var a=$(this).parents(".direct-chat").first();a.toggleClass("direct-chat-contacts-open")}),$('.btn-group[data-toggle="btn-toggle"]').each(function(){var a=$(this);$(this).find(".btn").on("click",function(b){a.find(".btn.active").removeClass("active"),$(this).addClass("active"),b.preventDefault()})})}),function(a){"use strict";a.fn.boxRefresh=function(b){function c(a){a.append(f),e.onLoadStart.call(a)}function d(a){a.find(f).remove(),e.onLoadDone.call(a)}var e=a.extend({trigger:".refresh-btn",source:"",onLoadStart:function(a){return a},onLoadDone:function(a){return a}},b),f=a('<div class="overlay"><div class="fa fa-refresh fa-spin"></div></div>');return this.each(function(){if(""===e.source)return void(window.console&&window.console.log("Please specify a source first - boxRefresh()"));var b=a(this),f=b.find(e.trigger).first();f.on("click",function(a){a.preventDefault(),c(b),b.find(".box-body").load(e.source,function(){d(b)})})})}}(jQuery),function(a){"use strict";a.fn.activateBox=function(){a.AdminLTE.boxWidget.activate(this)},a.fn.toggleBox=function(){var b=a(a.AdminLTE.boxWidget.selectors.collapse,this);a.AdminLTE.boxWidget.collapse(b)},a.fn.removeBox=function(){var b=a(a.AdminLTE.boxWidget.selectors.remove,this);a.AdminLTE.boxWidget.remove(b)}}(jQuery),function(a){"use strict";a.fn.todolist=function(b){var c=a.extend({onCheck:function(a){return a},onUncheck:function(a){return a}},b);return this.each(function(){"undefined"!=typeof a.fn.iCheck?(a("input",this).on("ifChecked",function(){var b=a(this).parents("li").first();b.toggleClass("done"),c.onCheck.call(b)}),a("input",this).on("ifUnchecked",function(){var b=a(this).parents("li").first();b.toggleClass("done"),c.onUncheck.call(b)})):a("input",this).on("change",function(){var b=a(this).parents("li").first();b.toggleClass("done"),a("input",b).is(":checked")?c.onCheck.call(b):c.onUncheck.call(b)})})}}(jQuery);
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1), __webpack_require__(1)))

/***/ },
/* 66 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*! jQuery UI - v1.11.4 - 2015-03-11
	* http://jqueryui.com
	* Includes: core.js, widget.js, mouse.js, position.js, accordion.js, autocomplete.js, button.js, datepicker.js, dialog.js, draggable.js, droppable.js, effect.js, effect-blind.js, effect-bounce.js, effect-clip.js, effect-drop.js, effect-explode.js, effect-fade.js, effect-fold.js, effect-highlight.js, effect-puff.js, effect-pulsate.js, effect-scale.js, effect-shake.js, effect-size.js, effect-slide.js, effect-transfer.js, menu.js, progressbar.js, resizable.js, selectable.js, selectmenu.js, slider.js, sortable.js, spinner.js, tabs.js, tooltip.js
	* Copyright 2015 jQuery Foundation and other contributors; Licensed MIT */
	
	(function( factory ) {
		if ( true ) {
	
			// AMD. Register as an anonymous module.
			!(__WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__(1) ], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
		} else {
	
			// Browser globals
			factory( jQuery );
		}
	}(function( $ ) {
	/*!
	 * jQuery UI Core 1.11.4
	 * http://jqueryui.com
	 *
	 * Copyright jQuery Foundation and other contributors
	 * Released under the MIT license.
	 * http://jquery.org/license
	 *
	 * http://api.jqueryui.com/category/ui-core/
	 */
	
	
	// $.ui might exist from components with no dependencies, e.g., $.ui.position
	$.ui = $.ui || {};
	
	$.extend( $.ui, {
		version: "1.11.4",
	
		keyCode: {
			BACKSPACE: 8,
			COMMA: 188,
			DELETE: 46,
			DOWN: 40,
			END: 35,
			ENTER: 13,
			ESCAPE: 27,
			HOME: 36,
			LEFT: 37,
			PAGE_DOWN: 34,
			PAGE_UP: 33,
			PERIOD: 190,
			RIGHT: 39,
			SPACE: 32,
			TAB: 9,
			UP: 38
		}
	});
	
	// plugins
	$.fn.extend({
		scrollParent: function( includeHidden ) {
			var position = this.css( "position" ),
				excludeStaticParent = position === "absolute",
				overflowRegex = includeHidden ? /(auto|scroll|hidden)/ : /(auto|scroll)/,
				scrollParent = this.parents().filter( function() {
					var parent = $( this );
					if ( excludeStaticParent && parent.css( "position" ) === "static" ) {
						return false;
					}
					return overflowRegex.test( parent.css( "overflow" ) + parent.css( "overflow-y" ) + parent.css( "overflow-x" ) );
				}).eq( 0 );
	
			return position === "fixed" || !scrollParent.length ? $( this[ 0 ].ownerDocument || document ) : scrollParent;
		},
	
		uniqueId: (function() {
			var uuid = 0;
	
			return function() {
				return this.each(function() {
					if ( !this.id ) {
						this.id = "ui-id-" + ( ++uuid );
					}
				});
			};
		})(),
	
		removeUniqueId: function() {
			return this.each(function() {
				if ( /^ui-id-\d+$/.test( this.id ) ) {
					$( this ).removeAttr( "id" );
				}
			});
		}
	});
	
	// selectors
	function focusable( element, isTabIndexNotNaN ) {
		var map, mapName, img,
			nodeName = element.nodeName.toLowerCase();
		if ( "area" === nodeName ) {
			map = element.parentNode;
			mapName = map.name;
			if ( !element.href || !mapName || map.nodeName.toLowerCase() !== "map" ) {
				return false;
			}
			img = $( "img[usemap='#" + mapName + "']" )[ 0 ];
			return !!img && visible( img );
		}
		return ( /^(input|select|textarea|button|object)$/.test( nodeName ) ?
			!element.disabled :
			"a" === nodeName ?
				element.href || isTabIndexNotNaN :
				isTabIndexNotNaN) &&
			// the element and all of its ancestors must be visible
			visible( element );
	}
	
	function visible( element ) {
		return $.expr.filters.visible( element ) &&
			!$( element ).parents().addBack().filter(function() {
				return $.css( this, "visibility" ) === "hidden";
			}).length;
	}
	
	$.extend( $.expr[ ":" ], {
		data: $.expr.createPseudo ?
			$.expr.createPseudo(function( dataName ) {
				return function( elem ) {
					return !!$.data( elem, dataName );
				};
			}) :
			// support: jQuery <1.8
			function( elem, i, match ) {
				return !!$.data( elem, match[ 3 ] );
			},
	
		focusable: function( element ) {
			return focusable( element, !isNaN( $.attr( element, "tabindex" ) ) );
		},
	
		tabbable: function( element ) {
			var tabIndex = $.attr( element, "tabindex" ),
				isTabIndexNaN = isNaN( tabIndex );
			return ( isTabIndexNaN || tabIndex >= 0 ) && focusable( element, !isTabIndexNaN );
		}
	});
	
	// support: jQuery <1.8
	if ( !$( "<a>" ).outerWidth( 1 ).jquery ) {
		$.each( [ "Width", "Height" ], function( i, name ) {
			var side = name === "Width" ? [ "Left", "Right" ] : [ "Top", "Bottom" ],
				type = name.toLowerCase(),
				orig = {
					innerWidth: $.fn.innerWidth,
					innerHeight: $.fn.innerHeight,
					outerWidth: $.fn.outerWidth,
					outerHeight: $.fn.outerHeight
				};
	
			function reduce( elem, size, border, margin ) {
				$.each( side, function() {
					size -= parseFloat( $.css( elem, "padding" + this ) ) || 0;
					if ( border ) {
						size -= parseFloat( $.css( elem, "border" + this + "Width" ) ) || 0;
					}
					if ( margin ) {
						size -= parseFloat( $.css( elem, "margin" + this ) ) || 0;
					}
				});
				return size;
			}
	
			$.fn[ "inner" + name ] = function( size ) {
				if ( size === undefined ) {
					return orig[ "inner" + name ].call( this );
				}
	
				return this.each(function() {
					$( this ).css( type, reduce( this, size ) + "px" );
				});
			};
	
			$.fn[ "outer" + name] = function( size, margin ) {
				if ( typeof size !== "number" ) {
					return orig[ "outer" + name ].call( this, size );
				}
	
				return this.each(function() {
					$( this).css( type, reduce( this, size, true, margin ) + "px" );
				});
			};
		});
	}
	
	// support: jQuery <1.8
	if ( !$.fn.addBack ) {
		$.fn.addBack = function( selector ) {
			return this.add( selector == null ?
				this.prevObject : this.prevObject.filter( selector )
			);
		};
	}
	
	// support: jQuery 1.6.1, 1.6.2 (http://bugs.jquery.com/ticket/9413)
	if ( $( "<a>" ).data( "a-b", "a" ).removeData( "a-b" ).data( "a-b" ) ) {
		$.fn.removeData = (function( removeData ) {
			return function( key ) {
				if ( arguments.length ) {
					return removeData.call( this, $.camelCase( key ) );
				} else {
					return removeData.call( this );
				}
			};
		})( $.fn.removeData );
	}
	
	// deprecated
	$.ui.ie = !!/msie [\w.]+/.exec( navigator.userAgent.toLowerCase() );
	
	$.fn.extend({
		focus: (function( orig ) {
			return function( delay, fn ) {
				return typeof delay === "number" ?
					this.each(function() {
						var elem = this;
						setTimeout(function() {
							$( elem ).focus();
							if ( fn ) {
								fn.call( elem );
							}
						}, delay );
					}) :
					orig.apply( this, arguments );
			};
		})( $.fn.focus ),
	
		disableSelection: (function() {
			var eventType = "onselectstart" in document.createElement( "div" ) ?
				"selectstart" :
				"mousedown";
	
			return function() {
				return this.bind( eventType + ".ui-disableSelection", function( event ) {
					event.preventDefault();
				});
			};
		})(),
	
		enableSelection: function() {
			return this.unbind( ".ui-disableSelection" );
		},
	
		zIndex: function( zIndex ) {
			if ( zIndex !== undefined ) {
				return this.css( "zIndex", zIndex );
			}
	
			if ( this.length ) {
				var elem = $( this[ 0 ] ), position, value;
				while ( elem.length && elem[ 0 ] !== document ) {
					// Ignore z-index if position is set to a value where z-index is ignored by the browser
					// This makes behavior of this function consistent across browsers
					// WebKit always returns auto if the element is positioned
					position = elem.css( "position" );
					if ( position === "absolute" || position === "relative" || position === "fixed" ) {
						// IE returns 0 when zIndex is not specified
						// other browsers return a string
						// we ignore the case of nested elements with an explicit value of 0
						// <div style="z-index: -10;"><div style="z-index: 0;"></div></div>
						value = parseInt( elem.css( "zIndex" ), 10 );
						if ( !isNaN( value ) && value !== 0 ) {
							return value;
						}
					}
					elem = elem.parent();
				}
			}
	
			return 0;
		}
	});
	
	// $.ui.plugin is deprecated. Use $.widget() extensions instead.
	$.ui.plugin = {
		add: function( module, option, set ) {
			var i,
				proto = $.ui[ module ].prototype;
			for ( i in set ) {
				proto.plugins[ i ] = proto.plugins[ i ] || [];
				proto.plugins[ i ].push( [ option, set[ i ] ] );
			}
		},
		call: function( instance, name, args, allowDisconnected ) {
			var i,
				set = instance.plugins[ name ];
	
			if ( !set ) {
				return;
			}
	
			if ( !allowDisconnected && ( !instance.element[ 0 ].parentNode || instance.element[ 0 ].parentNode.nodeType === 11 ) ) {
				return;
			}
	
			for ( i = 0; i < set.length; i++ ) {
				if ( instance.options[ set[ i ][ 0 ] ] ) {
					set[ i ][ 1 ].apply( instance.element, args );
				}
			}
		}
	};
	
	
	/*!
	 * jQuery UI Widget 1.11.4
	 * http://jqueryui.com
	 *
	 * Copyright jQuery Foundation and other contributors
	 * Released under the MIT license.
	 * http://jquery.org/license
	 *
	 * http://api.jqueryui.com/jQuery.widget/
	 */
	
	
	var widget_uuid = 0,
		widget_slice = Array.prototype.slice;
	
	$.cleanData = (function( orig ) {
		return function( elems ) {
			var events, elem, i;
			for ( i = 0; (elem = elems[i]) != null; i++ ) {
				try {
	
					// Only trigger remove when necessary to save time
					events = $._data( elem, "events" );
					if ( events && events.remove ) {
						$( elem ).triggerHandler( "remove" );
					}
	
				// http://bugs.jquery.com/ticket/8235
				} catch ( e ) {}
			}
			orig( elems );
		};
	})( $.cleanData );
	
	$.widget = function( name, base, prototype ) {
		var fullName, existingConstructor, constructor, basePrototype,
			// proxiedPrototype allows the provided prototype to remain unmodified
			// so that it can be used as a mixin for multiple widgets (#8876)
			proxiedPrototype = {},
			namespace = name.split( "." )[ 0 ];
	
		name = name.split( "." )[ 1 ];
		fullName = namespace + "-" + name;
	
		if ( !prototype ) {
			prototype = base;
			base = $.Widget;
		}
	
		// create selector for plugin
		$.expr[ ":" ][ fullName.toLowerCase() ] = function( elem ) {
			return !!$.data( elem, fullName );
		};
	
		$[ namespace ] = $[ namespace ] || {};
		existingConstructor = $[ namespace ][ name ];
		constructor = $[ namespace ][ name ] = function( options, element ) {
			// allow instantiation without "new" keyword
			if ( !this._createWidget ) {
				return new constructor( options, element );
			}
	
			// allow instantiation without initializing for simple inheritance
			// must use "new" keyword (the code above always passes args)
			if ( arguments.length ) {
				this._createWidget( options, element );
			}
		};
		// extend with the existing constructor to carry over any static properties
		$.extend( constructor, existingConstructor, {
			version: prototype.version,
			// copy the object used to create the prototype in case we need to
			// redefine the widget later
			_proto: $.extend( {}, prototype ),
			// track widgets that inherit from this widget in case this widget is
			// redefined after a widget inherits from it
			_childConstructors: []
		});
	
		basePrototype = new base();
		// we need to make the options hash a property directly on the new instance
		// otherwise we'll modify the options hash on the prototype that we're
		// inheriting from
		basePrototype.options = $.widget.extend( {}, basePrototype.options );
		$.each( prototype, function( prop, value ) {
			if ( !$.isFunction( value ) ) {
				proxiedPrototype[ prop ] = value;
				return;
			}
			proxiedPrototype[ prop ] = (function() {
				var _super = function() {
						return base.prototype[ prop ].apply( this, arguments );
					},
					_superApply = function( args ) {
						return base.prototype[ prop ].apply( this, args );
					};
				return function() {
					var __super = this._super,
						__superApply = this._superApply,
						returnValue;
	
					this._super = _super;
					this._superApply = _superApply;
	
					returnValue = value.apply( this, arguments );
	
					this._super = __super;
					this._superApply = __superApply;
	
					return returnValue;
				};
			})();
		});
		constructor.prototype = $.widget.extend( basePrototype, {
			// TODO: remove support for widgetEventPrefix
			// always use the name + a colon as the prefix, e.g., draggable:start
			// don't prefix for widgets that aren't DOM-based
			widgetEventPrefix: existingConstructor ? (basePrototype.widgetEventPrefix || name) : name
		}, proxiedPrototype, {
			constructor: constructor,
			namespace: namespace,
			widgetName: name,
			widgetFullName: fullName
		});
	
		// If this widget is being redefined then we need to find all widgets that
		// are inheriting from it and redefine all of them so that they inherit from
		// the new version of this widget. We're essentially trying to replace one
		// level in the prototype chain.
		if ( existingConstructor ) {
			$.each( existingConstructor._childConstructors, function( i, child ) {
				var childPrototype = child.prototype;
	
				// redefine the child widget using the same prototype that was
				// originally used, but inherit from the new version of the base
				$.widget( childPrototype.namespace + "." + childPrototype.widgetName, constructor, child._proto );
			});
			// remove the list of existing child constructors from the old constructor
			// so the old child constructors can be garbage collected
			delete existingConstructor._childConstructors;
		} else {
			base._childConstructors.push( constructor );
		}
	
		$.widget.bridge( name, constructor );
	
		return constructor;
	};
	
	$.widget.extend = function( target ) {
		var input = widget_slice.call( arguments, 1 ),
			inputIndex = 0,
			inputLength = input.length,
			key,
			value;
		for ( ; inputIndex < inputLength; inputIndex++ ) {
			for ( key in input[ inputIndex ] ) {
				value = input[ inputIndex ][ key ];
				if ( input[ inputIndex ].hasOwnProperty( key ) && value !== undefined ) {
					// Clone objects
					if ( $.isPlainObject( value ) ) {
						target[ key ] = $.isPlainObject( target[ key ] ) ?
							$.widget.extend( {}, target[ key ], value ) :
							// Don't extend strings, arrays, etc. with objects
							$.widget.extend( {}, value );
					// Copy everything else by reference
					} else {
						target[ key ] = value;
					}
				}
			}
		}
		return target;
	};
	
	$.widget.bridge = function( name, object ) {
		var fullName = object.prototype.widgetFullName || name;
		$.fn[ name ] = function( options ) {
			var isMethodCall = typeof options === "string",
				args = widget_slice.call( arguments, 1 ),
				returnValue = this;
	
			if ( isMethodCall ) {
				this.each(function() {
					var methodValue,
						instance = $.data( this, fullName );
					if ( options === "instance" ) {
						returnValue = instance;
						return false;
					}
					if ( !instance ) {
						return $.error( "cannot call methods on " + name + " prior to initialization; " +
							"attempted to call method '" + options + "'" );
					}
					if ( !$.isFunction( instance[options] ) || options.charAt( 0 ) === "_" ) {
						return $.error( "no such method '" + options + "' for " + name + " widget instance" );
					}
					methodValue = instance[ options ].apply( instance, args );
					if ( methodValue !== instance && methodValue !== undefined ) {
						returnValue = methodValue && methodValue.jquery ?
							returnValue.pushStack( methodValue.get() ) :
							methodValue;
						return false;
					}
				});
			} else {
	
				// Allow multiple hashes to be passed on init
				if ( args.length ) {
					options = $.widget.extend.apply( null, [ options ].concat(args) );
				}
	
				this.each(function() {
					var instance = $.data( this, fullName );
					if ( instance ) {
						instance.option( options || {} );
						if ( instance._init ) {
							instance._init();
						}
					} else {
						$.data( this, fullName, new object( options, this ) );
					}
				});
			}
	
			return returnValue;
		};
	};
	
	$.Widget = function( /* options, element */ ) {};
	$.Widget._childConstructors = [];
	
	$.Widget.prototype = {
		widgetName: "widget",
		widgetEventPrefix: "",
		defaultElement: "<div>",
		options: {
			disabled: false,
	
			// callbacks
			create: null
		},
		_createWidget: function( options, element ) {
			element = $( element || this.defaultElement || this )[ 0 ];
			this.element = $( element );
			this.uuid = widget_uuid++;
			this.eventNamespace = "." + this.widgetName + this.uuid;
	
			this.bindings = $();
			this.hoverable = $();
			this.focusable = $();
	
			if ( element !== this ) {
				$.data( element, this.widgetFullName, this );
				this._on( true, this.element, {
					remove: function( event ) {
						if ( event.target === element ) {
							this.destroy();
						}
					}
				});
				this.document = $( element.style ?
					// element within the document
					element.ownerDocument :
					// element is window or document
					element.document || element );
				this.window = $( this.document[0].defaultView || this.document[0].parentWindow );
			}
	
			this.options = $.widget.extend( {},
				this.options,
				this._getCreateOptions(),
				options );
	
			this._create();
			this._trigger( "create", null, this._getCreateEventData() );
			this._init();
		},
		_getCreateOptions: $.noop,
		_getCreateEventData: $.noop,
		_create: $.noop,
		_init: $.noop,
	
		destroy: function() {
			this._destroy();
			// we can probably remove the unbind calls in 2.0
			// all event bindings should go through this._on()
			this.element
				.unbind( this.eventNamespace )
				.removeData( this.widgetFullName )
				// support: jquery <1.6.3
				// http://bugs.jquery.com/ticket/9413
				.removeData( $.camelCase( this.widgetFullName ) );
			this.widget()
				.unbind( this.eventNamespace )
				.removeAttr( "aria-disabled" )
				.removeClass(
					this.widgetFullName + "-disabled " +
					"ui-state-disabled" );
	
			// clean up events and states
			this.bindings.unbind( this.eventNamespace );
			this.hoverable.removeClass( "ui-state-hover" );
			this.focusable.removeClass( "ui-state-focus" );
		},
		_destroy: $.noop,
	
		widget: function() {
			return this.element;
		},
	
		option: function( key, value ) {
			var options = key,
				parts,
				curOption,
				i;
	
			if ( arguments.length === 0 ) {
				// don't return a reference to the internal hash
				return $.widget.extend( {}, this.options );
			}
	
			if ( typeof key === "string" ) {
				// handle nested keys, e.g., "foo.bar" => { foo: { bar: ___ } }
				options = {};
				parts = key.split( "." );
				key = parts.shift();
				if ( parts.length ) {
					curOption = options[ key ] = $.widget.extend( {}, this.options[ key ] );
					for ( i = 0; i < parts.length - 1; i++ ) {
						curOption[ parts[ i ] ] = curOption[ parts[ i ] ] || {};
						curOption = curOption[ parts[ i ] ];
					}
					key = parts.pop();
					if ( arguments.length === 1 ) {
						return curOption[ key ] === undefined ? null : curOption[ key ];
					}
					curOption[ key ] = value;
				} else {
					if ( arguments.length === 1 ) {
						return this.options[ key ] === undefined ? null : this.options[ key ];
					}
					options[ key ] = value;
				}
			}
	
			this._setOptions( options );
	
			return this;
		},
		_setOptions: function( options ) {
			var key;
	
			for ( key in options ) {
				this._setOption( key, options[ key ] );
			}
	
			return this;
		},
		_setOption: function( key, value ) {
			this.options[ key ] = value;
	
			if ( key === "disabled" ) {
				this.widget()
					.toggleClass( this.widgetFullName + "-disabled", !!value );
	
				// If the widget is becoming disabled, then nothing is interactive
				if ( value ) {
					this.hoverable.removeClass( "ui-state-hover" );
					this.focusable.removeClass( "ui-state-focus" );
				}
			}
	
			return this;
		},
	
		enable: function() {
			return this._setOptions({ disabled: false });
		},
		disable: function() {
			return this._setOptions({ disabled: true });
		},
	
		_on: function( suppressDisabledCheck, element, handlers ) {
			var delegateElement,
				instance = this;
	
			// no suppressDisabledCheck flag, shuffle arguments
			if ( typeof suppressDisabledCheck !== "boolean" ) {
				handlers = element;
				element = suppressDisabledCheck;
				suppressDisabledCheck = false;
			}
	
			// no element argument, shuffle and use this.element
			if ( !handlers ) {
				handlers = element;
				element = this.element;
				delegateElement = this.widget();
			} else {
				element = delegateElement = $( element );
				this.bindings = this.bindings.add( element );
			}
	
			$.each( handlers, function( event, handler ) {
				function handlerProxy() {
					// allow widgets to customize the disabled handling
					// - disabled as an array instead of boolean
					// - disabled class as method for disabling individual parts
					if ( !suppressDisabledCheck &&
							( instance.options.disabled === true ||
								$( this ).hasClass( "ui-state-disabled" ) ) ) {
						return;
					}
					return ( typeof handler === "string" ? instance[ handler ] : handler )
						.apply( instance, arguments );
				}
	
				// copy the guid so direct unbinding works
				if ( typeof handler !== "string" ) {
					handlerProxy.guid = handler.guid =
						handler.guid || handlerProxy.guid || $.guid++;
				}
	
				var match = event.match( /^([\w:-]*)\s*(.*)$/ ),
					eventName = match[1] + instance.eventNamespace,
					selector = match[2];
				if ( selector ) {
					delegateElement.delegate( selector, eventName, handlerProxy );
				} else {
					element.bind( eventName, handlerProxy );
				}
			});
		},
	
		_off: function( element, eventName ) {
			eventName = (eventName || "").split( " " ).join( this.eventNamespace + " " ) +
				this.eventNamespace;
			element.unbind( eventName ).undelegate( eventName );
	
			// Clear the stack to avoid memory leaks (#10056)
			this.bindings = $( this.bindings.not( element ).get() );
			this.focusable = $( this.focusable.not( element ).get() );
			this.hoverable = $( this.hoverable.not( element ).get() );
		},
	
		_delay: function( handler, delay ) {
			function handlerProxy() {
				return ( typeof handler === "string" ? instance[ handler ] : handler )
					.apply( instance, arguments );
			}
			var instance = this;
			return setTimeout( handlerProxy, delay || 0 );
		},
	
		_hoverable: function( element ) {
			this.hoverable = this.hoverable.add( element );
			this._on( element, {
				mouseenter: function( event ) {
					$( event.currentTarget ).addClass( "ui-state-hover" );
				},
				mouseleave: function( event ) {
					$( event.currentTarget ).removeClass( "ui-state-hover" );
				}
			});
		},
	
		_focusable: function( element ) {
			this.focusable = this.focusable.add( element );
			this._on( element, {
				focusin: function( event ) {
					$( event.currentTarget ).addClass( "ui-state-focus" );
				},
				focusout: function( event ) {
					$( event.currentTarget ).removeClass( "ui-state-focus" );
				}
			});
		},
	
		_trigger: function( type, event, data ) {
			var prop, orig,
				callback = this.options[ type ];
	
			data = data || {};
			event = $.Event( event );
			event.type = ( type === this.widgetEventPrefix ?
				type :
				this.widgetEventPrefix + type ).toLowerCase();
			// the original event may come from any element
			// so we need to reset the target on the new event
			event.target = this.element[ 0 ];
	
			// copy original event properties over to the new event
			orig = event.originalEvent;
			if ( orig ) {
				for ( prop in orig ) {
					if ( !( prop in event ) ) {
						event[ prop ] = orig[ prop ];
					}
				}
			}
	
			this.element.trigger( event, data );
			return !( $.isFunction( callback ) &&
				callback.apply( this.element[0], [ event ].concat( data ) ) === false ||
				event.isDefaultPrevented() );
		}
	};
	
	$.each( { show: "fadeIn", hide: "fadeOut" }, function( method, defaultEffect ) {
		$.Widget.prototype[ "_" + method ] = function( element, options, callback ) {
			if ( typeof options === "string" ) {
				options = { effect: options };
			}
			var hasOptions,
				effectName = !options ?
					method :
					options === true || typeof options === "number" ?
						defaultEffect :
						options.effect || defaultEffect;
			options = options || {};
			if ( typeof options === "number" ) {
				options = { duration: options };
			}
			hasOptions = !$.isEmptyObject( options );
			options.complete = callback;
			if ( options.delay ) {
				element.delay( options.delay );
			}
			if ( hasOptions && $.effects && $.effects.effect[ effectName ] ) {
				element[ method ]( options );
			} else if ( effectName !== method && element[ effectName ] ) {
				element[ effectName ]( options.duration, options.easing, callback );
			} else {
				element.queue(function( next ) {
					$( this )[ method ]();
					if ( callback ) {
						callback.call( element[ 0 ] );
					}
					next();
				});
			}
		};
	});
	
	var widget = $.widget;
	
	
	/*!
	 * jQuery UI Mouse 1.11.4
	 * http://jqueryui.com
	 *
	 * Copyright jQuery Foundation and other contributors
	 * Released under the MIT license.
	 * http://jquery.org/license
	 *
	 * http://api.jqueryui.com/mouse/
	 */
	
	
	var mouseHandled = false;
	$( document ).mouseup( function() {
		mouseHandled = false;
	});
	
	var mouse = $.widget("ui.mouse", {
		version: "1.11.4",
		options: {
			cancel: "input,textarea,button,select,option",
			distance: 1,
			delay: 0
		},
		_mouseInit: function() {
			var that = this;
	
			this.element
				.bind("mousedown." + this.widgetName, function(event) {
					return that._mouseDown(event);
				})
				.bind("click." + this.widgetName, function(event) {
					if (true === $.data(event.target, that.widgetName + ".preventClickEvent")) {
						$.removeData(event.target, that.widgetName + ".preventClickEvent");
						event.stopImmediatePropagation();
						return false;
					}
				});
	
			this.started = false;
		},
	
		// TODO: make sure destroying one instance of mouse doesn't mess with
		// other instances of mouse
		_mouseDestroy: function() {
			this.element.unbind("." + this.widgetName);
			if ( this._mouseMoveDelegate ) {
				this.document
					.unbind("mousemove." + this.widgetName, this._mouseMoveDelegate)
					.unbind("mouseup." + this.widgetName, this._mouseUpDelegate);
			}
		},
	
		_mouseDown: function(event) {
			// don't let more than one widget handle mouseStart
			if ( mouseHandled ) {
				return;
			}
	
			this._mouseMoved = false;
	
			// we may have missed mouseup (out of window)
			(this._mouseStarted && this._mouseUp(event));
	
			this._mouseDownEvent = event;
	
			var that = this,
				btnIsLeft = (event.which === 1),
				// event.target.nodeName works around a bug in IE 8 with
				// disabled inputs (#7620)
				elIsCancel = (typeof this.options.cancel === "string" && event.target.nodeName ? $(event.target).closest(this.options.cancel).length : false);
			if (!btnIsLeft || elIsCancel || !this._mouseCapture(event)) {
				return true;
			}
	
			this.mouseDelayMet = !this.options.delay;
			if (!this.mouseDelayMet) {
				this._mouseDelayTimer = setTimeout(function() {
					that.mouseDelayMet = true;
				}, this.options.delay);
			}
	
			if (this._mouseDistanceMet(event) && this._mouseDelayMet(event)) {
				this._mouseStarted = (this._mouseStart(event) !== false);
				if (!this._mouseStarted) {
					event.preventDefault();
					return true;
				}
			}
	
			// Click event may never have fired (Gecko & Opera)
			if (true === $.data(event.target, this.widgetName + ".preventClickEvent")) {
				$.removeData(event.target, this.widgetName + ".preventClickEvent");
			}
	
			// these delegates are required to keep context
			this._mouseMoveDelegate = function(event) {
				return that._mouseMove(event);
			};
			this._mouseUpDelegate = function(event) {
				return that._mouseUp(event);
			};
	
			this.document
				.bind( "mousemove." + this.widgetName, this._mouseMoveDelegate )
				.bind( "mouseup." + this.widgetName, this._mouseUpDelegate );
	
			event.preventDefault();
	
			mouseHandled = true;
			return true;
		},
	
		_mouseMove: function(event) {
			// Only check for mouseups outside the document if you've moved inside the document
			// at least once. This prevents the firing of mouseup in the case of IE<9, which will
			// fire a mousemove event if content is placed under the cursor. See #7778
			// Support: IE <9
			if ( this._mouseMoved ) {
				// IE mouseup check - mouseup happened when mouse was out of window
				if ($.ui.ie && ( !document.documentMode || document.documentMode < 9 ) && !event.button) {
					return this._mouseUp(event);
	
				// Iframe mouseup check - mouseup occurred in another document
				} else if ( !event.which ) {
					return this._mouseUp( event );
				}
			}
	
			if ( event.which || event.button ) {
				this._mouseMoved = true;
			}
	
			if (this._mouseStarted) {
				this._mouseDrag(event);
				return event.preventDefault();
			}
	
			if (this._mouseDistanceMet(event) && this._mouseDelayMet(event)) {
				this._mouseStarted =
					(this._mouseStart(this._mouseDownEvent, event) !== false);
				(this._mouseStarted ? this._mouseDrag(event) : this._mouseUp(event));
			}
	
			return !this._mouseStarted;
		},
	
		_mouseUp: function(event) {
			this.document
				.unbind( "mousemove." + this.widgetName, this._mouseMoveDelegate )
				.unbind( "mouseup." + this.widgetName, this._mouseUpDelegate );
	
			if (this._mouseStarted) {
				this._mouseStarted = false;
	
				if (event.target === this._mouseDownEvent.target) {
					$.data(event.target, this.widgetName + ".preventClickEvent", true);
				}
	
				this._mouseStop(event);
			}
	
			mouseHandled = false;
			return false;
		},
	
		_mouseDistanceMet: function(event) {
			return (Math.max(
					Math.abs(this._mouseDownEvent.pageX - event.pageX),
					Math.abs(this._mouseDownEvent.pageY - event.pageY)
				) >= this.options.distance
			);
		},
	
		_mouseDelayMet: function(/* event */) {
			return this.mouseDelayMet;
		},
	
		// These are placeholder methods, to be overriden by extending plugin
		_mouseStart: function(/* event */) {},
		_mouseDrag: function(/* event */) {},
		_mouseStop: function(/* event */) {},
		_mouseCapture: function(/* event */) { return true; }
	});
	
	
	/*!
	 * jQuery UI Position 1.11.4
	 * http://jqueryui.com
	 *
	 * Copyright jQuery Foundation and other contributors
	 * Released under the MIT license.
	 * http://jquery.org/license
	 *
	 * http://api.jqueryui.com/position/
	 */
	
	(function() {
	
	$.ui = $.ui || {};
	
	var cachedScrollbarWidth, supportsOffsetFractions,
		max = Math.max,
		abs = Math.abs,
		round = Math.round,
		rhorizontal = /left|center|right/,
		rvertical = /top|center|bottom/,
		roffset = /[\+\-]\d+(\.[\d]+)?%?/,
		rposition = /^\w+/,
		rpercent = /%$/,
		_position = $.fn.position;
	
	function getOffsets( offsets, width, height ) {
		return [
			parseFloat( offsets[ 0 ] ) * ( rpercent.test( offsets[ 0 ] ) ? width / 100 : 1 ),
			parseFloat( offsets[ 1 ] ) * ( rpercent.test( offsets[ 1 ] ) ? height / 100 : 1 )
		];
	}
	
	function parseCss( element, property ) {
		return parseInt( $.css( element, property ), 10 ) || 0;
	}
	
	function getDimensions( elem ) {
		var raw = elem[0];
		if ( raw.nodeType === 9 ) {
			return {
				width: elem.width(),
				height: elem.height(),
				offset: { top: 0, left: 0 }
			};
		}
		if ( $.isWindow( raw ) ) {
			return {
				width: elem.width(),
				height: elem.height(),
				offset: { top: elem.scrollTop(), left: elem.scrollLeft() }
			};
		}
		if ( raw.preventDefault ) {
			return {
				width: 0,
				height: 0,
				offset: { top: raw.pageY, left: raw.pageX }
			};
		}
		return {
			width: elem.outerWidth(),
			height: elem.outerHeight(),
			offset: elem.offset()
		};
	}
	
	$.position = {
		scrollbarWidth: function() {
			if ( cachedScrollbarWidth !== undefined ) {
				return cachedScrollbarWidth;
			}
			var w1, w2,
				div = $( "<div style='display:block;position:absolute;width:50px;height:50px;overflow:hidden;'><div style='height:100px;width:auto;'></div></div>" ),
				innerDiv = div.children()[0];
	
			$( "body" ).append( div );
			w1 = innerDiv.offsetWidth;
			div.css( "overflow", "scroll" );
	
			w2 = innerDiv.offsetWidth;
	
			if ( w1 === w2 ) {
				w2 = div[0].clientWidth;
			}
	
			div.remove();
	
			return (cachedScrollbarWidth = w1 - w2);
		},
		getScrollInfo: function( within ) {
			var overflowX = within.isWindow || within.isDocument ? "" :
					within.element.css( "overflow-x" ),
				overflowY = within.isWindow || within.isDocument ? "" :
					within.element.css( "overflow-y" ),
				hasOverflowX = overflowX === "scroll" ||
					( overflowX === "auto" && within.width < within.element[0].scrollWidth ),
				hasOverflowY = overflowY === "scroll" ||
					( overflowY === "auto" && within.height < within.element[0].scrollHeight );
			return {
				width: hasOverflowY ? $.position.scrollbarWidth() : 0,
				height: hasOverflowX ? $.position.scrollbarWidth() : 0
			};
		},
		getWithinInfo: function( element ) {
			var withinElement = $( element || window ),
				isWindow = $.isWindow( withinElement[0] ),
				isDocument = !!withinElement[ 0 ] && withinElement[ 0 ].nodeType === 9;
			return {
				element: withinElement,
				isWindow: isWindow,
				isDocument: isDocument,
				offset: withinElement.offset() || { left: 0, top: 0 },
				scrollLeft: withinElement.scrollLeft(),
				scrollTop: withinElement.scrollTop(),
	
				// support: jQuery 1.6.x
				// jQuery 1.6 doesn't support .outerWidth/Height() on documents or windows
				width: isWindow || isDocument ? withinElement.width() : withinElement.outerWidth(),
				height: isWindow || isDocument ? withinElement.height() : withinElement.outerHeight()
			};
		}
	};
	
	$.fn.position = function( options ) {
		if ( !options || !options.of ) {
			return _position.apply( this, arguments );
		}
	
		// make a copy, we don't want to modify arguments
		options = $.extend( {}, options );
	
		var atOffset, targetWidth, targetHeight, targetOffset, basePosition, dimensions,
			target = $( options.of ),
			within = $.position.getWithinInfo( options.within ),
			scrollInfo = $.position.getScrollInfo( within ),
			collision = ( options.collision || "flip" ).split( " " ),
			offsets = {};
	
		dimensions = getDimensions( target );
		if ( target[0].preventDefault ) {
			// force left top to allow flipping
			options.at = "left top";
		}
		targetWidth = dimensions.width;
		targetHeight = dimensions.height;
		targetOffset = dimensions.offset;
		// clone to reuse original targetOffset later
		basePosition = $.extend( {}, targetOffset );
	
		// force my and at to have valid horizontal and vertical positions
		// if a value is missing or invalid, it will be converted to center
		$.each( [ "my", "at" ], function() {
			var pos = ( options[ this ] || "" ).split( " " ),
				horizontalOffset,
				verticalOffset;
	
			if ( pos.length === 1) {
				pos = rhorizontal.test( pos[ 0 ] ) ?
					pos.concat( [ "center" ] ) :
					rvertical.test( pos[ 0 ] ) ?
						[ "center" ].concat( pos ) :
						[ "center", "center" ];
			}
			pos[ 0 ] = rhorizontal.test( pos[ 0 ] ) ? pos[ 0 ] : "center";
			pos[ 1 ] = rvertical.test( pos[ 1 ] ) ? pos[ 1 ] : "center";
	
			// calculate offsets
			horizontalOffset = roffset.exec( pos[ 0 ] );
			verticalOffset = roffset.exec( pos[ 1 ] );
			offsets[ this ] = [
				horizontalOffset ? horizontalOffset[ 0 ] : 0,
				verticalOffset ? verticalOffset[ 0 ] : 0
			];
	
			// reduce to just the positions without the offsets
			options[ this ] = [
				rposition.exec( pos[ 0 ] )[ 0 ],
				rposition.exec( pos[ 1 ] )[ 0 ]
			];
		});
	
		// normalize collision option
		if ( collision.length === 1 ) {
			collision[ 1 ] = collision[ 0 ];
		}
	
		if ( options.at[ 0 ] === "right" ) {
			basePosition.left += targetWidth;
		} else if ( options.at[ 0 ] === "center" ) {
			basePosition.left += targetWidth / 2;
		}
	
		if ( options.at[ 1 ] === "bottom" ) {
			basePosition.top += targetHeight;
		} else if ( options.at[ 1 ] === "center" ) {
			basePosition.top += targetHeight / 2;
		}
	
		atOffset = getOffsets( offsets.at, targetWidth, targetHeight );
		basePosition.left += atOffset[ 0 ];
		basePosition.top += atOffset[ 1 ];
	
		return this.each(function() {
			var collisionPosition, using,
				elem = $( this ),
				elemWidth = elem.outerWidth(),
				elemHeight = elem.outerHeight(),
				marginLeft = parseCss( this, "marginLeft" ),
				marginTop = parseCss( this, "marginTop" ),
				collisionWidth = elemWidth + marginLeft + parseCss( this, "marginRight" ) + scrollInfo.width,
				collisionHeight = elemHeight + marginTop + parseCss( this, "marginBottom" ) + scrollInfo.height,
				position = $.extend( {}, basePosition ),
				myOffset = getOffsets( offsets.my, elem.outerWidth(), elem.outerHeight() );
	
			if ( options.my[ 0 ] === "right" ) {
				position.left -= elemWidth;
			} else if ( options.my[ 0 ] === "center" ) {
				position.left -= elemWidth / 2;
			}
	
			if ( options.my[ 1 ] === "bottom" ) {
				position.top -= elemHeight;
			} else if ( options.my[ 1 ] === "center" ) {
				position.top -= elemHeight / 2;
			}
	
			position.left += myOffset[ 0 ];
			position.top += myOffset[ 1 ];
	
			// if the browser doesn't support fractions, then round for consistent results
			if ( !supportsOffsetFractions ) {
				position.left = round( position.left );
				position.top = round( position.top );
			}
	
			collisionPosition = {
				marginLeft: marginLeft,
				marginTop: marginTop
			};
	
			$.each( [ "left", "top" ], function( i, dir ) {
				if ( $.ui.position[ collision[ i ] ] ) {
					$.ui.position[ collision[ i ] ][ dir ]( position, {
						targetWidth: targetWidth,
						targetHeight: targetHeight,
						elemWidth: elemWidth,
						elemHeight: elemHeight,
						collisionPosition: collisionPosition,
						collisionWidth: collisionWidth,
						collisionHeight: collisionHeight,
						offset: [ atOffset[ 0 ] + myOffset[ 0 ], atOffset [ 1 ] + myOffset[ 1 ] ],
						my: options.my,
						at: options.at,
						within: within,
						elem: elem
					});
				}
			});
	
			if ( options.using ) {
				// adds feedback as second argument to using callback, if present
				using = function( props ) {
					var left = targetOffset.left - position.left,
						right = left + targetWidth - elemWidth,
						top = targetOffset.top - position.top,
						bottom = top + targetHeight - elemHeight,
						feedback = {
							target: {
								element: target,
								left: targetOffset.left,
								top: targetOffset.top,
								width: targetWidth,
								height: targetHeight
							},
							element: {
								element: elem,
								left: position.left,
								top: position.top,
								width: elemWidth,
								height: elemHeight
							},
							horizontal: right < 0 ? "left" : left > 0 ? "right" : "center",
							vertical: bottom < 0 ? "top" : top > 0 ? "bottom" : "middle"
						};
					if ( targetWidth < elemWidth && abs( left + right ) < targetWidth ) {
						feedback.horizontal = "center";
					}
					if ( targetHeight < elemHeight && abs( top + bottom ) < targetHeight ) {
						feedback.vertical = "middle";
					}
					if ( max( abs( left ), abs( right ) ) > max( abs( top ), abs( bottom ) ) ) {
						feedback.important = "horizontal";
					} else {
						feedback.important = "vertical";
					}
					options.using.call( this, props, feedback );
				};
			}
	
			elem.offset( $.extend( position, { using: using } ) );
		});
	};
	
	$.ui.position = {
		fit: {
			left: function( position, data ) {
				var within = data.within,
					withinOffset = within.isWindow ? within.scrollLeft : within.offset.left,
					outerWidth = within.width,
					collisionPosLeft = position.left - data.collisionPosition.marginLeft,
					overLeft = withinOffset - collisionPosLeft,
					overRight = collisionPosLeft + data.collisionWidth - outerWidth - withinOffset,
					newOverRight;
	
				// element is wider than within
				if ( data.collisionWidth > outerWidth ) {
					// element is initially over the left side of within
					if ( overLeft > 0 && overRight <= 0 ) {
						newOverRight = position.left + overLeft + data.collisionWidth - outerWidth - withinOffset;
						position.left += overLeft - newOverRight;
					// element is initially over right side of within
					} else if ( overRight > 0 && overLeft <= 0 ) {
						position.left = withinOffset;
					// element is initially over both left and right sides of within
					} else {
						if ( overLeft > overRight ) {
							position.left = withinOffset + outerWidth - data.collisionWidth;
						} else {
							position.left = withinOffset;
						}
					}
				// too far left -> align with left edge
				} else if ( overLeft > 0 ) {
					position.left += overLeft;
				// too far right -> align with right edge
				} else if ( overRight > 0 ) {
					position.left -= overRight;
				// adjust based on position and margin
				} else {
					position.left = max( position.left - collisionPosLeft, position.left );
				}
			},
			top: function( position, data ) {
				var within = data.within,
					withinOffset = within.isWindow ? within.scrollTop : within.offset.top,
					outerHeight = data.within.height,
					collisionPosTop = position.top - data.collisionPosition.marginTop,
					overTop = withinOffset - collisionPosTop,
					overBottom = collisionPosTop + data.collisionHeight - outerHeight - withinOffset,
					newOverBottom;
	
				// element is taller than within
				if ( data.collisionHeight > outerHeight ) {
					// element is initially over the top of within
					if ( overTop > 0 && overBottom <= 0 ) {
						newOverBottom = position.top + overTop + data.collisionHeight - outerHeight - withinOffset;
						position.top += overTop - newOverBottom;
					// element is initially over bottom of within
					} else if ( overBottom > 0 && overTop <= 0 ) {
						position.top = withinOffset;
					// element is initially over both top and bottom of within
					} else {
						if ( overTop > overBottom ) {
							position.top = withinOffset + outerHeight - data.collisionHeight;
						} else {
							position.top = withinOffset;
						}
					}
				// too far up -> align with top
				} else if ( overTop > 0 ) {
					position.top += overTop;
				// too far down -> align with bottom edge
				} else if ( overBottom > 0 ) {
					position.top -= overBottom;
				// adjust based on position and margin
				} else {
					position.top = max( position.top - collisionPosTop, position.top );
				}
			}
		},
		flip: {
			left: function( position, data ) {
				var within = data.within,
					withinOffset = within.offset.left + within.scrollLeft,
					outerWidth = within.width,
					offsetLeft = within.isWindow ? within.scrollLeft : within.offset.left,
					collisionPosLeft = position.left - data.collisionPosition.marginLeft,
					overLeft = collisionPosLeft - offsetLeft,
					overRight = collisionPosLeft + data.collisionWidth - outerWidth - offsetLeft,
					myOffset = data.my[ 0 ] === "left" ?
						-data.elemWidth :
						data.my[ 0 ] === "right" ?
							data.elemWidth :
							0,
					atOffset = data.at[ 0 ] === "left" ?
						data.targetWidth :
						data.at[ 0 ] === "right" ?
							-data.targetWidth :
							0,
					offset = -2 * data.offset[ 0 ],
					newOverRight,
					newOverLeft;
	
				if ( overLeft < 0 ) {
					newOverRight = position.left + myOffset + atOffset + offset + data.collisionWidth - outerWidth - withinOffset;
					if ( newOverRight < 0 || newOverRight < abs( overLeft ) ) {
						position.left += myOffset + atOffset + offset;
					}
				} else if ( overRight > 0 ) {
					newOverLeft = position.left - data.collisionPosition.marginLeft + myOffset + atOffset + offset - offsetLeft;
					if ( newOverLeft > 0 || abs( newOverLeft ) < overRight ) {
						position.left += myOffset + atOffset + offset;
					}
				}
			},
			top: function( position, data ) {
				var within = data.within,
					withinOffset = within.offset.top + within.scrollTop,
					outerHeight = within.height,
					offsetTop = within.isWindow ? within.scrollTop : within.offset.top,
					collisionPosTop = position.top - data.collisionPosition.marginTop,
					overTop = collisionPosTop - offsetTop,
					overBottom = collisionPosTop + data.collisionHeight - outerHeight - offsetTop,
					top = data.my[ 1 ] === "top",
					myOffset = top ?
						-data.elemHeight :
						data.my[ 1 ] === "bottom" ?
							data.elemHeight :
							0,
					atOffset = data.at[ 1 ] === "top" ?
						data.targetHeight :
						data.at[ 1 ] === "bottom" ?
							-data.targetHeight :
							0,
					offset = -2 * data.offset[ 1 ],
					newOverTop,
					newOverBottom;
				if ( overTop < 0 ) {
					newOverBottom = position.top + myOffset + atOffset + offset + data.collisionHeight - outerHeight - withinOffset;
					if ( newOverBottom < 0 || newOverBottom < abs( overTop ) ) {
						position.top += myOffset + atOffset + offset;
					}
				} else if ( overBottom > 0 ) {
					newOverTop = position.top - data.collisionPosition.marginTop + myOffset + atOffset + offset - offsetTop;
					if ( newOverTop > 0 || abs( newOverTop ) < overBottom ) {
						position.top += myOffset + atOffset + offset;
					}
				}
			}
		},
		flipfit: {
			left: function() {
				$.ui.position.flip.left.apply( this, arguments );
				$.ui.position.fit.left.apply( this, arguments );
			},
			top: function() {
				$.ui.position.flip.top.apply( this, arguments );
				$.ui.position.fit.top.apply( this, arguments );
			}
		}
	};
	
	// fraction support test
	(function() {
		var testElement, testElementParent, testElementStyle, offsetLeft, i,
			body = document.getElementsByTagName( "body" )[ 0 ],
			div = document.createElement( "div" );
	
		//Create a "fake body" for testing based on method used in jQuery.support
		testElement = document.createElement( body ? "div" : "body" );
		testElementStyle = {
			visibility: "hidden",
			width: 0,
			height: 0,
			border: 0,
			margin: 0,
			background: "none"
		};
		if ( body ) {
			$.extend( testElementStyle, {
				position: "absolute",
				left: "-1000px",
				top: "-1000px"
			});
		}
		for ( i in testElementStyle ) {
			testElement.style[ i ] = testElementStyle[ i ];
		}
		testElement.appendChild( div );
		testElementParent = body || document.documentElement;
		testElementParent.insertBefore( testElement, testElementParent.firstChild );
	
		div.style.cssText = "position: absolute; left: 10.7432222px;";
	
		offsetLeft = $( div ).offset().left;
		supportsOffsetFractions = offsetLeft > 10 && offsetLeft < 11;
	
		testElement.innerHTML = "";
		testElementParent.removeChild( testElement );
	})();
	
	})();
	
	var position = $.ui.position;
	
	
	/*!
	 * jQuery UI Accordion 1.11.4
	 * http://jqueryui.com
	 *
	 * Copyright jQuery Foundation and other contributors
	 * Released under the MIT license.
	 * http://jquery.org/license
	 *
	 * http://api.jqueryui.com/accordion/
	 */
	
	
	var accordion = $.widget( "ui.accordion", {
		version: "1.11.4",
		options: {
			active: 0,
			animate: {},
			collapsible: false,
			event: "click",
			header: "> li > :first-child,> :not(li):even",
			heightStyle: "auto",
			icons: {
				activeHeader: "ui-icon-triangle-1-s",
				header: "ui-icon-triangle-1-e"
			},
	
			// callbacks
			activate: null,
			beforeActivate: null
		},
	
		hideProps: {
			borderTopWidth: "hide",
			borderBottomWidth: "hide",
			paddingTop: "hide",
			paddingBottom: "hide",
			height: "hide"
		},
	
		showProps: {
			borderTopWidth: "show",
			borderBottomWidth: "show",
			paddingTop: "show",
			paddingBottom: "show",
			height: "show"
		},
	
		_create: function() {
			var options = this.options;
			this.prevShow = this.prevHide = $();
			this.element.addClass( "ui-accordion ui-widget ui-helper-reset" )
				// ARIA
				.attr( "role", "tablist" );
	
			// don't allow collapsible: false and active: false / null
			if ( !options.collapsible && (options.active === false || options.active == null) ) {
				options.active = 0;
			}
	
			this._processPanels();
			// handle negative values
			if ( options.active < 0 ) {
				options.active += this.headers.length;
			}
			this._refresh();
		},
	
		_getCreateEventData: function() {
			return {
				header: this.active,
				panel: !this.active.length ? $() : this.active.next()
			};
		},
	
		_createIcons: function() {
			var icons = this.options.icons;
			if ( icons ) {
				$( "<span>" )
					.addClass( "ui-accordion-header-icon ui-icon " + icons.header )
					.prependTo( this.headers );
				this.active.children( ".ui-accordion-header-icon" )
					.removeClass( icons.header )
					.addClass( icons.activeHeader );
				this.headers.addClass( "ui-accordion-icons" );
			}
		},
	
		_destroyIcons: function() {
			this.headers
				.removeClass( "ui-accordion-icons" )
				.children( ".ui-accordion-header-icon" )
					.remove();
		},
	
		_destroy: function() {
			var contents;
	
			// clean up main element
			this.element
				.removeClass( "ui-accordion ui-widget ui-helper-reset" )
				.removeAttr( "role" );
	
			// clean up headers
			this.headers
				.removeClass( "ui-accordion-header ui-accordion-header-active ui-state-default " +
					"ui-corner-all ui-state-active ui-state-disabled ui-corner-top" )
				.removeAttr( "role" )
				.removeAttr( "aria-expanded" )
				.removeAttr( "aria-selected" )
				.removeAttr( "aria-controls" )
				.removeAttr( "tabIndex" )
				.removeUniqueId();
	
			this._destroyIcons();
	
			// clean up content panels
			contents = this.headers.next()
				.removeClass( "ui-helper-reset ui-widget-content ui-corner-bottom " +
					"ui-accordion-content ui-accordion-content-active ui-state-disabled" )
				.css( "display", "" )
				.removeAttr( "role" )
				.removeAttr( "aria-hidden" )
				.removeAttr( "aria-labelledby" )
				.removeUniqueId();
	
			if ( this.options.heightStyle !== "content" ) {
				contents.css( "height", "" );
			}
		},
	
		_setOption: function( key, value ) {
			if ( key === "active" ) {
				// _activate() will handle invalid values and update this.options
				this._activate( value );
				return;
			}
	
			if ( key === "event" ) {
				if ( this.options.event ) {
					this._off( this.headers, this.options.event );
				}
				this._setupEvents( value );
			}
	
			this._super( key, value );
	
			// setting collapsible: false while collapsed; open first panel
			if ( key === "collapsible" && !value && this.options.active === false ) {
				this._activate( 0 );
			}
	
			if ( key === "icons" ) {
				this._destroyIcons();
				if ( value ) {
					this._createIcons();
				}
			}
	
			// #5332 - opacity doesn't cascade to positioned elements in IE
			// so we need to add the disabled class to the headers and panels
			if ( key === "disabled" ) {
				this.element
					.toggleClass( "ui-state-disabled", !!value )
					.attr( "aria-disabled", value );
				this.headers.add( this.headers.next() )
					.toggleClass( "ui-state-disabled", !!value );
			}
		},
	
		_keydown: function( event ) {
			if ( event.altKey || event.ctrlKey ) {
				return;
			}
	
			var keyCode = $.ui.keyCode,
				length = this.headers.length,
				currentIndex = this.headers.index( event.target ),
				toFocus = false;
	
			switch ( event.keyCode ) {
				case keyCode.RIGHT:
				case keyCode.DOWN:
					toFocus = this.headers[ ( currentIndex + 1 ) % length ];
					break;
				case keyCode.LEFT:
				case keyCode.UP:
					toFocus = this.headers[ ( currentIndex - 1 + length ) % length ];
					break;
				case keyCode.SPACE:
				case keyCode.ENTER:
					this._eventHandler( event );
					break;
				case keyCode.HOME:
					toFocus = this.headers[ 0 ];
					break;
				case keyCode.END:
					toFocus = this.headers[ length - 1 ];
					break;
			}
	
			if ( toFocus ) {
				$( event.target ).attr( "tabIndex", -1 );
				$( toFocus ).attr( "tabIndex", 0 );
				toFocus.focus();
				event.preventDefault();
			}
		},
	
		_panelKeyDown: function( event ) {
			if ( event.keyCode === $.ui.keyCode.UP && event.ctrlKey ) {
				$( event.currentTarget ).prev().focus();
			}
		},
	
		refresh: function() {
			var options = this.options;
			this._processPanels();
	
			// was collapsed or no panel
			if ( ( options.active === false && options.collapsible === true ) || !this.headers.length ) {
				options.active = false;
				this.active = $();
			// active false only when collapsible is true
			} else if ( options.active === false ) {
				this._activate( 0 );
			// was active, but active panel is gone
			} else if ( this.active.length && !$.contains( this.element[ 0 ], this.active[ 0 ] ) ) {
				// all remaining panel are disabled
				if ( this.headers.length === this.headers.find(".ui-state-disabled").length ) {
					options.active = false;
					this.active = $();
				// activate previous panel
				} else {
					this._activate( Math.max( 0, options.active - 1 ) );
				}
			// was active, active panel still exists
			} else {
				// make sure active index is correct
				options.active = this.headers.index( this.active );
			}
	
			this._destroyIcons();
	
			this._refresh();
		},
	
		_processPanels: function() {
			var prevHeaders = this.headers,
				prevPanels = this.panels;
	
			this.headers = this.element.find( this.options.header )
				.addClass( "ui-accordion-header ui-state-default ui-corner-all" );
	
			this.panels = this.headers.next()
				.addClass( "ui-accordion-content ui-helper-reset ui-widget-content ui-corner-bottom" )
				.filter( ":not(.ui-accordion-content-active)" )
				.hide();
	
			// Avoid memory leaks (#10056)
			if ( prevPanels ) {
				this._off( prevHeaders.not( this.headers ) );
				this._off( prevPanels.not( this.panels ) );
			}
		},
	
		_refresh: function() {
			var maxHeight,
				options = this.options,
				heightStyle = options.heightStyle,
				parent = this.element.parent();
	
			this.active = this._findActive( options.active )
				.addClass( "ui-accordion-header-active ui-state-active ui-corner-top" )
				.removeClass( "ui-corner-all" );
			this.active.next()
				.addClass( "ui-accordion-content-active" )
				.show();
	
			this.headers
				.attr( "role", "tab" )
				.each(function() {
					var header = $( this ),
						headerId = header.uniqueId().attr( "id" ),
						panel = header.next(),
						panelId = panel.uniqueId().attr( "id" );
					header.attr( "aria-controls", panelId );
					panel.attr( "aria-labelledby", headerId );
				})
				.next()
					.attr( "role", "tabpanel" );
	
			this.headers
				.not( this.active )
				.attr({
					"aria-selected": "false",
					"aria-expanded": "false",
					tabIndex: -1
				})
				.next()
					.attr({
						"aria-hidden": "true"
					})
					.hide();
	
			// make sure at least one header is in the tab order
			if ( !this.active.length ) {
				this.headers.eq( 0 ).attr( "tabIndex", 0 );
			} else {
				this.active.attr({
					"aria-selected": "true",
					"aria-expanded": "true",
					tabIndex: 0
				})
				.next()
					.attr({
						"aria-hidden": "false"
					});
			}
	
			this._createIcons();
	
			this._setupEvents( options.event );
	
			if ( heightStyle === "fill" ) {
				maxHeight = parent.height();
				this.element.siblings( ":visible" ).each(function() {
					var elem = $( this ),
						position = elem.css( "position" );
	
					if ( position === "absolute" || position === "fixed" ) {
						return;
					}
					maxHeight -= elem.outerHeight( true );
				});
	
				this.headers.each(function() {
					maxHeight -= $( this ).outerHeight( true );
				});
	
				this.headers.next()
					.each(function() {
						$( this ).height( Math.max( 0, maxHeight -
							$( this ).innerHeight() + $( this ).height() ) );
					})
					.css( "overflow", "auto" );
			} else if ( heightStyle === "auto" ) {
				maxHeight = 0;
				this.headers.next()
					.each(function() {
						maxHeight = Math.max( maxHeight, $( this ).css( "height", "" ).height() );
					})
					.height( maxHeight );
			}
		},
	
		_activate: function( index ) {
			var active = this._findActive( index )[ 0 ];
	
			// trying to activate the already active panel
			if ( active === this.active[ 0 ] ) {
				return;
			}
	
			// trying to collapse, simulate a click on the currently active header
			active = active || this.active[ 0 ];
	
			this._eventHandler({
				target: active,
				currentTarget: active,
				preventDefault: $.noop
			});
		},
	
		_findActive: function( selector ) {
			return typeof selector === "number" ? this.headers.eq( selector ) : $();
		},
	
		_setupEvents: function( event ) {
			var events = {
				keydown: "_keydown"
			};
			if ( event ) {
				$.each( event.split( " " ), function( index, eventName ) {
					events[ eventName ] = "_eventHandler";
				});
			}
	
			this._off( this.headers.add( this.headers.next() ) );
			this._on( this.headers, events );
			this._on( this.headers.next(), { keydown: "_panelKeyDown" });
			this._hoverable( this.headers );
			this._focusable( this.headers );
		},
	
		_eventHandler: function( event ) {
			var options = this.options,
				active = this.active,
				clicked = $( event.currentTarget ),
				clickedIsActive = clicked[ 0 ] === active[ 0 ],
				collapsing = clickedIsActive && options.collapsible,
				toShow = collapsing ? $() : clicked.next(),
				toHide = active.next(),
				eventData = {
					oldHeader: active,
					oldPanel: toHide,
					newHeader: collapsing ? $() : clicked,
					newPanel: toShow
				};
	
			event.preventDefault();
	
			if (
					// click on active header, but not collapsible
					( clickedIsActive && !options.collapsible ) ||
					// allow canceling activation
					( this._trigger( "beforeActivate", event, eventData ) === false ) ) {
				return;
			}
	
			options.active = collapsing ? false : this.headers.index( clicked );
	
			// when the call to ._toggle() comes after the class changes
			// it causes a very odd bug in IE 8 (see #6720)
			this.active = clickedIsActive ? $() : clicked;
			this._toggle( eventData );
	
			// switch classes
			// corner classes on the previously active header stay after the animation
			active.removeClass( "ui-accordion-header-active ui-state-active" );
			if ( options.icons ) {
				active.children( ".ui-accordion-header-icon" )
					.removeClass( options.icons.activeHeader )
					.addClass( options.icons.header );
			}
	
			if ( !clickedIsActive ) {
				clicked
					.removeClass( "ui-corner-all" )
					.addClass( "ui-accordion-header-active ui-state-active ui-corner-top" );
				if ( options.icons ) {
					clicked.children( ".ui-accordion-header-icon" )
						.removeClass( options.icons.header )
						.addClass( options.icons.activeHeader );
				}
	
				clicked
					.next()
					.addClass( "ui-accordion-content-active" );
			}
		},
	
		_toggle: function( data ) {
			var toShow = data.newPanel,
				toHide = this.prevShow.length ? this.prevShow : data.oldPanel;
	
			// handle activating a panel during the animation for another activation
			this.prevShow.add( this.prevHide ).stop( true, true );
			this.prevShow = toShow;
			this.prevHide = toHide;
	
			if ( this.options.animate ) {
				this._animate( toShow, toHide, data );
			} else {
				toHide.hide();
				toShow.show();
				this._toggleComplete( data );
			}
	
			toHide.attr({
				"aria-hidden": "true"
			});
			toHide.prev().attr({
				"aria-selected": "false",
				"aria-expanded": "false"
			});
			// if we're switching panels, remove the old header from the tab order
			// if we're opening from collapsed state, remove the previous header from the tab order
			// if we're collapsing, then keep the collapsing header in the tab order
			if ( toShow.length && toHide.length ) {
				toHide.prev().attr({
					"tabIndex": -1,
					"aria-expanded": "false"
				});
			} else if ( toShow.length ) {
				this.headers.filter(function() {
					return parseInt( $( this ).attr( "tabIndex" ), 10 ) === 0;
				})
				.attr( "tabIndex", -1 );
			}
	
			toShow
				.attr( "aria-hidden", "false" )
				.prev()
					.attr({
						"aria-selected": "true",
						"aria-expanded": "true",
						tabIndex: 0
					});
		},
	
		_animate: function( toShow, toHide, data ) {
			var total, easing, duration,
				that = this,
				adjust = 0,
				boxSizing = toShow.css( "box-sizing" ),
				down = toShow.length &&
					( !toHide.length || ( toShow.index() < toHide.index() ) ),
				animate = this.options.animate || {},
				options = down && animate.down || animate,
				complete = function() {
					that._toggleComplete( data );
				};
	
			if ( typeof options === "number" ) {
				duration = options;
			}
			if ( typeof options === "string" ) {
				easing = options;
			}
			// fall back from options to animation in case of partial down settings
			easing = easing || options.easing || animate.easing;
			duration = duration || options.duration || animate.duration;
	
			if ( !toHide.length ) {
				return toShow.animate( this.showProps, duration, easing, complete );
			}
			if ( !toShow.length ) {
				return toHide.animate( this.hideProps, duration, easing, complete );
			}
	
			total = toShow.show().outerHeight();
			toHide.animate( this.hideProps, {
				duration: duration,
				easing: easing,
				step: function( now, fx ) {
					fx.now = Math.round( now );
				}
			});
			toShow
				.hide()
				.animate( this.showProps, {
					duration: duration,
					easing: easing,
					complete: complete,
					step: function( now, fx ) {
						fx.now = Math.round( now );
						if ( fx.prop !== "height" ) {
							if ( boxSizing === "content-box" ) {
								adjust += fx.now;
							}
						} else if ( that.options.heightStyle !== "content" ) {
							fx.now = Math.round( total - toHide.outerHeight() - adjust );
							adjust = 0;
						}
					}
				});
		},
	
		_toggleComplete: function( data ) {
			var toHide = data.oldPanel;
	
			toHide
				.removeClass( "ui-accordion-content-active" )
				.prev()
					.removeClass( "ui-corner-top" )
					.addClass( "ui-corner-all" );
	
			// Work around for rendering bug in IE (#5421)
			if ( toHide.length ) {
				toHide.parent()[ 0 ].className = toHide.parent()[ 0 ].className;
			}
			this._trigger( "activate", null, data );
		}
	});
	
	
	/*!
	 * jQuery UI Menu 1.11.4
	 * http://jqueryui.com
	 *
	 * Copyright jQuery Foundation and other contributors
	 * Released under the MIT license.
	 * http://jquery.org/license
	 *
	 * http://api.jqueryui.com/menu/
	 */
	
	
	var menu = $.widget( "ui.menu", {
		version: "1.11.4",
		defaultElement: "<ul>",
		delay: 300,
		options: {
			icons: {
				submenu: "ui-icon-carat-1-e"
			},
			items: "> *",
			menus: "ul",
			position: {
				my: "left-1 top",
				at: "right top"
			},
			role: "menu",
	
			// callbacks
			blur: null,
			focus: null,
			select: null
		},
	
		_create: function() {
			this.activeMenu = this.element;
	
			// Flag used to prevent firing of the click handler
			// as the event bubbles up through nested menus
			this.mouseHandled = false;
			this.element
				.uniqueId()
				.addClass( "ui-menu ui-widget ui-widget-content" )
				.toggleClass( "ui-menu-icons", !!this.element.find( ".ui-icon" ).length )
				.attr({
					role: this.options.role,
					tabIndex: 0
				});
	
			if ( this.options.disabled ) {
				this.element
					.addClass( "ui-state-disabled" )
					.attr( "aria-disabled", "true" );
			}
	
			this._on({
				// Prevent focus from sticking to links inside menu after clicking
				// them (focus should always stay on UL during navigation).
				"mousedown .ui-menu-item": function( event ) {
					event.preventDefault();
				},
				"click .ui-menu-item": function( event ) {
					var target = $( event.target );
					if ( !this.mouseHandled && target.not( ".ui-state-disabled" ).length ) {
						this.select( event );
	
						// Only set the mouseHandled flag if the event will bubble, see #9469.
						if ( !event.isPropagationStopped() ) {
							this.mouseHandled = true;
						}
	
						// Open submenu on click
						if ( target.has( ".ui-menu" ).length ) {
							this.expand( event );
						} else if ( !this.element.is( ":focus" ) && $( this.document[ 0 ].activeElement ).closest( ".ui-menu" ).length ) {
	
							// Redirect focus to the menu
							this.element.trigger( "focus", [ true ] );
	
							// If the active item is on the top level, let it stay active.
							// Otherwise, blur the active item since it is no longer visible.
							if ( this.active && this.active.parents( ".ui-menu" ).length === 1 ) {
								clearTimeout( this.timer );
							}
						}
					}
				},
				"mouseenter .ui-menu-item": function( event ) {
					// Ignore mouse events while typeahead is active, see #10458.
					// Prevents focusing the wrong item when typeahead causes a scroll while the mouse
					// is over an item in the menu
					if ( this.previousFilter ) {
						return;
					}
					var target = $( event.currentTarget );
					// Remove ui-state-active class from siblings of the newly focused menu item
					// to avoid a jump caused by adjacent elements both having a class with a border
					target.siblings( ".ui-state-active" ).removeClass( "ui-state-active" );
					this.focus( event, target );
				},
				mouseleave: "collapseAll",
				"mouseleave .ui-menu": "collapseAll",
				focus: function( event, keepActiveItem ) {
					// If there's already an active item, keep it active
					// If not, activate the first item
					var item = this.active || this.element.find( this.options.items ).eq( 0 );
	
					if ( !keepActiveItem ) {
						this.focus( event, item );
					}
				},
				blur: function( event ) {
					this._delay(function() {
						if ( !$.contains( this.element[0], this.document[0].activeElement ) ) {
							this.collapseAll( event );
						}
					});
				},
				keydown: "_keydown"
			});
	
			this.refresh();
	
			// Clicks outside of a menu collapse any open menus
			this._on( this.document, {
				click: function( event ) {
					if ( this._closeOnDocumentClick( event ) ) {
						this.collapseAll( event );
					}
	
					// Reset the mouseHandled flag
					this.mouseHandled = false;
				}
			});
		},
	
		_destroy: function() {
			// Destroy (sub)menus
			this.element
				.removeAttr( "aria-activedescendant" )
				.find( ".ui-menu" ).addBack()
					.removeClass( "ui-menu ui-widget ui-widget-content ui-menu-icons ui-front" )
					.removeAttr( "role" )
					.removeAttr( "tabIndex" )
					.removeAttr( "aria-labelledby" )
					.removeAttr( "aria-expanded" )
					.removeAttr( "aria-hidden" )
					.removeAttr( "aria-disabled" )
					.removeUniqueId()
					.show();
	
			// Destroy menu items
			this.element.find( ".ui-menu-item" )
				.removeClass( "ui-menu-item" )
				.removeAttr( "role" )
				.removeAttr( "aria-disabled" )
				.removeUniqueId()
				.removeClass( "ui-state-hover" )
				.removeAttr( "tabIndex" )
				.removeAttr( "role" )
				.removeAttr( "aria-haspopup" )
				.children().each( function() {
					var elem = $( this );
					if ( elem.data( "ui-menu-submenu-carat" ) ) {
						elem.remove();
					}
				});
	
			// Destroy menu dividers
			this.element.find( ".ui-menu-divider" ).removeClass( "ui-menu-divider ui-widget-content" );
		},
	
		_keydown: function( event ) {
			var match, prev, character, skip,
				preventDefault = true;
	
			switch ( event.keyCode ) {
			case $.ui.keyCode.PAGE_UP:
				this.previousPage( event );
				break;
			case $.ui.keyCode.PAGE_DOWN:
				this.nextPage( event );
				break;
			case $.ui.keyCode.HOME:
				this._move( "first", "first", event );
				break;
			case $.ui.keyCode.END:
				this._move( "last", "last", event );
				break;
			case $.ui.keyCode.UP:
				this.previous( event );
				break;
			case $.ui.keyCode.DOWN:
				this.next( event );
				break;
			case $.ui.keyCode.LEFT:
				this.collapse( event );
				break;
			case $.ui.keyCode.RIGHT:
				if ( this.active && !this.active.is( ".ui-state-disabled" ) ) {
					this.expand( event );
				}
				break;
			case $.ui.keyCode.ENTER:
			case $.ui.keyCode.SPACE:
				this._activate( event );
				break;
			case $.ui.keyCode.ESCAPE:
				this.collapse( event );
				break;
			default:
				preventDefault = false;
				prev = this.previousFilter || "";
				character = String.fromCharCode( event.keyCode );
				skip = false;
	
				clearTimeout( this.filterTimer );
	
				if ( character === prev ) {
					skip = true;
				} else {
					character = prev + character;
				}
	
				match = this._filterMenuItems( character );
				match = skip && match.index( this.active.next() ) !== -1 ?
					this.active.nextAll( ".ui-menu-item" ) :
					match;
	
				// If no matches on the current filter, reset to the last character pressed
				// to move down the menu to the first item that starts with that character
				if ( !match.length ) {
					character = String.fromCharCode( event.keyCode );
					match = this._filterMenuItems( character );
				}
	
				if ( match.length ) {
					this.focus( event, match );
					this.previousFilter = character;
					this.filterTimer = this._delay(function() {
						delete this.previousFilter;
					}, 1000 );
				} else {
					delete this.previousFilter;
				}
			}
	
			if ( preventDefault ) {
				event.preventDefault();
			}
		},
	
		_activate: function( event ) {
			if ( !this.active.is( ".ui-state-disabled" ) ) {
				if ( this.active.is( "[aria-haspopup='true']" ) ) {
					this.expand( event );
				} else {
					this.select( event );
				}
			}
		},
	
		refresh: function() {
			var menus, items,
				that = this,
				icon = this.options.icons.submenu,
				submenus = this.element.find( this.options.menus );
	
			this.element.toggleClass( "ui-menu-icons", !!this.element.find( ".ui-icon" ).length );
	
			// Initialize nested menus
			submenus.filter( ":not(.ui-menu)" )
				.addClass( "ui-menu ui-widget ui-widget-content ui-front" )
				.hide()
				.attr({
					role: this.options.role,
					"aria-hidden": "true",
					"aria-expanded": "false"
				})
				.each(function() {
					var menu = $( this ),
						item = menu.parent(),
						submenuCarat = $( "<span>" )
							.addClass( "ui-menu-icon ui-icon " + icon )
							.data( "ui-menu-submenu-carat", true );
	
					item
						.attr( "aria-haspopup", "true" )
						.prepend( submenuCarat );
					menu.attr( "aria-labelledby", item.attr( "id" ) );
				});
	
			menus = submenus.add( this.element );
			items = menus.find( this.options.items );
	
			// Initialize menu-items containing spaces and/or dashes only as dividers
			items.not( ".ui-menu-item" ).each(function() {
				var item = $( this );
				if ( that._isDivider( item ) ) {
					item.addClass( "ui-widget-content ui-menu-divider" );
				}
			});
	
			// Don't refresh list items that are already adapted
			items.not( ".ui-menu-item, .ui-menu-divider" )
				.addClass( "ui-menu-item" )
				.uniqueId()
				.attr({
					tabIndex: -1,
					role: this._itemRole()
				});
	
			// Add aria-disabled attribute to any disabled menu item
			items.filter( ".ui-state-disabled" ).attr( "aria-disabled", "true" );
	
			// If the active item has been removed, blur the menu
			if ( this.active && !$.contains( this.element[ 0 ], this.active[ 0 ] ) ) {
				this.blur();
			}
		},
	
		_itemRole: function() {
			return {
				menu: "menuitem",
				listbox: "option"
			}[ this.options.role ];
		},
	
		_setOption: function( key, value ) {
			if ( key === "icons" ) {
				this.element.find( ".ui-menu-icon" )
					.removeClass( this.options.icons.submenu )
					.addClass( value.submenu );
			}
			if ( key === "disabled" ) {
				this.element
					.toggleClass( "ui-state-disabled", !!value )
					.attr( "aria-disabled", value );
			}
			this._super( key, value );
		},
	
		focus: function( event, item ) {
			var nested, focused;
			this.blur( event, event && event.type === "focus" );
	
			this._scrollIntoView( item );
	
			this.active = item.first();
			focused = this.active.addClass( "ui-state-focus" ).removeClass( "ui-state-active" );
			// Only update aria-activedescendant if there's a role
			// otherwise we assume focus is managed elsewhere
			if ( this.options.role ) {
				this.element.attr( "aria-activedescendant", focused.attr( "id" ) );
			}
	
			// Highlight active parent menu item, if any
			this.active
				.parent()
				.closest( ".ui-menu-item" )
				.addClass( "ui-state-active" );
	
			if ( event && event.type === "keydown" ) {
				this._close();
			} else {
				this.timer = this._delay(function() {
					this._close();
				}, this.delay );
			}
	
			nested = item.children( ".ui-menu" );
			if ( nested.length && event && ( /^mouse/.test( event.type ) ) ) {
				this._startOpening(nested);
			}
			this.activeMenu = item.parent();
	
			this._trigger( "focus", event, { item: item } );
		},
	
		_scrollIntoView: function( item ) {
			var borderTop, paddingTop, offset, scroll, elementHeight, itemHeight;
			if ( this._hasScroll() ) {
				borderTop = parseFloat( $.css( this.activeMenu[0], "borderTopWidth" ) ) || 0;
				paddingTop = parseFloat( $.css( this.activeMenu[0], "paddingTop" ) ) || 0;
				offset = item.offset().top - this.activeMenu.offset().top - borderTop - paddingTop;
				scroll = this.activeMenu.scrollTop();
				elementHeight = this.activeMenu.height();
				itemHeight = item.outerHeight();
	
				if ( offset < 0 ) {
					this.activeMenu.scrollTop( scroll + offset );
				} else if ( offset + itemHeight > elementHeight ) {
					this.activeMenu.scrollTop( scroll + offset - elementHeight + itemHeight );
				}
			}
		},
	
		blur: function( event, fromFocus ) {
			if ( !fromFocus ) {
				clearTimeout( this.timer );
			}
	
			if ( !this.active ) {
				return;
			}
	
			this.active.removeClass( "ui-state-focus" );
			this.active = null;
	
			this._trigger( "blur", event, { item: this.active } );
		},
	
		_startOpening: function( submenu ) {
			clearTimeout( this.timer );
	
			// Don't open if already open fixes a Firefox bug that caused a .5 pixel
			// shift in the submenu position when mousing over the carat icon
			if ( submenu.attr( "aria-hidden" ) !== "true" ) {
				return;
			}
	
			this.timer = this._delay(function() {
				this._close();
				this._open( submenu );
			}, this.delay );
		},
	
		_open: function( submenu ) {
			var position = $.extend({
				of: this.active
			}, this.options.position );
	
			clearTimeout( this.timer );
			this.element.find( ".ui-menu" ).not( submenu.parents( ".ui-menu" ) )
				.hide()
				.attr( "aria-hidden", "true" );
	
			submenu
				.show()
				.removeAttr( "aria-hidden" )
				.attr( "aria-expanded", "true" )
				.position( position );
		},
	
		collapseAll: function( event, all ) {
			clearTimeout( this.timer );
			this.timer = this._delay(function() {
				// If we were passed an event, look for the submenu that contains the event
				var currentMenu = all ? this.element :
					$( event && event.target ).closest( this.element.find( ".ui-menu" ) );
	
				// If we found no valid submenu ancestor, use the main menu to close all sub menus anyway
				if ( !currentMenu.length ) {
					currentMenu = this.element;
				}
	
				this._close( currentMenu );
	
				this.blur( event );
				this.activeMenu = currentMenu;
			}, this.delay );
		},
	
		// With no arguments, closes the currently active menu - if nothing is active
		// it closes all menus.  If passed an argument, it will search for menus BELOW
		_close: function( startMenu ) {
			if ( !startMenu ) {
				startMenu = this.active ? this.active.parent() : this.element;
			}
	
			startMenu
				.find( ".ui-menu" )
					.hide()
					.attr( "aria-hidden", "true" )
					.attr( "aria-expanded", "false" )
				.end()
				.find( ".ui-state-active" ).not( ".ui-state-focus" )
					.removeClass( "ui-state-active" );
		},
	
		_closeOnDocumentClick: function( event ) {
			return !$( event.target ).closest( ".ui-menu" ).length;
		},
	
		_isDivider: function( item ) {
	
			// Match hyphen, em dash, en dash
			return !/[^\-\u2014\u2013\s]/.test( item.text() );
		},
	
		collapse: function( event ) {
			var newItem = this.active &&
				this.active.parent().closest( ".ui-menu-item", this.element );
			if ( newItem && newItem.length ) {
				this._close();
				this.focus( event, newItem );
			}
		},
	
		expand: function( event ) {
			var newItem = this.active &&
				this.active
					.children( ".ui-menu " )
					.find( this.options.items )
					.first();
	
			if ( newItem && newItem.length ) {
				this._open( newItem.parent() );
	
				// Delay so Firefox will not hide activedescendant change in expanding submenu from AT
				this._delay(function() {
					this.focus( event, newItem );
				});
			}
		},
	
		next: function( event ) {
			this._move( "next", "first", event );
		},
	
		previous: function( event ) {
			this._move( "prev", "last", event );
		},
	
		isFirstItem: function() {
			return this.active && !this.active.prevAll( ".ui-menu-item" ).length;
		},
	
		isLastItem: function() {
			return this.active && !this.active.nextAll( ".ui-menu-item" ).length;
		},
	
		_move: function( direction, filter, event ) {
			var next;
			if ( this.active ) {
				if ( direction === "first" || direction === "last" ) {
					next = this.active
						[ direction === "first" ? "prevAll" : "nextAll" ]( ".ui-menu-item" )
						.eq( -1 );
				} else {
					next = this.active
						[ direction + "All" ]( ".ui-menu-item" )
						.eq( 0 );
				}
			}
			if ( !next || !next.length || !this.active ) {
				next = this.activeMenu.find( this.options.items )[ filter ]();
			}
	
			this.focus( event, next );
		},
	
		nextPage: function( event ) {
			var item, base, height;
	
			if ( !this.active ) {
				this.next( event );
				return;
			}
			if ( this.isLastItem() ) {
				return;
			}
			if ( this._hasScroll() ) {
				base = this.active.offset().top;
				height = this.element.height();
				this.active.nextAll( ".ui-menu-item" ).each(function() {
					item = $( this );
					return item.offset().top - base - height < 0;
				});
	
				this.focus( event, item );
			} else {
				this.focus( event, this.activeMenu.find( this.options.items )
					[ !this.active ? "first" : "last" ]() );
			}
		},
	
		previousPage: function( event ) {
			var item, base, height;
			if ( !this.active ) {
				this.next( event );
				return;
			}
			if ( this.isFirstItem() ) {
				return;
			}
			if ( this._hasScroll() ) {
				base = this.active.offset().top;
				height = this.element.height();
				this.active.prevAll( ".ui-menu-item" ).each(function() {
					item = $( this );
					return item.offset().top - base + height > 0;
				});
	
				this.focus( event, item );
			} else {
				this.focus( event, this.activeMenu.find( this.options.items ).first() );
			}
		},
	
		_hasScroll: function() {
			return this.element.outerHeight() < this.element.prop( "scrollHeight" );
		},
	
		select: function( event ) {
			// TODO: It should never be possible to not have an active item at this
			// point, but the tests don't trigger mouseenter before click.
			this.active = this.active || $( event.target ).closest( ".ui-menu-item" );
			var ui = { item: this.active };
			if ( !this.active.has( ".ui-menu" ).length ) {
				this.collapseAll( event, true );
			}
			this._trigger( "select", event, ui );
		},
	
		_filterMenuItems: function(character) {
			var escapedCharacter = character.replace( /[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&" ),
				regex = new RegExp( "^" + escapedCharacter, "i" );
	
			return this.activeMenu
				.find( this.options.items )
	
				// Only match on items, not dividers or other content (#10571)
				.filter( ".ui-menu-item" )
				.filter(function() {
					return regex.test( $.trim( $( this ).text() ) );
				});
		}
	});
	
	
	/*!
	 * jQuery UI Autocomplete 1.11.4
	 * http://jqueryui.com
	 *
	 * Copyright jQuery Foundation and other contributors
	 * Released under the MIT license.
	 * http://jquery.org/license
	 *
	 * http://api.jqueryui.com/autocomplete/
	 */
	
	
	$.widget( "ui.autocomplete", {
		version: "1.11.4",
		defaultElement: "<input>",
		options: {
			appendTo: null,
			autoFocus: false,
			delay: 300,
			minLength: 1,
			position: {
				my: "left top",
				at: "left bottom",
				collision: "none"
			},
			source: null,
	
			// callbacks
			change: null,
			close: null,
			focus: null,
			open: null,
			response: null,
			search: null,
			select: null
		},
	
		requestIndex: 0,
		pending: 0,
	
		_create: function() {
			// Some browsers only repeat keydown events, not keypress events,
			// so we use the suppressKeyPress flag to determine if we've already
			// handled the keydown event. #7269
			// Unfortunately the code for & in keypress is the same as the up arrow,
			// so we use the suppressKeyPressRepeat flag to avoid handling keypress
			// events when we know the keydown event was used to modify the
			// search term. #7799
			var suppressKeyPress, suppressKeyPressRepeat, suppressInput,
				nodeName = this.element[ 0 ].nodeName.toLowerCase(),
				isTextarea = nodeName === "textarea",
				isInput = nodeName === "input";
	
			this.isMultiLine =
				// Textareas are always multi-line
				isTextarea ? true :
				// Inputs are always single-line, even if inside a contentEditable element
				// IE also treats inputs as contentEditable
				isInput ? false :
				// All other element types are determined by whether or not they're contentEditable
				this.element.prop( "isContentEditable" );
	
			this.valueMethod = this.element[ isTextarea || isInput ? "val" : "text" ];
			this.isNewMenu = true;
	
			this.element
				.addClass( "ui-autocomplete-input" )
				.attr( "autocomplete", "off" );
	
			this._on( this.element, {
				keydown: function( event ) {
					if ( this.element.prop( "readOnly" ) ) {
						suppressKeyPress = true;
						suppressInput = true;
						suppressKeyPressRepeat = true;
						return;
					}
	
					suppressKeyPress = false;
					suppressInput = false;
					suppressKeyPressRepeat = false;
					var keyCode = $.ui.keyCode;
					switch ( event.keyCode ) {
					case keyCode.PAGE_UP:
						suppressKeyPress = true;
						this._move( "previousPage", event );
						break;
					case keyCode.PAGE_DOWN:
						suppressKeyPress = true;
						this._move( "nextPage", event );
						break;
					case keyCode.UP:
						suppressKeyPress = true;
						this._keyEvent( "previous", event );
						break;
					case keyCode.DOWN:
						suppressKeyPress = true;
						this._keyEvent( "next", event );
						break;
					case keyCode.ENTER:
						// when menu is open and has focus
						if ( this.menu.active ) {
							// #6055 - Opera still allows the keypress to occur
							// which causes forms to submit
							suppressKeyPress = true;
							event.preventDefault();
							this.menu.select( event );
						}
						break;
					case keyCode.TAB:
						if ( this.menu.active ) {
							this.menu.select( event );
						}
						break;
					case keyCode.ESCAPE:
						if ( this.menu.element.is( ":visible" ) ) {
							if ( !this.isMultiLine ) {
								this._value( this.term );
							}
							this.close( event );
							// Different browsers have different default behavior for escape
							// Single press can mean undo or clear
							// Double press in IE means clear the whole form
							event.preventDefault();
						}
						break;
					default:
						suppressKeyPressRepeat = true;
						// search timeout should be triggered before the input value is changed
						this._searchTimeout( event );
						break;
					}
				},
				keypress: function( event ) {
					if ( suppressKeyPress ) {
						suppressKeyPress = false;
						if ( !this.isMultiLine || this.menu.element.is( ":visible" ) ) {
							event.preventDefault();
						}
						return;
					}
					if ( suppressKeyPressRepeat ) {
						return;
					}
	
					// replicate some key handlers to allow them to repeat in Firefox and Opera
					var keyCode = $.ui.keyCode;
					switch ( event.keyCode ) {
					case keyCode.PAGE_UP:
						this._move( "previousPage", event );
						break;
					case keyCode.PAGE_DOWN:
						this._move( "nextPage", event );
						break;
					case keyCode.UP:
						this._keyEvent( "previous", event );
						break;
					case keyCode.DOWN:
						this._keyEvent( "next", event );
						break;
					}
				},
				input: function( event ) {
					if ( suppressInput ) {
						suppressInput = false;
						event.preventDefault();
						return;
					}
					this._searchTimeout( event );
				},
				focus: function() {
					this.selectedItem = null;
					this.previous = this._value();
				},
				blur: function( event ) {
					if ( this.cancelBlur ) {
						delete this.cancelBlur;
						return;
					}
	
					clearTimeout( this.searching );
					this.close( event );
					this._change( event );
				}
			});
	
			this._initSource();
			this.menu = $( "<ul>" )
				.addClass( "ui-autocomplete ui-front" )
				.appendTo( this._appendTo() )
				.menu({
					// disable ARIA support, the live region takes care of that
					role: null
				})
				.hide()
				.menu( "instance" );
	
			this._on( this.menu.element, {
				mousedown: function( event ) {
					// prevent moving focus out of the text field
					event.preventDefault();
	
					// IE doesn't prevent moving focus even with event.preventDefault()
					// so we set a flag to know when we should ignore the blur event
					this.cancelBlur = true;
					this._delay(function() {
						delete this.cancelBlur;
					});
	
					// clicking on the scrollbar causes focus to shift to the body
					// but we can't detect a mouseup or a click immediately afterward
					// so we have to track the next mousedown and close the menu if
					// the user clicks somewhere outside of the autocomplete
					var menuElement = this.menu.element[ 0 ];
					if ( !$( event.target ).closest( ".ui-menu-item" ).length ) {
						this._delay(function() {
							var that = this;
							this.document.one( "mousedown", function( event ) {
								if ( event.target !== that.element[ 0 ] &&
										event.target !== menuElement &&
										!$.contains( menuElement, event.target ) ) {
									that.close();
								}
							});
						});
					}
				},
				menufocus: function( event, ui ) {
					var label, item;
					// support: Firefox
					// Prevent accidental activation of menu items in Firefox (#7024 #9118)
					if ( this.isNewMenu ) {
						this.isNewMenu = false;
						if ( event.originalEvent && /^mouse/.test( event.originalEvent.type ) ) {
							this.menu.blur();
	
							this.document.one( "mousemove", function() {
								$( event.target ).trigger( event.originalEvent );
							});
	
							return;
						}
					}
	
					item = ui.item.data( "ui-autocomplete-item" );
					if ( false !== this._trigger( "focus", event, { item: item } ) ) {
						// use value to match what will end up in the input, if it was a key event
						if ( event.originalEvent && /^key/.test( event.originalEvent.type ) ) {
							this._value( item.value );
						}
					}
	
					// Announce the value in the liveRegion
					label = ui.item.attr( "aria-label" ) || item.value;
					if ( label && $.trim( label ).length ) {
						this.liveRegion.children().hide();
						$( "<div>" ).text( label ).appendTo( this.liveRegion );
					}
				},
				menuselect: function( event, ui ) {
					var item = ui.item.data( "ui-autocomplete-item" ),
						previous = this.previous;
	
					// only trigger when focus was lost (click on menu)
					if ( this.element[ 0 ] !== this.document[ 0 ].activeElement ) {
						this.element.focus();
						this.previous = previous;
						// #6109 - IE triggers two focus events and the second
						// is asynchronous, so we need to reset the previous
						// term synchronously and asynchronously :-(
						this._delay(function() {
							this.previous = previous;
							this.selectedItem = item;
						});
					}
	
					if ( false !== this._trigger( "select", event, { item: item } ) ) {
						this._value( item.value );
					}
					// reset the term after the select event
					// this allows custom select handling to work properly
					this.term = this._value();
	
					this.close( event );
					this.selectedItem = item;
				}
			});
	
			this.liveRegion = $( "<span>", {
					role: "status",
					"aria-live": "assertive",
					"aria-relevant": "additions"
				})
				.addClass( "ui-helper-hidden-accessible" )
				.appendTo( this.document[ 0 ].body );
	
			// turning off autocomplete prevents the browser from remembering the
			// value when navigating through history, so we re-enable autocomplete
			// if the page is unloaded before the widget is destroyed. #7790
			this._on( this.window, {
				beforeunload: function() {
					this.element.removeAttr( "autocomplete" );
				}
			});
		},
	
		_destroy: function() {
			clearTimeout( this.searching );
			this.element
				.removeClass( "ui-autocomplete-input" )
				.removeAttr( "autocomplete" );
			this.menu.element.remove();
			this.liveRegion.remove();
		},
	
		_setOption: function( key, value ) {
			this._super( key, value );
			if ( key === "source" ) {
				this._initSource();
			}
			if ( key === "appendTo" ) {
				this.menu.element.appendTo( this._appendTo() );
			}
			if ( key === "disabled" && value && this.xhr ) {
				this.xhr.abort();
			}
		},
	
		_appendTo: function() {
			var element = this.options.appendTo;
	
			if ( element ) {
				element = element.jquery || element.nodeType ?
					$( element ) :
					this.document.find( element ).eq( 0 );
			}
	
			if ( !element || !element[ 0 ] ) {
				element = this.element.closest( ".ui-front" );
			}
	
			if ( !element.length ) {
				element = this.document[ 0 ].body;
			}
	
			return element;
		},
	
		_initSource: function() {
			var array, url,
				that = this;
			if ( $.isArray( this.options.source ) ) {
				array = this.options.source;
				this.source = function( request, response ) {
					response( $.ui.autocomplete.filter( array, request.term ) );
				};
			} else if ( typeof this.options.source === "string" ) {
				url = this.options.source;
				this.source = function( request, response ) {
					if ( that.xhr ) {
						that.xhr.abort();
					}
					that.xhr = $.ajax({
						url: url,
						data: request,
						dataType: "json",
						success: function( data ) {
							response( data );
						},
						error: function() {
							response([]);
						}
					});
				};
			} else {
				this.source = this.options.source;
			}
		},
	
		_searchTimeout: function( event ) {
			clearTimeout( this.searching );
			this.searching = this._delay(function() {
	
				// Search if the value has changed, or if the user retypes the same value (see #7434)
				var equalValues = this.term === this._value(),
					menuVisible = this.menu.element.is( ":visible" ),
					modifierKey = event.altKey || event.ctrlKey || event.metaKey || event.shiftKey;
	
				if ( !equalValues || ( equalValues && !menuVisible && !modifierKey ) ) {
					this.selectedItem = null;
					this.search( null, event );
				}
			}, this.options.delay );
		},
	
		search: function( value, event ) {
			value = value != null ? value : this._value();
	
			// always save the actual value, not the one passed as an argument
			this.term = this._value();
	
			if ( value.length < this.options.minLength ) {
				return this.close( event );
			}
	
			if ( this._trigger( "search", event ) === false ) {
				return;
			}
	
			return this._search( value );
		},
	
		_search: function( value ) {
			this.pending++;
			this.element.addClass( "ui-autocomplete-loading" );
			this.cancelSearch = false;
	
			this.source( { term: value }, this._response() );
		},
	
		_response: function() {
			var index = ++this.requestIndex;
	
			return $.proxy(function( content ) {
				if ( index === this.requestIndex ) {
					this.__response( content );
				}
	
				this.pending--;
				if ( !this.pending ) {
					this.element.removeClass( "ui-autocomplete-loading" );
				}
			}, this );
		},
	
		__response: function( content ) {
			if ( content ) {
				content = this._normalize( content );
			}
			this._trigger( "response", null, { content: content } );
			if ( !this.options.disabled && content && content.length && !this.cancelSearch ) {
				this._suggest( content );
				this._trigger( "open" );
			} else {
				// use ._close() instead of .close() so we don't cancel future searches
				this._close();
			}
		},
	
		close: function( event ) {
			this.cancelSearch = true;
			this._close( event );
		},
	
		_close: function( event ) {
			if ( this.menu.element.is( ":visible" ) ) {
				this.menu.element.hide();
				this.menu.blur();
				this.isNewMenu = true;
				this._trigger( "close", event );
			}
		},
	
		_change: function( event ) {
			if ( this.previous !== this._value() ) {
				this._trigger( "change", event, { item: this.selectedItem } );
			}
		},
	
		_normalize: function( items ) {
			// assume all items have the right format when the first item is complete
			if ( items.length && items[ 0 ].label && items[ 0 ].value ) {
				return items;
			}
			return $.map( items, function( item ) {
				if ( typeof item === "string" ) {
					return {
						label: item,
						value: item
					};
				}
				return $.extend( {}, item, {
					label: item.label || item.value,
					value: item.value || item.label
				});
			});
		},
	
		_suggest: function( items ) {
			var ul = this.menu.element.empty();
			this._renderMenu( ul, items );
			this.isNewMenu = true;
			this.menu.refresh();
	
			// size and position menu
			ul.show();
			this._resizeMenu();
			ul.position( $.extend({
				of: this.element
			}, this.options.position ) );
	
			if ( this.options.autoFocus ) {
				this.menu.next();
			}
		},
	
		_resizeMenu: function() {
			var ul = this.menu.element;
			ul.outerWidth( Math.max(
				// Firefox wraps long text (possibly a rounding bug)
				// so we add 1px to avoid the wrapping (#7513)
				ul.width( "" ).outerWidth() + 1,
				this.element.outerWidth()
			) );
		},
	
		_renderMenu: function( ul, items ) {
			var that = this;
			$.each( items, function( index, item ) {
				that._renderItemData( ul, item );
			});
		},
	
		_renderItemData: function( ul, item ) {
			return this._renderItem( ul, item ).data( "ui-autocomplete-item", item );
		},
	
		_renderItem: function( ul, item ) {
			return $( "<li>" ).text( item.label ).appendTo( ul );
		},
	
		_move: function( direction, event ) {
			if ( !this.menu.element.is( ":visible" ) ) {
				this.search( null, event );
				return;
			}
			if ( this.menu.isFirstItem() && /^previous/.test( direction ) ||
					this.menu.isLastItem() && /^next/.test( direction ) ) {
	
				if ( !this.isMultiLine ) {
					this._value( this.term );
				}
	
				this.menu.blur();
				return;
			}
			this.menu[ direction ]( event );
		},
	
		widget: function() {
			return this.menu.element;
		},
	
		_value: function() {
			return this.valueMethod.apply( this.element, arguments );
		},
	
		_keyEvent: function( keyEvent, event ) {
			if ( !this.isMultiLine || this.menu.element.is( ":visible" ) ) {
				this._move( keyEvent, event );
	
				// prevents moving cursor to beginning/end of the text field in some browsers
				event.preventDefault();
			}
		}
	});
	
	$.extend( $.ui.autocomplete, {
		escapeRegex: function( value ) {
			return value.replace( /[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&" );
		},
		filter: function( array, term ) {
			var matcher = new RegExp( $.ui.autocomplete.escapeRegex( term ), "i" );
			return $.grep( array, function( value ) {
				return matcher.test( value.label || value.value || value );
			});
		}
	});
	
	// live region extension, adding a `messages` option
	// NOTE: This is an experimental API. We are still investigating
	// a full solution for string manipulation and internationalization.
	$.widget( "ui.autocomplete", $.ui.autocomplete, {
		options: {
			messages: {
				noResults: "No search results.",
				results: function( amount ) {
					return amount + ( amount > 1 ? " results are" : " result is" ) +
						" available, use up and down arrow keys to navigate.";
				}
			}
		},
	
		__response: function( content ) {
			var message;
			this._superApply( arguments );
			if ( this.options.disabled || this.cancelSearch ) {
				return;
			}
			if ( content && content.length ) {
				message = this.options.messages.results( content.length );
			} else {
				message = this.options.messages.noResults;
			}
			this.liveRegion.children().hide();
			$( "<div>" ).text( message ).appendTo( this.liveRegion );
		}
	});
	
	var autocomplete = $.ui.autocomplete;
	
	
	/*!
	 * jQuery UI Button 1.11.4
	 * http://jqueryui.com
	 *
	 * Copyright jQuery Foundation and other contributors
	 * Released under the MIT license.
	 * http://jquery.org/license
	 *
	 * http://api.jqueryui.com/button/
	 */
	
	
	var lastActive,
		baseClasses = "ui-button ui-widget ui-state-default ui-corner-all",
		typeClasses = "ui-button-icons-only ui-button-icon-only ui-button-text-icons ui-button-text-icon-primary ui-button-text-icon-secondary ui-button-text-only",
		formResetHandler = function() {
			var form = $( this );
			setTimeout(function() {
				form.find( ":ui-button" ).button( "refresh" );
			}, 1 );
		},
		radioGroup = function( radio ) {
			var name = radio.name,
				form = radio.form,
				radios = $( [] );
			if ( name ) {
				name = name.replace( /'/g, "\\'" );
				if ( form ) {
					radios = $( form ).find( "[name='" + name + "'][type=radio]" );
				} else {
					radios = $( "[name='" + name + "'][type=radio]", radio.ownerDocument )
						.filter(function() {
							return !this.form;
						});
				}
			}
			return radios;
		};
	
	$.widget( "ui.button", {
		version: "1.11.4",
		defaultElement: "<button>",
		options: {
			disabled: null,
			text: true,
			label: null,
			icons: {
				primary: null,
				secondary: null
			}
		},
		_create: function() {
			this.element.closest( "form" )
				.unbind( "reset" + this.eventNamespace )
				.bind( "reset" + this.eventNamespace, formResetHandler );
	
			if ( typeof this.options.disabled !== "boolean" ) {
				this.options.disabled = !!this.element.prop( "disabled" );
			} else {
				this.element.prop( "disabled", this.options.disabled );
			}
	
			this._determineButtonType();
			this.hasTitle = !!this.buttonElement.attr( "title" );
	
			var that = this,
				options = this.options,
				toggleButton = this.type === "checkbox" || this.type === "radio",
				activeClass = !toggleButton ? "ui-state-active" : "";
	
			if ( options.label === null ) {
				options.label = (this.type === "input" ? this.buttonElement.val() : this.buttonElement.html());
			}
	
			this._hoverable( this.buttonElement );
	
			this.buttonElement
				.addClass( baseClasses )
				.attr( "role", "button" )
				.bind( "mouseenter" + this.eventNamespace, function() {
					if ( options.disabled ) {
						return;
					}
					if ( this === lastActive ) {
						$( this ).addClass( "ui-state-active" );
					}
				})
				.bind( "mouseleave" + this.eventNamespace, function() {
					if ( options.disabled ) {
						return;
					}
					$( this ).removeClass( activeClass );
				})
				.bind( "click" + this.eventNamespace, function( event ) {
					if ( options.disabled ) {
						event.preventDefault();
						event.stopImmediatePropagation();
					}
				});
	
			// Can't use _focusable() because the element that receives focus
			// and the element that gets the ui-state-focus class are different
			this._on({
				focus: function() {
					this.buttonElement.addClass( "ui-state-focus" );
				},
				blur: function() {
					this.buttonElement.removeClass( "ui-state-focus" );
				}
			});
	
			if ( toggleButton ) {
				this.element.bind( "change" + this.eventNamespace, function() {
					that.refresh();
				});
			}
	
			if ( this.type === "checkbox" ) {
				this.buttonElement.bind( "click" + this.eventNamespace, function() {
					if ( options.disabled ) {
						return false;
					}
				});
			} else if ( this.type === "radio" ) {
				this.buttonElement.bind( "click" + this.eventNamespace, function() {
					if ( options.disabled ) {
						return false;
					}
					$( this ).addClass( "ui-state-active" );
					that.buttonElement.attr( "aria-pressed", "true" );
	
					var radio = that.element[ 0 ];
					radioGroup( radio )
						.not( radio )
						.map(function() {
							return $( this ).button( "widget" )[ 0 ];
						})
						.removeClass( "ui-state-active" )
						.attr( "aria-pressed", "false" );
				});
			} else {
				this.buttonElement
					.bind( "mousedown" + this.eventNamespace, function() {
						if ( options.disabled ) {
							return false;
						}
						$( this ).addClass( "ui-state-active" );
						lastActive = this;
						that.document.one( "mouseup", function() {
							lastActive = null;
						});
					})
					.bind( "mouseup" + this.eventNamespace, function() {
						if ( options.disabled ) {
							return false;
						}
						$( this ).removeClass( "ui-state-active" );
					})
					.bind( "keydown" + this.eventNamespace, function(event) {
						if ( options.disabled ) {
							return false;
						}
						if ( event.keyCode === $.ui.keyCode.SPACE || event.keyCode === $.ui.keyCode.ENTER ) {
							$( this ).addClass( "ui-state-active" );
						}
					})
					// see #8559, we bind to blur here in case the button element loses
					// focus between keydown and keyup, it would be left in an "active" state
					.bind( "keyup" + this.eventNamespace + " blur" + this.eventNamespace, function() {
						$( this ).removeClass( "ui-state-active" );
					});
	
				if ( this.buttonElement.is("a") ) {
					this.buttonElement.keyup(function(event) {
						if ( event.keyCode === $.ui.keyCode.SPACE ) {
							// TODO pass through original event correctly (just as 2nd argument doesn't work)
							$( this ).click();
						}
					});
				}
			}
	
			this._setOption( "disabled", options.disabled );
			this._resetButton();
		},
	
		_determineButtonType: function() {
			var ancestor, labelSelector, checked;
	
			if ( this.element.is("[type=checkbox]") ) {
				this.type = "checkbox";
			} else if ( this.element.is("[type=radio]") ) {
				this.type = "radio";
			} else if ( this.element.is("input") ) {
				this.type = "input";
			} else {
				this.type = "button";
			}
	
			if ( this.type === "checkbox" || this.type === "radio" ) {
				// we don't search against the document in case the element
				// is disconnected from the DOM
				ancestor = this.element.parents().last();
				labelSelector = "label[for='" + this.element.attr("id") + "']";
				this.buttonElement = ancestor.find( labelSelector );
				if ( !this.buttonElement.length ) {
					ancestor = ancestor.length ? ancestor.siblings() : this.element.siblings();
					this.buttonElement = ancestor.filter( labelSelector );
					if ( !this.buttonElement.length ) {
						this.buttonElement = ancestor.find( labelSelector );
					}
				}
				this.element.addClass( "ui-helper-hidden-accessible" );
	
				checked = this.element.is( ":checked" );
				if ( checked ) {
					this.buttonElement.addClass( "ui-state-active" );
				}
				this.buttonElement.prop( "aria-pressed", checked );
			} else {
				this.buttonElement = this.element;
			}
		},
	
		widget: function() {
			return this.buttonElement;
		},
	
		_destroy: function() {
			this.element
				.removeClass( "ui-helper-hidden-accessible" );
			this.buttonElement
				.removeClass( baseClasses + " ui-state-active " + typeClasses )
				.removeAttr( "role" )
				.removeAttr( "aria-pressed" )
				.html( this.buttonElement.find(".ui-button-text").html() );
	
			if ( !this.hasTitle ) {
				this.buttonElement.removeAttr( "title" );
			}
		},
	
		_setOption: function( key, value ) {
			this._super( key, value );
			if ( key === "disabled" ) {
				this.widget().toggleClass( "ui-state-disabled", !!value );
				this.element.prop( "disabled", !!value );
				if ( value ) {
					if ( this.type === "checkbox" || this.type === "radio" ) {
						this.buttonElement.removeClass( "ui-state-focus" );
					} else {
						this.buttonElement.removeClass( "ui-state-focus ui-state-active" );
					}
				}
				return;
			}
			this._resetButton();
		},
	
		refresh: function() {
			//See #8237 & #8828
			var isDisabled = this.element.is( "input, button" ) ? this.element.is( ":disabled" ) : this.element.hasClass( "ui-button-disabled" );
	
			if ( isDisabled !== this.options.disabled ) {
				this._setOption( "disabled", isDisabled );
			}
			if ( this.type === "radio" ) {
				radioGroup( this.element[0] ).each(function() {
					if ( $( this ).is( ":checked" ) ) {
						$( this ).button( "widget" )
							.addClass( "ui-state-active" )
							.attr( "aria-pressed", "true" );
					} else {
						$( this ).button( "widget" )
							.removeClass( "ui-state-active" )
							.attr( "aria-pressed", "false" );
					}
				});
			} else if ( this.type === "checkbox" ) {
				if ( this.element.is( ":checked" ) ) {
					this.buttonElement
						.addClass( "ui-state-active" )
						.attr( "aria-pressed", "true" );
				} else {
					this.buttonElement
						.removeClass( "ui-state-active" )
						.attr( "aria-pressed", "false" );
				}
			}
		},
	
		_resetButton: function() {
			if ( this.type === "input" ) {
				if ( this.options.label ) {
					this.element.val( this.options.label );
				}
				return;
			}
			var buttonElement = this.buttonElement.removeClass( typeClasses ),
				buttonText = $( "<span></span>", this.document[0] )
					.addClass( "ui-button-text" )
					.html( this.options.label )
					.appendTo( buttonElement.empty() )
					.text(),
				icons = this.options.icons,
				multipleIcons = icons.primary && icons.secondary,
				buttonClasses = [];
	
			if ( icons.primary || icons.secondary ) {
				if ( this.options.text ) {
					buttonClasses.push( "ui-button-text-icon" + ( multipleIcons ? "s" : ( icons.primary ? "-primary" : "-secondary" ) ) );
				}
	
				if ( icons.primary ) {
					buttonElement.prepend( "<span class='ui-button-icon-primary ui-icon " + icons.primary + "'></span>" );
				}
	
				if ( icons.secondary ) {
					buttonElement.append( "<span class='ui-button-icon-secondary ui-icon " + icons.secondary + "'></span>" );
				}
	
				if ( !this.options.text ) {
					buttonClasses.push( multipleIcons ? "ui-button-icons-only" : "ui-button-icon-only" );
	
					if ( !this.hasTitle ) {
						buttonElement.attr( "title", $.trim( buttonText ) );
					}
				}
			} else {
				buttonClasses.push( "ui-button-text-only" );
			}
			buttonElement.addClass( buttonClasses.join( " " ) );
		}
	});
	
	$.widget( "ui.buttonset", {
		version: "1.11.4",
		options: {
			items: "button, input[type=button], input[type=submit], input[type=reset], input[type=checkbox], input[type=radio], a, :data(ui-button)"
		},
	
		_create: function() {
			this.element.addClass( "ui-buttonset" );
		},
	
		_init: function() {
			this.refresh();
		},
	
		_setOption: function( key, value ) {
			if ( key === "disabled" ) {
				this.buttons.button( "option", key, value );
			}
	
			this._super( key, value );
		},
	
		refresh: function() {
			var rtl = this.element.css( "direction" ) === "rtl",
				allButtons = this.element.find( this.options.items ),
				existingButtons = allButtons.filter( ":ui-button" );
	
			// Initialize new buttons
			allButtons.not( ":ui-button" ).button();
	
			// Refresh existing buttons
			existingButtons.button( "refresh" );
	
			this.buttons = allButtons
				.map(function() {
					return $( this ).button( "widget" )[ 0 ];
				})
					.removeClass( "ui-corner-all ui-corner-left ui-corner-right" )
					.filter( ":first" )
						.addClass( rtl ? "ui-corner-right" : "ui-corner-left" )
					.end()
					.filter( ":last" )
						.addClass( rtl ? "ui-corner-left" : "ui-corner-right" )
					.end()
				.end();
		},
	
		_destroy: function() {
			this.element.removeClass( "ui-buttonset" );
			this.buttons
				.map(function() {
					return $( this ).button( "widget" )[ 0 ];
				})
					.removeClass( "ui-corner-left ui-corner-right" )
				.end()
				.button( "destroy" );
		}
	});
	
	var button = $.ui.button;
	
	
	/*!
	 * jQuery UI Datepicker 1.11.4
	 * http://jqueryui.com
	 *
	 * Copyright jQuery Foundation and other contributors
	 * Released under the MIT license.
	 * http://jquery.org/license
	 *
	 * http://api.jqueryui.com/datepicker/
	 */
	
	
	$.extend($.ui, { datepicker: { version: "1.11.4" } });
	
	var datepicker_instActive;
	
	function datepicker_getZindex( elem ) {
		var position, value;
		while ( elem.length && elem[ 0 ] !== document ) {
			// Ignore z-index if position is set to a value where z-index is ignored by the browser
			// This makes behavior of this function consistent across browsers
			// WebKit always returns auto if the element is positioned
			position = elem.css( "position" );
			if ( position === "absolute" || position === "relative" || position === "fixed" ) {
				// IE returns 0 when zIndex is not specified
				// other browsers return a string
				// we ignore the case of nested elements with an explicit value of 0
				// <div style="z-index: -10;"><div style="z-index: 0;"></div></div>
				value = parseInt( elem.css( "zIndex" ), 10 );
				if ( !isNaN( value ) && value !== 0 ) {
					return value;
				}
			}
			elem = elem.parent();
		}
	
		return 0;
	}
	/* Date picker manager.
	   Use the singleton instance of this class, $.datepicker, to interact with the date picker.
	   Settings for (groups of) date pickers are maintained in an instance object,
	   allowing multiple different settings on the same page. */
	
	function Datepicker() {
		this._curInst = null; // The current instance in use
		this._keyEvent = false; // If the last event was a key event
		this._disabledInputs = []; // List of date picker inputs that have been disabled
		this._datepickerShowing = false; // True if the popup picker is showing , false if not
		this._inDialog = false; // True if showing within a "dialog", false if not
		this._mainDivId = "ui-datepicker-div"; // The ID of the main datepicker division
		this._inlineClass = "ui-datepicker-inline"; // The name of the inline marker class
		this._appendClass = "ui-datepicker-append"; // The name of the append marker class
		this._triggerClass = "ui-datepicker-trigger"; // The name of the trigger marker class
		this._dialogClass = "ui-datepicker-dialog"; // The name of the dialog marker class
		this._disableClass = "ui-datepicker-disabled"; // The name of the disabled covering marker class
		this._unselectableClass = "ui-datepicker-unselectable"; // The name of the unselectable cell marker class
		this._currentClass = "ui-datepicker-current-day"; // The name of the current day marker class
		this._dayOverClass = "ui-datepicker-days-cell-over"; // The name of the day hover marker class
		this.regional = []; // Available regional settings, indexed by language code
		this.regional[""] = { // Default regional settings
			closeText: "Done", // Display text for close link
			prevText: "Prev", // Display text for previous month link
			nextText: "Next", // Display text for next month link
			currentText: "Today", // Display text for current month link
			monthNames: ["January","February","March","April","May","June",
				"July","August","September","October","November","December"], // Names of months for drop-down and formatting
			monthNamesShort: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"], // For formatting
			dayNames: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"], // For formatting
			dayNamesShort: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"], // For formatting
			dayNamesMin: ["Su","Mo","Tu","We","Th","Fr","Sa"], // Column headings for days starting at Sunday
			weekHeader: "Wk", // Column header for week of the year
			dateFormat: "mm/dd/yy", // See format options on parseDate
			firstDay: 0, // The first day of the week, Sun = 0, Mon = 1, ...
			isRTL: false, // True if right-to-left language, false if left-to-right
			showMonthAfterYear: false, // True if the year select precedes month, false for month then year
			yearSuffix: "" // Additional text to append to the year in the month headers
		};
		this._defaults = { // Global defaults for all the date picker instances
			showOn: "focus", // "focus" for popup on focus,
				// "button" for trigger button, or "both" for either
			showAnim: "fadeIn", // Name of jQuery animation for popup
			showOptions: {}, // Options for enhanced animations
			defaultDate: null, // Used when field is blank: actual date,
				// +/-number for offset from today, null for today
			appendText: "", // Display text following the input box, e.g. showing the format
			buttonText: "...", // Text for trigger button
			buttonImage: "", // URL for trigger button image
			buttonImageOnly: false, // True if the image appears alone, false if it appears on a button
			hideIfNoPrevNext: false, // True to hide next/previous month links
				// if not applicable, false to just disable them
			navigationAsDateFormat: false, // True if date formatting applied to prev/today/next links
			gotoCurrent: false, // True if today link goes back to current selection instead
			changeMonth: false, // True if month can be selected directly, false if only prev/next
			changeYear: false, // True if year can be selected directly, false if only prev/next
			yearRange: "c-10:c+10", // Range of years to display in drop-down,
				// either relative to today's year (-nn:+nn), relative to currently displayed year
				// (c-nn:c+nn), absolute (nnnn:nnnn), or a combination of the above (nnnn:-n)
			showOtherMonths: false, // True to show dates in other months, false to leave blank
			selectOtherMonths: false, // True to allow selection of dates in other months, false for unselectable
			showWeek: false, // True to show week of the year, false to not show it
			calculateWeek: this.iso8601Week, // How to calculate the week of the year,
				// takes a Date and returns the number of the week for it
			shortYearCutoff: "+10", // Short year values < this are in the current century,
				// > this are in the previous century,
				// string value starting with "+" for current year + value
			minDate: null, // The earliest selectable date, or null for no limit
			maxDate: null, // The latest selectable date, or null for no limit
			duration: "fast", // Duration of display/closure
			beforeShowDay: null, // Function that takes a date and returns an array with
				// [0] = true if selectable, false if not, [1] = custom CSS class name(s) or "",
				// [2] = cell title (optional), e.g. $.datepicker.noWeekends
			beforeShow: null, // Function that takes an input field and
				// returns a set of custom settings for the date picker
			onSelect: null, // Define a callback function when a date is selected
			onChangeMonthYear: null, // Define a callback function when the month or year is changed
			onClose: null, // Define a callback function when the datepicker is closed
			numberOfMonths: 1, // Number of months to show at a time
			showCurrentAtPos: 0, // The position in multipe months at which to show the current month (starting at 0)
			stepMonths: 1, // Number of months to step back/forward
			stepBigMonths: 12, // Number of months to step back/forward for the big links
			altField: "", // Selector for an alternate field to store selected dates into
			altFormat: "", // The date format to use for the alternate field
			constrainInput: true, // The input is constrained by the current date format
			showButtonPanel: false, // True to show button panel, false to not show it
			autoSize: false, // True to size the input for the date format, false to leave as is
			disabled: false // The initial disabled state
		};
		$.extend(this._defaults, this.regional[""]);
		this.regional.en = $.extend( true, {}, this.regional[ "" ]);
		this.regional[ "en-US" ] = $.extend( true, {}, this.regional.en );
		this.dpDiv = datepicker_bindHover($("<div id='" + this._mainDivId + "' class='ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all'></div>"));
	}
	
	$.extend(Datepicker.prototype, {
		/* Class name added to elements to indicate already configured with a date picker. */
		markerClassName: "hasDatepicker",
	
		//Keep track of the maximum number of rows displayed (see #7043)
		maxRows: 4,
	
		// TODO rename to "widget" when switching to widget factory
		_widgetDatepicker: function() {
			return this.dpDiv;
		},
	
		/* Override the default settings for all instances of the date picker.
		 * @param  settings  object - the new settings to use as defaults (anonymous object)
		 * @return the manager object
		 */
		setDefaults: function(settings) {
			datepicker_extendRemove(this._defaults, settings || {});
			return this;
		},
	
		/* Attach the date picker to a jQuery selection.
		 * @param  target	element - the target input field or division or span
		 * @param  settings  object - the new settings to use for this date picker instance (anonymous)
		 */
		_attachDatepicker: function(target, settings) {
			var nodeName, inline, inst;
			nodeName = target.nodeName.toLowerCase();
			inline = (nodeName === "div" || nodeName === "span");
			if (!target.id) {
				this.uuid += 1;
				target.id = "dp" + this.uuid;
			}
			inst = this._newInst($(target), inline);
			inst.settings = $.extend({}, settings || {});
			if (nodeName === "input") {
				this._connectDatepicker(target, inst);
			} else if (inline) {
				this._inlineDatepicker(target, inst);
			}
		},
	
		/* Create a new instance object. */
		_newInst: function(target, inline) {
			var id = target[0].id.replace(/([^A-Za-z0-9_\-])/g, "\\\\$1"); // escape jQuery meta chars
			return {id: id, input: target, // associated target
				selectedDay: 0, selectedMonth: 0, selectedYear: 0, // current selection
				drawMonth: 0, drawYear: 0, // month being drawn
				inline: inline, // is datepicker inline or not
				dpDiv: (!inline ? this.dpDiv : // presentation div
				datepicker_bindHover($("<div class='" + this._inlineClass + " ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all'></div>")))};
		},
	
		/* Attach the date picker to an input field. */
		_connectDatepicker: function(target, inst) {
			var input = $(target);
			inst.append = $([]);
			inst.trigger = $([]);
			if (input.hasClass(this.markerClassName)) {
				return;
			}
			this._attachments(input, inst);
			input.addClass(this.markerClassName).keydown(this._doKeyDown).
				keypress(this._doKeyPress).keyup(this._doKeyUp);
			this._autoSize(inst);
			$.data(target, "datepicker", inst);
			//If disabled option is true, disable the datepicker once it has been attached to the input (see ticket #5665)
			if( inst.settings.disabled ) {
				this._disableDatepicker( target );
			}
		},
	
		/* Make attachments based on settings. */
		_attachments: function(input, inst) {
			var showOn, buttonText, buttonImage,
				appendText = this._get(inst, "appendText"),
				isRTL = this._get(inst, "isRTL");
	
			if (inst.append) {
				inst.append.remove();
			}
			if (appendText) {
				inst.append = $("<span class='" + this._appendClass + "'>" + appendText + "</span>");
				input[isRTL ? "before" : "after"](inst.append);
			}
	
			input.unbind("focus", this._showDatepicker);
	
			if (inst.trigger) {
				inst.trigger.remove();
			}
	
			showOn = this._get(inst, "showOn");
			if (showOn === "focus" || showOn === "both") { // pop-up date picker when in the marked field
				input.focus(this._showDatepicker);
			}
			if (showOn === "button" || showOn === "both") { // pop-up date picker when button clicked
				buttonText = this._get(inst, "buttonText");
				buttonImage = this._get(inst, "buttonImage");
				inst.trigger = $(this._get(inst, "buttonImageOnly") ?
					$("<img/>").addClass(this._triggerClass).
						attr({ src: buttonImage, alt: buttonText, title: buttonText }) :
					$("<button type='button'></button>").addClass(this._triggerClass).
						html(!buttonImage ? buttonText : $("<img/>").attr(
						{ src:buttonImage, alt:buttonText, title:buttonText })));
				input[isRTL ? "before" : "after"](inst.trigger);
				inst.trigger.click(function() {
					if ($.datepicker._datepickerShowing && $.datepicker._lastInput === input[0]) {
						$.datepicker._hideDatepicker();
					} else if ($.datepicker._datepickerShowing && $.datepicker._lastInput !== input[0]) {
						$.datepicker._hideDatepicker();
						$.datepicker._showDatepicker(input[0]);
					} else {
						$.datepicker._showDatepicker(input[0]);
					}
					return false;
				});
			}
		},
	
		/* Apply the maximum length for the date format. */
		_autoSize: function(inst) {
			if (this._get(inst, "autoSize") && !inst.inline) {
				var findMax, max, maxI, i,
					date = new Date(2009, 12 - 1, 20), // Ensure double digits
					dateFormat = this._get(inst, "dateFormat");
	
				if (dateFormat.match(/[DM]/)) {
					findMax = function(names) {
						max = 0;
						maxI = 0;
						for (i = 0; i < names.length; i++) {
							if (names[i].length > max) {
								max = names[i].length;
								maxI = i;
							}
						}
						return maxI;
					};
					date.setMonth(findMax(this._get(inst, (dateFormat.match(/MM/) ?
						"monthNames" : "monthNamesShort"))));
					date.setDate(findMax(this._get(inst, (dateFormat.match(/DD/) ?
						"dayNames" : "dayNamesShort"))) + 20 - date.getDay());
				}
				inst.input.attr("size", this._formatDate(inst, date).length);
			}
		},
	
		/* Attach an inline date picker to a div. */
		_inlineDatepicker: function(target, inst) {
			var divSpan = $(target);
			if (divSpan.hasClass(this.markerClassName)) {
				return;
			}
			divSpan.addClass(this.markerClassName).append(inst.dpDiv);
			$.data(target, "datepicker", inst);
			this._setDate(inst, this._getDefaultDate(inst), true);
			this._updateDatepicker(inst);
			this._updateAlternate(inst);
			//If disabled option is true, disable the datepicker before showing it (see ticket #5665)
			if( inst.settings.disabled ) {
				this._disableDatepicker( target );
			}
			// Set display:block in place of inst.dpDiv.show() which won't work on disconnected elements
			// http://bugs.jqueryui.com/ticket/7552 - A Datepicker created on a detached div has zero height
			inst.dpDiv.css( "display", "block" );
		},
	
		/* Pop-up the date picker in a "dialog" box.
		 * @param  input element - ignored
		 * @param  date	string or Date - the initial date to display
		 * @param  onSelect  function - the function to call when a date is selected
		 * @param  settings  object - update the dialog date picker instance's settings (anonymous object)
		 * @param  pos int[2] - coordinates for the dialog's position within the screen or
		 *					event - with x/y coordinates or
		 *					leave empty for default (screen centre)
		 * @return the manager object
		 */
		_dialogDatepicker: function(input, date, onSelect, settings, pos) {
			var id, browserWidth, browserHeight, scrollX, scrollY,
				inst = this._dialogInst; // internal instance
	
			if (!inst) {
				this.uuid += 1;
				id = "dp" + this.uuid;
				this._dialogInput = $("<input type='text' id='" + id +
					"' style='position: absolute; top: -100px; width: 0px;'/>");
				this._dialogInput.keydown(this._doKeyDown);
				$("body").append(this._dialogInput);
				inst = this._dialogInst = this._newInst(this._dialogInput, false);
				inst.settings = {};
				$.data(this._dialogInput[0], "datepicker", inst);
			}
			datepicker_extendRemove(inst.settings, settings || {});
			date = (date && date.constructor === Date ? this._formatDate(inst, date) : date);
			this._dialogInput.val(date);
	
			this._pos = (pos ? (pos.length ? pos : [pos.pageX, pos.pageY]) : null);
			if (!this._pos) {
				browserWidth = document.documentElement.clientWidth;
				browserHeight = document.documentElement.clientHeight;
				scrollX = document.documentElement.scrollLeft || document.body.scrollLeft;
				scrollY = document.documentElement.scrollTop || document.body.scrollTop;
				this._pos = // should use actual width/height below
					[(browserWidth / 2) - 100 + scrollX, (browserHeight / 2) - 150 + scrollY];
			}
	
			// move input on screen for focus, but hidden behind dialog
			this._dialogInput.css("left", (this._pos[0] + 20) + "px").css("top", this._pos[1] + "px");
			inst.settings.onSelect = onSelect;
			this._inDialog = true;
			this.dpDiv.addClass(this._dialogClass);
			this._showDatepicker(this._dialogInput[0]);
			if ($.blockUI) {
				$.blockUI(this.dpDiv);
			}
			$.data(this._dialogInput[0], "datepicker", inst);
			return this;
		},
	
		/* Detach a datepicker from its control.
		 * @param  target	element - the target input field or division or span
		 */
		_destroyDatepicker: function(target) {
			var nodeName,
				$target = $(target),
				inst = $.data(target, "datepicker");
	
			if (!$target.hasClass(this.markerClassName)) {
				return;
			}
	
			nodeName = target.nodeName.toLowerCase();
			$.removeData(target, "datepicker");
			if (nodeName === "input") {
				inst.append.remove();
				inst.trigger.remove();
				$target.removeClass(this.markerClassName).
					unbind("focus", this._showDatepicker).
					unbind("keydown", this._doKeyDown).
					unbind("keypress", this._doKeyPress).
					unbind("keyup", this._doKeyUp);
			} else if (nodeName === "div" || nodeName === "span") {
				$target.removeClass(this.markerClassName).empty();
			}
	
			if ( datepicker_instActive === inst ) {
				datepicker_instActive = null;
			}
		},
	
		/* Enable the date picker to a jQuery selection.
		 * @param  target	element - the target input field or division or span
		 */
		_enableDatepicker: function(target) {
			var nodeName, inline,
				$target = $(target),
				inst = $.data(target, "datepicker");
	
			if (!$target.hasClass(this.markerClassName)) {
				return;
			}
	
			nodeName = target.nodeName.toLowerCase();
			if (nodeName === "input") {
				target.disabled = false;
				inst.trigger.filter("button").
					each(function() { this.disabled = false; }).end().
					filter("img").css({opacity: "1.0", cursor: ""});
			} else if (nodeName === "div" || nodeName === "span") {
				inline = $target.children("." + this._inlineClass);
				inline.children().removeClass("ui-state-disabled");
				inline.find("select.ui-datepicker-month, select.ui-datepicker-year").
					prop("disabled", false);
			}
			this._disabledInputs = $.map(this._disabledInputs,
				function(value) { return (value === target ? null : value); }); // delete entry
		},
	
		/* Disable the date picker to a jQuery selection.
		 * @param  target	element - the target input field or division or span
		 */
		_disableDatepicker: function(target) {
			var nodeName, inline,
				$target = $(target),
				inst = $.data(target, "datepicker");
	
			if (!$target.hasClass(this.markerClassName)) {
				return;
			}
	
			nodeName = target.nodeName.toLowerCase();
			if (nodeName === "input") {
				target.disabled = true;
				inst.trigger.filter("button").
					each(function() { this.disabled = true; }).end().
					filter("img").css({opacity: "0.5", cursor: "default"});
			} else if (nodeName === "div" || nodeName === "span") {
				inline = $target.children("." + this._inlineClass);
				inline.children().addClass("ui-state-disabled");
				inline.find("select.ui-datepicker-month, select.ui-datepicker-year").
					prop("disabled", true);
			}
			this._disabledInputs = $.map(this._disabledInputs,
				function(value) { return (value === target ? null : value); }); // delete entry
			this._disabledInputs[this._disabledInputs.length] = target;
		},
	
		/* Is the first field in a jQuery collection disabled as a datepicker?
		 * @param  target	element - the target input field or division or span
		 * @return boolean - true if disabled, false if enabled
		 */
		_isDisabledDatepicker: function(target) {
			if (!target) {
				return false;
			}
			for (var i = 0; i < this._disabledInputs.length; i++) {
				if (this._disabledInputs[i] === target) {
					return true;
				}
			}
			return false;
		},
	
		/* Retrieve the instance data for the target control.
		 * @param  target  element - the target input field or division or span
		 * @return  object - the associated instance data
		 * @throws  error if a jQuery problem getting data
		 */
		_getInst: function(target) {
			try {
				return $.data(target, "datepicker");
			}
			catch (err) {
				throw "Missing instance data for this datepicker";
			}
		},
	
		/* Update or retrieve the settings for a date picker attached to an input field or division.
		 * @param  target  element - the target input field or division or span
		 * @param  name	object - the new settings to update or
		 *				string - the name of the setting to change or retrieve,
		 *				when retrieving also "all" for all instance settings or
		 *				"defaults" for all global defaults
		 * @param  value   any - the new value for the setting
		 *				(omit if above is an object or to retrieve a value)
		 */
		_optionDatepicker: function(target, name, value) {
			var settings, date, minDate, maxDate,
				inst = this._getInst(target);
	
			if (arguments.length === 2 && typeof name === "string") {
				return (name === "defaults" ? $.extend({}, $.datepicker._defaults) :
					(inst ? (name === "all" ? $.extend({}, inst.settings) :
					this._get(inst, name)) : null));
			}
	
			settings = name || {};
			if (typeof name === "string") {
				settings = {};
				settings[name] = value;
			}
	
			if (inst) {
				if (this._curInst === inst) {
					this._hideDatepicker();
				}
	
				date = this._getDateDatepicker(target, true);
				minDate = this._getMinMaxDate(inst, "min");
				maxDate = this._getMinMaxDate(inst, "max");
				datepicker_extendRemove(inst.settings, settings);
				// reformat the old minDate/maxDate values if dateFormat changes and a new minDate/maxDate isn't provided
				if (minDate !== null && settings.dateFormat !== undefined && settings.minDate === undefined) {
					inst.settings.minDate = this._formatDate(inst, minDate);
				}
				if (maxDate !== null && settings.dateFormat !== undefined && settings.maxDate === undefined) {
					inst.settings.maxDate = this._formatDate(inst, maxDate);
				}
				if ( "disabled" in settings ) {
					if ( settings.disabled ) {
						this._disableDatepicker(target);
					} else {
						this._enableDatepicker(target);
					}
				}
				this._attachments($(target), inst);
				this._autoSize(inst);
				this._setDate(inst, date);
				this._updateAlternate(inst);
				this._updateDatepicker(inst);
			}
		},
	
		// change method deprecated
		_changeDatepicker: function(target, name, value) {
			this._optionDatepicker(target, name, value);
		},
	
		/* Redraw the date picker attached to an input field or division.
		 * @param  target  element - the target input field or division or span
		 */
		_refreshDatepicker: function(target) {
			var inst = this._getInst(target);
			if (inst) {
				this._updateDatepicker(inst);
			}
		},
	
		/* Set the dates for a jQuery selection.
		 * @param  target element - the target input field or division or span
		 * @param  date	Date - the new date
		 */
		_setDateDatepicker: function(target, date) {
			var inst = this._getInst(target);
			if (inst) {
				this._setDate(inst, date);
				this._updateDatepicker(inst);
				this._updateAlternate(inst);
			}
		},
	
		/* Get the date(s) for the first entry in a jQuery selection.
		 * @param  target element - the target input field or division or span
		 * @param  noDefault boolean - true if no default date is to be used
		 * @return Date - the current date
		 */
		_getDateDatepicker: function(target, noDefault) {
			var inst = this._getInst(target);
			if (inst && !inst.inline) {
				this._setDateFromField(inst, noDefault);
			}
			return (inst ? this._getDate(inst) : null);
		},
	
		/* Handle keystrokes. */
		_doKeyDown: function(event) {
			var onSelect, dateStr, sel,
				inst = $.datepicker._getInst(event.target),
				handled = true,
				isRTL = inst.dpDiv.is(".ui-datepicker-rtl");
	
			inst._keyEvent = true;
			if ($.datepicker._datepickerShowing) {
				switch (event.keyCode) {
					case 9: $.datepicker._hideDatepicker();
							handled = false;
							break; // hide on tab out
					case 13: sel = $("td." + $.datepicker._dayOverClass + ":not(." +
										$.datepicker._currentClass + ")", inst.dpDiv);
							if (sel[0]) {
								$.datepicker._selectDay(event.target, inst.selectedMonth, inst.selectedYear, sel[0]);
							}
	
							onSelect = $.datepicker._get(inst, "onSelect");
							if (onSelect) {
								dateStr = $.datepicker._formatDate(inst);
	
								// trigger custom callback
								onSelect.apply((inst.input ? inst.input[0] : null), [dateStr, inst]);
							} else {
								$.datepicker._hideDatepicker();
							}
	
							return false; // don't submit the form
					case 27: $.datepicker._hideDatepicker();
							break; // hide on escape
					case 33: $.datepicker._adjustDate(event.target, (event.ctrlKey ?
								-$.datepicker._get(inst, "stepBigMonths") :
								-$.datepicker._get(inst, "stepMonths")), "M");
							break; // previous month/year on page up/+ ctrl
					case 34: $.datepicker._adjustDate(event.target, (event.ctrlKey ?
								+$.datepicker._get(inst, "stepBigMonths") :
								+$.datepicker._get(inst, "stepMonths")), "M");
							break; // next month/year on page down/+ ctrl
					case 35: if (event.ctrlKey || event.metaKey) {
								$.datepicker._clearDate(event.target);
							}
							handled = event.ctrlKey || event.metaKey;
							break; // clear on ctrl or command +end
					case 36: if (event.ctrlKey || event.metaKey) {
								$.datepicker._gotoToday(event.target);
							}
							handled = event.ctrlKey || event.metaKey;
							break; // current on ctrl or command +home
					case 37: if (event.ctrlKey || event.metaKey) {
								$.datepicker._adjustDate(event.target, (isRTL ? +1 : -1), "D");
							}
							handled = event.ctrlKey || event.metaKey;
							// -1 day on ctrl or command +left
							if (event.originalEvent.altKey) {
								$.datepicker._adjustDate(event.target, (event.ctrlKey ?
									-$.datepicker._get(inst, "stepBigMonths") :
									-$.datepicker._get(inst, "stepMonths")), "M");
							}
							// next month/year on alt +left on Mac
							break;
					case 38: if (event.ctrlKey || event.metaKey) {
								$.datepicker._adjustDate(event.target, -7, "D");
							}
							handled = event.ctrlKey || event.metaKey;
							break; // -1 week on ctrl or command +up
					case 39: if (event.ctrlKey || event.metaKey) {
								$.datepicker._adjustDate(event.target, (isRTL ? -1 : +1), "D");
							}
							handled = event.ctrlKey || event.metaKey;
							// +1 day on ctrl or command +right
							if (event.originalEvent.altKey) {
								$.datepicker._adjustDate(event.target, (event.ctrlKey ?
									+$.datepicker._get(inst, "stepBigMonths") :
									+$.datepicker._get(inst, "stepMonths")), "M");
							}
							// next month/year on alt +right
							break;
					case 40: if (event.ctrlKey || event.metaKey) {
								$.datepicker._adjustDate(event.target, +7, "D");
							}
							handled = event.ctrlKey || event.metaKey;
							break; // +1 week on ctrl or command +down
					default: handled = false;
				}
			} else if (event.keyCode === 36 && event.ctrlKey) { // display the date picker on ctrl+home
				$.datepicker._showDatepicker(this);
			} else {
				handled = false;
			}
	
			if (handled) {
				event.preventDefault();
				event.stopPropagation();
			}
		},
	
		/* Filter entered characters - based on date format. */
		_doKeyPress: function(event) {
			var chars, chr,
				inst = $.datepicker._getInst(event.target);
	
			if ($.datepicker._get(inst, "constrainInput")) {
				chars = $.datepicker._possibleChars($.datepicker._get(inst, "dateFormat"));
				chr = String.fromCharCode(event.charCode == null ? event.keyCode : event.charCode);
				return event.ctrlKey || event.metaKey || (chr < " " || !chars || chars.indexOf(chr) > -1);
			}
		},
	
		/* Synchronise manual entry and field/alternate field. */
		_doKeyUp: function(event) {
			var date,
				inst = $.datepicker._getInst(event.target);
	
			if (inst.input.val() !== inst.lastVal) {
				try {
					date = $.datepicker.parseDate($.datepicker._get(inst, "dateFormat"),
						(inst.input ? inst.input.val() : null),
						$.datepicker._getFormatConfig(inst));
	
					if (date) { // only if valid
						$.datepicker._setDateFromField(inst);
						$.datepicker._updateAlternate(inst);
						$.datepicker._updateDatepicker(inst);
					}
				}
				catch (err) {
				}
			}
			return true;
		},
	
		/* Pop-up the date picker for a given input field.
		 * If false returned from beforeShow event handler do not show.
		 * @param  input  element - the input field attached to the date picker or
		 *					event - if triggered by focus
		 */
		_showDatepicker: function(input) {
			input = input.target || input;
			if (input.nodeName.toLowerCase() !== "input") { // find from button/image trigger
				input = $("input", input.parentNode)[0];
			}
	
			if ($.datepicker._isDisabledDatepicker(input) || $.datepicker._lastInput === input) { // already here
				return;
			}
	
			var inst, beforeShow, beforeShowSettings, isFixed,
				offset, showAnim, duration;
	
			inst = $.datepicker._getInst(input);
			if ($.datepicker._curInst && $.datepicker._curInst !== inst) {
				$.datepicker._curInst.dpDiv.stop(true, true);
				if ( inst && $.datepicker._datepickerShowing ) {
					$.datepicker._hideDatepicker( $.datepicker._curInst.input[0] );
				}
			}
	
			beforeShow = $.datepicker._get(inst, "beforeShow");
			beforeShowSettings = beforeShow ? beforeShow.apply(input, [input, inst]) : {};
			if(beforeShowSettings === false){
				return;
			}
			datepicker_extendRemove(inst.settings, beforeShowSettings);
	
			inst.lastVal = null;
			$.datepicker._lastInput = input;
			$.datepicker._setDateFromField(inst);
	
			if ($.datepicker._inDialog) { // hide cursor
				input.value = "";
			}
			if (!$.datepicker._pos) { // position below input
				$.datepicker._pos = $.datepicker._findPos(input);
				$.datepicker._pos[1] += input.offsetHeight; // add the height
			}
	
			isFixed = false;
			$(input).parents().each(function() {
				isFixed |= $(this).css("position") === "fixed";
				return !isFixed;
			});
	
			offset = {left: $.datepicker._pos[0], top: $.datepicker._pos[1]};
			$.datepicker._pos = null;
			//to avoid flashes on Firefox
			inst.dpDiv.empty();
			// determine sizing offscreen
			inst.dpDiv.css({position: "absolute", display: "block", top: "-1000px"});
			$.datepicker._updateDatepicker(inst);
			// fix width for dynamic number of date pickers
			// and adjust position before showing
			offset = $.datepicker._checkOffset(inst, offset, isFixed);
			inst.dpDiv.css({position: ($.datepicker._inDialog && $.blockUI ?
				"static" : (isFixed ? "fixed" : "absolute")), display: "none",
				left: offset.left + "px", top: offset.top + "px"});
	
			if (!inst.inline) {
				showAnim = $.datepicker._get(inst, "showAnim");
				duration = $.datepicker._get(inst, "duration");
				inst.dpDiv.css( "z-index", datepicker_getZindex( $( input ) ) + 1 );
				$.datepicker._datepickerShowing = true;
	
				if ( $.effects && $.effects.effect[ showAnim ] ) {
					inst.dpDiv.show(showAnim, $.datepicker._get(inst, "showOptions"), duration);
				} else {
					inst.dpDiv[showAnim || "show"](showAnim ? duration : null);
				}
	
				if ( $.datepicker._shouldFocusInput( inst ) ) {
					inst.input.focus();
				}
	
				$.datepicker._curInst = inst;
			}
		},
	
		/* Generate the date picker content. */
		_updateDatepicker: function(inst) {
			this.maxRows = 4; //Reset the max number of rows being displayed (see #7043)
			datepicker_instActive = inst; // for delegate hover events
			inst.dpDiv.empty().append(this._generateHTML(inst));
			this._attachHandlers(inst);
	
			var origyearshtml,
				numMonths = this._getNumberOfMonths(inst),
				cols = numMonths[1],
				width = 17,
				activeCell = inst.dpDiv.find( "." + this._dayOverClass + " a" );
	
			if ( activeCell.length > 0 ) {
				datepicker_handleMouseover.apply( activeCell.get( 0 ) );
			}
	
			inst.dpDiv.removeClass("ui-datepicker-multi-2 ui-datepicker-multi-3 ui-datepicker-multi-4").width("");
			if (cols > 1) {
				inst.dpDiv.addClass("ui-datepicker-multi-" + cols).css("width", (width * cols) + "em");
			}
			inst.dpDiv[(numMonths[0] !== 1 || numMonths[1] !== 1 ? "add" : "remove") +
				"Class"]("ui-datepicker-multi");
			inst.dpDiv[(this._get(inst, "isRTL") ? "add" : "remove") +
				"Class"]("ui-datepicker-rtl");
	
			if (inst === $.datepicker._curInst && $.datepicker._datepickerShowing && $.datepicker._shouldFocusInput( inst ) ) {
				inst.input.focus();
			}
	
			// deffered render of the years select (to avoid flashes on Firefox)
			if( inst.yearshtml ){
				origyearshtml = inst.yearshtml;
				setTimeout(function(){
					//assure that inst.yearshtml didn't change.
					if( origyearshtml === inst.yearshtml && inst.yearshtml ){
						inst.dpDiv.find("select.ui-datepicker-year:first").replaceWith(inst.yearshtml);
					}
					origyearshtml = inst.yearshtml = null;
				}, 0);
			}
		},
	
		// #6694 - don't focus the input if it's already focused
		// this breaks the change event in IE
		// Support: IE and jQuery <1.9
		_shouldFocusInput: function( inst ) {
			return inst.input && inst.input.is( ":visible" ) && !inst.input.is( ":disabled" ) && !inst.input.is( ":focus" );
		},
	
		/* Check positioning to remain on screen. */
		_checkOffset: function(inst, offset, isFixed) {
			var dpWidth = inst.dpDiv.outerWidth(),
				dpHeight = inst.dpDiv.outerHeight(),
				inputWidth = inst.input ? inst.input.outerWidth() : 0,
				inputHeight = inst.input ? inst.input.outerHeight() : 0,
				viewWidth = document.documentElement.clientWidth + (isFixed ? 0 : $(document).scrollLeft()),
				viewHeight = document.documentElement.clientHeight + (isFixed ? 0 : $(document).scrollTop());
	
			offset.left -= (this._get(inst, "isRTL") ? (dpWidth - inputWidth) : 0);
			offset.left -= (isFixed && offset.left === inst.input.offset().left) ? $(document).scrollLeft() : 0;
			offset.top -= (isFixed && offset.top === (inst.input.offset().top + inputHeight)) ? $(document).scrollTop() : 0;
	
			// now check if datepicker is showing outside window viewport - move to a better place if so.
			offset.left -= Math.min(offset.left, (offset.left + dpWidth > viewWidth && viewWidth > dpWidth) ?
				Math.abs(offset.left + dpWidth - viewWidth) : 0);
			offset.top -= Math.min(offset.top, (offset.top + dpHeight > viewHeight && viewHeight > dpHeight) ?
				Math.abs(dpHeight + inputHeight) : 0);
	
			return offset;
		},
	
		/* Find an object's position on the screen. */
		_findPos: function(obj) {
			var position,
				inst = this._getInst(obj),
				isRTL = this._get(inst, "isRTL");
	
			while (obj && (obj.type === "hidden" || obj.nodeType !== 1 || $.expr.filters.hidden(obj))) {
				obj = obj[isRTL ? "previousSibling" : "nextSibling"];
			}
	
			position = $(obj).offset();
			return [position.left, position.top];
		},
	
		/* Hide the date picker from view.
		 * @param  input  element - the input field attached to the date picker
		 */
		_hideDatepicker: function(input) {
			var showAnim, duration, postProcess, onClose,
				inst = this._curInst;
	
			if (!inst || (input && inst !== $.data(input, "datepicker"))) {
				return;
			}
	
			if (this._datepickerShowing) {
				showAnim = this._get(inst, "showAnim");
				duration = this._get(inst, "duration");
				postProcess = function() {
					$.datepicker._tidyDialog(inst);
				};
	
				// DEPRECATED: after BC for 1.8.x $.effects[ showAnim ] is not needed
				if ( $.effects && ( $.effects.effect[ showAnim ] || $.effects[ showAnim ] ) ) {
					inst.dpDiv.hide(showAnim, $.datepicker._get(inst, "showOptions"), duration, postProcess);
				} else {
					inst.dpDiv[(showAnim === "slideDown" ? "slideUp" :
						(showAnim === "fadeIn" ? "fadeOut" : "hide"))]((showAnim ? duration : null), postProcess);
				}
	
				if (!showAnim) {
					postProcess();
				}
				this._datepickerShowing = false;
	
				onClose = this._get(inst, "onClose");
				if (onClose) {
					onClose.apply((inst.input ? inst.input[0] : null), [(inst.input ? inst.input.val() : ""), inst]);
				}
	
				this._lastInput = null;
				if (this._inDialog) {
					this._dialogInput.css({ position: "absolute", left: "0", top: "-100px" });
					if ($.blockUI) {
						$.unblockUI();
						$("body").append(this.dpDiv);
					}
				}
				this._inDialog = false;
			}
		},
	
		/* Tidy up after a dialog display. */
		_tidyDialog: function(inst) {
			inst.dpDiv.removeClass(this._dialogClass).unbind(".ui-datepicker-calendar");
		},
	
		/* Close date picker if clicked elsewhere. */
		_checkExternalClick: function(event) {
			if (!$.datepicker._curInst) {
				return;
			}
	
			var $target = $(event.target),
				inst = $.datepicker._getInst($target[0]);
	
			if ( ( ( $target[0].id !== $.datepicker._mainDivId &&
					$target.parents("#" + $.datepicker._mainDivId).length === 0 &&
					!$target.hasClass($.datepicker.markerClassName) &&
					!$target.closest("." + $.datepicker._triggerClass).length &&
					$.datepicker._datepickerShowing && !($.datepicker._inDialog && $.blockUI) ) ) ||
				( $target.hasClass($.datepicker.markerClassName) && $.datepicker._curInst !== inst ) ) {
					$.datepicker._hideDatepicker();
			}
		},
	
		/* Adjust one of the date sub-fields. */
		_adjustDate: function(id, offset, period) {
			var target = $(id),
				inst = this._getInst(target[0]);
	
			if (this._isDisabledDatepicker(target[0])) {
				return;
			}
			this._adjustInstDate(inst, offset +
				(period === "M" ? this._get(inst, "showCurrentAtPos") : 0), // undo positioning
				period);
			this._updateDatepicker(inst);
		},
	
		/* Action for current link. */
		_gotoToday: function(id) {
			var date,
				target = $(id),
				inst = this._getInst(target[0]);
	
			if (this._get(inst, "gotoCurrent") && inst.currentDay) {
				inst.selectedDay = inst.currentDay;
				inst.drawMonth = inst.selectedMonth = inst.currentMonth;
				inst.drawYear = inst.selectedYear = inst.currentYear;
			} else {
				date = new Date();
				inst.selectedDay = date.getDate();
				inst.drawMonth = inst.selectedMonth = date.getMonth();
				inst.drawYear = inst.selectedYear = date.getFullYear();
			}
			this._notifyChange(inst);
			this._adjustDate(target);
		},
	
		/* Action for selecting a new month/year. */
		_selectMonthYear: function(id, select, period) {
			var target = $(id),
				inst = this._getInst(target[0]);
	
			inst["selected" + (period === "M" ? "Month" : "Year")] =
			inst["draw" + (period === "M" ? "Month" : "Year")] =
				parseInt(select.options[select.selectedIndex].value,10);
	
			this._notifyChange(inst);
			this._adjustDate(target);
		},
	
		/* Action for selecting a day. */
		_selectDay: function(id, month, year, td) {
			var inst,
				target = $(id);
	
			if ($(td).hasClass(this._unselectableClass) || this._isDisabledDatepicker(target[0])) {
				return;
			}
	
			inst = this._getInst(target[0]);
			inst.selectedDay = inst.currentDay = $("a", td).html();
			inst.selectedMonth = inst.currentMonth = month;
			inst.selectedYear = inst.currentYear = year;
			this._selectDate(id, this._formatDate(inst,
				inst.currentDay, inst.currentMonth, inst.currentYear));
		},
	
		/* Erase the input field and hide the date picker. */
		_clearDate: function(id) {
			var target = $(id);
			this._selectDate(target, "");
		},
	
		/* Update the input field with the selected date. */
		_selectDate: function(id, dateStr) {
			var onSelect,
				target = $(id),
				inst = this._getInst(target[0]);
	
			dateStr = (dateStr != null ? dateStr : this._formatDate(inst));
			if (inst.input) {
				inst.input.val(dateStr);
			}
			this._updateAlternate(inst);
	
			onSelect = this._get(inst, "onSelect");
			if (onSelect) {
				onSelect.apply((inst.input ? inst.input[0] : null), [dateStr, inst]);  // trigger custom callback
			} else if (inst.input) {
				inst.input.trigger("change"); // fire the change event
			}
	
			if (inst.inline){
				this._updateDatepicker(inst);
			} else {
				this._hideDatepicker();
				this._lastInput = inst.input[0];
				if (typeof(inst.input[0]) !== "object") {
					inst.input.focus(); // restore focus
				}
				this._lastInput = null;
			}
		},
	
		/* Update any alternate field to synchronise with the main field. */
		_updateAlternate: function(inst) {
			var altFormat, date, dateStr,
				altField = this._get(inst, "altField");
	
			if (altField) { // update alternate field too
				altFormat = this._get(inst, "altFormat") || this._get(inst, "dateFormat");
				date = this._getDate(inst);
				dateStr = this.formatDate(altFormat, date, this._getFormatConfig(inst));
				$(altField).each(function() { $(this).val(dateStr); });
			}
		},
	
		/* Set as beforeShowDay function to prevent selection of weekends.
		 * @param  date  Date - the date to customise
		 * @return [boolean, string] - is this date selectable?, what is its CSS class?
		 */
		noWeekends: function(date) {
			var day = date.getDay();
			return [(day > 0 && day < 6), ""];
		},
	
		/* Set as calculateWeek to determine the week of the year based on the ISO 8601 definition.
		 * @param  date  Date - the date to get the week for
		 * @return  number - the number of the week within the year that contains this date
		 */
		iso8601Week: function(date) {
			var time,
				checkDate = new Date(date.getTime());
	
			// Find Thursday of this week starting on Monday
			checkDate.setDate(checkDate.getDate() + 4 - (checkDate.getDay() || 7));
	
			time = checkDate.getTime();
			checkDate.setMonth(0); // Compare with Jan 1
			checkDate.setDate(1);
			return Math.floor(Math.round((time - checkDate) / 86400000) / 7) + 1;
		},
	
		/* Parse a string value into a date object.
		 * See formatDate below for the possible formats.
		 *
		 * @param  format string - the expected format of the date
		 * @param  value string - the date in the above format
		 * @param  settings Object - attributes include:
		 *					shortYearCutoff  number - the cutoff year for determining the century (optional)
		 *					dayNamesShort	string[7] - abbreviated names of the days from Sunday (optional)
		 *					dayNames		string[7] - names of the days from Sunday (optional)
		 *					monthNamesShort string[12] - abbreviated names of the months (optional)
		 *					monthNames		string[12] - names of the months (optional)
		 * @return  Date - the extracted date value or null if value is blank
		 */
		parseDate: function (format, value, settings) {
			if (format == null || value == null) {
				throw "Invalid arguments";
			}
	
			value = (typeof value === "object" ? value.toString() : value + "");
			if (value === "") {
				return null;
			}
	
			var iFormat, dim, extra,
				iValue = 0,
				shortYearCutoffTemp = (settings ? settings.shortYearCutoff : null) || this._defaults.shortYearCutoff,
				shortYearCutoff = (typeof shortYearCutoffTemp !== "string" ? shortYearCutoffTemp :
					new Date().getFullYear() % 100 + parseInt(shortYearCutoffTemp, 10)),
				dayNamesShort = (settings ? settings.dayNamesShort : null) || this._defaults.dayNamesShort,
				dayNames = (settings ? settings.dayNames : null) || this._defaults.dayNames,
				monthNamesShort = (settings ? settings.monthNamesShort : null) || this._defaults.monthNamesShort,
				monthNames = (settings ? settings.monthNames : null) || this._defaults.monthNames,
				year = -1,
				month = -1,
				day = -1,
				doy = -1,
				literal = false,
				date,
				// Check whether a format character is doubled
				lookAhead = function(match) {
					var matches = (iFormat + 1 < format.length && format.charAt(iFormat + 1) === match);
					if (matches) {
						iFormat++;
					}
					return matches;
				},
				// Extract a number from the string value
				getNumber = function(match) {
					var isDoubled = lookAhead(match),
						size = (match === "@" ? 14 : (match === "!" ? 20 :
						(match === "y" && isDoubled ? 4 : (match === "o" ? 3 : 2)))),
						minSize = (match === "y" ? size : 1),
						digits = new RegExp("^\\d{" + minSize + "," + size + "}"),
						num = value.substring(iValue).match(digits);
					if (!num) {
						throw "Missing number at position " + iValue;
					}
					iValue += num[0].length;
					return parseInt(num[0], 10);
				},
				// Extract a name from the string value and convert to an index
				getName = function(match, shortNames, longNames) {
					var index = -1,
						names = $.map(lookAhead(match) ? longNames : shortNames, function (v, k) {
							return [ [k, v] ];
						}).sort(function (a, b) {
							return -(a[1].length - b[1].length);
						});
	
					$.each(names, function (i, pair) {
						var name = pair[1];
						if (value.substr(iValue, name.length).toLowerCase() === name.toLowerCase()) {
							index = pair[0];
							iValue += name.length;
							return false;
						}
					});
					if (index !== -1) {
						return index + 1;
					} else {
						throw "Unknown name at position " + iValue;
					}
				},
				// Confirm that a literal character matches the string value
				checkLiteral = function() {
					if (value.charAt(iValue) !== format.charAt(iFormat)) {
						throw "Unexpected literal at position " + iValue;
					}
					iValue++;
				};
	
			for (iFormat = 0; iFormat < format.length; iFormat++) {
				if (literal) {
					if (format.charAt(iFormat) === "'" && !lookAhead("'")) {
						literal = false;
					} else {
						checkLiteral();
					}
				} else {
					switch (format.charAt(iFormat)) {
						case "d":
							day = getNumber("d");
							break;
						case "D":
							getName("D", dayNamesShort, dayNames);
							break;
						case "o":
							doy = getNumber("o");
							break;
						case "m":
							month = getNumber("m");
							break;
						case "M":
							month = getName("M", monthNamesShort, monthNames);
							break;
						case "y":
							year = getNumber("y");
							break;
						case "@":
							date = new Date(getNumber("@"));
							year = date.getFullYear();
							month = date.getMonth() + 1;
							day = date.getDate();
							break;
						case "!":
							date = new Date((getNumber("!") - this._ticksTo1970) / 10000);
							year = date.getFullYear();
							month = date.getMonth() + 1;
							day = date.getDate();
							break;
						case "'":
							if (lookAhead("'")){
								checkLiteral();
							} else {
								literal = true;
							}
							break;
						default:
							checkLiteral();
					}
				}
			}
	
			if (iValue < value.length){
				extra = value.substr(iValue);
				if (!/^\s+/.test(extra)) {
					throw "Extra/unparsed characters found in date: " + extra;
				}
			}
	
			if (year === -1) {
				year = new Date().getFullYear();
			} else if (year < 100) {
				year += new Date().getFullYear() - new Date().getFullYear() % 100 +
					(year <= shortYearCutoff ? 0 : -100);
			}
	
			if (doy > -1) {
				month = 1;
				day = doy;
				do {
					dim = this._getDaysInMonth(year, month - 1);
					if (day <= dim) {
						break;
					}
					month++;
					day -= dim;
				} while (true);
			}
	
			date = this._daylightSavingAdjust(new Date(year, month - 1, day));
			if (date.getFullYear() !== year || date.getMonth() + 1 !== month || date.getDate() !== day) {
				throw "Invalid date"; // E.g. 31/02/00
			}
			return date;
		},
	
		/* Standard date formats. */
		ATOM: "yy-mm-dd", // RFC 3339 (ISO 8601)
		COOKIE: "D, dd M yy",
		ISO_8601: "yy-mm-dd",
		RFC_822: "D, d M y",
		RFC_850: "DD, dd-M-y",
		RFC_1036: "D, d M y",
		RFC_1123: "D, d M yy",
		RFC_2822: "D, d M yy",
		RSS: "D, d M y", // RFC 822
		TICKS: "!",
		TIMESTAMP: "@",
		W3C: "yy-mm-dd", // ISO 8601
	
		_ticksTo1970: (((1970 - 1) * 365 + Math.floor(1970 / 4) - Math.floor(1970 / 100) +
			Math.floor(1970 / 400)) * 24 * 60 * 60 * 10000000),
	
		/* Format a date object into a string value.
		 * The format can be combinations of the following:
		 * d  - day of month (no leading zero)
		 * dd - day of month (two digit)
		 * o  - day of year (no leading zeros)
		 * oo - day of year (three digit)
		 * D  - day name short
		 * DD - day name long
		 * m  - month of year (no leading zero)
		 * mm - month of year (two digit)
		 * M  - month name short
		 * MM - month name long
		 * y  - year (two digit)
		 * yy - year (four digit)
		 * @ - Unix timestamp (ms since 01/01/1970)
		 * ! - Windows ticks (100ns since 01/01/0001)
		 * "..." - literal text
		 * '' - single quote
		 *
		 * @param  format string - the desired format of the date
		 * @param  date Date - the date value to format
		 * @param  settings Object - attributes include:
		 *					dayNamesShort	string[7] - abbreviated names of the days from Sunday (optional)
		 *					dayNames		string[7] - names of the days from Sunday (optional)
		 *					monthNamesShort string[12] - abbreviated names of the months (optional)
		 *					monthNames		string[12] - names of the months (optional)
		 * @return  string - the date in the above format
		 */
		formatDate: function (format, date, settings) {
			if (!date) {
				return "";
			}
	
			var iFormat,
				dayNamesShort = (settings ? settings.dayNamesShort : null) || this._defaults.dayNamesShort,
				dayNames = (settings ? settings.dayNames : null) || this._defaults.dayNames,
				monthNamesShort = (settings ? settings.monthNamesShort : null) || this._defaults.monthNamesShort,
				monthNames = (settings ? settings.monthNames : null) || this._defaults.monthNames,
				// Check whether a format character is doubled
				lookAhead = function(match) {
					var matches = (iFormat + 1 < format.length && format.charAt(iFormat + 1) === match);
					if (matches) {
						iFormat++;
					}
					return matches;
				},
				// Format a number, with leading zero if necessary
				formatNumber = function(match, value, len) {
					var num = "" + value;
					if (lookAhead(match)) {
						while (num.length < len) {
							num = "0" + num;
						}
					}
					return num;
				},
				// Format a name, short or long as requested
				formatName = function(match, value, shortNames, longNames) {
					return (lookAhead(match) ? longNames[value] : shortNames[value]);
				},
				output = "",
				literal = false;
	
			if (date) {
				for (iFormat = 0; iFormat < format.length; iFormat++) {
					if (literal) {
						if (format.charAt(iFormat) === "'" && !lookAhead("'")) {
							literal = false;
						} else {
							output += format.charAt(iFormat);
						}
					} else {
						switch (format.charAt(iFormat)) {
							case "d":
								output += formatNumber("d", date.getDate(), 2);
								break;
							case "D":
								output += formatName("D", date.getDay(), dayNamesShort, dayNames);
								break;
							case "o":
								output += formatNumber("o",
									Math.round((new Date(date.getFullYear(), date.getMonth(), date.getDate()).getTime() - new Date(date.getFullYear(), 0, 0).getTime()) / 86400000), 3);
								break;
							case "m":
								output += formatNumber("m", date.getMonth() + 1, 2);
								break;
							case "M":
								output += formatName("M", date.getMonth(), monthNamesShort, monthNames);
								break;
							case "y":
								output += (lookAhead("y") ? date.getFullYear() :
									(date.getYear() % 100 < 10 ? "0" : "") + date.getYear() % 100);
								break;
							case "@":
								output += date.getTime();
								break;
							case "!":
								output += date.getTime() * 10000 + this._ticksTo1970;
								break;
							case "'":
								if (lookAhead("'")) {
									output += "'";
								} else {
									literal = true;
								}
								break;
							default:
								output += format.charAt(iFormat);
						}
					}
				}
			}
			return output;
		},
	
		/* Extract all possible characters from the date format. */
		_possibleChars: function (format) {
			var iFormat,
				chars = "",
				literal = false,
				// Check whether a format character is doubled
				lookAhead = function(match) {
					var matches = (iFormat + 1 < format.length && format.charAt(iFormat + 1) === match);
					if (matches) {
						iFormat++;
					}
					return matches;
				};
	
			for (iFormat = 0; iFormat < format.length; iFormat++) {
				if (literal) {
					if (format.charAt(iFormat) === "'" && !lookAhead("'")) {
						literal = false;
					} else {
						chars += format.charAt(iFormat);
					}
				} else {
					switch (format.charAt(iFormat)) {
						case "d": case "m": case "y": case "@":
							chars += "0123456789";
							break;
						case "D": case "M":
							return null; // Accept anything
						case "'":
							if (lookAhead("'")) {
								chars += "'";
							} else {
								literal = true;
							}
							break;
						default:
							chars += format.charAt(iFormat);
					}
				}
			}
			return chars;
		},
	
		/* Get a setting value, defaulting if necessary. */
		_get: function(inst, name) {
			return inst.settings[name] !== undefined ?
				inst.settings[name] : this._defaults[name];
		},
	
		/* Parse existing date and initialise date picker. */
		_setDateFromField: function(inst, noDefault) {
			if (inst.input.val() === inst.lastVal) {
				return;
			}
	
			var dateFormat = this._get(inst, "dateFormat"),
				dates = inst.lastVal = inst.input ? inst.input.val() : null,
				defaultDate = this._getDefaultDate(inst),
				date = defaultDate,
				settings = this._getFormatConfig(inst);
	
			try {
				date = this.parseDate(dateFormat, dates, settings) || defaultDate;
			} catch (event) {
				dates = (noDefault ? "" : dates);
			}
			inst.selectedDay = date.getDate();
			inst.drawMonth = inst.selectedMonth = date.getMonth();
			inst.drawYear = inst.selectedYear = date.getFullYear();
			inst.currentDay = (dates ? date.getDate() : 0);
			inst.currentMonth = (dates ? date.getMonth() : 0);
			inst.currentYear = (dates ? date.getFullYear() : 0);
			this._adjustInstDate(inst);
		},
	
		/* Retrieve the default date shown on opening. */
		_getDefaultDate: function(inst) {
			return this._restrictMinMax(inst,
				this._determineDate(inst, this._get(inst, "defaultDate"), new Date()));
		},
	
		/* A date may be specified as an exact value or a relative one. */
		_determineDate: function(inst, date, defaultDate) {
			var offsetNumeric = function(offset) {
					var date = new Date();
					date.setDate(date.getDate() + offset);
					return date;
				},
				offsetString = function(offset) {
					try {
						return $.datepicker.parseDate($.datepicker._get(inst, "dateFormat"),
							offset, $.datepicker._getFormatConfig(inst));
					}
					catch (e) {
						// Ignore
					}
	
					var date = (offset.toLowerCase().match(/^c/) ?
						$.datepicker._getDate(inst) : null) || new Date(),
						year = date.getFullYear(),
						month = date.getMonth(),
						day = date.getDate(),
						pattern = /([+\-]?[0-9]+)\s*(d|D|w|W|m|M|y|Y)?/g,
						matches = pattern.exec(offset);
	
					while (matches) {
						switch (matches[2] || "d") {
							case "d" : case "D" :
								day += parseInt(matches[1],10); break;
							case "w" : case "W" :
								day += parseInt(matches[1],10) * 7; break;
							case "m" : case "M" :
								month += parseInt(matches[1],10);
								day = Math.min(day, $.datepicker._getDaysInMonth(year, month));
								break;
							case "y": case "Y" :
								year += parseInt(matches[1],10);
								day = Math.min(day, $.datepicker._getDaysInMonth(year, month));
								break;
						}
						matches = pattern.exec(offset);
					}
					return new Date(year, month, day);
				},
				newDate = (date == null || date === "" ? defaultDate : (typeof date === "string" ? offsetString(date) :
					(typeof date === "number" ? (isNaN(date) ? defaultDate : offsetNumeric(date)) : new Date(date.getTime()))));
	
			newDate = (newDate && newDate.toString() === "Invalid Date" ? defaultDate : newDate);
			if (newDate) {
				newDate.setHours(0);
				newDate.setMinutes(0);
				newDate.setSeconds(0);
				newDate.setMilliseconds(0);
			}
			return this._daylightSavingAdjust(newDate);
		},
	
		/* Handle switch to/from daylight saving.
		 * Hours may be non-zero on daylight saving cut-over:
		 * > 12 when midnight changeover, but then cannot generate
		 * midnight datetime, so jump to 1AM, otherwise reset.
		 * @param  date  (Date) the date to check
		 * @return  (Date) the corrected date
		 */
		_daylightSavingAdjust: function(date) {
			if (!date) {
				return null;
			}
			date.setHours(date.getHours() > 12 ? date.getHours() + 2 : 0);
			return date;
		},
	
		/* Set the date(s) directly. */
		_setDate: function(inst, date, noChange) {
			var clear = !date,
				origMonth = inst.selectedMonth,
				origYear = inst.selectedYear,
				newDate = this._restrictMinMax(inst, this._determineDate(inst, date, new Date()));
	
			inst.selectedDay = inst.currentDay = newDate.getDate();
			inst.drawMonth = inst.selectedMonth = inst.currentMonth = newDate.getMonth();
			inst.drawYear = inst.selectedYear = inst.currentYear = newDate.getFullYear();
			if ((origMonth !== inst.selectedMonth || origYear !== inst.selectedYear) && !noChange) {
				this._notifyChange(inst);
			}
			this._adjustInstDate(inst);
			if (inst.input) {
				inst.input.val(clear ? "" : this._formatDate(inst));
			}
		},
	
		/* Retrieve the date(s) directly. */
		_getDate: function(inst) {
			var startDate = (!inst.currentYear || (inst.input && inst.input.val() === "") ? null :
				this._daylightSavingAdjust(new Date(
				inst.currentYear, inst.currentMonth, inst.currentDay)));
				return startDate;
		},
	
		/* Attach the onxxx handlers.  These are declared statically so
		 * they work with static code transformers like Caja.
		 */
		_attachHandlers: function(inst) {
			var stepMonths = this._get(inst, "stepMonths"),
				id = "#" + inst.id.replace( /\\\\/g, "\\" );
			inst.dpDiv.find("[data-handler]").map(function () {
				var handler = {
					prev: function () {
						$.datepicker._adjustDate(id, -stepMonths, "M");
					},
					next: function () {
						$.datepicker._adjustDate(id, +stepMonths, "M");
					},
					hide: function () {
						$.datepicker._hideDatepicker();
					},
					today: function () {
						$.datepicker._gotoToday(id);
					},
					selectDay: function () {
						$.datepicker._selectDay(id, +this.getAttribute("data-month"), +this.getAttribute("data-year"), this);
						return false;
					},
					selectMonth: function () {
						$.datepicker._selectMonthYear(id, this, "M");
						return false;
					},
					selectYear: function () {
						$.datepicker._selectMonthYear(id, this, "Y");
						return false;
					}
				};
				$(this).bind(this.getAttribute("data-event"), handler[this.getAttribute("data-handler")]);
			});
		},
	
		/* Generate the HTML for the current state of the date picker. */
		_generateHTML: function(inst) {
			var maxDraw, prevText, prev, nextText, next, currentText, gotoDate,
				controls, buttonPanel, firstDay, showWeek, dayNames, dayNamesMin,
				monthNames, monthNamesShort, beforeShowDay, showOtherMonths,
				selectOtherMonths, defaultDate, html, dow, row, group, col, selectedDate,
				cornerClass, calender, thead, day, daysInMonth, leadDays, curRows, numRows,
				printDate, dRow, tbody, daySettings, otherMonth, unselectable,
				tempDate = new Date(),
				today = this._daylightSavingAdjust(
					new Date(tempDate.getFullYear(), tempDate.getMonth(), tempDate.getDate())), // clear time
				isRTL = this._get(inst, "isRTL"),
				showButtonPanel = this._get(inst, "showButtonPanel"),
				hideIfNoPrevNext = this._get(inst, "hideIfNoPrevNext"),
				navigationAsDateFormat = this._get(inst, "navigationAsDateFormat"),
				numMonths = this._getNumberOfMonths(inst),
				showCurrentAtPos = this._get(inst, "showCurrentAtPos"),
				stepMonths = this._get(inst, "stepMonths"),
				isMultiMonth = (numMonths[0] !== 1 || numMonths[1] !== 1),
				currentDate = this._daylightSavingAdjust((!inst.currentDay ? new Date(9999, 9, 9) :
					new Date(inst.currentYear, inst.currentMonth, inst.currentDay))),
				minDate = this._getMinMaxDate(inst, "min"),
				maxDate = this._getMinMaxDate(inst, "max"),
				drawMonth = inst.drawMonth - showCurrentAtPos,
				drawYear = inst.drawYear;
	
			if (drawMonth < 0) {
				drawMonth += 12;
				drawYear--;
			}
			if (maxDate) {
				maxDraw = this._daylightSavingAdjust(new Date(maxDate.getFullYear(),
					maxDate.getMonth() - (numMonths[0] * numMonths[1]) + 1, maxDate.getDate()));
				maxDraw = (minDate && maxDraw < minDate ? minDate : maxDraw);
				while (this._daylightSavingAdjust(new Date(drawYear, drawMonth, 1)) > maxDraw) {
					drawMonth--;
					if (drawMonth < 0) {
						drawMonth = 11;
						drawYear--;
					}
				}
			}
			inst.drawMonth = drawMonth;
			inst.drawYear = drawYear;
	
			prevText = this._get(inst, "prevText");
			prevText = (!navigationAsDateFormat ? prevText : this.formatDate(prevText,
				this._daylightSavingAdjust(new Date(drawYear, drawMonth - stepMonths, 1)),
				this._getFormatConfig(inst)));
	
			prev = (this._canAdjustMonth(inst, -1, drawYear, drawMonth) ?
				"<a class='ui-datepicker-prev ui-corner-all' data-handler='prev' data-event='click'" +
				" title='" + prevText + "'><span class='ui-icon ui-icon-circle-triangle-" + ( isRTL ? "e" : "w") + "'>" + prevText + "</span></a>" :
				(hideIfNoPrevNext ? "" : "<a class='ui-datepicker-prev ui-corner-all ui-state-disabled' title='"+ prevText +"'><span class='ui-icon ui-icon-circle-triangle-" + ( isRTL ? "e" : "w") + "'>" + prevText + "</span></a>"));
	
			nextText = this._get(inst, "nextText");
			nextText = (!navigationAsDateFormat ? nextText : this.formatDate(nextText,
				this._daylightSavingAdjust(new Date(drawYear, drawMonth + stepMonths, 1)),
				this._getFormatConfig(inst)));
	
			next = (this._canAdjustMonth(inst, +1, drawYear, drawMonth) ?
				"<a class='ui-datepicker-next ui-corner-all' data-handler='next' data-event='click'" +
				" title='" + nextText + "'><span class='ui-icon ui-icon-circle-triangle-" + ( isRTL ? "w" : "e") + "'>" + nextText + "</span></a>" :
				(hideIfNoPrevNext ? "" : "<a class='ui-datepicker-next ui-corner-all ui-state-disabled' title='"+ nextText + "'><span class='ui-icon ui-icon-circle-triangle-" + ( isRTL ? "w" : "e") + "'>" + nextText + "</span></a>"));
	
			currentText = this._get(inst, "currentText");
			gotoDate = (this._get(inst, "gotoCurrent") && inst.currentDay ? currentDate : today);
			currentText = (!navigationAsDateFormat ? currentText :
				this.formatDate(currentText, gotoDate, this._getFormatConfig(inst)));
	
			controls = (!inst.inline ? "<button type='button' class='ui-datepicker-close ui-state-default ui-priority-primary ui-corner-all' data-handler='hide' data-event='click'>" +
				this._get(inst, "closeText") + "</button>" : "");
	
			buttonPanel = (showButtonPanel) ? "<div class='ui-datepicker-buttonpane ui-widget-content'>" + (isRTL ? controls : "") +
				(this._isInRange(inst, gotoDate) ? "<button type='button' class='ui-datepicker-current ui-state-default ui-priority-secondary ui-corner-all' data-handler='today' data-event='click'" +
				">" + currentText + "</button>" : "") + (isRTL ? "" : controls) + "</div>" : "";
	
			firstDay = parseInt(this._get(inst, "firstDay"),10);
			firstDay = (isNaN(firstDay) ? 0 : firstDay);
	
			showWeek = this._get(inst, "showWeek");
			dayNames = this._get(inst, "dayNames");
			dayNamesMin = this._get(inst, "dayNamesMin");
			monthNames = this._get(inst, "monthNames");
			monthNamesShort = this._get(inst, "monthNamesShort");
			beforeShowDay = this._get(inst, "beforeShowDay");
			showOtherMonths = this._get(inst, "showOtherMonths");
			selectOtherMonths = this._get(inst, "selectOtherMonths");
			defaultDate = this._getDefaultDate(inst);
			html = "";
			dow;
			for (row = 0; row < numMonths[0]; row++) {
				group = "";
				this.maxRows = 4;
				for (col = 0; col < numMonths[1]; col++) {
					selectedDate = this._daylightSavingAdjust(new Date(drawYear, drawMonth, inst.selectedDay));
					cornerClass = " ui-corner-all";
					calender = "";
					if (isMultiMonth) {
						calender += "<div class='ui-datepicker-group";
						if (numMonths[1] > 1) {
							switch (col) {
								case 0: calender += " ui-datepicker-group-first";
									cornerClass = " ui-corner-" + (isRTL ? "right" : "left"); break;
								case numMonths[1]-1: calender += " ui-datepicker-group-last";
									cornerClass = " ui-corner-" + (isRTL ? "left" : "right"); break;
								default: calender += " ui-datepicker-group-middle"; cornerClass = ""; break;
							}
						}
						calender += "'>";
					}
					calender += "<div class='ui-datepicker-header ui-widget-header ui-helper-clearfix" + cornerClass + "'>" +
						(/all|left/.test(cornerClass) && row === 0 ? (isRTL ? next : prev) : "") +
						(/all|right/.test(cornerClass) && row === 0 ? (isRTL ? prev : next) : "") +
						this._generateMonthYearHeader(inst, drawMonth, drawYear, minDate, maxDate,
						row > 0 || col > 0, monthNames, monthNamesShort) + // draw month headers
						"</div><table class='ui-datepicker-calendar'><thead>" +
						"<tr>";
					thead = (showWeek ? "<th class='ui-datepicker-week-col'>" + this._get(inst, "weekHeader") + "</th>" : "");
					for (dow = 0; dow < 7; dow++) { // days of the week
						day = (dow + firstDay) % 7;
						thead += "<th scope='col'" + ((dow + firstDay + 6) % 7 >= 5 ? " class='ui-datepicker-week-end'" : "") + ">" +
							"<span title='" + dayNames[day] + "'>" + dayNamesMin[day] + "</span></th>";
					}
					calender += thead + "</tr></thead><tbody>";
					daysInMonth = this._getDaysInMonth(drawYear, drawMonth);
					if (drawYear === inst.selectedYear && drawMonth === inst.selectedMonth) {
						inst.selectedDay = Math.min(inst.selectedDay, daysInMonth);
					}
					leadDays = (this._getFirstDayOfMonth(drawYear, drawMonth) - firstDay + 7) % 7;
					curRows = Math.ceil((leadDays + daysInMonth) / 7); // calculate the number of rows to generate
					numRows = (isMultiMonth ? this.maxRows > curRows ? this.maxRows : curRows : curRows); //If multiple months, use the higher number of rows (see #7043)
					this.maxRows = numRows;
					printDate = this._daylightSavingAdjust(new Date(drawYear, drawMonth, 1 - leadDays));
					for (dRow = 0; dRow < numRows; dRow++) { // create date picker rows
						calender += "<tr>";
						tbody = (!showWeek ? "" : "<td class='ui-datepicker-week-col'>" +
							this._get(inst, "calculateWeek")(printDate) + "</td>");
						for (dow = 0; dow < 7; dow++) { // create date picker days
							daySettings = (beforeShowDay ?
								beforeShowDay.apply((inst.input ? inst.input[0] : null), [printDate]) : [true, ""]);
							otherMonth = (printDate.getMonth() !== drawMonth);
							unselectable = (otherMonth && !selectOtherMonths) || !daySettings[0] ||
								(minDate && printDate < minDate) || (maxDate && printDate > maxDate);
							tbody += "<td class='" +
								((dow + firstDay + 6) % 7 >= 5 ? " ui-datepicker-week-end" : "") + // highlight weekends
								(otherMonth ? " ui-datepicker-other-month" : "") + // highlight days from other months
								((printDate.getTime() === selectedDate.getTime() && drawMonth === inst.selectedMonth && inst._keyEvent) || // user pressed key
								(defaultDate.getTime() === printDate.getTime() && defaultDate.getTime() === selectedDate.getTime()) ?
								// or defaultDate is current printedDate and defaultDate is selectedDate
								" " + this._dayOverClass : "") + // highlight selected day
								(unselectable ? " " + this._unselectableClass + " ui-state-disabled": "") +  // highlight unselectable days
								(otherMonth && !showOtherMonths ? "" : " " + daySettings[1] + // highlight custom dates
								(printDate.getTime() === currentDate.getTime() ? " " + this._currentClass : "") + // highlight selected day
								(printDate.getTime() === today.getTime() ? " ui-datepicker-today" : "")) + "'" + // highlight today (if different)
								((!otherMonth || showOtherMonths) && daySettings[2] ? " title='" + daySettings[2].replace(/'/g, "&#39;") + "'" : "") + // cell title
								(unselectable ? "" : " data-handler='selectDay' data-event='click' data-month='" + printDate.getMonth() + "' data-year='" + printDate.getFullYear() + "'") + ">" + // actions
								(otherMonth && !showOtherMonths ? "&#xa0;" : // display for other months
								(unselectable ? "<span class='ui-state-default'>" + printDate.getDate() + "</span>" : "<a class='ui-state-default" +
								(printDate.getTime() === today.getTime() ? " ui-state-highlight" : "") +
								(printDate.getTime() === currentDate.getTime() ? " ui-state-active" : "") + // highlight selected day
								(otherMonth ? " ui-priority-secondary" : "") + // distinguish dates from other months
								"' href='#'>" + printDate.getDate() + "</a>")) + "</td>"; // display selectable date
							printDate.setDate(printDate.getDate() + 1);
							printDate = this._daylightSavingAdjust(printDate);
						}
						calender += tbody + "</tr>";
					}
					drawMonth++;
					if (drawMonth > 11) {
						drawMonth = 0;
						drawYear++;
					}
					calender += "</tbody></table>" + (isMultiMonth ? "</div>" +
								((numMonths[0] > 0 && col === numMonths[1]-1) ? "<div class='ui-datepicker-row-break'></div>" : "") : "");
					group += calender;
				}
				html += group;
			}
			html += buttonPanel;
			inst._keyEvent = false;
			return html;
		},
	
		/* Generate the month and year header. */
		_generateMonthYearHeader: function(inst, drawMonth, drawYear, minDate, maxDate,
				secondary, monthNames, monthNamesShort) {
	
			var inMinYear, inMaxYear, month, years, thisYear, determineYear, year, endYear,
				changeMonth = this._get(inst, "changeMonth"),
				changeYear = this._get(inst, "changeYear"),
				showMonthAfterYear = this._get(inst, "showMonthAfterYear"),
				html = "<div class='ui-datepicker-title'>",
				monthHtml = "";
	
			// month selection
			if (secondary || !changeMonth) {
				monthHtml += "<span class='ui-datepicker-month'>" + monthNames[drawMonth] + "</span>";
			} else {
				inMinYear = (minDate && minDate.getFullYear() === drawYear);
				inMaxYear = (maxDate && maxDate.getFullYear() === drawYear);
				monthHtml += "<select class='ui-datepicker-month' data-handler='selectMonth' data-event='change'>";
				for ( month = 0; month < 12; month++) {
					if ((!inMinYear || month >= minDate.getMonth()) && (!inMaxYear || month <= maxDate.getMonth())) {
						monthHtml += "<option value='" + month + "'" +
							(month === drawMonth ? " selected='selected'" : "") +
							">" + monthNamesShort[month] + "</option>";
					}
				}
				monthHtml += "</select>";
			}
	
			if (!showMonthAfterYear) {
				html += monthHtml + (secondary || !(changeMonth && changeYear) ? "&#xa0;" : "");
			}
	
			// year selection
			if ( !inst.yearshtml ) {
				inst.yearshtml = "";
				if (secondary || !changeYear) {
					html += "<span class='ui-datepicker-year'>" + drawYear + "</span>";
				} else {
					// determine range of years to display
					years = this._get(inst, "yearRange").split(":");
					thisYear = new Date().getFullYear();
					determineYear = function(value) {
						var year = (value.match(/c[+\-].*/) ? drawYear + parseInt(value.substring(1), 10) :
							(value.match(/[+\-].*/) ? thisYear + parseInt(value, 10) :
							parseInt(value, 10)));
						return (isNaN(year) ? thisYear : year);
					};
					year = determineYear(years[0]);
					endYear = Math.max(year, determineYear(years[1] || ""));
					year = (minDate ? Math.max(year, minDate.getFullYear()) : year);
					endYear = (maxDate ? Math.min(endYear, maxDate.getFullYear()) : endYear);
					inst.yearshtml += "<select class='ui-datepicker-year' data-handler='selectYear' data-event='change'>";
					for (; year <= endYear; year++) {
						inst.yearshtml += "<option value='" + year + "'" +
							(year === drawYear ? " selected='selected'" : "") +
							">" + year + "</option>";
					}
					inst.yearshtml += "</select>";
	
					html += inst.yearshtml;
					inst.yearshtml = null;
				}
			}
	
			html += this._get(inst, "yearSuffix");
			if (showMonthAfterYear) {
				html += (secondary || !(changeMonth && changeYear) ? "&#xa0;" : "") + monthHtml;
			}
			html += "</div>"; // Close datepicker_header
			return html;
		},
	
		/* Adjust one of the date sub-fields. */
		_adjustInstDate: function(inst, offset, period) {
			var year = inst.drawYear + (period === "Y" ? offset : 0),
				month = inst.drawMonth + (period === "M" ? offset : 0),
				day = Math.min(inst.selectedDay, this._getDaysInMonth(year, month)) + (period === "D" ? offset : 0),
				date = this._restrictMinMax(inst, this._daylightSavingAdjust(new Date(year, month, day)));
	
			inst.selectedDay = date.getDate();
			inst.drawMonth = inst.selectedMonth = date.getMonth();
			inst.drawYear = inst.selectedYear = date.getFullYear();
			if (period === "M" || period === "Y") {
				this._notifyChange(inst);
			}
		},
	
		/* Ensure a date is within any min/max bounds. */
		_restrictMinMax: function(inst, date) {
			var minDate = this._getMinMaxDate(inst, "min"),
				maxDate = this._getMinMaxDate(inst, "max"),
				newDate = (minDate && date < minDate ? minDate : date);
			return (maxDate && newDate > maxDate ? maxDate : newDate);
		},
	
		/* Notify change of month/year. */
		_notifyChange: function(inst) {
			var onChange = this._get(inst, "onChangeMonthYear");
			if (onChange) {
				onChange.apply((inst.input ? inst.input[0] : null),
					[inst.selectedYear, inst.selectedMonth + 1, inst]);
			}
		},
	
		/* Determine the number of months to show. */
		_getNumberOfMonths: function(inst) {
			var numMonths = this._get(inst, "numberOfMonths");
			return (numMonths == null ? [1, 1] : (typeof numMonths === "number" ? [1, numMonths] : numMonths));
		},
	
		/* Determine the current maximum date - ensure no time components are set. */
		_getMinMaxDate: function(inst, minMax) {
			return this._determineDate(inst, this._get(inst, minMax + "Date"), null);
		},
	
		/* Find the number of days in a given month. */
		_getDaysInMonth: function(year, month) {
			return 32 - this._daylightSavingAdjust(new Date(year, month, 32)).getDate();
		},
	
		/* Find the day of the week of the first of a month. */
		_getFirstDayOfMonth: function(year, month) {
			return new Date(year, month, 1).getDay();
		},
	
		/* Determines if we should allow a "next/prev" month display change. */
		_canAdjustMonth: function(inst, offset, curYear, curMonth) {
			var numMonths = this._getNumberOfMonths(inst),
				date = this._daylightSavingAdjust(new Date(curYear,
				curMonth + (offset < 0 ? offset : numMonths[0] * numMonths[1]), 1));
	
			if (offset < 0) {
				date.setDate(this._getDaysInMonth(date.getFullYear(), date.getMonth()));
			}
			return this._isInRange(inst, date);
		},
	
		/* Is the given date in the accepted range? */
		_isInRange: function(inst, date) {
			var yearSplit, currentYear,
				minDate = this._getMinMaxDate(inst, "min"),
				maxDate = this._getMinMaxDate(inst, "max"),
				minYear = null,
				maxYear = null,
				years = this._get(inst, "yearRange");
				if (years){
					yearSplit = years.split(":");
					currentYear = new Date().getFullYear();
					minYear = parseInt(yearSplit[0], 10);
					maxYear = parseInt(yearSplit[1], 10);
					if ( yearSplit[0].match(/[+\-].*/) ) {
						minYear += currentYear;
					}
					if ( yearSplit[1].match(/[+\-].*/) ) {
						maxYear += currentYear;
					}
				}
	
			return ((!minDate || date.getTime() >= minDate.getTime()) &&
				(!maxDate || date.getTime() <= maxDate.getTime()) &&
				(!minYear || date.getFullYear() >= minYear) &&
				(!maxYear || date.getFullYear() <= maxYear));
		},
	
		/* Provide the configuration settings for formatting/parsing. */
		_getFormatConfig: function(inst) {
			var shortYearCutoff = this._get(inst, "shortYearCutoff");
			shortYearCutoff = (typeof shortYearCutoff !== "string" ? shortYearCutoff :
				new Date().getFullYear() % 100 + parseInt(shortYearCutoff, 10));
			return {shortYearCutoff: shortYearCutoff,
				dayNamesShort: this._get(inst, "dayNamesShort"), dayNames: this._get(inst, "dayNames"),
				monthNamesShort: this._get(inst, "monthNamesShort"), monthNames: this._get(inst, "monthNames")};
		},
	
		/* Format the given date for display. */
		_formatDate: function(inst, day, month, year) {
			if (!day) {
				inst.currentDay = inst.selectedDay;
				inst.currentMonth = inst.selectedMonth;
				inst.currentYear = inst.selectedYear;
			}
			var date = (day ? (typeof day === "object" ? day :
				this._daylightSavingAdjust(new Date(year, month, day))) :
				this._daylightSavingAdjust(new Date(inst.currentYear, inst.currentMonth, inst.currentDay)));
			return this.formatDate(this._get(inst, "dateFormat"), date, this._getFormatConfig(inst));
		}
	});
	
	/*
	 * Bind hover events for datepicker elements.
	 * Done via delegate so the binding only occurs once in the lifetime of the parent div.
	 * Global datepicker_instActive, set by _updateDatepicker allows the handlers to find their way back to the active picker.
	 */
	function datepicker_bindHover(dpDiv) {
		var selector = "button, .ui-datepicker-prev, .ui-datepicker-next, .ui-datepicker-calendar td a";
		return dpDiv.delegate(selector, "mouseout", function() {
				$(this).removeClass("ui-state-hover");
				if (this.className.indexOf("ui-datepicker-prev") !== -1) {
					$(this).removeClass("ui-datepicker-prev-hover");
				}
				if (this.className.indexOf("ui-datepicker-next") !== -1) {
					$(this).removeClass("ui-datepicker-next-hover");
				}
			})
			.delegate( selector, "mouseover", datepicker_handleMouseover );
	}
	
	function datepicker_handleMouseover() {
		if (!$.datepicker._isDisabledDatepicker( datepicker_instActive.inline? datepicker_instActive.dpDiv.parent()[0] : datepicker_instActive.input[0])) {
			$(this).parents(".ui-datepicker-calendar").find("a").removeClass("ui-state-hover");
			$(this).addClass("ui-state-hover");
			if (this.className.indexOf("ui-datepicker-prev") !== -1) {
				$(this).addClass("ui-datepicker-prev-hover");
			}
			if (this.className.indexOf("ui-datepicker-next") !== -1) {
				$(this).addClass("ui-datepicker-next-hover");
			}
		}
	}
	
	/* jQuery extend now ignores nulls! */
	function datepicker_extendRemove(target, props) {
		$.extend(target, props);
		for (var name in props) {
			if (props[name] == null) {
				target[name] = props[name];
			}
		}
		return target;
	}
	
	/* Invoke the datepicker functionality.
	   @param  options  string - a command, optionally followed by additional parameters or
						Object - settings for attaching new datepicker functionality
	   @return  jQuery object */
	$.fn.datepicker = function(options){
	
		/* Verify an empty collection wasn't passed - Fixes #6976 */
		if ( !this.length ) {
			return this;
		}
	
		/* Initialise the date picker. */
		if (!$.datepicker.initialized) {
			$(document).mousedown($.datepicker._checkExternalClick);
			$.datepicker.initialized = true;
		}
	
		/* Append datepicker main container to body if not exist. */
		if ($("#"+$.datepicker._mainDivId).length === 0) {
			$("body").append($.datepicker.dpDiv);
		}
	
		var otherArgs = Array.prototype.slice.call(arguments, 1);
		if (typeof options === "string" && (options === "isDisabled" || options === "getDate" || options === "widget")) {
			return $.datepicker["_" + options + "Datepicker"].
				apply($.datepicker, [this[0]].concat(otherArgs));
		}
		if (options === "option" && arguments.length === 2 && typeof arguments[1] === "string") {
			return $.datepicker["_" + options + "Datepicker"].
				apply($.datepicker, [this[0]].concat(otherArgs));
		}
		return this.each(function() {
			typeof options === "string" ?
				$.datepicker["_" + options + "Datepicker"].
					apply($.datepicker, [this].concat(otherArgs)) :
				$.datepicker._attachDatepicker(this, options);
		});
	};
	
	$.datepicker = new Datepicker(); // singleton instance
	$.datepicker.initialized = false;
	$.datepicker.uuid = new Date().getTime();
	$.datepicker.version = "1.11.4";
	
	var datepicker = $.datepicker;
	
	
	/*!
	 * jQuery UI Draggable 1.11.4
	 * http://jqueryui.com
	 *
	 * Copyright jQuery Foundation and other contributors
	 * Released under the MIT license.
	 * http://jquery.org/license
	 *
	 * http://api.jqueryui.com/draggable/
	 */
	
	
	$.widget("ui.draggable", $.ui.mouse, {
		version: "1.11.4",
		widgetEventPrefix: "drag",
		options: {
			addClasses: true,
			appendTo: "parent",
			axis: false,
			connectToSortable: false,
			containment: false,
			cursor: "auto",
			cursorAt: false,
			grid: false,
			handle: false,
			helper: "original",
			iframeFix: false,
			opacity: false,
			refreshPositions: false,
			revert: false,
			revertDuration: 500,
			scope: "default",
			scroll: true,
			scrollSensitivity: 20,
			scrollSpeed: 20,
			snap: false,
			snapMode: "both",
			snapTolerance: 20,
			stack: false,
			zIndex: false,
	
			// callbacks
			drag: null,
			start: null,
			stop: null
		},
		_create: function() {
	
			if ( this.options.helper === "original" ) {
				this._setPositionRelative();
			}
			if (this.options.addClasses){
				this.element.addClass("ui-draggable");
			}
			if (this.options.disabled){
				this.element.addClass("ui-draggable-disabled");
			}
			this._setHandleClassName();
	
			this._mouseInit();
		},
	
		_setOption: function( key, value ) {
			this._super( key, value );
			if ( key === "handle" ) {
				this._removeHandleClassName();
				this._setHandleClassName();
			}
		},
	
		_destroy: function() {
			if ( ( this.helper || this.element ).is( ".ui-draggable-dragging" ) ) {
				this.destroyOnClear = true;
				return;
			}
			this.element.removeClass( "ui-draggable ui-draggable-dragging ui-draggable-disabled" );
			this._removeHandleClassName();
			this._mouseDestroy();
		},
	
		_mouseCapture: function(event) {
			var o = this.options;
	
			this._blurActiveElement( event );
	
			// among others, prevent a drag on a resizable-handle
			if (this.helper || o.disabled || $(event.target).closest(".ui-resizable-handle").length > 0) {
				return false;
			}
	
			//Quit if we're not on a valid handle
			this.handle = this._getHandle(event);
			if (!this.handle) {
				return false;
			}
	
			this._blockFrames( o.iframeFix === true ? "iframe" : o.iframeFix );
	
			return true;
	
		},
	
		_blockFrames: function( selector ) {
			this.iframeBlocks = this.document.find( selector ).map(function() {
				var iframe = $( this );
	
				return $( "<div>" )
					.css( "position", "absolute" )
					.appendTo( iframe.parent() )
					.outerWidth( iframe.outerWidth() )
					.outerHeight( iframe.outerHeight() )
					.offset( iframe.offset() )[ 0 ];
			});
		},
	
		_unblockFrames: function() {
			if ( this.iframeBlocks ) {
				this.iframeBlocks.remove();
				delete this.iframeBlocks;
			}
		},
	
		_blurActiveElement: function( event ) {
			var document = this.document[ 0 ];
	
			// Only need to blur if the event occurred on the draggable itself, see #10527
			if ( !this.handleElement.is( event.target ) ) {
				return;
			}
	
			// support: IE9
			// IE9 throws an "Unspecified error" accessing document.activeElement from an <iframe>
			try {
	
				// Support: IE9, IE10
				// If the <body> is blurred, IE will switch windows, see #9520
				if ( document.activeElement && document.activeElement.nodeName.toLowerCase() !== "body" ) {
	
					// Blur any element that currently has focus, see #4261
					$( document.activeElement ).blur();
				}
			} catch ( error ) {}
		},
	
		_mouseStart: function(event) {
	
			var o = this.options;
	
			//Create and append the visible helper
			this.helper = this._createHelper(event);
	
			this.helper.addClass("ui-draggable-dragging");
	
			//Cache the helper size
			this._cacheHelperProportions();
	
			//If ddmanager is used for droppables, set the global draggable
			if ($.ui.ddmanager) {
				$.ui.ddmanager.current = this;
			}
	
			/*
			 * - Position generation -
			 * This block generates everything position related - it's the core of draggables.
			 */
	
			//Cache the margins of the original element
			this._cacheMargins();
	
			//Store the helper's css position
			this.cssPosition = this.helper.css( "position" );
			this.scrollParent = this.helper.scrollParent( true );
			this.offsetParent = this.helper.offsetParent();
			this.hasFixedAncestor = this.helper.parents().filter(function() {
					return $( this ).css( "position" ) === "fixed";
				}).length > 0;
	
			//The element's absolute position on the page minus margins
			this.positionAbs = this.element.offset();
			this._refreshOffsets( event );
	
			//Generate the original position
			this.originalPosition = this.position = this._generatePosition( event, false );
			this.originalPageX = event.pageX;
			this.originalPageY = event.pageY;
	
			//Adjust the mouse offset relative to the helper if "cursorAt" is supplied
			(o.cursorAt && this._adjustOffsetFromHelper(o.cursorAt));
	
			//Set a containment if given in the options
			this._setContainment();
	
			//Trigger event + callbacks
			if (this._trigger("start", event) === false) {
				this._clear();
				return false;
			}
	
			//Recache the helper size
			this._cacheHelperProportions();
	
			//Prepare the droppable offsets
			if ($.ui.ddmanager && !o.dropBehaviour) {
				$.ui.ddmanager.prepareOffsets(this, event);
			}
	
			// Reset helper's right/bottom css if they're set and set explicit width/height instead
			// as this prevents resizing of elements with right/bottom set (see #7772)
			this._normalizeRightBottom();
	
			this._mouseDrag(event, true); //Execute the drag once - this causes the helper not to be visible before getting its correct position
	
			//If the ddmanager is used for droppables, inform the manager that dragging has started (see #5003)
			if ( $.ui.ddmanager ) {
				$.ui.ddmanager.dragStart(this, event);
			}
	
			return true;
		},
	
		_refreshOffsets: function( event ) {
			this.offset = {
				top: this.positionAbs.top - this.margins.top,
				left: this.positionAbs.left - this.margins.left,
				scroll: false,
				parent: this._getParentOffset(),
				relative: this._getRelativeOffset()
			};
	
			this.offset.click = {
				left: event.pageX - this.offset.left,
				top: event.pageY - this.offset.top
			};
		},
	
		_mouseDrag: function(event, noPropagation) {
			// reset any necessary cached properties (see #5009)
			if ( this.hasFixedAncestor ) {
				this.offset.parent = this._getParentOffset();
			}
	
			//Compute the helpers position
			this.position = this._generatePosition( event, true );
			this.positionAbs = this._convertPositionTo("absolute");
	
			//Call plugins and callbacks and use the resulting position if something is returned
			if (!noPropagation) {
				var ui = this._uiHash();
				if (this._trigger("drag", event, ui) === false) {
					this._mouseUp({});
					return false;
				}
				this.position = ui.position;
			}
	
			this.helper[ 0 ].style.left = this.position.left + "px";
			this.helper[ 0 ].style.top = this.position.top + "px";
	
			if ($.ui.ddmanager) {
				$.ui.ddmanager.drag(this, event);
			}
	
			return false;
		},
	
		_mouseStop: function(event) {
	
			//If we are using droppables, inform the manager about the drop
			var that = this,
				dropped = false;
			if ($.ui.ddmanager && !this.options.dropBehaviour) {
				dropped = $.ui.ddmanager.drop(this, event);
			}
	
			//if a drop comes from outside (a sortable)
			if (this.dropped) {
				dropped = this.dropped;
				this.dropped = false;
			}
	
			if ((this.options.revert === "invalid" && !dropped) || (this.options.revert === "valid" && dropped) || this.options.revert === true || ($.isFunction(this.options.revert) && this.options.revert.call(this.element, dropped))) {
				$(this.helper).animate(this.originalPosition, parseInt(this.options.revertDuration, 10), function() {
					if (that._trigger("stop", event) !== false) {
						that._clear();
					}
				});
			} else {
				if (this._trigger("stop", event) !== false) {
					this._clear();
				}
			}
	
			return false;
		},
	
		_mouseUp: function( event ) {
			this._unblockFrames();
	
			//If the ddmanager is used for droppables, inform the manager that dragging has stopped (see #5003)
			if ( $.ui.ddmanager ) {
				$.ui.ddmanager.dragStop(this, event);
			}
	
			// Only need to focus if the event occurred on the draggable itself, see #10527
			if ( this.handleElement.is( event.target ) ) {
				// The interaction is over; whether or not the click resulted in a drag, focus the element
				this.element.focus();
			}
	
			return $.ui.mouse.prototype._mouseUp.call(this, event);
		},
	
		cancel: function() {
	
			if (this.helper.is(".ui-draggable-dragging")) {
				this._mouseUp({});
			} else {
				this._clear();
			}
	
			return this;
	
		},
	
		_getHandle: function(event) {
			return this.options.handle ?
				!!$( event.target ).closest( this.element.find( this.options.handle ) ).length :
				true;
		},
	
		_setHandleClassName: function() {
			this.handleElement = this.options.handle ?
				this.element.find( this.options.handle ) : this.element;
			this.handleElement.addClass( "ui-draggable-handle" );
		},
	
		_removeHandleClassName: function() {
			this.handleElement.removeClass( "ui-draggable-handle" );
		},
	
		_createHelper: function(event) {
	
			var o = this.options,
				helperIsFunction = $.isFunction( o.helper ),
				helper = helperIsFunction ?
					$( o.helper.apply( this.element[ 0 ], [ event ] ) ) :
					( o.helper === "clone" ?
						this.element.clone().removeAttr( "id" ) :
						this.element );
	
			if (!helper.parents("body").length) {
				helper.appendTo((o.appendTo === "parent" ? this.element[0].parentNode : o.appendTo));
			}
	
			// http://bugs.jqueryui.com/ticket/9446
			// a helper function can return the original element
			// which wouldn't have been set to relative in _create
			if ( helperIsFunction && helper[ 0 ] === this.element[ 0 ] ) {
				this._setPositionRelative();
			}
	
			if (helper[0] !== this.element[0] && !(/(fixed|absolute)/).test(helper.css("position"))) {
				helper.css("position", "absolute");
			}
	
			return helper;
	
		},
	
		_setPositionRelative: function() {
			if ( !( /^(?:r|a|f)/ ).test( this.element.css( "position" ) ) ) {
				this.element[ 0 ].style.position = "relative";
			}
		},
	
		_adjustOffsetFromHelper: function(obj) {
			if (typeof obj === "string") {
				obj = obj.split(" ");
			}
			if ($.isArray(obj)) {
				obj = { left: +obj[0], top: +obj[1] || 0 };
			}
			if ("left" in obj) {
				this.offset.click.left = obj.left + this.margins.left;
			}
			if ("right" in obj) {
				this.offset.click.left = this.helperProportions.width - obj.right + this.margins.left;
			}
			if ("top" in obj) {
				this.offset.click.top = obj.top + this.margins.top;
			}
			if ("bottom" in obj) {
				this.offset.click.top = this.helperProportions.height - obj.bottom + this.margins.top;
			}
		},
	
		_isRootNode: function( element ) {
			return ( /(html|body)/i ).test( element.tagName ) || element === this.document[ 0 ];
		},
	
		_getParentOffset: function() {
	
			//Get the offsetParent and cache its position
			var po = this.offsetParent.offset(),
				document = this.document[ 0 ];
	
			// This is a special case where we need to modify a offset calculated on start, since the following happened:
			// 1. The position of the helper is absolute, so it's position is calculated based on the next positioned parent
			// 2. The actual offset parent is a child of the scroll parent, and the scroll parent isn't the document, which means that
			//    the scroll is included in the initial calculation of the offset of the parent, and never recalculated upon drag
			if (this.cssPosition === "absolute" && this.scrollParent[0] !== document && $.contains(this.scrollParent[0], this.offsetParent[0])) {
				po.left += this.scrollParent.scrollLeft();
				po.top += this.scrollParent.scrollTop();
			}
	
			if ( this._isRootNode( this.offsetParent[ 0 ] ) ) {
				po = { top: 0, left: 0 };
			}
	
			return {
				top: po.top + (parseInt(this.offsetParent.css("borderTopWidth"), 10) || 0),
				left: po.left + (parseInt(this.offsetParent.css("borderLeftWidth"), 10) || 0)
			};
	
		},
	
		_getRelativeOffset: function() {
			if ( this.cssPosition !== "relative" ) {
				return { top: 0, left: 0 };
			}
	
			var p = this.element.position(),
				scrollIsRootNode = this._isRootNode( this.scrollParent[ 0 ] );
	
			return {
				top: p.top - ( parseInt(this.helper.css( "top" ), 10) || 0 ) + ( !scrollIsRootNode ? this.scrollParent.scrollTop() : 0 ),
				left: p.left - ( parseInt(this.helper.css( "left" ), 10) || 0 ) + ( !scrollIsRootNode ? this.scrollParent.scrollLeft() : 0 )
			};
	
		},
	
		_cacheMargins: function() {
			this.margins = {
				left: (parseInt(this.element.css("marginLeft"), 10) || 0),
				top: (parseInt(this.element.css("marginTop"), 10) || 0),
				right: (parseInt(this.element.css("marginRight"), 10) || 0),
				bottom: (parseInt(this.element.css("marginBottom"), 10) || 0)
			};
		},
	
		_cacheHelperProportions: function() {
			this.helperProportions = {
				width: this.helper.outerWidth(),
				height: this.helper.outerHeight()
			};
		},
	
		_setContainment: function() {
	
			var isUserScrollable, c, ce,
				o = this.options,
				document = this.document[ 0 ];
	
			this.relativeContainer = null;
	
			if ( !o.containment ) {
				this.containment = null;
				return;
			}
	
			if ( o.containment === "window" ) {
				this.containment = [
					$( window ).scrollLeft() - this.offset.relative.left - this.offset.parent.left,
					$( window ).scrollTop() - this.offset.relative.top - this.offset.parent.top,
					$( window ).scrollLeft() + $( window ).width() - this.helperProportions.width - this.margins.left,
					$( window ).scrollTop() + ( $( window ).height() || document.body.parentNode.scrollHeight ) - this.helperProportions.height - this.margins.top
				];
				return;
			}
	
			if ( o.containment === "document") {
				this.containment = [
					0,
					0,
					$( document ).width() - this.helperProportions.width - this.margins.left,
					( $( document ).height() || document.body.parentNode.scrollHeight ) - this.helperProportions.height - this.margins.top
				];
				return;
			}
	
			if ( o.containment.constructor === Array ) {
				this.containment = o.containment;
				return;
			}
	
			if ( o.containment === "parent" ) {
				o.containment = this.helper[ 0 ].parentNode;
			}
	
			c = $( o.containment );
			ce = c[ 0 ];
	
			if ( !ce ) {
				return;
			}
	
			isUserScrollable = /(scroll|auto)/.test( c.css( "overflow" ) );
	
			this.containment = [
				( parseInt( c.css( "borderLeftWidth" ), 10 ) || 0 ) + ( parseInt( c.css( "paddingLeft" ), 10 ) || 0 ),
				( parseInt( c.css( "borderTopWidth" ), 10 ) || 0 ) + ( parseInt( c.css( "paddingTop" ), 10 ) || 0 ),
				( isUserScrollable ? Math.max( ce.scrollWidth, ce.offsetWidth ) : ce.offsetWidth ) -
					( parseInt( c.css( "borderRightWidth" ), 10 ) || 0 ) -
					( parseInt( c.css( "paddingRight" ), 10 ) || 0 ) -
					this.helperProportions.width -
					this.margins.left -
					this.margins.right,
				( isUserScrollable ? Math.max( ce.scrollHeight, ce.offsetHeight ) : ce.offsetHeight ) -
					( parseInt( c.css( "borderBottomWidth" ), 10 ) || 0 ) -
					( parseInt( c.css( "paddingBottom" ), 10 ) || 0 ) -
					this.helperProportions.height -
					this.margins.top -
					this.margins.bottom
			];
			this.relativeContainer = c;
		},
	
		_convertPositionTo: function(d, pos) {
	
			if (!pos) {
				pos = this.position;
			}
	
			var mod = d === "absolute" ? 1 : -1,
				scrollIsRootNode = this._isRootNode( this.scrollParent[ 0 ] );
	
			return {
				top: (
					pos.top	+																// The absolute mouse position
					this.offset.relative.top * mod +										// Only for relative positioned nodes: Relative offset from element to offset parent
					this.offset.parent.top * mod -										// The offsetParent's offset without borders (offset + border)
					( ( this.cssPosition === "fixed" ? -this.offset.scroll.top : ( scrollIsRootNode ? 0 : this.offset.scroll.top ) ) * mod)
				),
				left: (
					pos.left +																// The absolute mouse position
					this.offset.relative.left * mod +										// Only for relative positioned nodes: Relative offset from element to offset parent
					this.offset.parent.left * mod	-										// The offsetParent's offset without borders (offset + border)
					( ( this.cssPosition === "fixed" ? -this.offset.scroll.left : ( scrollIsRootNode ? 0 : this.offset.scroll.left ) ) * mod)
				)
			};
	
		},
	
		_generatePosition: function( event, constrainPosition ) {
	
			var containment, co, top, left,
				o = this.options,
				scrollIsRootNode = this._isRootNode( this.scrollParent[ 0 ] ),
				pageX = event.pageX,
				pageY = event.pageY;
	
			// Cache the scroll
			if ( !scrollIsRootNode || !this.offset.scroll ) {
				this.offset.scroll = {
					top: this.scrollParent.scrollTop(),
					left: this.scrollParent.scrollLeft()
				};
			}
	
			/*
			 * - Position constraining -
			 * Constrain the position to a mix of grid, containment.
			 */
	
			// If we are not dragging yet, we won't check for options
			if ( constrainPosition ) {
				if ( this.containment ) {
					if ( this.relativeContainer ){
						co = this.relativeContainer.offset();
						containment = [
							this.containment[ 0 ] + co.left,
							this.containment[ 1 ] + co.top,
							this.containment[ 2 ] + co.left,
							this.containment[ 3 ] + co.top
						];
					} else {
						containment = this.containment;
					}
	
					if (event.pageX - this.offset.click.left < containment[0]) {
						pageX = containment[0] + this.offset.click.left;
					}
					if (event.pageY - this.offset.click.top < containment[1]) {
						pageY = containment[1] + this.offset.click.top;
					}
					if (event.pageX - this.offset.click.left > containment[2]) {
						pageX = containment[2] + this.offset.click.left;
					}
					if (event.pageY - this.offset.click.top > containment[3]) {
						pageY = containment[3] + this.offset.click.top;
					}
				}
	
				if (o.grid) {
					//Check for grid elements set to 0 to prevent divide by 0 error causing invalid argument errors in IE (see ticket #6950)
					top = o.grid[1] ? this.originalPageY + Math.round((pageY - this.originalPageY) / o.grid[1]) * o.grid[1] : this.originalPageY;
					pageY = containment ? ((top - this.offset.click.top >= containment[1] || top - this.offset.click.top > containment[3]) ? top : ((top - this.offset.click.top >= containment[1]) ? top - o.grid[1] : top + o.grid[1])) : top;
	
					left = o.grid[0] ? this.originalPageX + Math.round((pageX - this.originalPageX) / o.grid[0]) * o.grid[0] : this.originalPageX;
					pageX = containment ? ((left - this.offset.click.left >= containment[0] || left - this.offset.click.left > containment[2]) ? left : ((left - this.offset.click.left >= containment[0]) ? left - o.grid[0] : left + o.grid[0])) : left;
				}
	
				if ( o.axis === "y" ) {
					pageX = this.originalPageX;
				}
	
				if ( o.axis === "x" ) {
					pageY = this.originalPageY;
				}
			}
	
			return {
				top: (
					pageY -																	// The absolute mouse position
					this.offset.click.top	-												// Click offset (relative to the element)
					this.offset.relative.top -												// Only for relative positioned nodes: Relative offset from element to offset parent
					this.offset.parent.top +												// The offsetParent's offset without borders (offset + border)
					( this.cssPosition === "fixed" ? -this.offset.scroll.top : ( scrollIsRootNode ? 0 : this.offset.scroll.top ) )
				),
				left: (
					pageX -																	// The absolute mouse position
					this.offset.click.left -												// Click offset (relative to the element)
					this.offset.relative.left -												// Only for relative positioned nodes: Relative offset from element to offset parent
					this.offset.parent.left +												// The offsetParent's offset without borders (offset + border)
					( this.cssPosition === "fixed" ? -this.offset.scroll.left : ( scrollIsRootNode ? 0 : this.offset.scroll.left ) )
				)
			};
	
		},
	
		_clear: function() {
			this.helper.removeClass("ui-draggable-dragging");
			if (this.helper[0] !== this.element[0] && !this.cancelHelperRemoval) {
				this.helper.remove();
			}
			this.helper = null;
			this.cancelHelperRemoval = false;
			if ( this.destroyOnClear ) {
				this.destroy();
			}
		},
	
		_normalizeRightBottom: function() {
			if ( this.options.axis !== "y" && this.helper.css( "right" ) !== "auto" ) {
				this.helper.width( this.helper.width() );
				this.helper.css( "right", "auto" );
			}
			if ( this.options.axis !== "x" && this.helper.css( "bottom" ) !== "auto" ) {
				this.helper.height( this.helper.height() );
				this.helper.css( "bottom", "auto" );
			}
		},
	
		// From now on bulk stuff - mainly helpers
	
		_trigger: function( type, event, ui ) {
			ui = ui || this._uiHash();
			$.ui.plugin.call( this, type, [ event, ui, this ], true );
	
			// Absolute position and offset (see #6884 ) have to be recalculated after plugins
			if ( /^(drag|start|stop)/.test( type ) ) {
				this.positionAbs = this._convertPositionTo( "absolute" );
				ui.offset = this.positionAbs;
			}
			return $.Widget.prototype._trigger.call( this, type, event, ui );
		},
	
		plugins: {},
	
		_uiHash: function() {
			return {
				helper: this.helper,
				position: this.position,
				originalPosition: this.originalPosition,
				offset: this.positionAbs
			};
		}
	
	});
	
	$.ui.plugin.add( "draggable", "connectToSortable", {
		start: function( event, ui, draggable ) {
			var uiSortable = $.extend( {}, ui, {
				item: draggable.element
			});
	
			draggable.sortables = [];
			$( draggable.options.connectToSortable ).each(function() {
				var sortable = $( this ).sortable( "instance" );
	
				if ( sortable && !sortable.options.disabled ) {
					draggable.sortables.push( sortable );
	
					// refreshPositions is called at drag start to refresh the containerCache
					// which is used in drag. This ensures it's initialized and synchronized
					// with any changes that might have happened on the page since initialization.
					sortable.refreshPositions();
					sortable._trigger("activate", event, uiSortable);
				}
			});
		},
		stop: function( event, ui, draggable ) {
			var uiSortable = $.extend( {}, ui, {
				item: draggable.element
			});
	
			draggable.cancelHelperRemoval = false;
	
			$.each( draggable.sortables, function() {
				var sortable = this;
	
				if ( sortable.isOver ) {
					sortable.isOver = 0;
	
					// Allow this sortable to handle removing the helper
					draggable.cancelHelperRemoval = true;
					sortable.cancelHelperRemoval = false;
	
					// Use _storedCSS To restore properties in the sortable,
					// as this also handles revert (#9675) since the draggable
					// may have modified them in unexpected ways (#8809)
					sortable._storedCSS = {
						position: sortable.placeholder.css( "position" ),
						top: sortable.placeholder.css( "top" ),
						left: sortable.placeholder.css( "left" )
					};
	
					sortable._mouseStop(event);
	
					// Once drag has ended, the sortable should return to using
					// its original helper, not the shared helper from draggable
					sortable.options.helper = sortable.options._helper;
				} else {
					// Prevent this Sortable from removing the helper.
					// However, don't set the draggable to remove the helper
					// either as another connected Sortable may yet handle the removal.
					sortable.cancelHelperRemoval = true;
	
					sortable._trigger( "deactivate", event, uiSortable );
				}
			});
		},
		drag: function( event, ui, draggable ) {
			$.each( draggable.sortables, function() {
				var innermostIntersecting = false,
					sortable = this;
	
				// Copy over variables that sortable's _intersectsWith uses
				sortable.positionAbs = draggable.positionAbs;
				sortable.helperProportions = draggable.helperProportions;
				sortable.offset.click = draggable.offset.click;
	
				if ( sortable._intersectsWith( sortable.containerCache ) ) {
					innermostIntersecting = true;
	
					$.each( draggable.sortables, function() {
						// Copy over variables that sortable's _intersectsWith uses
						this.positionAbs = draggable.positionAbs;
						this.helperProportions = draggable.helperProportions;
						this.offset.click = draggable.offset.click;
	
						if ( this !== sortable &&
								this._intersectsWith( this.containerCache ) &&
								$.contains( sortable.element[ 0 ], this.element[ 0 ] ) ) {
							innermostIntersecting = false;
						}
	
						return innermostIntersecting;
					});
				}
	
				if ( innermostIntersecting ) {
					// If it intersects, we use a little isOver variable and set it once,
					// so that the move-in stuff gets fired only once.
					if ( !sortable.isOver ) {
						sortable.isOver = 1;
	
						// Store draggable's parent in case we need to reappend to it later.
						draggable._parent = ui.helper.parent();
	
						sortable.currentItem = ui.helper
							.appendTo( sortable.element )
							.data( "ui-sortable-item", true );
	
						// Store helper option to later restore it
						sortable.options._helper = sortable.options.helper;
	
						sortable.options.helper = function() {
							return ui.helper[ 0 ];
						};
	
						// Fire the start events of the sortable with our passed browser event,
						// and our own helper (so it doesn't create a new one)
						event.target = sortable.currentItem[ 0 ];
						sortable._mouseCapture( event, true );
						sortable._mouseStart( event, true, true );
	
						// Because the browser event is way off the new appended portlet,
						// modify necessary variables to reflect the changes
						sortable.offset.click.top = draggable.offset.click.top;
						sortable.offset.click.left = draggable.offset.click.left;
						sortable.offset.parent.left -= draggable.offset.parent.left -
							sortable.offset.parent.left;
						sortable.offset.parent.top -= draggable.offset.parent.top -
							sortable.offset.parent.top;
	
						draggable._trigger( "toSortable", event );
	
						// Inform draggable that the helper is in a valid drop zone,
						// used solely in the revert option to handle "valid/invalid".
						draggable.dropped = sortable.element;
	
						// Need to refreshPositions of all sortables in the case that
						// adding to one sortable changes the location of the other sortables (#9675)
						$.each( draggable.sortables, function() {
							this.refreshPositions();
						});
	
						// hack so receive/update callbacks work (mostly)
						draggable.currentItem = draggable.element;
						sortable.fromOutside = draggable;
					}
	
					if ( sortable.currentItem ) {
						sortable._mouseDrag( event );
						// Copy the sortable's position because the draggable's can potentially reflect
						// a relative position, while sortable is always absolute, which the dragged
						// element has now become. (#8809)
						ui.position = sortable.position;
					}
				} else {
					// If it doesn't intersect with the sortable, and it intersected before,
					// we fake the drag stop of the sortable, but make sure it doesn't remove
					// the helper by using cancelHelperRemoval.
					if ( sortable.isOver ) {
	
						sortable.isOver = 0;
						sortable.cancelHelperRemoval = true;
	
						// Calling sortable's mouseStop would trigger a revert,
						// so revert must be temporarily false until after mouseStop is called.
						sortable.options._revert = sortable.options.revert;
						sortable.options.revert = false;
	
						sortable._trigger( "out", event, sortable._uiHash( sortable ) );
						sortable._mouseStop( event, true );
	
						// restore sortable behaviors that were modfied
						// when the draggable entered the sortable area (#9481)
						sortable.options.revert = sortable.options._revert;
						sortable.options.helper = sortable.options._helper;
	
						if ( sortable.placeholder ) {
							sortable.placeholder.remove();
						}
	
						// Restore and recalculate the draggable's offset considering the sortable
						// may have modified them in unexpected ways. (#8809, #10669)
						ui.helper.appendTo( draggable._parent );
						draggable._refreshOffsets( event );
						ui.position = draggable._generatePosition( event, true );
	
						draggable._trigger( "fromSortable", event );
	
						// Inform draggable that the helper is no longer in a valid drop zone
						draggable.dropped = false;
	
						// Need to refreshPositions of all sortables just in case removing
						// from one sortable changes the location of other sortables (#9675)
						$.each( draggable.sortables, function() {
							this.refreshPositions();
						});
					}
				}
			});
		}
	});
	
	$.ui.plugin.add("draggable", "cursor", {
		start: function( event, ui, instance ) {
			var t = $( "body" ),
				o = instance.options;
	
			if (t.css("cursor")) {
				o._cursor = t.css("cursor");
			}
			t.css("cursor", o.cursor);
		},
		stop: function( event, ui, instance ) {
			var o = instance.options;
			if (o._cursor) {
				$("body").css("cursor", o._cursor);
			}
		}
	});
	
	$.ui.plugin.add("draggable", "opacity", {
		start: function( event, ui, instance ) {
			var t = $( ui.helper ),
				o = instance.options;
			if (t.css("opacity")) {
				o._opacity = t.css("opacity");
			}
			t.css("opacity", o.opacity);
		},
		stop: function( event, ui, instance ) {
			var o = instance.options;
			if (o._opacity) {
				$(ui.helper).css("opacity", o._opacity);
			}
		}
	});
	
	$.ui.plugin.add("draggable", "scroll", {
		start: function( event, ui, i ) {
			if ( !i.scrollParentNotHidden ) {
				i.scrollParentNotHidden = i.helper.scrollParent( false );
			}
	
			if ( i.scrollParentNotHidden[ 0 ] !== i.document[ 0 ] && i.scrollParentNotHidden[ 0 ].tagName !== "HTML" ) {
				i.overflowOffset = i.scrollParentNotHidden.offset();
			}
		},
		drag: function( event, ui, i  ) {
	
			var o = i.options,
				scrolled = false,
				scrollParent = i.scrollParentNotHidden[ 0 ],
				document = i.document[ 0 ];
	
			if ( scrollParent !== document && scrollParent.tagName !== "HTML" ) {
				if ( !o.axis || o.axis !== "x" ) {
					if ( ( i.overflowOffset.top + scrollParent.offsetHeight ) - event.pageY < o.scrollSensitivity ) {
						scrollParent.scrollTop = scrolled = scrollParent.scrollTop + o.scrollSpeed;
					} else if ( event.pageY - i.overflowOffset.top < o.scrollSensitivity ) {
						scrollParent.scrollTop = scrolled = scrollParent.scrollTop - o.scrollSpeed;
					}
				}
	
				if ( !o.axis || o.axis !== "y" ) {
					if ( ( i.overflowOffset.left + scrollParent.offsetWidth ) - event.pageX < o.scrollSensitivity ) {
						scrollParent.scrollLeft = scrolled = scrollParent.scrollLeft + o.scrollSpeed;
					} else if ( event.pageX - i.overflowOffset.left < o.scrollSensitivity ) {
						scrollParent.scrollLeft = scrolled = scrollParent.scrollLeft - o.scrollSpeed;
					}
				}
	
			} else {
	
				if (!o.axis || o.axis !== "x") {
					if (event.pageY - $(document).scrollTop() < o.scrollSensitivity) {
						scrolled = $(document).scrollTop($(document).scrollTop() - o.scrollSpeed);
					} else if ($(window).height() - (event.pageY - $(document).scrollTop()) < o.scrollSensitivity) {
						scrolled = $(document).scrollTop($(document).scrollTop() + o.scrollSpeed);
					}
				}
	
				if (!o.axis || o.axis !== "y") {
					if (event.pageX - $(document).scrollLeft() < o.scrollSensitivity) {
						scrolled = $(document).scrollLeft($(document).scrollLeft() - o.scrollSpeed);
					} else if ($(window).width() - (event.pageX - $(document).scrollLeft()) < o.scrollSensitivity) {
						scrolled = $(document).scrollLeft($(document).scrollLeft() + o.scrollSpeed);
					}
				}
	
			}
	
			if (scrolled !== false && $.ui.ddmanager && !o.dropBehaviour) {
				$.ui.ddmanager.prepareOffsets(i, event);
			}
	
		}
	});
	
	$.ui.plugin.add("draggable", "snap", {
		start: function( event, ui, i ) {
	
			var o = i.options;
	
			i.snapElements = [];
	
			$(o.snap.constructor !== String ? ( o.snap.items || ":data(ui-draggable)" ) : o.snap).each(function() {
				var $t = $(this),
					$o = $t.offset();
				if (this !== i.element[0]) {
					i.snapElements.push({
						item: this,
						width: $t.outerWidth(), height: $t.outerHeight(),
						top: $o.top, left: $o.left
					});
				}
			});
	
		},
		drag: function( event, ui, inst ) {
	
			var ts, bs, ls, rs, l, r, t, b, i, first,
				o = inst.options,
				d = o.snapTolerance,
				x1 = ui.offset.left, x2 = x1 + inst.helperProportions.width,
				y1 = ui.offset.top, y2 = y1 + inst.helperProportions.height;
	
			for (i = inst.snapElements.length - 1; i >= 0; i--){
	
				l = inst.snapElements[i].left - inst.margins.left;
				r = l + inst.snapElements[i].width;
				t = inst.snapElements[i].top - inst.margins.top;
				b = t + inst.snapElements[i].height;
	
				if ( x2 < l - d || x1 > r + d || y2 < t - d || y1 > b + d || !$.contains( inst.snapElements[ i ].item.ownerDocument, inst.snapElements[ i ].item ) ) {
					if (inst.snapElements[i].snapping) {
						(inst.options.snap.release && inst.options.snap.release.call(inst.element, event, $.extend(inst._uiHash(), { snapItem: inst.snapElements[i].item })));
					}
					inst.snapElements[i].snapping = false;
					continue;
				}
	
				if (o.snapMode !== "inner") {
					ts = Math.abs(t - y2) <= d;
					bs = Math.abs(b - y1) <= d;
					ls = Math.abs(l - x2) <= d;
					rs = Math.abs(r - x1) <= d;
					if (ts) {
						ui.position.top = inst._convertPositionTo("relative", { top: t - inst.helperProportions.height, left: 0 }).top;
					}
					if (bs) {
						ui.position.top = inst._convertPositionTo("relative", { top: b, left: 0 }).top;
					}
					if (ls) {
						ui.position.left = inst._convertPositionTo("relative", { top: 0, left: l - inst.helperProportions.width }).left;
					}
					if (rs) {
						ui.position.left = inst._convertPositionTo("relative", { top: 0, left: r }).left;
					}
				}
	
				first = (ts || bs || ls || rs);
	
				if (o.snapMode !== "outer") {
					ts = Math.abs(t - y1) <= d;
					bs = Math.abs(b - y2) <= d;
					ls = Math.abs(l - x1) <= d;
					rs = Math.abs(r - x2) <= d;
					if (ts) {
						ui.position.top = inst._convertPositionTo("relative", { top: t, left: 0 }).top;
					}
					if (bs) {
						ui.position.top = inst._convertPositionTo("relative", { top: b - inst.helperProportions.height, left: 0 }).top;
					}
					if (ls) {
						ui.position.left = inst._convertPositionTo("relative", { top: 0, left: l }).left;
					}
					if (rs) {
						ui.position.left = inst._convertPositionTo("relative", { top: 0, left: r - inst.helperProportions.width }).left;
					}
				}
	
				if (!inst.snapElements[i].snapping && (ts || bs || ls || rs || first)) {
					(inst.options.snap.snap && inst.options.snap.snap.call(inst.element, event, $.extend(inst._uiHash(), { snapItem: inst.snapElements[i].item })));
				}
				inst.snapElements[i].snapping = (ts || bs || ls || rs || first);
	
			}
	
		}
	});
	
	$.ui.plugin.add("draggable", "stack", {
		start: function( event, ui, instance ) {
			var min,
				o = instance.options,
				group = $.makeArray($(o.stack)).sort(function(a, b) {
					return (parseInt($(a).css("zIndex"), 10) || 0) - (parseInt($(b).css("zIndex"), 10) || 0);
				});
	
			if (!group.length) { return; }
	
			min = parseInt($(group[0]).css("zIndex"), 10) || 0;
			$(group).each(function(i) {
				$(this).css("zIndex", min + i);
			});
			this.css("zIndex", (min + group.length));
		}
	});
	
	$.ui.plugin.add("draggable", "zIndex", {
		start: function( event, ui, instance ) {
			var t = $( ui.helper ),
				o = instance.options;
	
			if (t.css("zIndex")) {
				o._zIndex = t.css("zIndex");
			}
			t.css("zIndex", o.zIndex);
		},
		stop: function( event, ui, instance ) {
			var o = instance.options;
	
			if (o._zIndex) {
				$(ui.helper).css("zIndex", o._zIndex);
			}
		}
	});
	
	var draggable = $.ui.draggable;
	
	
	/*!
	 * jQuery UI Resizable 1.11.4
	 * http://jqueryui.com
	 *
	 * Copyright jQuery Foundation and other contributors
	 * Released under the MIT license.
	 * http://jquery.org/license
	 *
	 * http://api.jqueryui.com/resizable/
	 */
	
	
	$.widget("ui.resizable", $.ui.mouse, {
		version: "1.11.4",
		widgetEventPrefix: "resize",
		options: {
			alsoResize: false,
			animate: false,
			animateDuration: "slow",
			animateEasing: "swing",
			aspectRatio: false,
			autoHide: false,
			containment: false,
			ghost: false,
			grid: false,
			handles: "e,s,se",
			helper: false,
			maxHeight: null,
			maxWidth: null,
			minHeight: 10,
			minWidth: 10,
			// See #7960
			zIndex: 90,
	
			// callbacks
			resize: null,
			start: null,
			stop: null
		},
	
		_num: function( value ) {
			return parseInt( value, 10 ) || 0;
		},
	
		_isNumber: function( value ) {
			return !isNaN( parseInt( value, 10 ) );
		},
	
		_hasScroll: function( el, a ) {
	
			if ( $( el ).css( "overflow" ) === "hidden") {
				return false;
			}
	
			var scroll = ( a && a === "left" ) ? "scrollLeft" : "scrollTop",
				has = false;
	
			if ( el[ scroll ] > 0 ) {
				return true;
			}
	
			// TODO: determine which cases actually cause this to happen
			// if the element doesn't have the scroll set, see if it's possible to
			// set the scroll
			el[ scroll ] = 1;
			has = ( el[ scroll ] > 0 );
			el[ scroll ] = 0;
			return has;
		},
	
		_create: function() {
	
			var n, i, handle, axis, hname,
				that = this,
				o = this.options;
			this.element.addClass("ui-resizable");
	
			$.extend(this, {
				_aspectRatio: !!(o.aspectRatio),
				aspectRatio: o.aspectRatio,
				originalElement: this.element,
				_proportionallyResizeElements: [],
				_helper: o.helper || o.ghost || o.animate ? o.helper || "ui-resizable-helper" : null
			});
	
			// Wrap the element if it cannot hold child nodes
			if (this.element[0].nodeName.match(/^(canvas|textarea|input|select|button|img)$/i)) {
	
				this.element.wrap(
					$("<div class='ui-wrapper' style='overflow: hidden;'></div>").css({
						position: this.element.css("position"),
						width: this.element.outerWidth(),
						height: this.element.outerHeight(),
						top: this.element.css("top"),
						left: this.element.css("left")
					})
				);
	
				this.element = this.element.parent().data(
					"ui-resizable", this.element.resizable( "instance" )
				);
	
				this.elementIsWrapper = true;
	
				this.element.css({
					marginLeft: this.originalElement.css("marginLeft"),
					marginTop: this.originalElement.css("marginTop"),
					marginRight: this.originalElement.css("marginRight"),
					marginBottom: this.originalElement.css("marginBottom")
				});
				this.originalElement.css({
					marginLeft: 0,
					marginTop: 0,
					marginRight: 0,
					marginBottom: 0
				});
				// support: Safari
				// Prevent Safari textarea resize
				this.originalResizeStyle = this.originalElement.css("resize");
				this.originalElement.css("resize", "none");
	
				this._proportionallyResizeElements.push( this.originalElement.css({
					position: "static",
					zoom: 1,
					display: "block"
				}) );
	
				// support: IE9
				// avoid IE jump (hard set the margin)
				this.originalElement.css({ margin: this.originalElement.css("margin") });
	
				this._proportionallyResize();
			}
	
			this.handles = o.handles ||
				( !$(".ui-resizable-handle", this.element).length ?
					"e,s,se" : {
						n: ".ui-resizable-n",
						e: ".ui-resizable-e",
						s: ".ui-resizable-s",
						w: ".ui-resizable-w",
						se: ".ui-resizable-se",
						sw: ".ui-resizable-sw",
						ne: ".ui-resizable-ne",
						nw: ".ui-resizable-nw"
					} );
	
			this._handles = $();
			if ( this.handles.constructor === String ) {
	
				if ( this.handles === "all") {
					this.handles = "n,e,s,w,se,sw,ne,nw";
				}
	
				n = this.handles.split(",");
				this.handles = {};
	
				for (i = 0; i < n.length; i++) {
	
					handle = $.trim(n[i]);
					hname = "ui-resizable-" + handle;
					axis = $("<div class='ui-resizable-handle " + hname + "'></div>");
	
					axis.css({ zIndex: o.zIndex });
	
					// TODO : What's going on here?
					if ("se" === handle) {
						axis.addClass("ui-icon ui-icon-gripsmall-diagonal-se");
					}
	
					this.handles[handle] = ".ui-resizable-" + handle;
					this.element.append(axis);
				}
	
			}
	
			this._renderAxis = function(target) {
	
				var i, axis, padPos, padWrapper;
	
				target = target || this.element;
	
				for (i in this.handles) {
	
					if (this.handles[i].constructor === String) {
						this.handles[i] = this.element.children( this.handles[ i ] ).first().show();
					} else if ( this.handles[ i ].jquery || this.handles[ i ].nodeType ) {
						this.handles[ i ] = $( this.handles[ i ] );
						this._on( this.handles[ i ], { "mousedown": that._mouseDown });
					}
	
					if (this.elementIsWrapper && this.originalElement[0].nodeName.match(/^(textarea|input|select|button)$/i)) {
	
						axis = $(this.handles[i], this.element);
	
						padWrapper = /sw|ne|nw|se|n|s/.test(i) ? axis.outerHeight() : axis.outerWidth();
	
						padPos = [ "padding",
							/ne|nw|n/.test(i) ? "Top" :
							/se|sw|s/.test(i) ? "Bottom" :
							/^e$/.test(i) ? "Right" : "Left" ].join("");
	
						target.css(padPos, padWrapper);
	
						this._proportionallyResize();
					}
	
					this._handles = this._handles.add( this.handles[ i ] );
				}
			};
	
			// TODO: make renderAxis a prototype function
			this._renderAxis(this.element);
	
			this._handles = this._handles.add( this.element.find( ".ui-resizable-handle" ) );
			this._handles.disableSelection();
	
			this._handles.mouseover(function() {
				if (!that.resizing) {
					if (this.className) {
						axis = this.className.match(/ui-resizable-(se|sw|ne|nw|n|e|s|w)/i);
					}
					that.axis = axis && axis[1] ? axis[1] : "se";
				}
			});
	
			if (o.autoHide) {
				this._handles.hide();
				$(this.element)
					.addClass("ui-resizable-autohide")
					.mouseenter(function() {
						if (o.disabled) {
							return;
						}
						$(this).removeClass("ui-resizable-autohide");
						that._handles.show();
					})
					.mouseleave(function() {
						if (o.disabled) {
							return;
						}
						if (!that.resizing) {
							$(this).addClass("ui-resizable-autohide");
							that._handles.hide();
						}
					});
			}
	
			this._mouseInit();
		},
	
		_destroy: function() {
	
			this._mouseDestroy();
	
			var wrapper,
				_destroy = function(exp) {
					$(exp)
						.removeClass("ui-resizable ui-resizable-disabled ui-resizable-resizing")
						.removeData("resizable")
						.removeData("ui-resizable")
						.unbind(".resizable")
						.find(".ui-resizable-handle")
							.remove();
				};
	
			// TODO: Unwrap at same DOM position
			if (this.elementIsWrapper) {
				_destroy(this.element);
				wrapper = this.element;
				this.originalElement.css({
					position: wrapper.css("position"),
					width: wrapper.outerWidth(),
					height: wrapper.outerHeight(),
					top: wrapper.css("top"),
					left: wrapper.css("left")
				}).insertAfter( wrapper );
				wrapper.remove();
			}
	
			this.originalElement.css("resize", this.originalResizeStyle);
			_destroy(this.originalElement);
	
			return this;
		},
	
		_mouseCapture: function(event) {
			var i, handle,
				capture = false;
	
			for (i in this.handles) {
				handle = $(this.handles[i])[0];
				if (handle === event.target || $.contains(handle, event.target)) {
					capture = true;
				}
			}
	
			return !this.options.disabled && capture;
		},
	
		_mouseStart: function(event) {
	
			var curleft, curtop, cursor,
				o = this.options,
				el = this.element;
	
			this.resizing = true;
	
			this._renderProxy();
	
			curleft = this._num(this.helper.css("left"));
			curtop = this._num(this.helper.css("top"));
	
			if (o.containment) {
				curleft += $(o.containment).scrollLeft() || 0;
				curtop += $(o.containment).scrollTop() || 0;
			}
	
			this.offset = this.helper.offset();
			this.position = { left: curleft, top: curtop };
	
			this.size = this._helper ? {
					width: this.helper.width(),
					height: this.helper.height()
				} : {
					width: el.width(),
					height: el.height()
				};
	
			this.originalSize = this._helper ? {
					width: el.outerWidth(),
					height: el.outerHeight()
				} : {
					width: el.width(),
					height: el.height()
				};
	
			this.sizeDiff = {
				width: el.outerWidth() - el.width(),
				height: el.outerHeight() - el.height()
			};
	
			this.originalPosition = { left: curleft, top: curtop };
			this.originalMousePosition = { left: event.pageX, top: event.pageY };
	
			this.aspectRatio = (typeof o.aspectRatio === "number") ?
				o.aspectRatio :
				((this.originalSize.width / this.originalSize.height) || 1);
	
			cursor = $(".ui-resizable-" + this.axis).css("cursor");
			$("body").css("cursor", cursor === "auto" ? this.axis + "-resize" : cursor);
	
			el.addClass("ui-resizable-resizing");
			this._propagate("start", event);
			return true;
		},
	
		_mouseDrag: function(event) {
	
			var data, props,
				smp = this.originalMousePosition,
				a = this.axis,
				dx = (event.pageX - smp.left) || 0,
				dy = (event.pageY - smp.top) || 0,
				trigger = this._change[a];
	
			this._updatePrevProperties();
	
			if (!trigger) {
				return false;
			}
	
			data = trigger.apply(this, [ event, dx, dy ]);
	
			this._updateVirtualBoundaries(event.shiftKey);
			if (this._aspectRatio || event.shiftKey) {
				data = this._updateRatio(data, event);
			}
	
			data = this._respectSize(data, event);
	
			this._updateCache(data);
	
			this._propagate("resize", event);
	
			props = this._applyChanges();
	
			if ( !this._helper && this._proportionallyResizeElements.length ) {
				this._proportionallyResize();
			}
	
			if ( !$.isEmptyObject( props ) ) {
				this._updatePrevProperties();
				this._trigger( "resize", event, this.ui() );
				this._applyChanges();
			}
	
			return false;
		},
	
		_mouseStop: function(event) {
	
			this.resizing = false;
			var pr, ista, soffseth, soffsetw, s, left, top,
				o = this.options, that = this;
	
			if (this._helper) {
	
				pr = this._proportionallyResizeElements;
				ista = pr.length && (/textarea/i).test(pr[0].nodeName);
				soffseth = ista && this._hasScroll(pr[0], "left") ? 0 : that.sizeDiff.height;
				soffsetw = ista ? 0 : that.sizeDiff.width;
	
				s = {
					width: (that.helper.width()  - soffsetw),
					height: (that.helper.height() - soffseth)
				};
				left = (parseInt(that.element.css("left"), 10) +
					(that.position.left - that.originalPosition.left)) || null;
				top = (parseInt(that.element.css("top"), 10) +
					(that.position.top - that.originalPosition.top)) || null;
	
				if (!o.animate) {
					this.element.css($.extend(s, { top: top, left: left }));
				}
	
				that.helper.height(that.size.height);
				that.helper.width(that.size.width);
	
				if (this._helper && !o.animate) {
					this._proportionallyResize();
				}
			}
	
			$("body").css("cursor", "auto");
	
			this.element.removeClass("ui-resizable-resizing");
	
			this._propagate("stop", event);
	
			if (this._helper) {
				this.helper.remove();
			}
	
			return false;
	
		},
	
		_updatePrevProperties: function() {
			this.prevPosition = {
				top: this.position.top,
				left: this.position.left
			};
			this.prevSize = {
				width: this.size.width,
				height: this.size.height
			};
		},
	
		_applyChanges: function() {
			var props = {};
	
			if ( this.position.top !== this.prevPosition.top ) {
				props.top = this.position.top + "px";
			}
			if ( this.position.left !== this.prevPosition.left ) {
				props.left = this.position.left + "px";
			}
			if ( this.size.width !== this.prevSize.width ) {
				props.width = this.size.width + "px";
			}
			if ( this.size.height !== this.prevSize.height ) {
				props.height = this.size.height + "px";
			}
	
			this.helper.css( props );
	
			return props;
		},
	
		_updateVirtualBoundaries: function(forceAspectRatio) {
			var pMinWidth, pMaxWidth, pMinHeight, pMaxHeight, b,
				o = this.options;
	
			b = {
				minWidth: this._isNumber(o.minWidth) ? o.minWidth : 0,
				maxWidth: this._isNumber(o.maxWidth) ? o.maxWidth : Infinity,
				minHeight: this._isNumber(o.minHeight) ? o.minHeight : 0,
				maxHeight: this._isNumber(o.maxHeight) ? o.maxHeight : Infinity
			};
	
			if (this._aspectRatio || forceAspectRatio) {
				pMinWidth = b.minHeight * this.aspectRatio;
				pMinHeight = b.minWidth / this.aspectRatio;
				pMaxWidth = b.maxHeight * this.aspectRatio;
				pMaxHeight = b.maxWidth / this.aspectRatio;
	
				if (pMinWidth > b.minWidth) {
					b.minWidth = pMinWidth;
				}
				if (pMinHeight > b.minHeight) {
					b.minHeight = pMinHeight;
				}
				if (pMaxWidth < b.maxWidth) {
					b.maxWidth = pMaxWidth;
				}
				if (pMaxHeight < b.maxHeight) {
					b.maxHeight = pMaxHeight;
				}
			}
			this._vBoundaries = b;
		},
	
		_updateCache: function(data) {
			this.offset = this.helper.offset();
			if (this._isNumber(data.left)) {
				this.position.left = data.left;
			}
			if (this._isNumber(data.top)) {
				this.position.top = data.top;
			}
			if (this._isNumber(data.height)) {
				this.size.height = data.height;
			}
			if (this._isNumber(data.width)) {
				this.size.width = data.width;
			}
		},
	
		_updateRatio: function( data ) {
	
			var cpos = this.position,
				csize = this.size,
				a = this.axis;
	
			if (this._isNumber(data.height)) {
				data.width = (data.height * this.aspectRatio);
			} else if (this._isNumber(data.width)) {
				data.height = (data.width / this.aspectRatio);
			}
	
			if (a === "sw") {
				data.left = cpos.left + (csize.width - data.width);
				data.top = null;
			}
			if (a === "nw") {
				data.top = cpos.top + (csize.height - data.height);
				data.left = cpos.left + (csize.width - data.width);
			}
	
			return data;
		},
	
		_respectSize: function( data ) {
	
			var o = this._vBoundaries,
				a = this.axis,
				ismaxw = this._isNumber(data.width) && o.maxWidth && (o.maxWidth < data.width),
				ismaxh = this._isNumber(data.height) && o.maxHeight && (o.maxHeight < data.height),
				isminw = this._isNumber(data.width) && o.minWidth && (o.minWidth > data.width),
				isminh = this._isNumber(data.height) && o.minHeight && (o.minHeight > data.height),
				dw = this.originalPosition.left + this.originalSize.width,
				dh = this.position.top + this.size.height,
				cw = /sw|nw|w/.test(a), ch = /nw|ne|n/.test(a);
			if (isminw) {
				data.width = o.minWidth;
			}
			if (isminh) {
				data.height = o.minHeight;
			}
			if (ismaxw) {
				data.width = o.maxWidth;
			}
			if (ismaxh) {
				data.height = o.maxHeight;
			}
	
			if (isminw && cw) {
				data.left = dw - o.minWidth;
			}
			if (ismaxw && cw) {
				data.left = dw - o.maxWidth;
			}
			if (isminh && ch) {
				data.top = dh - o.minHeight;
			}
			if (ismaxh && ch) {
				data.top = dh - o.maxHeight;
			}
	
			// Fixing jump error on top/left - bug #2330
			if (!data.width && !data.height && !data.left && data.top) {
				data.top = null;
			} else if (!data.width && !data.height && !data.top && data.left) {
				data.left = null;
			}
	
			return data;
		},
	
		_getPaddingPlusBorderDimensions: function( element ) {
			var i = 0,
				widths = [],
				borders = [
					element.css( "borderTopWidth" ),
					element.css( "borderRightWidth" ),
					element.css( "borderBottomWidth" ),
					element.css( "borderLeftWidth" )
				],
				paddings = [
					element.css( "paddingTop" ),
					element.css( "paddingRight" ),
					element.css( "paddingBottom" ),
					element.css( "paddingLeft" )
				];
	
			for ( ; i < 4; i++ ) {
				widths[ i ] = ( parseInt( borders[ i ], 10 ) || 0 );
				widths[ i ] += ( parseInt( paddings[ i ], 10 ) || 0 );
			}
	
			return {
				height: widths[ 0 ] + widths[ 2 ],
				width: widths[ 1 ] + widths[ 3 ]
			};
		},
	
		_proportionallyResize: function() {
	
			if (!this._proportionallyResizeElements.length) {
				return;
			}
	
			var prel,
				i = 0,
				element = this.helper || this.element;
	
			for ( ; i < this._proportionallyResizeElements.length; i++) {
	
				prel = this._proportionallyResizeElements[i];
	
				// TODO: Seems like a bug to cache this.outerDimensions
				// considering that we are in a loop.
				if (!this.outerDimensions) {
					this.outerDimensions = this._getPaddingPlusBorderDimensions( prel );
				}
	
				prel.css({
					height: (element.height() - this.outerDimensions.height) || 0,
					width: (element.width() - this.outerDimensions.width) || 0
				});
	
			}
	
		},
	
		_renderProxy: function() {
	
			var el = this.element, o = this.options;
			this.elementOffset = el.offset();
	
			if (this._helper) {
	
				this.helper = this.helper || $("<div style='overflow:hidden;'></div>");
	
				this.helper.addClass(this._helper).css({
					width: this.element.outerWidth() - 1,
					height: this.element.outerHeight() - 1,
					position: "absolute",
					left: this.elementOffset.left + "px",
					top: this.elementOffset.top + "px",
					zIndex: ++o.zIndex //TODO: Don't modify option
				});
	
				this.helper
					.appendTo("body")
					.disableSelection();
	
			} else {
				this.helper = this.element;
			}
	
		},
	
		_change: {
			e: function(event, dx) {
				return { width: this.originalSize.width + dx };
			},
			w: function(event, dx) {
				var cs = this.originalSize, sp = this.originalPosition;
				return { left: sp.left + dx, width: cs.width - dx };
			},
			n: function(event, dx, dy) {
				var cs = this.originalSize, sp = this.originalPosition;
				return { top: sp.top + dy, height: cs.height - dy };
			},
			s: function(event, dx, dy) {
				return { height: this.originalSize.height + dy };
			},
			se: function(event, dx, dy) {
				return $.extend(this._change.s.apply(this, arguments),
					this._change.e.apply(this, [ event, dx, dy ]));
			},
			sw: function(event, dx, dy) {
				return $.extend(this._change.s.apply(this, arguments),
					this._change.w.apply(this, [ event, dx, dy ]));
			},
			ne: function(event, dx, dy) {
				return $.extend(this._change.n.apply(this, arguments),
					this._change.e.apply(this, [ event, dx, dy ]));
			},
			nw: function(event, dx, dy) {
				return $.extend(this._change.n.apply(this, arguments),
					this._change.w.apply(this, [ event, dx, dy ]));
			}
		},
	
		_propagate: function(n, event) {
			$.ui.plugin.call(this, n, [ event, this.ui() ]);
			(n !== "resize" && this._trigger(n, event, this.ui()));
		},
	
		plugins: {},
	
		ui: function() {
			return {
				originalElement: this.originalElement,
				element: this.element,
				helper: this.helper,
				position: this.position,
				size: this.size,
				originalSize: this.originalSize,
				originalPosition: this.originalPosition
			};
		}
	
	});
	
	/*
	 * Resizable Extensions
	 */
	
	$.ui.plugin.add("resizable", "animate", {
	
		stop: function( event ) {
			var that = $(this).resizable( "instance" ),
				o = that.options,
				pr = that._proportionallyResizeElements,
				ista = pr.length && (/textarea/i).test(pr[0].nodeName),
				soffseth = ista && that._hasScroll(pr[0], "left") ? 0 : that.sizeDiff.height,
				soffsetw = ista ? 0 : that.sizeDiff.width,
				style = { width: (that.size.width - soffsetw), height: (that.size.height - soffseth) },
				left = (parseInt(that.element.css("left"), 10) +
					(that.position.left - that.originalPosition.left)) || null,
				top = (parseInt(that.element.css("top"), 10) +
					(that.position.top - that.originalPosition.top)) || null;
	
			that.element.animate(
				$.extend(style, top && left ? { top: top, left: left } : {}), {
					duration: o.animateDuration,
					easing: o.animateEasing,
					step: function() {
	
						var data = {
							width: parseInt(that.element.css("width"), 10),
							height: parseInt(that.element.css("height"), 10),
							top: parseInt(that.element.css("top"), 10),
							left: parseInt(that.element.css("left"), 10)
						};
	
						if (pr && pr.length) {
							$(pr[0]).css({ width: data.width, height: data.height });
						}
	
						// propagating resize, and updating values for each animation step
						that._updateCache(data);
						that._propagate("resize", event);
	
					}
				}
			);
		}
	
	});
	
	$.ui.plugin.add( "resizable", "containment", {
	
		start: function() {
			var element, p, co, ch, cw, width, height,
				that = $( this ).resizable( "instance" ),
				o = that.options,
				el = that.element,
				oc = o.containment,
				ce = ( oc instanceof $ ) ? oc.get( 0 ) : ( /parent/.test( oc ) ) ? el.parent().get( 0 ) : oc;
	
			if ( !ce ) {
				return;
			}
	
			that.containerElement = $( ce );
	
			if ( /document/.test( oc ) || oc === document ) {
				that.containerOffset = {
					left: 0,
					top: 0
				};
				that.containerPosition = {
					left: 0,
					top: 0
				};
	
				that.parentData = {
					element: $( document ),
					left: 0,
					top: 0,
					width: $( document ).width(),
					height: $( document ).height() || document.body.parentNode.scrollHeight
				};
			} else {
				element = $( ce );
				p = [];
				$([ "Top", "Right", "Left", "Bottom" ]).each(function( i, name ) {
					p[ i ] = that._num( element.css( "padding" + name ) );
				});
	
				that.containerOffset = element.offset();
				that.containerPosition = element.position();
				that.containerSize = {
					height: ( element.innerHeight() - p[ 3 ] ),
					width: ( element.innerWidth() - p[ 1 ] )
				};
	
				co = that.containerOffset;
				ch = that.containerSize.height;
				cw = that.containerSize.width;
				width = ( that._hasScroll ( ce, "left" ) ? ce.scrollWidth : cw );
				height = ( that._hasScroll ( ce ) ? ce.scrollHeight : ch ) ;
	
				that.parentData = {
					element: ce,
					left: co.left,
					top: co.top,
					width: width,
					height: height
				};
			}
		},
	
		resize: function( event ) {
			var woset, hoset, isParent, isOffsetRelative,
				that = $( this ).resizable( "instance" ),
				o = that.options,
				co = that.containerOffset,
				cp = that.position,
				pRatio = that._aspectRatio || event.shiftKey,
				cop = {
					top: 0,
					left: 0
				},
				ce = that.containerElement,
				continueResize = true;
	
			if ( ce[ 0 ] !== document && ( /static/ ).test( ce.css( "position" ) ) ) {
				cop = co;
			}
	
			if ( cp.left < ( that._helper ? co.left : 0 ) ) {
				that.size.width = that.size.width +
					( that._helper ?
						( that.position.left - co.left ) :
						( that.position.left - cop.left ) );
	
				if ( pRatio ) {
					that.size.height = that.size.width / that.aspectRatio;
					continueResize = false;
				}
				that.position.left = o.helper ? co.left : 0;
			}
	
			if ( cp.top < ( that._helper ? co.top : 0 ) ) {
				that.size.height = that.size.height +
					( that._helper ?
						( that.position.top - co.top ) :
						that.position.top );
	
				if ( pRatio ) {
					that.size.width = that.size.height * that.aspectRatio;
					continueResize = false;
				}
				that.position.top = that._helper ? co.top : 0;
			}
	
			isParent = that.containerElement.get( 0 ) === that.element.parent().get( 0 );
			isOffsetRelative = /relative|absolute/.test( that.containerElement.css( "position" ) );
	
			if ( isParent && isOffsetRelative ) {
				that.offset.left = that.parentData.left + that.position.left;
				that.offset.top = that.parentData.top + that.position.top;
			} else {
				that.offset.left = that.element.offset().left;
				that.offset.top = that.element.offset().top;
			}
	
			woset = Math.abs( that.sizeDiff.width +
				(that._helper ?
					that.offset.left - cop.left :
					(that.offset.left - co.left)) );
	
			hoset = Math.abs( that.sizeDiff.height +
				(that._helper ?
					that.offset.top - cop.top :
					(that.offset.top - co.top)) );
	
			if ( woset + that.size.width >= that.parentData.width ) {
				that.size.width = that.parentData.width - woset;
				if ( pRatio ) {
					that.size.height = that.size.width / that.aspectRatio;
					continueResize = false;
				}
			}
	
			if ( hoset + that.size.height >= that.parentData.height ) {
				that.size.height = that.parentData.height - hoset;
				if ( pRatio ) {
					that.size.width = that.size.height * that.aspectRatio;
					continueResize = false;
				}
			}
	
			if ( !continueResize ) {
				that.position.left = that.prevPosition.left;
				that.position.top = that.prevPosition.top;
				that.size.width = that.prevSize.width;
				that.size.height = that.prevSize.height;
			}
		},
	
		stop: function() {
			var that = $( this ).resizable( "instance" ),
				o = that.options,
				co = that.containerOffset,
				cop = that.containerPosition,
				ce = that.containerElement,
				helper = $( that.helper ),
				ho = helper.offset(),
				w = helper.outerWidth() - that.sizeDiff.width,
				h = helper.outerHeight() - that.sizeDiff.height;
	
			if ( that._helper && !o.animate && ( /relative/ ).test( ce.css( "position" ) ) ) {
				$( this ).css({
					left: ho.left - cop.left - co.left,
					width: w,
					height: h
				});
			}
	
			if ( that._helper && !o.animate && ( /static/ ).test( ce.css( "position" ) ) ) {
				$( this ).css({
					left: ho.left - cop.left - co.left,
					width: w,
					height: h
				});
			}
		}
	});
	
	$.ui.plugin.add("resizable", "alsoResize", {
	
		start: function() {
			var that = $(this).resizable( "instance" ),
				o = that.options;
	
			$(o.alsoResize).each(function() {
				var el = $(this);
				el.data("ui-resizable-alsoresize", {
					width: parseInt(el.width(), 10), height: parseInt(el.height(), 10),
					left: parseInt(el.css("left"), 10), top: parseInt(el.css("top"), 10)
				});
			});
		},
	
		resize: function(event, ui) {
			var that = $(this).resizable( "instance" ),
				o = that.options,
				os = that.originalSize,
				op = that.originalPosition,
				delta = {
					height: (that.size.height - os.height) || 0,
					width: (that.size.width - os.width) || 0,
					top: (that.position.top - op.top) || 0,
					left: (that.position.left - op.left) || 0
				};
	
				$(o.alsoResize).each(function() {
					var el = $(this), start = $(this).data("ui-resizable-alsoresize"), style = {},
						css = el.parents(ui.originalElement[0]).length ?
								[ "width", "height" ] :
								[ "width", "height", "top", "left" ];
	
					$.each(css, function(i, prop) {
						var sum = (start[prop] || 0) + (delta[prop] || 0);
						if (sum && sum >= 0) {
							style[prop] = sum || null;
						}
					});
	
					el.css(style);
				});
		},
	
		stop: function() {
			$(this).removeData("resizable-alsoresize");
		}
	});
	
	$.ui.plugin.add("resizable", "ghost", {
	
		start: function() {
	
			var that = $(this).resizable( "instance" ), o = that.options, cs = that.size;
	
			that.ghost = that.originalElement.clone();
			that.ghost
				.css({
					opacity: 0.25,
					display: "block",
					position: "relative",
					height: cs.height,
					width: cs.width,
					margin: 0,
					left: 0,
					top: 0
				})
				.addClass("ui-resizable-ghost")
				.addClass(typeof o.ghost === "string" ? o.ghost : "");
	
			that.ghost.appendTo(that.helper);
	
		},
	
		resize: function() {
			var that = $(this).resizable( "instance" );
			if (that.ghost) {
				that.ghost.css({
					position: "relative",
					height: that.size.height,
					width: that.size.width
				});
			}
		},
	
		stop: function() {
			var that = $(this).resizable( "instance" );
			if (that.ghost && that.helper) {
				that.helper.get(0).removeChild(that.ghost.get(0));
			}
		}
	
	});
	
	$.ui.plugin.add("resizable", "grid", {
	
		resize: function() {
			var outerDimensions,
				that = $(this).resizable( "instance" ),
				o = that.options,
				cs = that.size,
				os = that.originalSize,
				op = that.originalPosition,
				a = that.axis,
				grid = typeof o.grid === "number" ? [ o.grid, o.grid ] : o.grid,
				gridX = (grid[0] || 1),
				gridY = (grid[1] || 1),
				ox = Math.round((cs.width - os.width) / gridX) * gridX,
				oy = Math.round((cs.height - os.height) / gridY) * gridY,
				newWidth = os.width + ox,
				newHeight = os.height + oy,
				isMaxWidth = o.maxWidth && (o.maxWidth < newWidth),
				isMaxHeight = o.maxHeight && (o.maxHeight < newHeight),
				isMinWidth = o.minWidth && (o.minWidth > newWidth),
				isMinHeight = o.minHeight && (o.minHeight > newHeight);
	
			o.grid = grid;
	
			if (isMinWidth) {
				newWidth += gridX;
			}
			if (isMinHeight) {
				newHeight += gridY;
			}
			if (isMaxWidth) {
				newWidth -= gridX;
			}
			if (isMaxHeight) {
				newHeight -= gridY;
			}
	
			if (/^(se|s|e)$/.test(a)) {
				that.size.width = newWidth;
				that.size.height = newHeight;
			} else if (/^(ne)$/.test(a)) {
				that.size.width = newWidth;
				that.size.height = newHeight;
				that.position.top = op.top - oy;
			} else if (/^(sw)$/.test(a)) {
				that.size.width = newWidth;
				that.size.height = newHeight;
				that.position.left = op.left - ox;
			} else {
				if ( newHeight - gridY <= 0 || newWidth - gridX <= 0) {
					outerDimensions = that._getPaddingPlusBorderDimensions( this );
				}
	
				if ( newHeight - gridY > 0 ) {
					that.size.height = newHeight;
					that.position.top = op.top - oy;
				} else {
					newHeight = gridY - outerDimensions.height;
					that.size.height = newHeight;
					that.position.top = op.top + os.height - newHeight;
				}
				if ( newWidth - gridX > 0 ) {
					that.size.width = newWidth;
					that.position.left = op.left - ox;
				} else {
					newWidth = gridX - outerDimensions.width;
					that.size.width = newWidth;
					that.position.left = op.left + os.width - newWidth;
				}
			}
		}
	
	});
	
	var resizable = $.ui.resizable;
	
	
	/*!
	 * jQuery UI Dialog 1.11.4
	 * http://jqueryui.com
	 *
	 * Copyright jQuery Foundation and other contributors
	 * Released under the MIT license.
	 * http://jquery.org/license
	 *
	 * http://api.jqueryui.com/dialog/
	 */
	
	
	var dialog = $.widget( "ui.dialog", {
		version: "1.11.4",
		options: {
			appendTo: "body",
			autoOpen: true,
			buttons: [],
			closeOnEscape: true,
			closeText: "Close",
			dialogClass: "",
			draggable: true,
			hide: null,
			height: "auto",
			maxHeight: null,
			maxWidth: null,
			minHeight: 150,
			minWidth: 150,
			modal: false,
			position: {
				my: "center",
				at: "center",
				of: window,
				collision: "fit",
				// Ensure the titlebar is always visible
				using: function( pos ) {
					var topOffset = $( this ).css( pos ).offset().top;
					if ( topOffset < 0 ) {
						$( this ).css( "top", pos.top - topOffset );
					}
				}
			},
			resizable: true,
			show: null,
			title: null,
			width: 300,
	
			// callbacks
			beforeClose: null,
			close: null,
			drag: null,
			dragStart: null,
			dragStop: null,
			focus: null,
			open: null,
			resize: null,
			resizeStart: null,
			resizeStop: null
		},
	
		sizeRelatedOptions: {
			buttons: true,
			height: true,
			maxHeight: true,
			maxWidth: true,
			minHeight: true,
			minWidth: true,
			width: true
		},
	
		resizableRelatedOptions: {
			maxHeight: true,
			maxWidth: true,
			minHeight: true,
			minWidth: true
		},
	
		_create: function() {
			this.originalCss = {
				display: this.element[ 0 ].style.display,
				width: this.element[ 0 ].style.width,
				minHeight: this.element[ 0 ].style.minHeight,
				maxHeight: this.element[ 0 ].style.maxHeight,
				height: this.element[ 0 ].style.height
			};
			this.originalPosition = {
				parent: this.element.parent(),
				index: this.element.parent().children().index( this.element )
			};
			this.originalTitle = this.element.attr( "title" );
			this.options.title = this.options.title || this.originalTitle;
	
			this._createWrapper();
	
			this.element
				.show()
				.removeAttr( "title" )
				.addClass( "ui-dialog-content ui-widget-content" )
				.appendTo( this.uiDialog );
	
			this._createTitlebar();
			this._createButtonPane();
	
			if ( this.options.draggable && $.fn.draggable ) {
				this._makeDraggable();
			}
			if ( this.options.resizable && $.fn.resizable ) {
				this._makeResizable();
			}
	
			this._isOpen = false;
	
			this._trackFocus();
		},
	
		_init: function() {
			if ( this.options.autoOpen ) {
				this.open();
			}
		},
	
		_appendTo: function() {
			var element = this.options.appendTo;
			if ( element && (element.jquery || element.nodeType) ) {
				return $( element );
			}
			return this.document.find( element || "body" ).eq( 0 );
		},
	
		_destroy: function() {
			var next,
				originalPosition = this.originalPosition;
	
			this._untrackInstance();
			this._destroyOverlay();
	
			this.element
				.removeUniqueId()
				.removeClass( "ui-dialog-content ui-widget-content" )
				.css( this.originalCss )
				// Without detaching first, the following becomes really slow
				.detach();
	
			this.uiDialog.stop( true, true ).remove();
	
			if ( this.originalTitle ) {
				this.element.attr( "title", this.originalTitle );
			}
	
			next = originalPosition.parent.children().eq( originalPosition.index );
			// Don't try to place the dialog next to itself (#8613)
			if ( next.length && next[ 0 ] !== this.element[ 0 ] ) {
				next.before( this.element );
			} else {
				originalPosition.parent.append( this.element );
			}
		},
	
		widget: function() {
			return this.uiDialog;
		},
	
		disable: $.noop,
		enable: $.noop,
	
		close: function( event ) {
			var activeElement,
				that = this;
	
			if ( !this._isOpen || this._trigger( "beforeClose", event ) === false ) {
				return;
			}
	
			this._isOpen = false;
			this._focusedElement = null;
			this._destroyOverlay();
			this._untrackInstance();
	
			if ( !this.opener.filter( ":focusable" ).focus().length ) {
	
				// support: IE9
				// IE9 throws an "Unspecified error" accessing document.activeElement from an <iframe>
				try {
					activeElement = this.document[ 0 ].activeElement;
	
					// Support: IE9, IE10
					// If the <body> is blurred, IE will switch windows, see #4520
					if ( activeElement && activeElement.nodeName.toLowerCase() !== "body" ) {
	
						// Hiding a focused element doesn't trigger blur in WebKit
						// so in case we have nothing to focus on, explicitly blur the active element
						// https://bugs.webkit.org/show_bug.cgi?id=47182
						$( activeElement ).blur();
					}
				} catch ( error ) {}
			}
	
			this._hide( this.uiDialog, this.options.hide, function() {
				that._trigger( "close", event );
			});
		},
	
		isOpen: function() {
			return this._isOpen;
		},
	
		moveToTop: function() {
			this._moveToTop();
		},
	
		_moveToTop: function( event, silent ) {
			var moved = false,
				zIndices = this.uiDialog.siblings( ".ui-front:visible" ).map(function() {
					return +$( this ).css( "z-index" );
				}).get(),
				zIndexMax = Math.max.apply( null, zIndices );
	
			if ( zIndexMax >= +this.uiDialog.css( "z-index" ) ) {
				this.uiDialog.css( "z-index", zIndexMax + 1 );
				moved = true;
			}
	
			if ( moved && !silent ) {
				this._trigger( "focus", event );
			}
			return moved;
		},
	
		open: function() {
			var that = this;
			if ( this._isOpen ) {
				if ( this._moveToTop() ) {
					this._focusTabbable();
				}
				return;
			}
	
			this._isOpen = true;
			this.opener = $( this.document[ 0 ].activeElement );
	
			this._size();
			this._position();
			this._createOverlay();
			this._moveToTop( null, true );
	
			// Ensure the overlay is moved to the top with the dialog, but only when
			// opening. The overlay shouldn't move after the dialog is open so that
			// modeless dialogs opened after the modal dialog stack properly.
			if ( this.overlay ) {
				this.overlay.css( "z-index", this.uiDialog.css( "z-index" ) - 1 );
			}
	
			this._show( this.uiDialog, this.options.show, function() {
				that._focusTabbable();
				that._trigger( "focus" );
			});
	
			// Track the dialog immediately upon openening in case a focus event
			// somehow occurs outside of the dialog before an element inside the
			// dialog is focused (#10152)
			this._makeFocusTarget();
	
			this._trigger( "open" );
		},
	
		_focusTabbable: function() {
			// Set focus to the first match:
			// 1. An element that was focused previously
			// 2. First element inside the dialog matching [autofocus]
			// 3. Tabbable element inside the content element
			// 4. Tabbable element inside the buttonpane
			// 5. The close button
			// 6. The dialog itself
			var hasFocus = this._focusedElement;
			if ( !hasFocus ) {
				hasFocus = this.element.find( "[autofocus]" );
			}
			if ( !hasFocus.length ) {
				hasFocus = this.element.find( ":tabbable" );
			}
			if ( !hasFocus.length ) {
				hasFocus = this.uiDialogButtonPane.find( ":tabbable" );
			}
			if ( !hasFocus.length ) {
				hasFocus = this.uiDialogTitlebarClose.filter( ":tabbable" );
			}
			if ( !hasFocus.length ) {
				hasFocus = this.uiDialog;
			}
			hasFocus.eq( 0 ).focus();
		},
	
		_keepFocus: function( event ) {
			function checkFocus() {
				var activeElement = this.document[0].activeElement,
					isActive = this.uiDialog[0] === activeElement ||
						$.contains( this.uiDialog[0], activeElement );
				if ( !isActive ) {
					this._focusTabbable();
				}
			}
			event.preventDefault();
			checkFocus.call( this );
			// support: IE
			// IE <= 8 doesn't prevent moving focus even with event.preventDefault()
			// so we check again later
			this._delay( checkFocus );
		},
	
		_createWrapper: function() {
			this.uiDialog = $("<div>")
				.addClass( "ui-dialog ui-widget ui-widget-content ui-corner-all ui-front " +
					this.options.dialogClass )
				.hide()
				.attr({
					// Setting tabIndex makes the div focusable
					tabIndex: -1,
					role: "dialog"
				})
				.appendTo( this._appendTo() );
	
			this._on( this.uiDialog, {
				keydown: function( event ) {
					if ( this.options.closeOnEscape && !event.isDefaultPrevented() && event.keyCode &&
							event.keyCode === $.ui.keyCode.ESCAPE ) {
						event.preventDefault();
						this.close( event );
						return;
					}
	
					// prevent tabbing out of dialogs
					if ( event.keyCode !== $.ui.keyCode.TAB || event.isDefaultPrevented() ) {
						return;
					}
					var tabbables = this.uiDialog.find( ":tabbable" ),
						first = tabbables.filter( ":first" ),
						last = tabbables.filter( ":last" );
	
					if ( ( event.target === last[0] || event.target === this.uiDialog[0] ) && !event.shiftKey ) {
						this._delay(function() {
							first.focus();
						});
						event.preventDefault();
					} else if ( ( event.target === first[0] || event.target === this.uiDialog[0] ) && event.shiftKey ) {
						this._delay(function() {
							last.focus();
						});
						event.preventDefault();
					}
				},
				mousedown: function( event ) {
					if ( this._moveToTop( event ) ) {
						this._focusTabbable();
					}
				}
			});
	
			// We assume that any existing aria-describedby attribute means
			// that the dialog content is marked up properly
			// otherwise we brute force the content as the description
			if ( !this.element.find( "[aria-describedby]" ).length ) {
				this.uiDialog.attr({
					"aria-describedby": this.element.uniqueId().attr( "id" )
				});
			}
		},
	
		_createTitlebar: function() {
			var uiDialogTitle;
	
			this.uiDialogTitlebar = $( "<div>" )
				.addClass( "ui-dialog-titlebar ui-widget-header ui-corner-all ui-helper-clearfix" )
				.prependTo( this.uiDialog );
			this._on( this.uiDialogTitlebar, {
				mousedown: function( event ) {
					// Don't prevent click on close button (#8838)
					// Focusing a dialog that is partially scrolled out of view
					// causes the browser to scroll it into view, preventing the click event
					if ( !$( event.target ).closest( ".ui-dialog-titlebar-close" ) ) {
						// Dialog isn't getting focus when dragging (#8063)
						this.uiDialog.focus();
					}
				}
			});
	
			// support: IE
			// Use type="button" to prevent enter keypresses in textboxes from closing the
			// dialog in IE (#9312)
			this.uiDialogTitlebarClose = $( "<button type='button'></button>" )
				.button({
					label: this.options.closeText,
					icons: {
						primary: "ui-icon-closethick"
					},
					text: false
				})
				.addClass( "ui-dialog-titlebar-close" )
				.appendTo( this.uiDialogTitlebar );
			this._on( this.uiDialogTitlebarClose, {
				click: function( event ) {
					event.preventDefault();
					this.close( event );
				}
			});
	
			uiDialogTitle = $( "<span>" )
				.uniqueId()
				.addClass( "ui-dialog-title" )
				.prependTo( this.uiDialogTitlebar );
			this._title( uiDialogTitle );
	
			this.uiDialog.attr({
				"aria-labelledby": uiDialogTitle.attr( "id" )
			});
		},
	
		_title: function( title ) {
			if ( !this.options.title ) {
				title.html( "&#160;" );
			}
			title.text( this.options.title );
		},
	
		_createButtonPane: function() {
			this.uiDialogButtonPane = $( "<div>" )
				.addClass( "ui-dialog-buttonpane ui-widget-content ui-helper-clearfix" );
	
			this.uiButtonSet = $( "<div>" )
				.addClass( "ui-dialog-buttonset" )
				.appendTo( this.uiDialogButtonPane );
	
			this._createButtons();
		},
	
		_createButtons: function() {
			var that = this,
				buttons = this.options.buttons;
	
			// if we already have a button pane, remove it
			this.uiDialogButtonPane.remove();
			this.uiButtonSet.empty();
	
			if ( $.isEmptyObject( buttons ) || ($.isArray( buttons ) && !buttons.length) ) {
				this.uiDialog.removeClass( "ui-dialog-buttons" );
				return;
			}
	
			$.each( buttons, function( name, props ) {
				var click, buttonOptions;
				props = $.isFunction( props ) ?
					{ click: props, text: name } :
					props;
				// Default to a non-submitting button
				props = $.extend( { type: "button" }, props );
				// Change the context for the click callback to be the main element
				click = props.click;
				props.click = function() {
					click.apply( that.element[ 0 ], arguments );
				};
				buttonOptions = {
					icons: props.icons,
					text: props.showText
				};
				delete props.icons;
				delete props.showText;
				$( "<button></button>", props )
					.button( buttonOptions )
					.appendTo( that.uiButtonSet );
			});
			this.uiDialog.addClass( "ui-dialog-buttons" );
			this.uiDialogButtonPane.appendTo( this.uiDialog );
		},
	
		_makeDraggable: function() {
			var that = this,
				options = this.options;
	
			function filteredUi( ui ) {
				return {
					position: ui.position,
					offset: ui.offset
				};
			}
	
			this.uiDialog.draggable({
				cancel: ".ui-dialog-content, .ui-dialog-titlebar-close",
				handle: ".ui-dialog-titlebar",
				containment: "document",
				start: function( event, ui ) {
					$( this ).addClass( "ui-dialog-dragging" );
					that._blockFrames();
					that._trigger( "dragStart", event, filteredUi( ui ) );
				},
				drag: function( event, ui ) {
					that._trigger( "drag", event, filteredUi( ui ) );
				},
				stop: function( event, ui ) {
					var left = ui.offset.left - that.document.scrollLeft(),
						top = ui.offset.top - that.document.scrollTop();
	
					options.position = {
						my: "left top",
						at: "left" + (left >= 0 ? "+" : "") + left + " " +
							"top" + (top >= 0 ? "+" : "") + top,
						of: that.window
					};
					$( this ).removeClass( "ui-dialog-dragging" );
					that._unblockFrames();
					that._trigger( "dragStop", event, filteredUi( ui ) );
				}
			});
		},
	
		_makeResizable: function() {
			var that = this,
				options = this.options,
				handles = options.resizable,
				// .ui-resizable has position: relative defined in the stylesheet
				// but dialogs have to use absolute or fixed positioning
				position = this.uiDialog.css("position"),
				resizeHandles = typeof handles === "string" ?
					handles	:
					"n,e,s,w,se,sw,ne,nw";
	
			function filteredUi( ui ) {
				return {
					originalPosition: ui.originalPosition,
					originalSize: ui.originalSize,
					position: ui.position,
					size: ui.size
				};
			}
	
			this.uiDialog.resizable({
				cancel: ".ui-dialog-content",
				containment: "document",
				alsoResize: this.element,
				maxWidth: options.maxWidth,
				maxHeight: options.maxHeight,
				minWidth: options.minWidth,
				minHeight: this._minHeight(),
				handles: resizeHandles,
				start: function( event, ui ) {
					$( this ).addClass( "ui-dialog-resizing" );
					that._blockFrames();
					that._trigger( "resizeStart", event, filteredUi( ui ) );
				},
				resize: function( event, ui ) {
					that._trigger( "resize", event, filteredUi( ui ) );
				},
				stop: function( event, ui ) {
					var offset = that.uiDialog.offset(),
						left = offset.left - that.document.scrollLeft(),
						top = offset.top - that.document.scrollTop();
	
					options.height = that.uiDialog.height();
					options.width = that.uiDialog.width();
					options.position = {
						my: "left top",
						at: "left" + (left >= 0 ? "+" : "") + left + " " +
							"top" + (top >= 0 ? "+" : "") + top,
						of: that.window
					};
					$( this ).removeClass( "ui-dialog-resizing" );
					that._unblockFrames();
					that._trigger( "resizeStop", event, filteredUi( ui ) );
				}
			})
			.css( "position", position );
		},
	
		_trackFocus: function() {
			this._on( this.widget(), {
				focusin: function( event ) {
					this._makeFocusTarget();
					this._focusedElement = $( event.target );
				}
			});
		},
	
		_makeFocusTarget: function() {
			this._untrackInstance();
			this._trackingInstances().unshift( this );
		},
	
		_untrackInstance: function() {
			var instances = this._trackingInstances(),
				exists = $.inArray( this, instances );
			if ( exists !== -1 ) {
				instances.splice( exists, 1 );
			}
		},
	
		_trackingInstances: function() {
			var instances = this.document.data( "ui-dialog-instances" );
			if ( !instances ) {
				instances = [];
				this.document.data( "ui-dialog-instances", instances );
			}
			return instances;
		},
	
		_minHeight: function() {
			var options = this.options;
	
			return options.height === "auto" ?
				options.minHeight :
				Math.min( options.minHeight, options.height );
		},
	
		_position: function() {
			// Need to show the dialog to get the actual offset in the position plugin
			var isVisible = this.uiDialog.is( ":visible" );
			if ( !isVisible ) {
				this.uiDialog.show();
			}
			this.uiDialog.position( this.options.position );
			if ( !isVisible ) {
				this.uiDialog.hide();
			}
		},
	
		_setOptions: function( options ) {
			var that = this,
				resize = false,
				resizableOptions = {};
	
			$.each( options, function( key, value ) {
				that._setOption( key, value );
	
				if ( key in that.sizeRelatedOptions ) {
					resize = true;
				}
				if ( key in that.resizableRelatedOptions ) {
					resizableOptions[ key ] = value;
				}
			});
	
			if ( resize ) {
				this._size();
				this._position();
			}
			if ( this.uiDialog.is( ":data(ui-resizable)" ) ) {
				this.uiDialog.resizable( "option", resizableOptions );
			}
		},
	
		_setOption: function( key, value ) {
			var isDraggable, isResizable,
				uiDialog = this.uiDialog;
	
			if ( key === "dialogClass" ) {
				uiDialog
					.removeClass( this.options.dialogClass )
					.addClass( value );
			}
	
			if ( key === "disabled" ) {
				return;
			}
	
			this._super( key, value );
	
			if ( key === "appendTo" ) {
				this.uiDialog.appendTo( this._appendTo() );
			}
	
			if ( key === "buttons" ) {
				this._createButtons();
			}
	
			if ( key === "closeText" ) {
				this.uiDialogTitlebarClose.button({
					// Ensure that we always pass a string
					label: "" + value
				});
			}
	
			if ( key === "draggable" ) {
				isDraggable = uiDialog.is( ":data(ui-draggable)" );
				if ( isDraggable && !value ) {
					uiDialog.draggable( "destroy" );
				}
	
				if ( !isDraggable && value ) {
					this._makeDraggable();
				}
			}
	
			if ( key === "position" ) {
				this._position();
			}
	
			if ( key === "resizable" ) {
				// currently resizable, becoming non-resizable
				isResizable = uiDialog.is( ":data(ui-resizable)" );
				if ( isResizable && !value ) {
					uiDialog.resizable( "destroy" );
				}
	
				// currently resizable, changing handles
				if ( isResizable && typeof value === "string" ) {
					uiDialog.resizable( "option", "handles", value );
				}
	
				// currently non-resizable, becoming resizable
				if ( !isResizable && value !== false ) {
					this._makeResizable();
				}
			}
	
			if ( key === "title" ) {
				this._title( this.uiDialogTitlebar.find( ".ui-dialog-title" ) );
			}
		},
	
		_size: function() {
			// If the user has resized the dialog, the .ui-dialog and .ui-dialog-content
			// divs will both have width and height set, so we need to reset them
			var nonContentHeight, minContentHeight, maxContentHeight,
				options = this.options;
	
			// Reset content sizing
			this.element.show().css({
				width: "auto",
				minHeight: 0,
				maxHeight: "none",
				height: 0
			});
	
			if ( options.minWidth > options.width ) {
				options.width = options.minWidth;
			}
	
			// reset wrapper sizing
			// determine the height of all the non-content elements
			nonContentHeight = this.uiDialog.css({
					height: "auto",
					width: options.width
				})
				.outerHeight();
			minContentHeight = Math.max( 0, options.minHeight - nonContentHeight );
			maxContentHeight = typeof options.maxHeight === "number" ?
				Math.max( 0, options.maxHeight - nonContentHeight ) :
				"none";
	
			if ( options.height === "auto" ) {
				this.element.css({
					minHeight: minContentHeight,
					maxHeight: maxContentHeight,
					height: "auto"
				});
			} else {
				this.element.height( Math.max( 0, options.height - nonContentHeight ) );
			}
	
			if ( this.uiDialog.is( ":data(ui-resizable)" ) ) {
				this.uiDialog.resizable( "option", "minHeight", this._minHeight() );
			}
		},
	
		_blockFrames: function() {
			this.iframeBlocks = this.document.find( "iframe" ).map(function() {
				var iframe = $( this );
	
				return $( "<div>" )
					.css({
						position: "absolute",
						width: iframe.outerWidth(),
						height: iframe.outerHeight()
					})
					.appendTo( iframe.parent() )
					.offset( iframe.offset() )[0];
			});
		},
	
		_unblockFrames: function() {
			if ( this.iframeBlocks ) {
				this.iframeBlocks.remove();
				delete this.iframeBlocks;
			}
		},
	
		_allowInteraction: function( event ) {
			if ( $( event.target ).closest( ".ui-dialog" ).length ) {
				return true;
			}
	
			// TODO: Remove hack when datepicker implements
			// the .ui-front logic (#8989)
			return !!$( event.target ).closest( ".ui-datepicker" ).length;
		},
	
		_createOverlay: function() {
			if ( !this.options.modal ) {
				return;
			}
	
			// We use a delay in case the overlay is created from an
			// event that we're going to be cancelling (#2804)
			var isOpening = true;
			this._delay(function() {
				isOpening = false;
			});
	
			if ( !this.document.data( "ui-dialog-overlays" ) ) {
	
				// Prevent use of anchors and inputs
				// Using _on() for an event handler shared across many instances is
				// safe because the dialogs stack and must be closed in reverse order
				this._on( this.document, {
					focusin: function( event ) {
						if ( isOpening ) {
							return;
						}
	
						if ( !this._allowInteraction( event ) ) {
							event.preventDefault();
							this._trackingInstances()[ 0 ]._focusTabbable();
						}
					}
				});
			}
	
			this.overlay = $( "<div>" )
				.addClass( "ui-widget-overlay ui-front" )
				.appendTo( this._appendTo() );
			this._on( this.overlay, {
				mousedown: "_keepFocus"
			});
			this.document.data( "ui-dialog-overlays",
				(this.document.data( "ui-dialog-overlays" ) || 0) + 1 );
		},
	
		_destroyOverlay: function() {
			if ( !this.options.modal ) {
				return;
			}
	
			if ( this.overlay ) {
				var overlays = this.document.data( "ui-dialog-overlays" ) - 1;
	
				if ( !overlays ) {
					this.document
						.unbind( "focusin" )
						.removeData( "ui-dialog-overlays" );
				} else {
					this.document.data( "ui-dialog-overlays", overlays );
				}
	
				this.overlay.remove();
				this.overlay = null;
			}
		}
	});
	
	
	/*!
	 * jQuery UI Droppable 1.11.4
	 * http://jqueryui.com
	 *
	 * Copyright jQuery Foundation and other contributors
	 * Released under the MIT license.
	 * http://jquery.org/license
	 *
	 * http://api.jqueryui.com/droppable/
	 */
	
	
	$.widget( "ui.droppable", {
		version: "1.11.4",
		widgetEventPrefix: "drop",
		options: {
			accept: "*",
			activeClass: false,
			addClasses: true,
			greedy: false,
			hoverClass: false,
			scope: "default",
			tolerance: "intersect",
	
			// callbacks
			activate: null,
			deactivate: null,
			drop: null,
			out: null,
			over: null
		},
		_create: function() {
	
			var proportions,
				o = this.options,
				accept = o.accept;
	
			this.isover = false;
			this.isout = true;
	
			this.accept = $.isFunction( accept ) ? accept : function( d ) {
				return d.is( accept );
			};
	
			this.proportions = function( /* valueToWrite */ ) {
				if ( arguments.length ) {
					// Store the droppable's proportions
					proportions = arguments[ 0 ];
				} else {
					// Retrieve or derive the droppable's proportions
					return proportions ?
						proportions :
						proportions = {
							width: this.element[ 0 ].offsetWidth,
							height: this.element[ 0 ].offsetHeight
						};
				}
			};
	
			this._addToManager( o.scope );
	
			o.addClasses && this.element.addClass( "ui-droppable" );
	
		},
	
		_addToManager: function( scope ) {
			// Add the reference and positions to the manager
			$.ui.ddmanager.droppables[ scope ] = $.ui.ddmanager.droppables[ scope ] || [];
			$.ui.ddmanager.droppables[ scope ].push( this );
		},
	
		_splice: function( drop ) {
			var i = 0;
			for ( ; i < drop.length; i++ ) {
				if ( drop[ i ] === this ) {
					drop.splice( i, 1 );
				}
			}
		},
	
		_destroy: function() {
			var drop = $.ui.ddmanager.droppables[ this.options.scope ];
	
			this._splice( drop );
	
			this.element.removeClass( "ui-droppable ui-droppable-disabled" );
		},
	
		_setOption: function( key, value ) {
	
			if ( key === "accept" ) {
				this.accept = $.isFunction( value ) ? value : function( d ) {
					return d.is( value );
				};
			} else if ( key === "scope" ) {
				var drop = $.ui.ddmanager.droppables[ this.options.scope ];
	
				this._splice( drop );
				this._addToManager( value );
			}
	
			this._super( key, value );
		},
	
		_activate: function( event ) {
			var draggable = $.ui.ddmanager.current;
			if ( this.options.activeClass ) {
				this.element.addClass( this.options.activeClass );
			}
			if ( draggable ){
				this._trigger( "activate", event, this.ui( draggable ) );
			}
		},
	
		_deactivate: function( event ) {
			var draggable = $.ui.ddmanager.current;
			if ( this.options.activeClass ) {
				this.element.removeClass( this.options.activeClass );
			}
			if ( draggable ){
				this._trigger( "deactivate", event, this.ui( draggable ) );
			}
		},
	
		_over: function( event ) {
	
			var draggable = $.ui.ddmanager.current;
	
			// Bail if draggable and droppable are same element
			if ( !draggable || ( draggable.currentItem || draggable.element )[ 0 ] === this.element[ 0 ] ) {
				return;
			}
	
			if ( this.accept.call( this.element[ 0 ], ( draggable.currentItem || draggable.element ) ) ) {
				if ( this.options.hoverClass ) {
					this.element.addClass( this.options.hoverClass );
				}
				this._trigger( "over", event, this.ui( draggable ) );
			}
	
		},
	
		_out: function( event ) {
	
			var draggable = $.ui.ddmanager.current;
	
			// Bail if draggable and droppable are same element
			if ( !draggable || ( draggable.currentItem || draggable.element )[ 0 ] === this.element[ 0 ] ) {
				return;
			}
	
			if ( this.accept.call( this.element[ 0 ], ( draggable.currentItem || draggable.element ) ) ) {
				if ( this.options.hoverClass ) {
					this.element.removeClass( this.options.hoverClass );
				}
				this._trigger( "out", event, this.ui( draggable ) );
			}
	
		},
	
		_drop: function( event, custom ) {
	
			var draggable = custom || $.ui.ddmanager.current,
				childrenIntersection = false;
	
			// Bail if draggable and droppable are same element
			if ( !draggable || ( draggable.currentItem || draggable.element )[ 0 ] === this.element[ 0 ] ) {
				return false;
			}
	
			this.element.find( ":data(ui-droppable)" ).not( ".ui-draggable-dragging" ).each(function() {
				var inst = $( this ).droppable( "instance" );
				if (
					inst.options.greedy &&
					!inst.options.disabled &&
					inst.options.scope === draggable.options.scope &&
					inst.accept.call( inst.element[ 0 ], ( draggable.currentItem || draggable.element ) ) &&
					$.ui.intersect( draggable, $.extend( inst, { offset: inst.element.offset() } ), inst.options.tolerance, event )
				) { childrenIntersection = true; return false; }
			});
			if ( childrenIntersection ) {
				return false;
			}
	
			if ( this.accept.call( this.element[ 0 ], ( draggable.currentItem || draggable.element ) ) ) {
				if ( this.options.activeClass ) {
					this.element.removeClass( this.options.activeClass );
				}
				if ( this.options.hoverClass ) {
					this.element.removeClass( this.options.hoverClass );
				}
				this._trigger( "drop", event, this.ui( draggable ) );
				return this.element;
			}
	
			return false;
	
		},
	
		ui: function( c ) {
			return {
				draggable: ( c.currentItem || c.element ),
				helper: c.helper,
				position: c.position,
				offset: c.positionAbs
			};
		}
	
	});
	
	$.ui.intersect = (function() {
		function isOverAxis( x, reference, size ) {
			return ( x >= reference ) && ( x < ( reference + size ) );
		}
	
		return function( draggable, droppable, toleranceMode, event ) {
	
			if ( !droppable.offset ) {
				return false;
			}
	
			var x1 = ( draggable.positionAbs || draggable.position.absolute ).left + draggable.margins.left,
				y1 = ( draggable.positionAbs || draggable.position.absolute ).top + draggable.margins.top,
				x2 = x1 + draggable.helperProportions.width,
				y2 = y1 + draggable.helperProportions.height,
				l = droppable.offset.left,
				t = droppable.offset.top,
				r = l + droppable.proportions().width,
				b = t + droppable.proportions().height;
	
			switch ( toleranceMode ) {
			case "fit":
				return ( l <= x1 && x2 <= r && t <= y1 && y2 <= b );
			case "intersect":
				return ( l < x1 + ( draggable.helperProportions.width / 2 ) && // Right Half
					x2 - ( draggable.helperProportions.width / 2 ) < r && // Left Half
					t < y1 + ( draggable.helperProportions.height / 2 ) && // Bottom Half
					y2 - ( draggable.helperProportions.height / 2 ) < b ); // Top Half
			case "pointer":
				return isOverAxis( event.pageY, t, droppable.proportions().height ) && isOverAxis( event.pageX, l, droppable.proportions().width );
			case "touch":
				return (
					( y1 >= t && y1 <= b ) || // Top edge touching
					( y2 >= t && y2 <= b ) || // Bottom edge touching
					( y1 < t && y2 > b ) // Surrounded vertically
				) && (
					( x1 >= l && x1 <= r ) || // Left edge touching
					( x2 >= l && x2 <= r ) || // Right edge touching
					( x1 < l && x2 > r ) // Surrounded horizontally
				);
			default:
				return false;
			}
		};
	})();
	
	/*
		This manager tracks offsets of draggables and droppables
	*/
	$.ui.ddmanager = {
		current: null,
		droppables: { "default": [] },
		prepareOffsets: function( t, event ) {
	
			var i, j,
				m = $.ui.ddmanager.droppables[ t.options.scope ] || [],
				type = event ? event.type : null, // workaround for #2317
				list = ( t.currentItem || t.element ).find( ":data(ui-droppable)" ).addBack();
	
			droppablesLoop: for ( i = 0; i < m.length; i++ ) {
	
				// No disabled and non-accepted
				if ( m[ i ].options.disabled || ( t && !m[ i ].accept.call( m[ i ].element[ 0 ], ( t.currentItem || t.element ) ) ) ) {
					continue;
				}
	
				// Filter out elements in the current dragged item
				for ( j = 0; j < list.length; j++ ) {
					if ( list[ j ] === m[ i ].element[ 0 ] ) {
						m[ i ].proportions().height = 0;
						continue droppablesLoop;
					}
				}
	
				m[ i ].visible = m[ i ].element.css( "display" ) !== "none";
				if ( !m[ i ].visible ) {
					continue;
				}
	
				// Activate the droppable if used directly from draggables
				if ( type === "mousedown" ) {
					m[ i ]._activate.call( m[ i ], event );
				}
	
				m[ i ].offset = m[ i ].element.offset();
				m[ i ].proportions({ width: m[ i ].element[ 0 ].offsetWidth, height: m[ i ].element[ 0 ].offsetHeight });
	
			}
	
		},
		drop: function( draggable, event ) {
	
			var dropped = false;
			// Create a copy of the droppables in case the list changes during the drop (#9116)
			$.each( ( $.ui.ddmanager.droppables[ draggable.options.scope ] || [] ).slice(), function() {
	
				if ( !this.options ) {
					return;
				}
				if ( !this.options.disabled && this.visible && $.ui.intersect( draggable, this, this.options.tolerance, event ) ) {
					dropped = this._drop.call( this, event ) || dropped;
				}
	
				if ( !this.options.disabled && this.visible && this.accept.call( this.element[ 0 ], ( draggable.currentItem || draggable.element ) ) ) {
					this.isout = true;
					this.isover = false;
					this._deactivate.call( this, event );
				}
	
			});
			return dropped;
	
		},
		dragStart: function( draggable, event ) {
			// Listen for scrolling so that if the dragging causes scrolling the position of the droppables can be recalculated (see #5003)
			draggable.element.parentsUntil( "body" ).bind( "scroll.droppable", function() {
				if ( !draggable.options.refreshPositions ) {
					$.ui.ddmanager.prepareOffsets( draggable, event );
				}
			});
		},
		drag: function( draggable, event ) {
	
			// If you have a highly dynamic page, you might try this option. It renders positions every time you move the mouse.
			if ( draggable.options.refreshPositions ) {
				$.ui.ddmanager.prepareOffsets( draggable, event );
			}
	
			// Run through all droppables and check their positions based on specific tolerance options
			$.each( $.ui.ddmanager.droppables[ draggable.options.scope ] || [], function() {
	
				if ( this.options.disabled || this.greedyChild || !this.visible ) {
					return;
				}
	
				var parentInstance, scope, parent,
					intersects = $.ui.intersect( draggable, this, this.options.tolerance, event ),
					c = !intersects && this.isover ? "isout" : ( intersects && !this.isover ? "isover" : null );
				if ( !c ) {
					return;
				}
	
				if ( this.options.greedy ) {
					// find droppable parents with same scope
					scope = this.options.scope;
					parent = this.element.parents( ":data(ui-droppable)" ).filter(function() {
						return $( this ).droppable( "instance" ).options.scope === scope;
					});
	
					if ( parent.length ) {
						parentInstance = $( parent[ 0 ] ).droppable( "instance" );
						parentInstance.greedyChild = ( c === "isover" );
					}
				}
	
				// we just moved into a greedy child
				if ( parentInstance && c === "isover" ) {
					parentInstance.isover = false;
					parentInstance.isout = true;
					parentInstance._out.call( parentInstance, event );
				}
	
				this[ c ] = true;
				this[c === "isout" ? "isover" : "isout"] = false;
				this[c === "isover" ? "_over" : "_out"].call( this, event );
	
				// we just moved out of a greedy child
				if ( parentInstance && c === "isout" ) {
					parentInstance.isout = false;
					parentInstance.isover = true;
					parentInstance._over.call( parentInstance, event );
				}
			});
	
		},
		dragStop: function( draggable, event ) {
			draggable.element.parentsUntil( "body" ).unbind( "scroll.droppable" );
			// Call prepareOffsets one final time since IE does not fire return scroll events when overflow was caused by drag (see #5003)
			if ( !draggable.options.refreshPositions ) {
				$.ui.ddmanager.prepareOffsets( draggable, event );
			}
		}
	};
	
	var droppable = $.ui.droppable;
	
	
	/*!
	 * jQuery UI Effects 1.11.4
	 * http://jqueryui.com
	 *
	 * Copyright jQuery Foundation and other contributors
	 * Released under the MIT license.
	 * http://jquery.org/license
	 *
	 * http://api.jqueryui.com/category/effects-core/
	 */
	
	
	var dataSpace = "ui-effects-",
	
		// Create a local jQuery because jQuery Color relies on it and the
		// global may not exist with AMD and a custom build (#10199)
		jQuery = $;
	
	$.effects = {
		effect: {}
	};
	
	/*!
	 * jQuery Color Animations v2.1.2
	 * https://github.com/jquery/jquery-color
	 *
	 * Copyright 2014 jQuery Foundation and other contributors
	 * Released under the MIT license.
	 * http://jquery.org/license
	 *
	 * Date: Wed Jan 16 08:47:09 2013 -0600
	 */
	(function( jQuery, undefined ) {
	
		var stepHooks = "backgroundColor borderBottomColor borderLeftColor borderRightColor borderTopColor color columnRuleColor outlineColor textDecorationColor textEmphasisColor",
	
		// plusequals test for += 100 -= 100
		rplusequals = /^([\-+])=\s*(\d+\.?\d*)/,
		// a set of RE's that can match strings and generate color tuples.
		stringParsers = [ {
				re: /rgba?\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*(?:,\s*(\d?(?:\.\d+)?)\s*)?\)/,
				parse: function( execResult ) {
					return [
						execResult[ 1 ],
						execResult[ 2 ],
						execResult[ 3 ],
						execResult[ 4 ]
					];
				}
			}, {
				re: /rgba?\(\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*(?:,\s*(\d?(?:\.\d+)?)\s*)?\)/,
				parse: function( execResult ) {
					return [
						execResult[ 1 ] * 2.55,
						execResult[ 2 ] * 2.55,
						execResult[ 3 ] * 2.55,
						execResult[ 4 ]
					];
				}
			}, {
				// this regex ignores A-F because it's compared against an already lowercased string
				re: /#([a-f0-9]{2})([a-f0-9]{2})([a-f0-9]{2})/,
				parse: function( execResult ) {
					return [
						parseInt( execResult[ 1 ], 16 ),
						parseInt( execResult[ 2 ], 16 ),
						parseInt( execResult[ 3 ], 16 )
					];
				}
			}, {
				// this regex ignores A-F because it's compared against an already lowercased string
				re: /#([a-f0-9])([a-f0-9])([a-f0-9])/,
				parse: function( execResult ) {
					return [
						parseInt( execResult[ 1 ] + execResult[ 1 ], 16 ),
						parseInt( execResult[ 2 ] + execResult[ 2 ], 16 ),
						parseInt( execResult[ 3 ] + execResult[ 3 ], 16 )
					];
				}
			}, {
				re: /hsla?\(\s*(\d+(?:\.\d+)?)\s*,\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*(?:,\s*(\d?(?:\.\d+)?)\s*)?\)/,
				space: "hsla",
				parse: function( execResult ) {
					return [
						execResult[ 1 ],
						execResult[ 2 ] / 100,
						execResult[ 3 ] / 100,
						execResult[ 4 ]
					];
				}
			} ],
	
		// jQuery.Color( )
		color = jQuery.Color = function( color, green, blue, alpha ) {
			return new jQuery.Color.fn.parse( color, green, blue, alpha );
		},
		spaces = {
			rgba: {
				props: {
					red: {
						idx: 0,
						type: "byte"
					},
					green: {
						idx: 1,
						type: "byte"
					},
					blue: {
						idx: 2,
						type: "byte"
					}
				}
			},
	
			hsla: {
				props: {
					hue: {
						idx: 0,
						type: "degrees"
					},
					saturation: {
						idx: 1,
						type: "percent"
					},
					lightness: {
						idx: 2,
						type: "percent"
					}
				}
			}
		},
		propTypes = {
			"byte": {
				floor: true,
				max: 255
			},
			"percent": {
				max: 1
			},
			"degrees": {
				mod: 360,
				floor: true
			}
		},
		support = color.support = {},
	
		// element for support tests
		supportElem = jQuery( "<p>" )[ 0 ],
	
		// colors = jQuery.Color.names
		colors,
	
		// local aliases of functions called often
		each = jQuery.each;
	
	// determine rgba support immediately
	supportElem.style.cssText = "background-color:rgba(1,1,1,.5)";
	support.rgba = supportElem.style.backgroundColor.indexOf( "rgba" ) > -1;
	
	// define cache name and alpha properties
	// for rgba and hsla spaces
	each( spaces, function( spaceName, space ) {
		space.cache = "_" + spaceName;
		space.props.alpha = {
			idx: 3,
			type: "percent",
			def: 1
		};
	});
	
	function clamp( value, prop, allowEmpty ) {
		var type = propTypes[ prop.type ] || {};
	
		if ( value == null ) {
			return (allowEmpty || !prop.def) ? null : prop.def;
		}
	
		// ~~ is an short way of doing floor for positive numbers
		value = type.floor ? ~~value : parseFloat( value );
	
		// IE will pass in empty strings as value for alpha,
		// which will hit this case
		if ( isNaN( value ) ) {
			return prop.def;
		}
	
		if ( type.mod ) {
			// we add mod before modding to make sure that negatives values
			// get converted properly: -10 -> 350
			return (value + type.mod) % type.mod;
		}
	
		// for now all property types without mod have min and max
		return 0 > value ? 0 : type.max < value ? type.max : value;
	}
	
	function stringParse( string ) {
		var inst = color(),
			rgba = inst._rgba = [];
	
		string = string.toLowerCase();
	
		each( stringParsers, function( i, parser ) {
			var parsed,
				match = parser.re.exec( string ),
				values = match && parser.parse( match ),
				spaceName = parser.space || "rgba";
	
			if ( values ) {
				parsed = inst[ spaceName ]( values );
	
				// if this was an rgba parse the assignment might happen twice
				// oh well....
				inst[ spaces[ spaceName ].cache ] = parsed[ spaces[ spaceName ].cache ];
				rgba = inst._rgba = parsed._rgba;
	
				// exit each( stringParsers ) here because we matched
				return false;
			}
		});
	
		// Found a stringParser that handled it
		if ( rgba.length ) {
	
			// if this came from a parsed string, force "transparent" when alpha is 0
			// chrome, (and maybe others) return "transparent" as rgba(0,0,0,0)
			if ( rgba.join() === "0,0,0,0" ) {
				jQuery.extend( rgba, colors.transparent );
			}
			return inst;
		}
	
		// named colors
		return colors[ string ];
	}
	
	color.fn = jQuery.extend( color.prototype, {
		parse: function( red, green, blue, alpha ) {
			if ( red === undefined ) {
				this._rgba = [ null, null, null, null ];
				return this;
			}
			if ( red.jquery || red.nodeType ) {
				red = jQuery( red ).css( green );
				green = undefined;
			}
	
			var inst = this,
				type = jQuery.type( red ),
				rgba = this._rgba = [];
	
			// more than 1 argument specified - assume ( red, green, blue, alpha )
			if ( green !== undefined ) {
				red = [ red, green, blue, alpha ];
				type = "array";
			}
	
			if ( type === "string" ) {
				return this.parse( stringParse( red ) || colors._default );
			}
	
			if ( type === "array" ) {
				each( spaces.rgba.props, function( key, prop ) {
					rgba[ prop.idx ] = clamp( red[ prop.idx ], prop );
				});
				return this;
			}
	
			if ( type === "object" ) {
				if ( red instanceof color ) {
					each( spaces, function( spaceName, space ) {
						if ( red[ space.cache ] ) {
							inst[ space.cache ] = red[ space.cache ].slice();
						}
					});
				} else {
					each( spaces, function( spaceName, space ) {
						var cache = space.cache;
						each( space.props, function( key, prop ) {
	
							// if the cache doesn't exist, and we know how to convert
							if ( !inst[ cache ] && space.to ) {
	
								// if the value was null, we don't need to copy it
								// if the key was alpha, we don't need to copy it either
								if ( key === "alpha" || red[ key ] == null ) {
									return;
								}
								inst[ cache ] = space.to( inst._rgba );
							}
	
							// this is the only case where we allow nulls for ALL properties.
							// call clamp with alwaysAllowEmpty
							inst[ cache ][ prop.idx ] = clamp( red[ key ], prop, true );
						});
	
						// everything defined but alpha?
						if ( inst[ cache ] && jQuery.inArray( null, inst[ cache ].slice( 0, 3 ) ) < 0 ) {
							// use the default of 1
							inst[ cache ][ 3 ] = 1;
							if ( space.from ) {
								inst._rgba = space.from( inst[ cache ] );
							}
						}
					});
				}
				return this;
			}
		},
		is: function( compare ) {
			var is = color( compare ),
				same = true,
				inst = this;
	
			each( spaces, function( _, space ) {
				var localCache,
					isCache = is[ space.cache ];
				if (isCache) {
					localCache = inst[ space.cache ] || space.to && space.to( inst._rgba ) || [];
					each( space.props, function( _, prop ) {
						if ( isCache[ prop.idx ] != null ) {
							same = ( isCache[ prop.idx ] === localCache[ prop.idx ] );
							return same;
						}
					});
				}
				return same;
			});
			return same;
		},
		_space: function() {
			var used = [],
				inst = this;
			each( spaces, function( spaceName, space ) {
				if ( inst[ space.cache ] ) {
					used.push( spaceName );
				}
			});
			return used.pop();
		},
		transition: function( other, distance ) {
			var end = color( other ),
				spaceName = end._space(),
				space = spaces[ spaceName ],
				startColor = this.alpha() === 0 ? color( "transparent" ) : this,
				start = startColor[ space.cache ] || space.to( startColor._rgba ),
				result = start.slice();
	
			end = end[ space.cache ];
			each( space.props, function( key, prop ) {
				var index = prop.idx,
					startValue = start[ index ],
					endValue = end[ index ],
					type = propTypes[ prop.type ] || {};
	
				// if null, don't override start value
				if ( endValue === null ) {
					return;
				}
				// if null - use end
				if ( startValue === null ) {
					result[ index ] = endValue;
				} else {
					if ( type.mod ) {
						if ( endValue - startValue > type.mod / 2 ) {
							startValue += type.mod;
						} else if ( startValue - endValue > type.mod / 2 ) {
							startValue -= type.mod;
						}
					}
					result[ index ] = clamp( ( endValue - startValue ) * distance + startValue, prop );
				}
			});
			return this[ spaceName ]( result );
		},
		blend: function( opaque ) {
			// if we are already opaque - return ourself
			if ( this._rgba[ 3 ] === 1 ) {
				return this;
			}
	
			var rgb = this._rgba.slice(),
				a = rgb.pop(),
				blend = color( opaque )._rgba;
	
			return color( jQuery.map( rgb, function( v, i ) {
				return ( 1 - a ) * blend[ i ] + a * v;
			}));
		},
		toRgbaString: function() {
			var prefix = "rgba(",
				rgba = jQuery.map( this._rgba, function( v, i ) {
					return v == null ? ( i > 2 ? 1 : 0 ) : v;
				});
	
			if ( rgba[ 3 ] === 1 ) {
				rgba.pop();
				prefix = "rgb(";
			}
	
			return prefix + rgba.join() + ")";
		},
		toHslaString: function() {
			var prefix = "hsla(",
				hsla = jQuery.map( this.hsla(), function( v, i ) {
					if ( v == null ) {
						v = i > 2 ? 1 : 0;
					}
	
					// catch 1 and 2
					if ( i && i < 3 ) {
						v = Math.round( v * 100 ) + "%";
					}
					return v;
				});
	
			if ( hsla[ 3 ] === 1 ) {
				hsla.pop();
				prefix = "hsl(";
			}
			return prefix + hsla.join() + ")";
		},
		toHexString: function( includeAlpha ) {
			var rgba = this._rgba.slice(),
				alpha = rgba.pop();
	
			if ( includeAlpha ) {
				rgba.push( ~~( alpha * 255 ) );
			}
	
			return "#" + jQuery.map( rgba, function( v ) {
	
				// default to 0 when nulls exist
				v = ( v || 0 ).toString( 16 );
				return v.length === 1 ? "0" + v : v;
			}).join("");
		},
		toString: function() {
			return this._rgba[ 3 ] === 0 ? "transparent" : this.toRgbaString();
		}
	});
	color.fn.parse.prototype = color.fn;
	
	// hsla conversions adapted from:
	// https://code.google.com/p/maashaack/source/browse/packages/graphics/trunk/src/graphics/colors/HUE2RGB.as?r=5021
	
	function hue2rgb( p, q, h ) {
		h = ( h + 1 ) % 1;
		if ( h * 6 < 1 ) {
			return p + ( q - p ) * h * 6;
		}
		if ( h * 2 < 1) {
			return q;
		}
		if ( h * 3 < 2 ) {
			return p + ( q - p ) * ( ( 2 / 3 ) - h ) * 6;
		}
		return p;
	}
	
	spaces.hsla.to = function( rgba ) {
		if ( rgba[ 0 ] == null || rgba[ 1 ] == null || rgba[ 2 ] == null ) {
			return [ null, null, null, rgba[ 3 ] ];
		}
		var r = rgba[ 0 ] / 255,
			g = rgba[ 1 ] / 255,
			b = rgba[ 2 ] / 255,
			a = rgba[ 3 ],
			max = Math.max( r, g, b ),
			min = Math.min( r, g, b ),
			diff = max - min,
			add = max + min,
			l = add * 0.5,
			h, s;
	
		if ( min === max ) {
			h = 0;
		} else if ( r === max ) {
			h = ( 60 * ( g - b ) / diff ) + 360;
		} else if ( g === max ) {
			h = ( 60 * ( b - r ) / diff ) + 120;
		} else {
			h = ( 60 * ( r - g ) / diff ) + 240;
		}
	
		// chroma (diff) == 0 means greyscale which, by definition, saturation = 0%
		// otherwise, saturation is based on the ratio of chroma (diff) to lightness (add)
		if ( diff === 0 ) {
			s = 0;
		} else if ( l <= 0.5 ) {
			s = diff / add;
		} else {
			s = diff / ( 2 - add );
		}
		return [ Math.round(h) % 360, s, l, a == null ? 1 : a ];
	};
	
	spaces.hsla.from = function( hsla ) {
		if ( hsla[ 0 ] == null || hsla[ 1 ] == null || hsla[ 2 ] == null ) {
			return [ null, null, null, hsla[ 3 ] ];
		}
		var h = hsla[ 0 ] / 360,
			s = hsla[ 1 ],
			l = hsla[ 2 ],
			a = hsla[ 3 ],
			q = l <= 0.5 ? l * ( 1 + s ) : l + s - l * s,
			p = 2 * l - q;
	
		return [
			Math.round( hue2rgb( p, q, h + ( 1 / 3 ) ) * 255 ),
			Math.round( hue2rgb( p, q, h ) * 255 ),
			Math.round( hue2rgb( p, q, h - ( 1 / 3 ) ) * 255 ),
			a
		];
	};
	
	each( spaces, function( spaceName, space ) {
		var props = space.props,
			cache = space.cache,
			to = space.to,
			from = space.from;
	
		// makes rgba() and hsla()
		color.fn[ spaceName ] = function( value ) {
	
			// generate a cache for this space if it doesn't exist
			if ( to && !this[ cache ] ) {
				this[ cache ] = to( this._rgba );
			}
			if ( value === undefined ) {
				return this[ cache ].slice();
			}
	
			var ret,
				type = jQuery.type( value ),
				arr = ( type === "array" || type === "object" ) ? value : arguments,
				local = this[ cache ].slice();
	
			each( props, function( key, prop ) {
				var val = arr[ type === "object" ? key : prop.idx ];
				if ( val == null ) {
					val = local[ prop.idx ];
				}
				local[ prop.idx ] = clamp( val, prop );
			});
	
			if ( from ) {
				ret = color( from( local ) );
				ret[ cache ] = local;
				return ret;
			} else {
				return color( local );
			}
		};
	
		// makes red() green() blue() alpha() hue() saturation() lightness()
		each( props, function( key, prop ) {
			// alpha is included in more than one space
			if ( color.fn[ key ] ) {
				return;
			}
			color.fn[ key ] = function( value ) {
				var vtype = jQuery.type( value ),
					fn = ( key === "alpha" ? ( this._hsla ? "hsla" : "rgba" ) : spaceName ),
					local = this[ fn ](),
					cur = local[ prop.idx ],
					match;
	
				if ( vtype === "undefined" ) {
					return cur;
				}
	
				if ( vtype === "function" ) {
					value = value.call( this, cur );
					vtype = jQuery.type( value );
				}
				if ( value == null && prop.empty ) {
					return this;
				}
				if ( vtype === "string" ) {
					match = rplusequals.exec( value );
					if ( match ) {
						value = cur + parseFloat( match[ 2 ] ) * ( match[ 1 ] === "+" ? 1 : -1 );
					}
				}
				local[ prop.idx ] = value;
				return this[ fn ]( local );
			};
		});
	});
	
	// add cssHook and .fx.step function for each named hook.
	// accept a space separated string of properties
	color.hook = function( hook ) {
		var hooks = hook.split( " " );
		each( hooks, function( i, hook ) {
			jQuery.cssHooks[ hook ] = {
				set: function( elem, value ) {
					var parsed, curElem,
						backgroundColor = "";
	
					if ( value !== "transparent" && ( jQuery.type( value ) !== "string" || ( parsed = stringParse( value ) ) ) ) {
						value = color( parsed || value );
						if ( !support.rgba && value._rgba[ 3 ] !== 1 ) {
							curElem = hook === "backgroundColor" ? elem.parentNode : elem;
							while (
								(backgroundColor === "" || backgroundColor === "transparent") &&
								curElem && curElem.style
							) {
								try {
									backgroundColor = jQuery.css( curElem, "backgroundColor" );
									curElem = curElem.parentNode;
								} catch ( e ) {
								}
							}
	
							value = value.blend( backgroundColor && backgroundColor !== "transparent" ?
								backgroundColor :
								"_default" );
						}
	
						value = value.toRgbaString();
					}
					try {
						elem.style[ hook ] = value;
					} catch ( e ) {
						// wrapped to prevent IE from throwing errors on "invalid" values like 'auto' or 'inherit'
					}
				}
			};
			jQuery.fx.step[ hook ] = function( fx ) {
				if ( !fx.colorInit ) {
					fx.start = color( fx.elem, hook );
					fx.end = color( fx.end );
					fx.colorInit = true;
				}
				jQuery.cssHooks[ hook ].set( fx.elem, fx.start.transition( fx.end, fx.pos ) );
			};
		});
	
	};
	
	color.hook( stepHooks );
	
	jQuery.cssHooks.borderColor = {
		expand: function( value ) {
			var expanded = {};
	
			each( [ "Top", "Right", "Bottom", "Left" ], function( i, part ) {
				expanded[ "border" + part + "Color" ] = value;
			});
			return expanded;
		}
	};
	
	// Basic color names only.
	// Usage of any of the other color names requires adding yourself or including
	// jquery.color.svg-names.js.
	colors = jQuery.Color.names = {
		// 4.1. Basic color keywords
		aqua: "#00ffff",
		black: "#000000",
		blue: "#0000ff",
		fuchsia: "#ff00ff",
		gray: "#808080",
		green: "#008000",
		lime: "#00ff00",
		maroon: "#800000",
		navy: "#000080",
		olive: "#808000",
		purple: "#800080",
		red: "#ff0000",
		silver: "#c0c0c0",
		teal: "#008080",
		white: "#ffffff",
		yellow: "#ffff00",
	
		// 4.2.3. "transparent" color keyword
		transparent: [ null, null, null, 0 ],
	
		_default: "#ffffff"
	};
	
	})( jQuery );
	
	/******************************************************************************/
	/****************************** CLASS ANIMATIONS ******************************/
	/******************************************************************************/
	(function() {
	
	var classAnimationActions = [ "add", "remove", "toggle" ],
		shorthandStyles = {
			border: 1,
			borderBottom: 1,
			borderColor: 1,
			borderLeft: 1,
			borderRight: 1,
			borderTop: 1,
			borderWidth: 1,
			margin: 1,
			padding: 1
		};
	
	$.each([ "borderLeftStyle", "borderRightStyle", "borderBottomStyle", "borderTopStyle" ], function( _, prop ) {
		$.fx.step[ prop ] = function( fx ) {
			if ( fx.end !== "none" && !fx.setAttr || fx.pos === 1 && !fx.setAttr ) {
				jQuery.style( fx.elem, prop, fx.end );
				fx.setAttr = true;
			}
		};
	});
	
	function getElementStyles( elem ) {
		var key, len,
			style = elem.ownerDocument.defaultView ?
				elem.ownerDocument.defaultView.getComputedStyle( elem, null ) :
				elem.currentStyle,
			styles = {};
	
		if ( style && style.length && style[ 0 ] && style[ style[ 0 ] ] ) {
			len = style.length;
			while ( len-- ) {
				key = style[ len ];
				if ( typeof style[ key ] === "string" ) {
					styles[ $.camelCase( key ) ] = style[ key ];
				}
			}
		// support: Opera, IE <9
		} else {
			for ( key in style ) {
				if ( typeof style[ key ] === "string" ) {
					styles[ key ] = style[ key ];
				}
			}
		}
	
		return styles;
	}
	
	function styleDifference( oldStyle, newStyle ) {
		var diff = {},
			name, value;
	
		for ( name in newStyle ) {
			value = newStyle[ name ];
			if ( oldStyle[ name ] !== value ) {
				if ( !shorthandStyles[ name ] ) {
					if ( $.fx.step[ name ] || !isNaN( parseFloat( value ) ) ) {
						diff[ name ] = value;
					}
				}
			}
		}
	
		return diff;
	}
	
	// support: jQuery <1.8
	if ( !$.fn.addBack ) {
		$.fn.addBack = function( selector ) {
			return this.add( selector == null ?
				this.prevObject : this.prevObject.filter( selector )
			);
		};
	}
	
	$.effects.animateClass = function( value, duration, easing, callback ) {
		var o = $.speed( duration, easing, callback );
	
		return this.queue( function() {
			var animated = $( this ),
				baseClass = animated.attr( "class" ) || "",
				applyClassChange,
				allAnimations = o.children ? animated.find( "*" ).addBack() : animated;
	
			// map the animated objects to store the original styles.
			allAnimations = allAnimations.map(function() {
				var el = $( this );
				return {
					el: el,
					start: getElementStyles( this )
				};
			});
	
			// apply class change
			applyClassChange = function() {
				$.each( classAnimationActions, function(i, action) {
					if ( value[ action ] ) {
						animated[ action + "Class" ]( value[ action ] );
					}
				});
			};
			applyClassChange();
	
			// map all animated objects again - calculate new styles and diff
			allAnimations = allAnimations.map(function() {
				this.end = getElementStyles( this.el[ 0 ] );
				this.diff = styleDifference( this.start, this.end );
				return this;
			});
	
			// apply original class
			animated.attr( "class", baseClass );
	
			// map all animated objects again - this time collecting a promise
			allAnimations = allAnimations.map(function() {
				var styleInfo = this,
					dfd = $.Deferred(),
					opts = $.extend({}, o, {
						queue: false,
						complete: function() {
							dfd.resolve( styleInfo );
						}
					});
	
				this.el.animate( this.diff, opts );
				return dfd.promise();
			});
	
			// once all animations have completed:
			$.when.apply( $, allAnimations.get() ).done(function() {
	
				// set the final class
				applyClassChange();
	
				// for each animated element,
				// clear all css properties that were animated
				$.each( arguments, function() {
					var el = this.el;
					$.each( this.diff, function(key) {
						el.css( key, "" );
					});
				});
	
				// this is guarnteed to be there if you use jQuery.speed()
				// it also handles dequeuing the next anim...
				o.complete.call( animated[ 0 ] );
			});
		});
	};
	
	$.fn.extend({
		addClass: (function( orig ) {
			return function( classNames, speed, easing, callback ) {
				return speed ?
					$.effects.animateClass.call( this,
						{ add: classNames }, speed, easing, callback ) :
					orig.apply( this, arguments );
			};
		})( $.fn.addClass ),
	
		removeClass: (function( orig ) {
			return function( classNames, speed, easing, callback ) {
				return arguments.length > 1 ?
					$.effects.animateClass.call( this,
						{ remove: classNames }, speed, easing, callback ) :
					orig.apply( this, arguments );
			};
		})( $.fn.removeClass ),
	
		toggleClass: (function( orig ) {
			return function( classNames, force, speed, easing, callback ) {
				if ( typeof force === "boolean" || force === undefined ) {
					if ( !speed ) {
						// without speed parameter
						return orig.apply( this, arguments );
					} else {
						return $.effects.animateClass.call( this,
							(force ? { add: classNames } : { remove: classNames }),
							speed, easing, callback );
					}
				} else {
					// without force parameter
					return $.effects.animateClass.call( this,
						{ toggle: classNames }, force, speed, easing );
				}
			};
		})( $.fn.toggleClass ),
	
		switchClass: function( remove, add, speed, easing, callback) {
			return $.effects.animateClass.call( this, {
				add: add,
				remove: remove
			}, speed, easing, callback );
		}
	});
	
	})();
	
	/******************************************************************************/
	/*********************************** EFFECTS **********************************/
	/******************************************************************************/
	
	(function() {
	
	$.extend( $.effects, {
		version: "1.11.4",
	
		// Saves a set of properties in a data storage
		save: function( element, set ) {
			for ( var i = 0; i < set.length; i++ ) {
				if ( set[ i ] !== null ) {
					element.data( dataSpace + set[ i ], element[ 0 ].style[ set[ i ] ] );
				}
			}
		},
	
		// Restores a set of previously saved properties from a data storage
		restore: function( element, set ) {
			var val, i;
			for ( i = 0; i < set.length; i++ ) {
				if ( set[ i ] !== null ) {
					val = element.data( dataSpace + set[ i ] );
					// support: jQuery 1.6.2
					// http://bugs.jquery.com/ticket/9917
					// jQuery 1.6.2 incorrectly returns undefined for any falsy value.
					// We can't differentiate between "" and 0 here, so we just assume
					// empty string since it's likely to be a more common value...
					if ( val === undefined ) {
						val = "";
					}
					element.css( set[ i ], val );
				}
			}
		},
	
		setMode: function( el, mode ) {
			if (mode === "toggle") {
				mode = el.is( ":hidden" ) ? "show" : "hide";
			}
			return mode;
		},
	
		// Translates a [top,left] array into a baseline value
		// this should be a little more flexible in the future to handle a string & hash
		getBaseline: function( origin, original ) {
			var y, x;
			switch ( origin[ 0 ] ) {
				case "top": y = 0; break;
				case "middle": y = 0.5; break;
				case "bottom": y = 1; break;
				default: y = origin[ 0 ] / original.height;
			}
			switch ( origin[ 1 ] ) {
				case "left": x = 0; break;
				case "center": x = 0.5; break;
				case "right": x = 1; break;
				default: x = origin[ 1 ] / original.width;
			}
			return {
				x: x,
				y: y
			};
		},
	
		// Wraps the element around a wrapper that copies position properties
		createWrapper: function( element ) {
	
			// if the element is already wrapped, return it
			if ( element.parent().is( ".ui-effects-wrapper" )) {
				return element.parent();
			}
	
			// wrap the element
			var props = {
					width: element.outerWidth(true),
					height: element.outerHeight(true),
					"float": element.css( "float" )
				},
				wrapper = $( "<div></div>" )
					.addClass( "ui-effects-wrapper" )
					.css({
						fontSize: "100%",
						background: "transparent",
						border: "none",
						margin: 0,
						padding: 0
					}),
				// Store the size in case width/height are defined in % - Fixes #5245
				size = {
					width: element.width(),
					height: element.height()
				},
				active = document.activeElement;
	
			// support: Firefox
			// Firefox incorrectly exposes anonymous content
			// https://bugzilla.mozilla.org/show_bug.cgi?id=561664
			try {
				active.id;
			} catch ( e ) {
				active = document.body;
			}
	
			element.wrap( wrapper );
	
			// Fixes #7595 - Elements lose focus when wrapped.
			if ( element[ 0 ] === active || $.contains( element[ 0 ], active ) ) {
				$( active ).focus();
			}
	
			wrapper = element.parent(); //Hotfix for jQuery 1.4 since some change in wrap() seems to actually lose the reference to the wrapped element
	
			// transfer positioning properties to the wrapper
			if ( element.css( "position" ) === "static" ) {
				wrapper.css({ position: "relative" });
				element.css({ position: "relative" });
			} else {
				$.extend( props, {
					position: element.css( "position" ),
					zIndex: element.css( "z-index" )
				});
				$.each([ "top", "left", "bottom", "right" ], function(i, pos) {
					props[ pos ] = element.css( pos );
					if ( isNaN( parseInt( props[ pos ], 10 ) ) ) {
						props[ pos ] = "auto";
					}
				});
				element.css({
					position: "relative",
					top: 0,
					left: 0,
					right: "auto",
					bottom: "auto"
				});
			}
			element.css(size);
	
			return wrapper.css( props ).show();
		},
	
		removeWrapper: function( element ) {
			var active = document.activeElement;
	
			if ( element.parent().is( ".ui-effects-wrapper" ) ) {
				element.parent().replaceWith( element );
	
				// Fixes #7595 - Elements lose focus when wrapped.
				if ( element[ 0 ] === active || $.contains( element[ 0 ], active ) ) {
					$( active ).focus();
				}
			}
	
			return element;
		},
	
		setTransition: function( element, list, factor, value ) {
			value = value || {};
			$.each( list, function( i, x ) {
				var unit = element.cssUnit( x );
				if ( unit[ 0 ] > 0 ) {
					value[ x ] = unit[ 0 ] * factor + unit[ 1 ];
				}
			});
			return value;
		}
	});
	
	// return an effect options object for the given parameters:
	function _normalizeArguments( effect, options, speed, callback ) {
	
		// allow passing all options as the first parameter
		if ( $.isPlainObject( effect ) ) {
			options = effect;
			effect = effect.effect;
		}
	
		// convert to an object
		effect = { effect: effect };
	
		// catch (effect, null, ...)
		if ( options == null ) {
			options = {};
		}
	
		// catch (effect, callback)
		if ( $.isFunction( options ) ) {
			callback = options;
			speed = null;
			options = {};
		}
	
		// catch (effect, speed, ?)
		if ( typeof options === "number" || $.fx.speeds[ options ] ) {
			callback = speed;
			speed = options;
			options = {};
		}
	
		// catch (effect, options, callback)
		if ( $.isFunction( speed ) ) {
			callback = speed;
			speed = null;
		}
	
		// add options to effect
		if ( options ) {
			$.extend( effect, options );
		}
	
		speed = speed || options.duration;
		effect.duration = $.fx.off ? 0 :
			typeof speed === "number" ? speed :
			speed in $.fx.speeds ? $.fx.speeds[ speed ] :
			$.fx.speeds._default;
	
		effect.complete = callback || options.complete;
	
		return effect;
	}
	
	function standardAnimationOption( option ) {
		// Valid standard speeds (nothing, number, named speed)
		if ( !option || typeof option === "number" || $.fx.speeds[ option ] ) {
			return true;
		}
	
		// Invalid strings - treat as "normal" speed
		if ( typeof option === "string" && !$.effects.effect[ option ] ) {
			return true;
		}
	
		// Complete callback
		if ( $.isFunction( option ) ) {
			return true;
		}
	
		// Options hash (but not naming an effect)
		if ( typeof option === "object" && !option.effect ) {
			return true;
		}
	
		// Didn't match any standard API
		return false;
	}
	
	$.fn.extend({
		effect: function( /* effect, options, speed, callback */ ) {
			var args = _normalizeArguments.apply( this, arguments ),
				mode = args.mode,
				queue = args.queue,
				effectMethod = $.effects.effect[ args.effect ];
	
			if ( $.fx.off || !effectMethod ) {
				// delegate to the original method (e.g., .show()) if possible
				if ( mode ) {
					return this[ mode ]( args.duration, args.complete );
				} else {
					return this.each( function() {
						if ( args.complete ) {
							args.complete.call( this );
						}
					});
				}
			}
	
			function run( next ) {
				var elem = $( this ),
					complete = args.complete,
					mode = args.mode;
	
				function done() {
					if ( $.isFunction( complete ) ) {
						complete.call( elem[0] );
					}
					if ( $.isFunction( next ) ) {
						next();
					}
				}
	
				// If the element already has the correct final state, delegate to
				// the core methods so the internal tracking of "olddisplay" works.
				if ( elem.is( ":hidden" ) ? mode === "hide" : mode === "show" ) {
					elem[ mode ]();
					done();
				} else {
					effectMethod.call( elem[0], args, done );
				}
			}
	
			return queue === false ? this.each( run ) : this.queue( queue || "fx", run );
		},
	
		show: (function( orig ) {
			return function( option ) {
				if ( standardAnimationOption( option ) ) {
					return orig.apply( this, arguments );
				} else {
					var args = _normalizeArguments.apply( this, arguments );
					args.mode = "show";
					return this.effect.call( this, args );
				}
			};
		})( $.fn.show ),
	
		hide: (function( orig ) {
			return function( option ) {
				if ( standardAnimationOption( option ) ) {
					return orig.apply( this, arguments );
				} else {
					var args = _normalizeArguments.apply( this, arguments );
					args.mode = "hide";
					return this.effect.call( this, args );
				}
			};
		})( $.fn.hide ),
	
		toggle: (function( orig ) {
			return function( option ) {
				if ( standardAnimationOption( option ) || typeof option === "boolean" ) {
					return orig.apply( this, arguments );
				} else {
					var args = _normalizeArguments.apply( this, arguments );
					args.mode = "toggle";
					return this.effect.call( this, args );
				}
			};
		})( $.fn.toggle ),
	
		// helper functions
		cssUnit: function(key) {
			var style = this.css( key ),
				val = [];
	
			$.each( [ "em", "px", "%", "pt" ], function( i, unit ) {
				if ( style.indexOf( unit ) > 0 ) {
					val = [ parseFloat( style ), unit ];
				}
			});
			return val;
		}
	});
	
	})();
	
	/******************************************************************************/
	/*********************************** EASING ***********************************/
	/******************************************************************************/
	
	(function() {
	
	// based on easing equations from Robert Penner (http://www.robertpenner.com/easing)
	
	var baseEasings = {};
	
	$.each( [ "Quad", "Cubic", "Quart", "Quint", "Expo" ], function( i, name ) {
		baseEasings[ name ] = function( p ) {
			return Math.pow( p, i + 2 );
		};
	});
	
	$.extend( baseEasings, {
		Sine: function( p ) {
			return 1 - Math.cos( p * Math.PI / 2 );
		},
		Circ: function( p ) {
			return 1 - Math.sqrt( 1 - p * p );
		},
		Elastic: function( p ) {
			return p === 0 || p === 1 ? p :
				-Math.pow( 2, 8 * (p - 1) ) * Math.sin( ( (p - 1) * 80 - 7.5 ) * Math.PI / 15 );
		},
		Back: function( p ) {
			return p * p * ( 3 * p - 2 );
		},
		Bounce: function( p ) {
			var pow2,
				bounce = 4;
	
			while ( p < ( ( pow2 = Math.pow( 2, --bounce ) ) - 1 ) / 11 ) {}
			return 1 / Math.pow( 4, 3 - bounce ) - 7.5625 * Math.pow( ( pow2 * 3 - 2 ) / 22 - p, 2 );
		}
	});
	
	$.each( baseEasings, function( name, easeIn ) {
		$.easing[ "easeIn" + name ] = easeIn;
		$.easing[ "easeOut" + name ] = function( p ) {
			return 1 - easeIn( 1 - p );
		};
		$.easing[ "easeInOut" + name ] = function( p ) {
			return p < 0.5 ?
				easeIn( p * 2 ) / 2 :
				1 - easeIn( p * -2 + 2 ) / 2;
		};
	});
	
	})();
	
	var effect = $.effects;
	
	
	/*!
	 * jQuery UI Effects Blind 1.11.4
	 * http://jqueryui.com
	 *
	 * Copyright jQuery Foundation and other contributors
	 * Released under the MIT license.
	 * http://jquery.org/license
	 *
	 * http://api.jqueryui.com/blind-effect/
	 */
	
	
	var effectBlind = $.effects.effect.blind = function( o, done ) {
		// Create element
		var el = $( this ),
			rvertical = /up|down|vertical/,
			rpositivemotion = /up|left|vertical|horizontal/,
			props = [ "position", "top", "bottom", "left", "right", "height", "width" ],
			mode = $.effects.setMode( el, o.mode || "hide" ),
			direction = o.direction || "up",
			vertical = rvertical.test( direction ),
			ref = vertical ? "height" : "width",
			ref2 = vertical ? "top" : "left",
			motion = rpositivemotion.test( direction ),
			animation = {},
			show = mode === "show",
			wrapper, distance, margin;
	
		// if already wrapped, the wrapper's properties are my property. #6245
		if ( el.parent().is( ".ui-effects-wrapper" ) ) {
			$.effects.save( el.parent(), props );
		} else {
			$.effects.save( el, props );
		}
		el.show();
		wrapper = $.effects.createWrapper( el ).css({
			overflow: "hidden"
		});
	
		distance = wrapper[ ref ]();
		margin = parseFloat( wrapper.css( ref2 ) ) || 0;
	
		animation[ ref ] = show ? distance : 0;
		if ( !motion ) {
			el
				.css( vertical ? "bottom" : "right", 0 )
				.css( vertical ? "top" : "left", "auto" )
				.css({ position: "absolute" });
	
			animation[ ref2 ] = show ? margin : distance + margin;
		}
	
		// start at 0 if we are showing
		if ( show ) {
			wrapper.css( ref, 0 );
			if ( !motion ) {
				wrapper.css( ref2, margin + distance );
			}
		}
	
		// Animate
		wrapper.animate( animation, {
			duration: o.duration,
			easing: o.easing,
			queue: false,
			complete: function() {
				if ( mode === "hide" ) {
					el.hide();
				}
				$.effects.restore( el, props );
				$.effects.removeWrapper( el );
				done();
			}
		});
	};
	
	
	/*!
	 * jQuery UI Effects Bounce 1.11.4
	 * http://jqueryui.com
	 *
	 * Copyright jQuery Foundation and other contributors
	 * Released under the MIT license.
	 * http://jquery.org/license
	 *
	 * http://api.jqueryui.com/bounce-effect/
	 */
	
	
	var effectBounce = $.effects.effect.bounce = function( o, done ) {
		var el = $( this ),
			props = [ "position", "top", "bottom", "left", "right", "height", "width" ],
	
			// defaults:
			mode = $.effects.setMode( el, o.mode || "effect" ),
			hide = mode === "hide",
			show = mode === "show",
			direction = o.direction || "up",
			distance = o.distance,
			times = o.times || 5,
	
			// number of internal animations
			anims = times * 2 + ( show || hide ? 1 : 0 ),
			speed = o.duration / anims,
			easing = o.easing,
	
			// utility:
			ref = ( direction === "up" || direction === "down" ) ? "top" : "left",
			motion = ( direction === "up" || direction === "left" ),
			i,
			upAnim,
			downAnim,
	
			// we will need to re-assemble the queue to stack our animations in place
			queue = el.queue(),
			queuelen = queue.length;
	
		// Avoid touching opacity to prevent clearType and PNG issues in IE
		if ( show || hide ) {
			props.push( "opacity" );
		}
	
		$.effects.save( el, props );
		el.show();
		$.effects.createWrapper( el ); // Create Wrapper
	
		// default distance for the BIGGEST bounce is the outer Distance / 3
		if ( !distance ) {
			distance = el[ ref === "top" ? "outerHeight" : "outerWidth" ]() / 3;
		}
	
		if ( show ) {
			downAnim = { opacity: 1 };
			downAnim[ ref ] = 0;
	
			// if we are showing, force opacity 0 and set the initial position
			// then do the "first" animation
			el.css( "opacity", 0 )
				.css( ref, motion ? -distance * 2 : distance * 2 )
				.animate( downAnim, speed, easing );
		}
	
		// start at the smallest distance if we are hiding
		if ( hide ) {
			distance = distance / Math.pow( 2, times - 1 );
		}
	
		downAnim = {};
		downAnim[ ref ] = 0;
		// Bounces up/down/left/right then back to 0 -- times * 2 animations happen here
		for ( i = 0; i < times; i++ ) {
			upAnim = {};
			upAnim[ ref ] = ( motion ? "-=" : "+=" ) + distance;
	
			el.animate( upAnim, speed, easing )
				.animate( downAnim, speed, easing );
	
			distance = hide ? distance * 2 : distance / 2;
		}
	
		// Last Bounce when Hiding
		if ( hide ) {
			upAnim = { opacity: 0 };
			upAnim[ ref ] = ( motion ? "-=" : "+=" ) + distance;
	
			el.animate( upAnim, speed, easing );
		}
	
		el.queue(function() {
			if ( hide ) {
				el.hide();
			}
			$.effects.restore( el, props );
			$.effects.removeWrapper( el );
			done();
		});
	
		// inject all the animations we just queued to be first in line (after "inprogress")
		if ( queuelen > 1) {
			queue.splice.apply( queue,
				[ 1, 0 ].concat( queue.splice( queuelen, anims + 1 ) ) );
		}
		el.dequeue();
	
	};
	
	
	/*!
	 * jQuery UI Effects Clip 1.11.4
	 * http://jqueryui.com
	 *
	 * Copyright jQuery Foundation and other contributors
	 * Released under the MIT license.
	 * http://jquery.org/license
	 *
	 * http://api.jqueryui.com/clip-effect/
	 */
	
	
	var effectClip = $.effects.effect.clip = function( o, done ) {
		// Create element
		var el = $( this ),
			props = [ "position", "top", "bottom", "left", "right", "height", "width" ],
			mode = $.effects.setMode( el, o.mode || "hide" ),
			show = mode === "show",
			direction = o.direction || "vertical",
			vert = direction === "vertical",
			size = vert ? "height" : "width",
			position = vert ? "top" : "left",
			animation = {},
			wrapper, animate, distance;
	
		// Save & Show
		$.effects.save( el, props );
		el.show();
	
		// Create Wrapper
		wrapper = $.effects.createWrapper( el ).css({
			overflow: "hidden"
		});
		animate = ( el[0].tagName === "IMG" ) ? wrapper : el;
		distance = animate[ size ]();
	
		// Shift
		if ( show ) {
			animate.css( size, 0 );
			animate.css( position, distance / 2 );
		}
	
		// Create Animation Object:
		animation[ size ] = show ? distance : 0;
		animation[ position ] = show ? 0 : distance / 2;
	
		// Animate
		animate.animate( animation, {
			queue: false,
			duration: o.duration,
			easing: o.easing,
			complete: function() {
				if ( !show ) {
					el.hide();
				}
				$.effects.restore( el, props );
				$.effects.removeWrapper( el );
				done();
			}
		});
	
	};
	
	
	/*!
	 * jQuery UI Effects Drop 1.11.4
	 * http://jqueryui.com
	 *
	 * Copyright jQuery Foundation and other contributors
	 * Released under the MIT license.
	 * http://jquery.org/license
	 *
	 * http://api.jqueryui.com/drop-effect/
	 */
	
	
	var effectDrop = $.effects.effect.drop = function( o, done ) {
	
		var el = $( this ),
			props = [ "position", "top", "bottom", "left", "right", "opacity", "height", "width" ],
			mode = $.effects.setMode( el, o.mode || "hide" ),
			show = mode === "show",
			direction = o.direction || "left",
			ref = ( direction === "up" || direction === "down" ) ? "top" : "left",
			motion = ( direction === "up" || direction === "left" ) ? "pos" : "neg",
			animation = {
				opacity: show ? 1 : 0
			},
			distance;
	
		// Adjust
		$.effects.save( el, props );
		el.show();
		$.effects.createWrapper( el );
	
		distance = o.distance || el[ ref === "top" ? "outerHeight" : "outerWidth" ]( true ) / 2;
	
		if ( show ) {
			el
				.css( "opacity", 0 )
				.css( ref, motion === "pos" ? -distance : distance );
		}
	
		// Animation
		animation[ ref ] = ( show ?
			( motion === "pos" ? "+=" : "-=" ) :
			( motion === "pos" ? "-=" : "+=" ) ) +
			distance;
	
		// Animate
		el.animate( animation, {
			queue: false,
			duration: o.duration,
			easing: o.easing,
			complete: function() {
				if ( mode === "hide" ) {
					el.hide();
				}
				$.effects.restore( el, props );
				$.effects.removeWrapper( el );
				done();
			}
		});
	};
	
	
	/*!
	 * jQuery UI Effects Explode 1.11.4
	 * http://jqueryui.com
	 *
	 * Copyright jQuery Foundation and other contributors
	 * Released under the MIT license.
	 * http://jquery.org/license
	 *
	 * http://api.jqueryui.com/explode-effect/
	 */
	
	
	var effectExplode = $.effects.effect.explode = function( o, done ) {
	
		var rows = o.pieces ? Math.round( Math.sqrt( o.pieces ) ) : 3,
			cells = rows,
			el = $( this ),
			mode = $.effects.setMode( el, o.mode || "hide" ),
			show = mode === "show",
	
			// show and then visibility:hidden the element before calculating offset
			offset = el.show().css( "visibility", "hidden" ).offset(),
	
			// width and height of a piece
			width = Math.ceil( el.outerWidth() / cells ),
			height = Math.ceil( el.outerHeight() / rows ),
			pieces = [],
	
			// loop
			i, j, left, top, mx, my;
	
		// children animate complete:
		function childComplete() {
			pieces.push( this );
			if ( pieces.length === rows * cells ) {
				animComplete();
			}
		}
	
		// clone the element for each row and cell.
		for ( i = 0; i < rows ; i++ ) { // ===>
			top = offset.top + i * height;
			my = i - ( rows - 1 ) / 2 ;
	
			for ( j = 0; j < cells ; j++ ) { // |||
				left = offset.left + j * width;
				mx = j - ( cells - 1 ) / 2 ;
	
				// Create a clone of the now hidden main element that will be absolute positioned
				// within a wrapper div off the -left and -top equal to size of our pieces
				el
					.clone()
					.appendTo( "body" )
					.wrap( "<div></div>" )
					.css({
						position: "absolute",
						visibility: "visible",
						left: -j * width,
						top: -i * height
					})
	
				// select the wrapper - make it overflow: hidden and absolute positioned based on
				// where the original was located +left and +top equal to the size of pieces
					.parent()
					.addClass( "ui-effects-explode" )
					.css({
						position: "absolute",
						overflow: "hidden",
						width: width,
						height: height,
						left: left + ( show ? mx * width : 0 ),
						top: top + ( show ? my * height : 0 ),
						opacity: show ? 0 : 1
					}).animate({
						left: left + ( show ? 0 : mx * width ),
						top: top + ( show ? 0 : my * height ),
						opacity: show ? 1 : 0
					}, o.duration || 500, o.easing, childComplete );
			}
		}
	
		function animComplete() {
			el.css({
				visibility: "visible"
			});
			$( pieces ).remove();
			if ( !show ) {
				el.hide();
			}
			done();
		}
	};
	
	
	/*!
	 * jQuery UI Effects Fade 1.11.4
	 * http://jqueryui.com
	 *
	 * Copyright jQuery Foundation and other contributors
	 * Released under the MIT license.
	 * http://jquery.org/license
	 *
	 * http://api.jqueryui.com/fade-effect/
	 */
	
	
	var effectFade = $.effects.effect.fade = function( o, done ) {
		var el = $( this ),
			mode = $.effects.setMode( el, o.mode || "toggle" );
	
		el.animate({
			opacity: mode
		}, {
			queue: false,
			duration: o.duration,
			easing: o.easing,
			complete: done
		});
	};
	
	
	/*!
	 * jQuery UI Effects Fold 1.11.4
	 * http://jqueryui.com
	 *
	 * Copyright jQuery Foundation and other contributors
	 * Released under the MIT license.
	 * http://jquery.org/license
	 *
	 * http://api.jqueryui.com/fold-effect/
	 */
	
	
	var effectFold = $.effects.effect.fold = function( o, done ) {
	
		// Create element
		var el = $( this ),
			props = [ "position", "top", "bottom", "left", "right", "height", "width" ],
			mode = $.effects.setMode( el, o.mode || "hide" ),
			show = mode === "show",
			hide = mode === "hide",
			size = o.size || 15,
			percent = /([0-9]+)%/.exec( size ),
			horizFirst = !!o.horizFirst,
			widthFirst = show !== horizFirst,
			ref = widthFirst ? [ "width", "height" ] : [ "height", "width" ],
			duration = o.duration / 2,
			wrapper, distance,
			animation1 = {},
			animation2 = {};
	
		$.effects.save( el, props );
		el.show();
	
		// Create Wrapper
		wrapper = $.effects.createWrapper( el ).css({
			overflow: "hidden"
		});
		distance = widthFirst ?
			[ wrapper.width(), wrapper.height() ] :
			[ wrapper.height(), wrapper.width() ];
	
		if ( percent ) {
			size = parseInt( percent[ 1 ], 10 ) / 100 * distance[ hide ? 0 : 1 ];
		}
		if ( show ) {
			wrapper.css( horizFirst ? {
				height: 0,
				width: size
			} : {
				height: size,
				width: 0
			});
		}
	
		// Animation
		animation1[ ref[ 0 ] ] = show ? distance[ 0 ] : size;
		animation2[ ref[ 1 ] ] = show ? distance[ 1 ] : 0;
	
		// Animate
		wrapper
			.animate( animation1, duration, o.easing )
			.animate( animation2, duration, o.easing, function() {
				if ( hide ) {
					el.hide();
				}
				$.effects.restore( el, props );
				$.effects.removeWrapper( el );
				done();
			});
	
	};
	
	
	/*!
	 * jQuery UI Effects Highlight 1.11.4
	 * http://jqueryui.com
	 *
	 * Copyright jQuery Foundation and other contributors
	 * Released under the MIT license.
	 * http://jquery.org/license
	 *
	 * http://api.jqueryui.com/highlight-effect/
	 */
	
	
	var effectHighlight = $.effects.effect.highlight = function( o, done ) {
		var elem = $( this ),
			props = [ "backgroundImage", "backgroundColor", "opacity" ],
			mode = $.effects.setMode( elem, o.mode || "show" ),
			animation = {
				backgroundColor: elem.css( "backgroundColor" )
			};
	
		if (mode === "hide") {
			animation.opacity = 0;
		}
	
		$.effects.save( elem, props );
	
		elem
			.show()
			.css({
				backgroundImage: "none",
				backgroundColor: o.color || "#ffff99"
			})
			.animate( animation, {
				queue: false,
				duration: o.duration,
				easing: o.easing,
				complete: function() {
					if ( mode === "hide" ) {
						elem.hide();
					}
					$.effects.restore( elem, props );
					done();
				}
			});
	};
	
	
	/*!
	 * jQuery UI Effects Size 1.11.4
	 * http://jqueryui.com
	 *
	 * Copyright jQuery Foundation and other contributors
	 * Released under the MIT license.
	 * http://jquery.org/license
	 *
	 * http://api.jqueryui.com/size-effect/
	 */
	
	
	var effectSize = $.effects.effect.size = function( o, done ) {
	
		// Create element
		var original, baseline, factor,
			el = $( this ),
			props0 = [ "position", "top", "bottom", "left", "right", "width", "height", "overflow", "opacity" ],
	
			// Always restore
			props1 = [ "position", "top", "bottom", "left", "right", "overflow", "opacity" ],
	
			// Copy for children
			props2 = [ "width", "height", "overflow" ],
			cProps = [ "fontSize" ],
			vProps = [ "borderTopWidth", "borderBottomWidth", "paddingTop", "paddingBottom" ],
			hProps = [ "borderLeftWidth", "borderRightWidth", "paddingLeft", "paddingRight" ],
	
			// Set options
			mode = $.effects.setMode( el, o.mode || "effect" ),
			restore = o.restore || mode !== "effect",
			scale = o.scale || "both",
			origin = o.origin || [ "middle", "center" ],
			position = el.css( "position" ),
			props = restore ? props0 : props1,
			zero = {
				height: 0,
				width: 0,
				outerHeight: 0,
				outerWidth: 0
			};
	
		if ( mode === "show" ) {
			el.show();
		}
		original = {
			height: el.height(),
			width: el.width(),
			outerHeight: el.outerHeight(),
			outerWidth: el.outerWidth()
		};
	
		if ( o.mode === "toggle" && mode === "show" ) {
			el.from = o.to || zero;
			el.to = o.from || original;
		} else {
			el.from = o.from || ( mode === "show" ? zero : original );
			el.to = o.to || ( mode === "hide" ? zero : original );
		}
	
		// Set scaling factor
		factor = {
			from: {
				y: el.from.height / original.height,
				x: el.from.width / original.width
			},
			to: {
				y: el.to.height / original.height,
				x: el.to.width / original.width
			}
		};
	
		// Scale the css box
		if ( scale === "box" || scale === "both" ) {
	
			// Vertical props scaling
			if ( factor.from.y !== factor.to.y ) {
				props = props.concat( vProps );
				el.from = $.effects.setTransition( el, vProps, factor.from.y, el.from );
				el.to = $.effects.setTransition( el, vProps, factor.to.y, el.to );
			}
	
			// Horizontal props scaling
			if ( factor.from.x !== factor.to.x ) {
				props = props.concat( hProps );
				el.from = $.effects.setTransition( el, hProps, factor.from.x, el.from );
				el.to = $.effects.setTransition( el, hProps, factor.to.x, el.to );
			}
		}
	
		// Scale the content
		if ( scale === "content" || scale === "both" ) {
	
			// Vertical props scaling
			if ( factor.from.y !== factor.to.y ) {
				props = props.concat( cProps ).concat( props2 );
				el.from = $.effects.setTransition( el, cProps, factor.from.y, el.from );
				el.to = $.effects.setTransition( el, cProps, factor.to.y, el.to );
			}
		}
	
		$.effects.save( el, props );
		el.show();
		$.effects.createWrapper( el );
		el.css( "overflow", "hidden" ).css( el.from );
	
		// Adjust
		if (origin) { // Calculate baseline shifts
			baseline = $.effects.getBaseline( origin, original );
			el.from.top = ( original.outerHeight - el.outerHeight() ) * baseline.y;
			el.from.left = ( original.outerWidth - el.outerWidth() ) * baseline.x;
			el.to.top = ( original.outerHeight - el.to.outerHeight ) * baseline.y;
			el.to.left = ( original.outerWidth - el.to.outerWidth ) * baseline.x;
		}
		el.css( el.from ); // set top & left
	
		// Animate
		if ( scale === "content" || scale === "both" ) { // Scale the children
	
			// Add margins/font-size
			vProps = vProps.concat([ "marginTop", "marginBottom" ]).concat(cProps);
			hProps = hProps.concat([ "marginLeft", "marginRight" ]);
			props2 = props0.concat(vProps).concat(hProps);
	
			el.find( "*[width]" ).each( function() {
				var child = $( this ),
					c_original = {
						height: child.height(),
						width: child.width(),
						outerHeight: child.outerHeight(),
						outerWidth: child.outerWidth()
					};
				if (restore) {
					$.effects.save(child, props2);
				}
	
				child.from = {
					height: c_original.height * factor.from.y,
					width: c_original.width * factor.from.x,
					outerHeight: c_original.outerHeight * factor.from.y,
					outerWidth: c_original.outerWidth * factor.from.x
				};
				child.to = {
					height: c_original.height * factor.to.y,
					width: c_original.width * factor.to.x,
					outerHeight: c_original.height * factor.to.y,
					outerWidth: c_original.width * factor.to.x
				};
	
				// Vertical props scaling
				if ( factor.from.y !== factor.to.y ) {
					child.from = $.effects.setTransition( child, vProps, factor.from.y, child.from );
					child.to = $.effects.setTransition( child, vProps, factor.to.y, child.to );
				}
	
				// Horizontal props scaling
				if ( factor.from.x !== factor.to.x ) {
					child.from = $.effects.setTransition( child, hProps, factor.from.x, child.from );
					child.to = $.effects.setTransition( child, hProps, factor.to.x, child.to );
				}
	
				// Animate children
				child.css( child.from );
				child.animate( child.to, o.duration, o.easing, function() {
	
					// Restore children
					if ( restore ) {
						$.effects.restore( child, props2 );
					}
				});
			});
		}
	
		// Animate
		el.animate( el.to, {
			queue: false,
			duration: o.duration,
			easing: o.easing,
			complete: function() {
				if ( el.to.opacity === 0 ) {
					el.css( "opacity", el.from.opacity );
				}
				if ( mode === "hide" ) {
					el.hide();
				}
				$.effects.restore( el, props );
				if ( !restore ) {
	
					// we need to calculate our new positioning based on the scaling
					if ( position === "static" ) {
						el.css({
							position: "relative",
							top: el.to.top,
							left: el.to.left
						});
					} else {
						$.each([ "top", "left" ], function( idx, pos ) {
							el.css( pos, function( _, str ) {
								var val = parseInt( str, 10 ),
									toRef = idx ? el.to.left : el.to.top;
	
								// if original was "auto", recalculate the new value from wrapper
								if ( str === "auto" ) {
									return toRef + "px";
								}
	
								return val + toRef + "px";
							});
						});
					}
				}
	
				$.effects.removeWrapper( el );
				done();
			}
		});
	
	};
	
	
	/*!
	 * jQuery UI Effects Scale 1.11.4
	 * http://jqueryui.com
	 *
	 * Copyright jQuery Foundation and other contributors
	 * Released under the MIT license.
	 * http://jquery.org/license
	 *
	 * http://api.jqueryui.com/scale-effect/
	 */
	
	
	var effectScale = $.effects.effect.scale = function( o, done ) {
	
		// Create element
		var el = $( this ),
			options = $.extend( true, {}, o ),
			mode = $.effects.setMode( el, o.mode || "effect" ),
			percent = parseInt( o.percent, 10 ) ||
				( parseInt( o.percent, 10 ) === 0 ? 0 : ( mode === "hide" ? 0 : 100 ) ),
			direction = o.direction || "both",
			origin = o.origin,
			original = {
				height: el.height(),
				width: el.width(),
				outerHeight: el.outerHeight(),
				outerWidth: el.outerWidth()
			},
			factor = {
				y: direction !== "horizontal" ? (percent / 100) : 1,
				x: direction !== "vertical" ? (percent / 100) : 1
			};
	
		// We are going to pass this effect to the size effect:
		options.effect = "size";
		options.queue = false;
		options.complete = done;
	
		// Set default origin and restore for show/hide
		if ( mode !== "effect" ) {
			options.origin = origin || [ "middle", "center" ];
			options.restore = true;
		}
	
		options.from = o.from || ( mode === "show" ? {
			height: 0,
			width: 0,
			outerHeight: 0,
			outerWidth: 0
		} : original );
		options.to = {
			height: original.height * factor.y,
			width: original.width * factor.x,
			outerHeight: original.outerHeight * factor.y,
			outerWidth: original.outerWidth * factor.x
		};
	
		// Fade option to support puff
		if ( options.fade ) {
			if ( mode === "show" ) {
				options.from.opacity = 0;
				options.to.opacity = 1;
			}
			if ( mode === "hide" ) {
				options.from.opacity = 1;
				options.to.opacity = 0;
			}
		}
	
		// Animate
		el.effect( options );
	
	};
	
	
	/*!
	 * jQuery UI Effects Puff 1.11.4
	 * http://jqueryui.com
	 *
	 * Copyright jQuery Foundation and other contributors
	 * Released under the MIT license.
	 * http://jquery.org/license
	 *
	 * http://api.jqueryui.com/puff-effect/
	 */
	
	
	var effectPuff = $.effects.effect.puff = function( o, done ) {
		var elem = $( this ),
			mode = $.effects.setMode( elem, o.mode || "hide" ),
			hide = mode === "hide",
			percent = parseInt( o.percent, 10 ) || 150,
			factor = percent / 100,
			original = {
				height: elem.height(),
				width: elem.width(),
				outerHeight: elem.outerHeight(),
				outerWidth: elem.outerWidth()
			};
	
		$.extend( o, {
			effect: "scale",
			queue: false,
			fade: true,
			mode: mode,
			complete: done,
			percent: hide ? percent : 100,
			from: hide ?
				original :
				{
					height: original.height * factor,
					width: original.width * factor,
					outerHeight: original.outerHeight * factor,
					outerWidth: original.outerWidth * factor
				}
		});
	
		elem.effect( o );
	};
	
	
	/*!
	 * jQuery UI Effects Pulsate 1.11.4
	 * http://jqueryui.com
	 *
	 * Copyright jQuery Foundation and other contributors
	 * Released under the MIT license.
	 * http://jquery.org/license
	 *
	 * http://api.jqueryui.com/pulsate-effect/
	 */
	
	
	var effectPulsate = $.effects.effect.pulsate = function( o, done ) {
		var elem = $( this ),
			mode = $.effects.setMode( elem, o.mode || "show" ),
			show = mode === "show",
			hide = mode === "hide",
			showhide = ( show || mode === "hide" ),
	
			// showing or hiding leaves of the "last" animation
			anims = ( ( o.times || 5 ) * 2 ) + ( showhide ? 1 : 0 ),
			duration = o.duration / anims,
			animateTo = 0,
			queue = elem.queue(),
			queuelen = queue.length,
			i;
	
		if ( show || !elem.is(":visible")) {
			elem.css( "opacity", 0 ).show();
			animateTo = 1;
		}
	
		// anims - 1 opacity "toggles"
		for ( i = 1; i < anims; i++ ) {
			elem.animate({
				opacity: animateTo
			}, duration, o.easing );
			animateTo = 1 - animateTo;
		}
	
		elem.animate({
			opacity: animateTo
		}, duration, o.easing);
	
		elem.queue(function() {
			if ( hide ) {
				elem.hide();
			}
			done();
		});
	
		// We just queued up "anims" animations, we need to put them next in the queue
		if ( queuelen > 1 ) {
			queue.splice.apply( queue,
				[ 1, 0 ].concat( queue.splice( queuelen, anims + 1 ) ) );
		}
		elem.dequeue();
	};
	
	
	/*!
	 * jQuery UI Effects Shake 1.11.4
	 * http://jqueryui.com
	 *
	 * Copyright jQuery Foundation and other contributors
	 * Released under the MIT license.
	 * http://jquery.org/license
	 *
	 * http://api.jqueryui.com/shake-effect/
	 */
	
	
	var effectShake = $.effects.effect.shake = function( o, done ) {
	
		var el = $( this ),
			props = [ "position", "top", "bottom", "left", "right", "height", "width" ],
			mode = $.effects.setMode( el, o.mode || "effect" ),
			direction = o.direction || "left",
			distance = o.distance || 20,
			times = o.times || 3,
			anims = times * 2 + 1,
			speed = Math.round( o.duration / anims ),
			ref = (direction === "up" || direction === "down") ? "top" : "left",
			positiveMotion = (direction === "up" || direction === "left"),
			animation = {},
			animation1 = {},
			animation2 = {},
			i,
	
			// we will need to re-assemble the queue to stack our animations in place
			queue = el.queue(),
			queuelen = queue.length;
	
		$.effects.save( el, props );
		el.show();
		$.effects.createWrapper( el );
	
		// Animation
		animation[ ref ] = ( positiveMotion ? "-=" : "+=" ) + distance;
		animation1[ ref ] = ( positiveMotion ? "+=" : "-=" ) + distance * 2;
		animation2[ ref ] = ( positiveMotion ? "-=" : "+=" ) + distance * 2;
	
		// Animate
		el.animate( animation, speed, o.easing );
	
		// Shakes
		for ( i = 1; i < times; i++ ) {
			el.animate( animation1, speed, o.easing ).animate( animation2, speed, o.easing );
		}
		el
			.animate( animation1, speed, o.easing )
			.animate( animation, speed / 2, o.easing )
			.queue(function() {
				if ( mode === "hide" ) {
					el.hide();
				}
				$.effects.restore( el, props );
				$.effects.removeWrapper( el );
				done();
			});
	
		// inject all the animations we just queued to be first in line (after "inprogress")
		if ( queuelen > 1) {
			queue.splice.apply( queue,
				[ 1, 0 ].concat( queue.splice( queuelen, anims + 1 ) ) );
		}
		el.dequeue();
	
	};
	
	
	/*!
	 * jQuery UI Effects Slide 1.11.4
	 * http://jqueryui.com
	 *
	 * Copyright jQuery Foundation and other contributors
	 * Released under the MIT license.
	 * http://jquery.org/license
	 *
	 * http://api.jqueryui.com/slide-effect/
	 */
	
	
	var effectSlide = $.effects.effect.slide = function( o, done ) {
	
		// Create element
		var el = $( this ),
			props = [ "position", "top", "bottom", "left", "right", "width", "height" ],
			mode = $.effects.setMode( el, o.mode || "show" ),
			show = mode === "show",
			direction = o.direction || "left",
			ref = (direction === "up" || direction === "down") ? "top" : "left",
			positiveMotion = (direction === "up" || direction === "left"),
			distance,
			animation = {};
	
		// Adjust
		$.effects.save( el, props );
		el.show();
		distance = o.distance || el[ ref === "top" ? "outerHeight" : "outerWidth" ]( true );
	
		$.effects.createWrapper( el ).css({
			overflow: "hidden"
		});
	
		if ( show ) {
			el.css( ref, positiveMotion ? (isNaN(distance) ? "-" + distance : -distance) : distance );
		}
	
		// Animation
		animation[ ref ] = ( show ?
			( positiveMotion ? "+=" : "-=") :
			( positiveMotion ? "-=" : "+=")) +
			distance;
	
		// Animate
		el.animate( animation, {
			queue: false,
			duration: o.duration,
			easing: o.easing,
			complete: function() {
				if ( mode === "hide" ) {
					el.hide();
				}
				$.effects.restore( el, props );
				$.effects.removeWrapper( el );
				done();
			}
		});
	};
	
	
	/*!
	 * jQuery UI Effects Transfer 1.11.4
	 * http://jqueryui.com
	 *
	 * Copyright jQuery Foundation and other contributors
	 * Released under the MIT license.
	 * http://jquery.org/license
	 *
	 * http://api.jqueryui.com/transfer-effect/
	 */
	
	
	var effectTransfer = $.effects.effect.transfer = function( o, done ) {
		var elem = $( this ),
			target = $( o.to ),
			targetFixed = target.css( "position" ) === "fixed",
			body = $("body"),
			fixTop = targetFixed ? body.scrollTop() : 0,
			fixLeft = targetFixed ? body.scrollLeft() : 0,
			endPosition = target.offset(),
			animation = {
				top: endPosition.top - fixTop,
				left: endPosition.left - fixLeft,
				height: target.innerHeight(),
				width: target.innerWidth()
			},
			startPosition = elem.offset(),
			transfer = $( "<div class='ui-effects-transfer'></div>" )
				.appendTo( document.body )
				.addClass( o.className )
				.css({
					top: startPosition.top - fixTop,
					left: startPosition.left - fixLeft,
					height: elem.innerHeight(),
					width: elem.innerWidth(),
					position: targetFixed ? "fixed" : "absolute"
				})
				.animate( animation, o.duration, o.easing, function() {
					transfer.remove();
					done();
				});
	};
	
	
	/*!
	 * jQuery UI Progressbar 1.11.4
	 * http://jqueryui.com
	 *
	 * Copyright jQuery Foundation and other contributors
	 * Released under the MIT license.
	 * http://jquery.org/license
	 *
	 * http://api.jqueryui.com/progressbar/
	 */
	
	
	var progressbar = $.widget( "ui.progressbar", {
		version: "1.11.4",
		options: {
			max: 100,
			value: 0,
	
			change: null,
			complete: null
		},
	
		min: 0,
	
		_create: function() {
			// Constrain initial value
			this.oldValue = this.options.value = this._constrainedValue();
	
			this.element
				.addClass( "ui-progressbar ui-widget ui-widget-content ui-corner-all" )
				.attr({
					// Only set static values, aria-valuenow and aria-valuemax are
					// set inside _refreshValue()
					role: "progressbar",
					"aria-valuemin": this.min
				});
	
			this.valueDiv = $( "<div class='ui-progressbar-value ui-widget-header ui-corner-left'></div>" )
				.appendTo( this.element );
	
			this._refreshValue();
		},
	
		_destroy: function() {
			this.element
				.removeClass( "ui-progressbar ui-widget ui-widget-content ui-corner-all" )
				.removeAttr( "role" )
				.removeAttr( "aria-valuemin" )
				.removeAttr( "aria-valuemax" )
				.removeAttr( "aria-valuenow" );
	
			this.valueDiv.remove();
		},
	
		value: function( newValue ) {
			if ( newValue === undefined ) {
				return this.options.value;
			}
	
			this.options.value = this._constrainedValue( newValue );
			this._refreshValue();
		},
	
		_constrainedValue: function( newValue ) {
			if ( newValue === undefined ) {
				newValue = this.options.value;
			}
	
			this.indeterminate = newValue === false;
	
			// sanitize value
			if ( typeof newValue !== "number" ) {
				newValue = 0;
			}
	
			return this.indeterminate ? false :
				Math.min( this.options.max, Math.max( this.min, newValue ) );
		},
	
		_setOptions: function( options ) {
			// Ensure "value" option is set after other values (like max)
			var value = options.value;
			delete options.value;
	
			this._super( options );
	
			this.options.value = this._constrainedValue( value );
			this._refreshValue();
		},
	
		_setOption: function( key, value ) {
			if ( key === "max" ) {
				// Don't allow a max less than min
				value = Math.max( this.min, value );
			}
			if ( key === "disabled" ) {
				this.element
					.toggleClass( "ui-state-disabled", !!value )
					.attr( "aria-disabled", value );
			}
			this._super( key, value );
		},
	
		_percentage: function() {
			return this.indeterminate ? 100 : 100 * ( this.options.value - this.min ) / ( this.options.max - this.min );
		},
	
		_refreshValue: function() {
			var value = this.options.value,
				percentage = this._percentage();
	
			this.valueDiv
				.toggle( this.indeterminate || value > this.min )
				.toggleClass( "ui-corner-right", value === this.options.max )
				.width( percentage.toFixed(0) + "%" );
	
			this.element.toggleClass( "ui-progressbar-indeterminate", this.indeterminate );
	
			if ( this.indeterminate ) {
				this.element.removeAttr( "aria-valuenow" );
				if ( !this.overlayDiv ) {
					this.overlayDiv = $( "<div class='ui-progressbar-overlay'></div>" ).appendTo( this.valueDiv );
				}
			} else {
				this.element.attr({
					"aria-valuemax": this.options.max,
					"aria-valuenow": value
				});
				if ( this.overlayDiv ) {
					this.overlayDiv.remove();
					this.overlayDiv = null;
				}
			}
	
			if ( this.oldValue !== value ) {
				this.oldValue = value;
				this._trigger( "change" );
			}
			if ( value === this.options.max ) {
				this._trigger( "complete" );
			}
		}
	});
	
	
	/*!
	 * jQuery UI Selectable 1.11.4
	 * http://jqueryui.com
	 *
	 * Copyright jQuery Foundation and other contributors
	 * Released under the MIT license.
	 * http://jquery.org/license
	 *
	 * http://api.jqueryui.com/selectable/
	 */
	
	
	var selectable = $.widget("ui.selectable", $.ui.mouse, {
		version: "1.11.4",
		options: {
			appendTo: "body",
			autoRefresh: true,
			distance: 0,
			filter: "*",
			tolerance: "touch",
	
			// callbacks
			selected: null,
			selecting: null,
			start: null,
			stop: null,
			unselected: null,
			unselecting: null
		},
		_create: function() {
			var selectees,
				that = this;
	
			this.element.addClass("ui-selectable");
	
			this.dragged = false;
	
			// cache selectee children based on filter
			this.refresh = function() {
				selectees = $(that.options.filter, that.element[0]);
				selectees.addClass("ui-selectee");
				selectees.each(function() {
					var $this = $(this),
						pos = $this.offset();
					$.data(this, "selectable-item", {
						element: this,
						$element: $this,
						left: pos.left,
						top: pos.top,
						right: pos.left + $this.outerWidth(),
						bottom: pos.top + $this.outerHeight(),
						startselected: false,
						selected: $this.hasClass("ui-selected"),
						selecting: $this.hasClass("ui-selecting"),
						unselecting: $this.hasClass("ui-unselecting")
					});
				});
			};
			this.refresh();
	
			this.selectees = selectees.addClass("ui-selectee");
	
			this._mouseInit();
	
			this.helper = $("<div class='ui-selectable-helper'></div>");
		},
	
		_destroy: function() {
			this.selectees
				.removeClass("ui-selectee")
				.removeData("selectable-item");
			this.element
				.removeClass("ui-selectable ui-selectable-disabled");
			this._mouseDestroy();
		},
	
		_mouseStart: function(event) {
			var that = this,
				options = this.options;
	
			this.opos = [ event.pageX, event.pageY ];
	
			if (this.options.disabled) {
				return;
			}
	
			this.selectees = $(options.filter, this.element[0]);
	
			this._trigger("start", event);
	
			$(options.appendTo).append(this.helper);
			// position helper (lasso)
			this.helper.css({
				"left": event.pageX,
				"top": event.pageY,
				"width": 0,
				"height": 0
			});
	
			if (options.autoRefresh) {
				this.refresh();
			}
	
			this.selectees.filter(".ui-selected").each(function() {
				var selectee = $.data(this, "selectable-item");
				selectee.startselected = true;
				if (!event.metaKey && !event.ctrlKey) {
					selectee.$element.removeClass("ui-selected");
					selectee.selected = false;
					selectee.$element.addClass("ui-unselecting");
					selectee.unselecting = true;
					// selectable UNSELECTING callback
					that._trigger("unselecting", event, {
						unselecting: selectee.element
					});
				}
			});
	
			$(event.target).parents().addBack().each(function() {
				var doSelect,
					selectee = $.data(this, "selectable-item");
				if (selectee) {
					doSelect = (!event.metaKey && !event.ctrlKey) || !selectee.$element.hasClass("ui-selected");
					selectee.$element
						.removeClass(doSelect ? "ui-unselecting" : "ui-selected")
						.addClass(doSelect ? "ui-selecting" : "ui-unselecting");
					selectee.unselecting = !doSelect;
					selectee.selecting = doSelect;
					selectee.selected = doSelect;
					// selectable (UN)SELECTING callback
					if (doSelect) {
						that._trigger("selecting", event, {
							selecting: selectee.element
						});
					} else {
						that._trigger("unselecting", event, {
							unselecting: selectee.element
						});
					}
					return false;
				}
			});
	
		},
	
		_mouseDrag: function(event) {
	
			this.dragged = true;
	
			if (this.options.disabled) {
				return;
			}
	
			var tmp,
				that = this,
				options = this.options,
				x1 = this.opos[0],
				y1 = this.opos[1],
				x2 = event.pageX,
				y2 = event.pageY;
	
			if (x1 > x2) { tmp = x2; x2 = x1; x1 = tmp; }
			if (y1 > y2) { tmp = y2; y2 = y1; y1 = tmp; }
			this.helper.css({ left: x1, top: y1, width: x2 - x1, height: y2 - y1 });
	
			this.selectees.each(function() {
				var selectee = $.data(this, "selectable-item"),
					hit = false;
	
				//prevent helper from being selected if appendTo: selectable
				if (!selectee || selectee.element === that.element[0]) {
					return;
				}
	
				if (options.tolerance === "touch") {
					hit = ( !(selectee.left > x2 || selectee.right < x1 || selectee.top > y2 || selectee.bottom < y1) );
				} else if (options.tolerance === "fit") {
					hit = (selectee.left > x1 && selectee.right < x2 && selectee.top > y1 && selectee.bottom < y2);
				}
	
				if (hit) {
					// SELECT
					if (selectee.selected) {
						selectee.$element.removeClass("ui-selected");
						selectee.selected = false;
					}
					if (selectee.unselecting) {
						selectee.$element.removeClass("ui-unselecting");
						selectee.unselecting = false;
					}
					if (!selectee.selecting) {
						selectee.$element.addClass("ui-selecting");
						selectee.selecting = true;
						// selectable SELECTING callback
						that._trigger("selecting", event, {
							selecting: selectee.element
						});
					}
				} else {
					// UNSELECT
					if (selectee.selecting) {
						if ((event.metaKey || event.ctrlKey) && selectee.startselected) {
							selectee.$element.removeClass("ui-selecting");
							selectee.selecting = false;
							selectee.$element.addClass("ui-selected");
							selectee.selected = true;
						} else {
							selectee.$element.removeClass("ui-selecting");
							selectee.selecting = false;
							if (selectee.startselected) {
								selectee.$element.addClass("ui-unselecting");
								selectee.unselecting = true;
							}
							// selectable UNSELECTING callback
							that._trigger("unselecting", event, {
								unselecting: selectee.element
							});
						}
					}
					if (selectee.selected) {
						if (!event.metaKey && !event.ctrlKey && !selectee.startselected) {
							selectee.$element.removeClass("ui-selected");
							selectee.selected = false;
	
							selectee.$element.addClass("ui-unselecting");
							selectee.unselecting = true;
							// selectable UNSELECTING callback
							that._trigger("unselecting", event, {
								unselecting: selectee.element
							});
						}
					}
				}
			});
	
			return false;
		},
	
		_mouseStop: function(event) {
			var that = this;
	
			this.dragged = false;
	
			$(".ui-unselecting", this.element[0]).each(function() {
				var selectee = $.data(this, "selectable-item");
				selectee.$element.removeClass("ui-unselecting");
				selectee.unselecting = false;
				selectee.startselected = false;
				that._trigger("unselected", event, {
					unselected: selectee.element
				});
			});
			$(".ui-selecting", this.element[0]).each(function() {
				var selectee = $.data(this, "selectable-item");
				selectee.$element.removeClass("ui-selecting").addClass("ui-selected");
				selectee.selecting = false;
				selectee.selected = true;
				selectee.startselected = true;
				that._trigger("selected", event, {
					selected: selectee.element
				});
			});
			this._trigger("stop", event);
	
			this.helper.remove();
	
			return false;
		}
	
	});
	
	
	/*!
	 * jQuery UI Selectmenu 1.11.4
	 * http://jqueryui.com
	 *
	 * Copyright jQuery Foundation and other contributors
	 * Released under the MIT license.
	 * http://jquery.org/license
	 *
	 * http://api.jqueryui.com/selectmenu
	 */
	
	
	var selectmenu = $.widget( "ui.selectmenu", {
		version: "1.11.4",
		defaultElement: "<select>",
		options: {
			appendTo: null,
			disabled: null,
			icons: {
				button: "ui-icon-triangle-1-s"
			},
			position: {
				my: "left top",
				at: "left bottom",
				collision: "none"
			},
			width: null,
	
			// callbacks
			change: null,
			close: null,
			focus: null,
			open: null,
			select: null
		},
	
		_create: function() {
			var selectmenuId = this.element.uniqueId().attr( "id" );
			this.ids = {
				element: selectmenuId,
				button: selectmenuId + "-button",
				menu: selectmenuId + "-menu"
			};
	
			this._drawButton();
			this._drawMenu();
	
			if ( this.options.disabled ) {
				this.disable();
			}
		},
	
		_drawButton: function() {
			var that = this;
	
			// Associate existing label with the new button
			this.label = $( "label[for='" + this.ids.element + "']" ).attr( "for", this.ids.button );
			this._on( this.label, {
				click: function( event ) {
					this.button.focus();
					event.preventDefault();
				}
			});
	
			// Hide original select element
			this.element.hide();
	
			// Create button
			this.button = $( "<span>", {
				"class": "ui-selectmenu-button ui-widget ui-state-default ui-corner-all",
				tabindex: this.options.disabled ? -1 : 0,
				id: this.ids.button,
				role: "combobox",
				"aria-expanded": "false",
				"aria-autocomplete": "list",
				"aria-owns": this.ids.menu,
				"aria-haspopup": "true"
			})
				.insertAfter( this.element );
	
			$( "<span>", {
				"class": "ui-icon " + this.options.icons.button
			})
				.prependTo( this.button );
	
			this.buttonText = $( "<span>", {
				"class": "ui-selectmenu-text"
			})
				.appendTo( this.button );
	
			this._setText( this.buttonText, this.element.find( "option:selected" ).text() );
			this._resizeButton();
	
			this._on( this.button, this._buttonEvents );
			this.button.one( "focusin", function() {
	
				// Delay rendering the menu items until the button receives focus.
				// The menu may have already been rendered via a programmatic open.
				if ( !that.menuItems ) {
					that._refreshMenu();
				}
			});
			this._hoverable( this.button );
			this._focusable( this.button );
		},
	
		_drawMenu: function() {
			var that = this;
	
			// Create menu
			this.menu = $( "<ul>", {
				"aria-hidden": "true",
				"aria-labelledby": this.ids.button,
				id: this.ids.menu
			});
	
			// Wrap menu
			this.menuWrap = $( "<div>", {
				"class": "ui-selectmenu-menu ui-front"
			})
				.append( this.menu )
				.appendTo( this._appendTo() );
	
			// Initialize menu widget
			this.menuInstance = this.menu
				.menu({
					role: "listbox",
					select: function( event, ui ) {
						event.preventDefault();
	
						// support: IE8
						// If the item was selected via a click, the text selection
						// will be destroyed in IE
						that._setSelection();
	
						that._select( ui.item.data( "ui-selectmenu-item" ), event );
					},
					focus: function( event, ui ) {
						var item = ui.item.data( "ui-selectmenu-item" );
	
						// Prevent inital focus from firing and check if its a newly focused item
						if ( that.focusIndex != null && item.index !== that.focusIndex ) {
							that._trigger( "focus", event, { item: item } );
							if ( !that.isOpen ) {
								that._select( item, event );
							}
						}
						that.focusIndex = item.index;
	
						that.button.attr( "aria-activedescendant",
							that.menuItems.eq( item.index ).attr( "id" ) );
					}
				})
				.menu( "instance" );
	
			// Adjust menu styles to dropdown
			this.menu
				.addClass( "ui-corner-bottom" )
				.removeClass( "ui-corner-all" );
	
			// Don't close the menu on mouseleave
			this.menuInstance._off( this.menu, "mouseleave" );
	
			// Cancel the menu's collapseAll on document click
			this.menuInstance._closeOnDocumentClick = function() {
				return false;
			};
	
			// Selects often contain empty items, but never contain dividers
			this.menuInstance._isDivider = function() {
				return false;
			};
		},
	
		refresh: function() {
			this._refreshMenu();
			this._setText( this.buttonText, this._getSelectedItem().text() );
			if ( !this.options.width ) {
				this._resizeButton();
			}
		},
	
		_refreshMenu: function() {
			this.menu.empty();
	
			var item,
				options = this.element.find( "option" );
	
			if ( !options.length ) {
				return;
			}
	
			this._parseOptions( options );
			this._renderMenu( this.menu, this.items );
	
			this.menuInstance.refresh();
			this.menuItems = this.menu.find( "li" ).not( ".ui-selectmenu-optgroup" );
	
			item = this._getSelectedItem();
	
			// Update the menu to have the correct item focused
			this.menuInstance.focus( null, item );
			this._setAria( item.data( "ui-selectmenu-item" ) );
	
			// Set disabled state
			this._setOption( "disabled", this.element.prop( "disabled" ) );
		},
	
		open: function( event ) {
			if ( this.options.disabled ) {
				return;
			}
	
			// If this is the first time the menu is being opened, render the items
			if ( !this.menuItems ) {
				this._refreshMenu();
			} else {
	
				// Menu clears focus on close, reset focus to selected item
				this.menu.find( ".ui-state-focus" ).removeClass( "ui-state-focus" );
				this.menuInstance.focus( null, this._getSelectedItem() );
			}
	
			this.isOpen = true;
			this._toggleAttr();
			this._resizeMenu();
			this._position();
	
			this._on( this.document, this._documentClick );
	
			this._trigger( "open", event );
		},
	
		_position: function() {
			this.menuWrap.position( $.extend( { of: this.button }, this.options.position ) );
		},
	
		close: function( event ) {
			if ( !this.isOpen ) {
				return;
			}
	
			this.isOpen = false;
			this._toggleAttr();
	
			this.range = null;
			this._off( this.document );
	
			this._trigger( "close", event );
		},
	
		widget: function() {
			return this.button;
		},
	
		menuWidget: function() {
			return this.menu;
		},
	
		_renderMenu: function( ul, items ) {
			var that = this,
				currentOptgroup = "";
	
			$.each( items, function( index, item ) {
				if ( item.optgroup !== currentOptgroup ) {
					$( "<li>", {
						"class": "ui-selectmenu-optgroup ui-menu-divider" +
							( item.element.parent( "optgroup" ).prop( "disabled" ) ?
								" ui-state-disabled" :
								"" ),
						text: item.optgroup
					})
						.appendTo( ul );
	
					currentOptgroup = item.optgroup;
				}
	
				that._renderItemData( ul, item );
			});
		},
	
		_renderItemData: function( ul, item ) {
			return this._renderItem( ul, item ).data( "ui-selectmenu-item", item );
		},
	
		_renderItem: function( ul, item ) {
			var li = $( "<li>" );
	
			if ( item.disabled ) {
				li.addClass( "ui-state-disabled" );
			}
			this._setText( li, item.label );
	
			return li.appendTo( ul );
		},
	
		_setText: function( element, value ) {
			if ( value ) {
				element.text( value );
			} else {
				element.html( "&#160;" );
			}
		},
	
		_move: function( direction, event ) {
			var item, next,
				filter = ".ui-menu-item";
	
			if ( this.isOpen ) {
				item = this.menuItems.eq( this.focusIndex );
			} else {
				item = this.menuItems.eq( this.element[ 0 ].selectedIndex );
				filter += ":not(.ui-state-disabled)";
			}
	
			if ( direction === "first" || direction === "last" ) {
				next = item[ direction === "first" ? "prevAll" : "nextAll" ]( filter ).eq( -1 );
			} else {
				next = item[ direction + "All" ]( filter ).eq( 0 );
			}
	
			if ( next.length ) {
				this.menuInstance.focus( event, next );
			}
		},
	
		_getSelectedItem: function() {
			return this.menuItems.eq( this.element[ 0 ].selectedIndex );
		},
	
		_toggle: function( event ) {
			this[ this.isOpen ? "close" : "open" ]( event );
		},
	
		_setSelection: function() {
			var selection;
	
			if ( !this.range ) {
				return;
			}
	
			if ( window.getSelection ) {
				selection = window.getSelection();
				selection.removeAllRanges();
				selection.addRange( this.range );
	
			// support: IE8
			} else {
				this.range.select();
			}
	
			// support: IE
			// Setting the text selection kills the button focus in IE, but
			// restoring the focus doesn't kill the selection.
			this.button.focus();
		},
	
		_documentClick: {
			mousedown: function( event ) {
				if ( !this.isOpen ) {
					return;
				}
	
				if ( !$( event.target ).closest( ".ui-selectmenu-menu, #" + this.ids.button ).length ) {
					this.close( event );
				}
			}
		},
	
		_buttonEvents: {
	
			// Prevent text selection from being reset when interacting with the selectmenu (#10144)
			mousedown: function() {
				var selection;
	
				if ( window.getSelection ) {
					selection = window.getSelection();
					if ( selection.rangeCount ) {
						this.range = selection.getRangeAt( 0 );
					}
	
				// support: IE8
				} else {
					this.range = document.selection.createRange();
				}
			},
	
			click: function( event ) {
				this._setSelection();
				this._toggle( event );
			},
	
			keydown: function( event ) {
				var preventDefault = true;
				switch ( event.keyCode ) {
					case $.ui.keyCode.TAB:
					case $.ui.keyCode.ESCAPE:
						this.close( event );
						preventDefault = false;
						break;
					case $.ui.keyCode.ENTER:
						if ( this.isOpen ) {
							this._selectFocusedItem( event );
						}
						break;
					case $.ui.keyCode.UP:
						if ( event.altKey ) {
							this._toggle( event );
						} else {
							this._move( "prev", event );
						}
						break;
					case $.ui.keyCode.DOWN:
						if ( event.altKey ) {
							this._toggle( event );
						} else {
							this._move( "next", event );
						}
						break;
					case $.ui.keyCode.SPACE:
						if ( this.isOpen ) {
							this._selectFocusedItem( event );
						} else {
							this._toggle( event );
						}
						break;
					case $.ui.keyCode.LEFT:
						this._move( "prev", event );
						break;
					case $.ui.keyCode.RIGHT:
						this._move( "next", event );
						break;
					case $.ui.keyCode.HOME:
					case $.ui.keyCode.PAGE_UP:
						this._move( "first", event );
						break;
					case $.ui.keyCode.END:
					case $.ui.keyCode.PAGE_DOWN:
						this._move( "last", event );
						break;
					default:
						this.menu.trigger( event );
						preventDefault = false;
				}
	
				if ( preventDefault ) {
					event.preventDefault();
				}
			}
		},
	
		_selectFocusedItem: function( event ) {
			var item = this.menuItems.eq( this.focusIndex );
			if ( !item.hasClass( "ui-state-disabled" ) ) {
				this._select( item.data( "ui-selectmenu-item" ), event );
			}
		},
	
		_select: function( item, event ) {
			var oldIndex = this.element[ 0 ].selectedIndex;
	
			// Change native select element
			this.element[ 0 ].selectedIndex = item.index;
			this._setText( this.buttonText, item.label );
			this._setAria( item );
			this._trigger( "select", event, { item: item } );
	
			if ( item.index !== oldIndex ) {
				this._trigger( "change", event, { item: item } );
			}
	
			this.close( event );
		},
	
		_setAria: function( item ) {
			var id = this.menuItems.eq( item.index ).attr( "id" );
	
			this.button.attr({
				"aria-labelledby": id,
				"aria-activedescendant": id
			});
			this.menu.attr( "aria-activedescendant", id );
		},
	
		_setOption: function( key, value ) {
			if ( key === "icons" ) {
				this.button.find( "span.ui-icon" )
					.removeClass( this.options.icons.button )
					.addClass( value.button );
			}
	
			this._super( key, value );
	
			if ( key === "appendTo" ) {
				this.menuWrap.appendTo( this._appendTo() );
			}
	
			if ( key === "disabled" ) {
				this.menuInstance.option( "disabled", value );
				this.button
					.toggleClass( "ui-state-disabled", value )
					.attr( "aria-disabled", value );
	
				this.element.prop( "disabled", value );
				if ( value ) {
					this.button.attr( "tabindex", -1 );
					this.close();
				} else {
					this.button.attr( "tabindex", 0 );
				}
			}
	
			if ( key === "width" ) {
				this._resizeButton();
			}
		},
	
		_appendTo: function() {
			var element = this.options.appendTo;
	
			if ( element ) {
				element = element.jquery || element.nodeType ?
					$( element ) :
					this.document.find( element ).eq( 0 );
			}
	
			if ( !element || !element[ 0 ] ) {
				element = this.element.closest( ".ui-front" );
			}
	
			if ( !element.length ) {
				element = this.document[ 0 ].body;
			}
	
			return element;
		},
	
		_toggleAttr: function() {
			this.button
				.toggleClass( "ui-corner-top", this.isOpen )
				.toggleClass( "ui-corner-all", !this.isOpen )
				.attr( "aria-expanded", this.isOpen );
			this.menuWrap.toggleClass( "ui-selectmenu-open", this.isOpen );
			this.menu.attr( "aria-hidden", !this.isOpen );
		},
	
		_resizeButton: function() {
			var width = this.options.width;
	
			if ( !width ) {
				width = this.element.show().outerWidth();
				this.element.hide();
			}
	
			this.button.outerWidth( width );
		},
	
		_resizeMenu: function() {
			this.menu.outerWidth( Math.max(
				this.button.outerWidth(),
	
				// support: IE10
				// IE10 wraps long text (possibly a rounding bug)
				// so we add 1px to avoid the wrapping
				this.menu.width( "" ).outerWidth() + 1
			) );
		},
	
		_getCreateOptions: function() {
			return { disabled: this.element.prop( "disabled" ) };
		},
	
		_parseOptions: function( options ) {
			var data = [];
			options.each(function( index, item ) {
				var option = $( item ),
					optgroup = option.parent( "optgroup" );
				data.push({
					element: option,
					index: index,
					value: option.val(),
					label: option.text(),
					optgroup: optgroup.attr( "label" ) || "",
					disabled: optgroup.prop( "disabled" ) || option.prop( "disabled" )
				});
			});
			this.items = data;
		},
	
		_destroy: function() {
			this.menuWrap.remove();
			this.button.remove();
			this.element.show();
			this.element.removeUniqueId();
			this.label.attr( "for", this.ids.element );
		}
	});
	
	
	/*!
	 * jQuery UI Slider 1.11.4
	 * http://jqueryui.com
	 *
	 * Copyright jQuery Foundation and other contributors
	 * Released under the MIT license.
	 * http://jquery.org/license
	 *
	 * http://api.jqueryui.com/slider/
	 */
	
	
	var slider = $.widget( "ui.slider", $.ui.mouse, {
		version: "1.11.4",
		widgetEventPrefix: "slide",
	
		options: {
			animate: false,
			distance: 0,
			max: 100,
			min: 0,
			orientation: "horizontal",
			range: false,
			step: 1,
			value: 0,
			values: null,
	
			// callbacks
			change: null,
			slide: null,
			start: null,
			stop: null
		},
	
		// number of pages in a slider
		// (how many times can you page up/down to go through the whole range)
		numPages: 5,
	
		_create: function() {
			this._keySliding = false;
			this._mouseSliding = false;
			this._animateOff = true;
			this._handleIndex = null;
			this._detectOrientation();
			this._mouseInit();
			this._calculateNewMax();
	
			this.element
				.addClass( "ui-slider" +
					" ui-slider-" + this.orientation +
					" ui-widget" +
					" ui-widget-content" +
					" ui-corner-all");
	
			this._refresh();
			this._setOption( "disabled", this.options.disabled );
	
			this._animateOff = false;
		},
	
		_refresh: function() {
			this._createRange();
			this._createHandles();
			this._setupEvents();
			this._refreshValue();
		},
	
		_createHandles: function() {
			var i, handleCount,
				options = this.options,
				existingHandles = this.element.find( ".ui-slider-handle" ).addClass( "ui-state-default ui-corner-all" ),
				handle = "<span class='ui-slider-handle ui-state-default ui-corner-all' tabindex='0'></span>",
				handles = [];
	
			handleCount = ( options.values && options.values.length ) || 1;
	
			if ( existingHandles.length > handleCount ) {
				existingHandles.slice( handleCount ).remove();
				existingHandles = existingHandles.slice( 0, handleCount );
			}
	
			for ( i = existingHandles.length; i < handleCount; i++ ) {
				handles.push( handle );
			}
	
			this.handles = existingHandles.add( $( handles.join( "" ) ).appendTo( this.element ) );
	
			this.handle = this.handles.eq( 0 );
	
			this.handles.each(function( i ) {
				$( this ).data( "ui-slider-handle-index", i );
			});
		},
	
		_createRange: function() {
			var options = this.options,
				classes = "";
	
			if ( options.range ) {
				if ( options.range === true ) {
					if ( !options.values ) {
						options.values = [ this._valueMin(), this._valueMin() ];
					} else if ( options.values.length && options.values.length !== 2 ) {
						options.values = [ options.values[0], options.values[0] ];
					} else if ( $.isArray( options.values ) ) {
						options.values = options.values.slice(0);
					}
				}
	
				if ( !this.range || !this.range.length ) {
					this.range = $( "<div></div>" )
						.appendTo( this.element );
	
					classes = "ui-slider-range" +
					// note: this isn't the most fittingly semantic framework class for this element,
					// but worked best visually with a variety of themes
					" ui-widget-header ui-corner-all";
				} else {
					this.range.removeClass( "ui-slider-range-min ui-slider-range-max" )
						// Handle range switching from true to min/max
						.css({
							"left": "",
							"bottom": ""
						});
				}
	
				this.range.addClass( classes +
					( ( options.range === "min" || options.range === "max" ) ? " ui-slider-range-" + options.range : "" ) );
			} else {
				if ( this.range ) {
					this.range.remove();
				}
				this.range = null;
			}
		},
	
		_setupEvents: function() {
			this._off( this.handles );
			this._on( this.handles, this._handleEvents );
			this._hoverable( this.handles );
			this._focusable( this.handles );
		},
	
		_destroy: function() {
			this.handles.remove();
			if ( this.range ) {
				this.range.remove();
			}
	
			this.element
				.removeClass( "ui-slider" +
					" ui-slider-horizontal" +
					" ui-slider-vertical" +
					" ui-widget" +
					" ui-widget-content" +
					" ui-corner-all" );
	
			this._mouseDestroy();
		},
	
		_mouseCapture: function( event ) {
			var position, normValue, distance, closestHandle, index, allowed, offset, mouseOverHandle,
				that = this,
				o = this.options;
	
			if ( o.disabled ) {
				return false;
			}
	
			this.elementSize = {
				width: this.element.outerWidth(),
				height: this.element.outerHeight()
			};
			this.elementOffset = this.element.offset();
	
			position = { x: event.pageX, y: event.pageY };
			normValue = this._normValueFromMouse( position );
			distance = this._valueMax() - this._valueMin() + 1;
			this.handles.each(function( i ) {
				var thisDistance = Math.abs( normValue - that.values(i) );
				if (( distance > thisDistance ) ||
					( distance === thisDistance &&
						(i === that._lastChangedValue || that.values(i) === o.min ))) {
					distance = thisDistance;
					closestHandle = $( this );
					index = i;
				}
			});
	
			allowed = this._start( event, index );
			if ( allowed === false ) {
				return false;
			}
			this._mouseSliding = true;
	
			this._handleIndex = index;
	
			closestHandle
				.addClass( "ui-state-active" )
				.focus();
	
			offset = closestHandle.offset();
			mouseOverHandle = !$( event.target ).parents().addBack().is( ".ui-slider-handle" );
			this._clickOffset = mouseOverHandle ? { left: 0, top: 0 } : {
				left: event.pageX - offset.left - ( closestHandle.width() / 2 ),
				top: event.pageY - offset.top -
					( closestHandle.height() / 2 ) -
					( parseInt( closestHandle.css("borderTopWidth"), 10 ) || 0 ) -
					( parseInt( closestHandle.css("borderBottomWidth"), 10 ) || 0) +
					( parseInt( closestHandle.css("marginTop"), 10 ) || 0)
			};
	
			if ( !this.handles.hasClass( "ui-state-hover" ) ) {
				this._slide( event, index, normValue );
			}
			this._animateOff = true;
			return true;
		},
	
		_mouseStart: function() {
			return true;
		},
	
		_mouseDrag: function( event ) {
			var position = { x: event.pageX, y: event.pageY },
				normValue = this._normValueFromMouse( position );
	
			this._slide( event, this._handleIndex, normValue );
	
			return false;
		},
	
		_mouseStop: function( event ) {
			this.handles.removeClass( "ui-state-active" );
			this._mouseSliding = false;
	
			this._stop( event, this._handleIndex );
			this._change( event, this._handleIndex );
	
			this._handleIndex = null;
			this._clickOffset = null;
			this._animateOff = false;
	
			return false;
		},
	
		_detectOrientation: function() {
			this.orientation = ( this.options.orientation === "vertical" ) ? "vertical" : "horizontal";
		},
	
		_normValueFromMouse: function( position ) {
			var pixelTotal,
				pixelMouse,
				percentMouse,
				valueTotal,
				valueMouse;
	
			if ( this.orientation === "horizontal" ) {
				pixelTotal = this.elementSize.width;
				pixelMouse = position.x - this.elementOffset.left - ( this._clickOffset ? this._clickOffset.left : 0 );
			} else {
				pixelTotal = this.elementSize.height;
				pixelMouse = position.y - this.elementOffset.top - ( this._clickOffset ? this._clickOffset.top : 0 );
			}
	
			percentMouse = ( pixelMouse / pixelTotal );
			if ( percentMouse > 1 ) {
				percentMouse = 1;
			}
			if ( percentMouse < 0 ) {
				percentMouse = 0;
			}
			if ( this.orientation === "vertical" ) {
				percentMouse = 1 - percentMouse;
			}
	
			valueTotal = this._valueMax() - this._valueMin();
			valueMouse = this._valueMin() + percentMouse * valueTotal;
	
			return this._trimAlignValue( valueMouse );
		},
	
		_start: function( event, index ) {
			var uiHash = {
				handle: this.handles[ index ],
				value: this.value()
			};
			if ( this.options.values && this.options.values.length ) {
				uiHash.value = this.values( index );
				uiHash.values = this.values();
			}
			return this._trigger( "start", event, uiHash );
		},
	
		_slide: function( event, index, newVal ) {
			var otherVal,
				newValues,
				allowed;
	
			if ( this.options.values && this.options.values.length ) {
				otherVal = this.values( index ? 0 : 1 );
	
				if ( ( this.options.values.length === 2 && this.options.range === true ) &&
						( ( index === 0 && newVal > otherVal) || ( index === 1 && newVal < otherVal ) )
					) {
					newVal = otherVal;
				}
	
				if ( newVal !== this.values( index ) ) {
					newValues = this.values();
					newValues[ index ] = newVal;
					// A slide can be canceled by returning false from the slide callback
					allowed = this._trigger( "slide", event, {
						handle: this.handles[ index ],
						value: newVal,
						values: newValues
					} );
					otherVal = this.values( index ? 0 : 1 );
					if ( allowed !== false ) {
						this.values( index, newVal );
					}
				}
			} else {
				if ( newVal !== this.value() ) {
					// A slide can be canceled by returning false from the slide callback
					allowed = this._trigger( "slide", event, {
						handle: this.handles[ index ],
						value: newVal
					} );
					if ( allowed !== false ) {
						this.value( newVal );
					}
				}
			}
		},
	
		_stop: function( event, index ) {
			var uiHash = {
				handle: this.handles[ index ],
				value: this.value()
			};
			if ( this.options.values && this.options.values.length ) {
				uiHash.value = this.values( index );
				uiHash.values = this.values();
			}
	
			this._trigger( "stop", event, uiHash );
		},
	
		_change: function( event, index ) {
			if ( !this._keySliding && !this._mouseSliding ) {
				var uiHash = {
					handle: this.handles[ index ],
					value: this.value()
				};
				if ( this.options.values && this.options.values.length ) {
					uiHash.value = this.values( index );
					uiHash.values = this.values();
				}
	
				//store the last changed value index for reference when handles overlap
				this._lastChangedValue = index;
	
				this._trigger( "change", event, uiHash );
			}
		},
	
		value: function( newValue ) {
			if ( arguments.length ) {
				this.options.value = this._trimAlignValue( newValue );
				this._refreshValue();
				this._change( null, 0 );
				return;
			}
	
			return this._value();
		},
	
		values: function( index, newValue ) {
			var vals,
				newValues,
				i;
	
			if ( arguments.length > 1 ) {
				this.options.values[ index ] = this._trimAlignValue( newValue );
				this._refreshValue();
				this._change( null, index );
				return;
			}
	
			if ( arguments.length ) {
				if ( $.isArray( arguments[ 0 ] ) ) {
					vals = this.options.values;
					newValues = arguments[ 0 ];
					for ( i = 0; i < vals.length; i += 1 ) {
						vals[ i ] = this._trimAlignValue( newValues[ i ] );
						this._change( null, i );
					}
					this._refreshValue();
				} else {
					if ( this.options.values && this.options.values.length ) {
						return this._values( index );
					} else {
						return this.value();
					}
				}
			} else {
				return this._values();
			}
		},
	
		_setOption: function( key, value ) {
			var i,
				valsLength = 0;
	
			if ( key === "range" && this.options.range === true ) {
				if ( value === "min" ) {
					this.options.value = this._values( 0 );
					this.options.values = null;
				} else if ( value === "max" ) {
					this.options.value = this._values( this.options.values.length - 1 );
					this.options.values = null;
				}
			}
	
			if ( $.isArray( this.options.values ) ) {
				valsLength = this.options.values.length;
			}
	
			if ( key === "disabled" ) {
				this.element.toggleClass( "ui-state-disabled", !!value );
			}
	
			this._super( key, value );
	
			switch ( key ) {
				case "orientation":
					this._detectOrientation();
					this.element
						.removeClass( "ui-slider-horizontal ui-slider-vertical" )
						.addClass( "ui-slider-" + this.orientation );
					this._refreshValue();
	
					// Reset positioning from previous orientation
					this.handles.css( value === "horizontal" ? "bottom" : "left", "" );
					break;
				case "value":
					this._animateOff = true;
					this._refreshValue();
					this._change( null, 0 );
					this._animateOff = false;
					break;
				case "values":
					this._animateOff = true;
					this._refreshValue();
					for ( i = 0; i < valsLength; i += 1 ) {
						this._change( null, i );
					}
					this._animateOff = false;
					break;
				case "step":
				case "min":
				case "max":
					this._animateOff = true;
					this._calculateNewMax();
					this._refreshValue();
					this._animateOff = false;
					break;
				case "range":
					this._animateOff = true;
					this._refresh();
					this._animateOff = false;
					break;
			}
		},
	
		//internal value getter
		// _value() returns value trimmed by min and max, aligned by step
		_value: function() {
			var val = this.options.value;
			val = this._trimAlignValue( val );
	
			return val;
		},
	
		//internal values getter
		// _values() returns array of values trimmed by min and max, aligned by step
		// _values( index ) returns single value trimmed by min and max, aligned by step
		_values: function( index ) {
			var val,
				vals,
				i;
	
			if ( arguments.length ) {
				val = this.options.values[ index ];
				val = this._trimAlignValue( val );
	
				return val;
			} else if ( this.options.values && this.options.values.length ) {
				// .slice() creates a copy of the array
				// this copy gets trimmed by min and max and then returned
				vals = this.options.values.slice();
				for ( i = 0; i < vals.length; i += 1) {
					vals[ i ] = this._trimAlignValue( vals[ i ] );
				}
	
				return vals;
			} else {
				return [];
			}
		},
	
		// returns the step-aligned value that val is closest to, between (inclusive) min and max
		_trimAlignValue: function( val ) {
			if ( val <= this._valueMin() ) {
				return this._valueMin();
			}
			if ( val >= this._valueMax() ) {
				return this._valueMax();
			}
			var step = ( this.options.step > 0 ) ? this.options.step : 1,
				valModStep = (val - this._valueMin()) % step,
				alignValue = val - valModStep;
	
			if ( Math.abs(valModStep) * 2 >= step ) {
				alignValue += ( valModStep > 0 ) ? step : ( -step );
			}
	
			// Since JavaScript has problems with large floats, round
			// the final value to 5 digits after the decimal point (see #4124)
			return parseFloat( alignValue.toFixed(5) );
		},
	
		_calculateNewMax: function() {
			var max = this.options.max,
				min = this._valueMin(),
				step = this.options.step,
				aboveMin = Math.floor( ( +( max - min ).toFixed( this._precision() ) ) / step ) * step;
			max = aboveMin + min;
			this.max = parseFloat( max.toFixed( this._precision() ) );
		},
	
		_precision: function() {
			var precision = this._precisionOf( this.options.step );
			if ( this.options.min !== null ) {
				precision = Math.max( precision, this._precisionOf( this.options.min ) );
			}
			return precision;
		},
	
		_precisionOf: function( num ) {
			var str = num.toString(),
				decimal = str.indexOf( "." );
			return decimal === -1 ? 0 : str.length - decimal - 1;
		},
	
		_valueMin: function() {
			return this.options.min;
		},
	
		_valueMax: function() {
			return this.max;
		},
	
		_refreshValue: function() {
			var lastValPercent, valPercent, value, valueMin, valueMax,
				oRange = this.options.range,
				o = this.options,
				that = this,
				animate = ( !this._animateOff ) ? o.animate : false,
				_set = {};
	
			if ( this.options.values && this.options.values.length ) {
				this.handles.each(function( i ) {
					valPercent = ( that.values(i) - that._valueMin() ) / ( that._valueMax() - that._valueMin() ) * 100;
					_set[ that.orientation === "horizontal" ? "left" : "bottom" ] = valPercent + "%";
					$( this ).stop( 1, 1 )[ animate ? "animate" : "css" ]( _set, o.animate );
					if ( that.options.range === true ) {
						if ( that.orientation === "horizontal" ) {
							if ( i === 0 ) {
								that.range.stop( 1, 1 )[ animate ? "animate" : "css" ]( { left: valPercent + "%" }, o.animate );
							}
							if ( i === 1 ) {
								that.range[ animate ? "animate" : "css" ]( { width: ( valPercent - lastValPercent ) + "%" }, { queue: false, duration: o.animate } );
							}
						} else {
							if ( i === 0 ) {
								that.range.stop( 1, 1 )[ animate ? "animate" : "css" ]( { bottom: ( valPercent ) + "%" }, o.animate );
							}
							if ( i === 1 ) {
								that.range[ animate ? "animate" : "css" ]( { height: ( valPercent - lastValPercent ) + "%" }, { queue: false, duration: o.animate } );
							}
						}
					}
					lastValPercent = valPercent;
				});
			} else {
				value = this.value();
				valueMin = this._valueMin();
				valueMax = this._valueMax();
				valPercent = ( valueMax !== valueMin ) ?
						( value - valueMin ) / ( valueMax - valueMin ) * 100 :
						0;
				_set[ this.orientation === "horizontal" ? "left" : "bottom" ] = valPercent + "%";
				this.handle.stop( 1, 1 )[ animate ? "animate" : "css" ]( _set, o.animate );
	
				if ( oRange === "min" && this.orientation === "horizontal" ) {
					this.range.stop( 1, 1 )[ animate ? "animate" : "css" ]( { width: valPercent + "%" }, o.animate );
				}
				if ( oRange === "max" && this.orientation === "horizontal" ) {
					this.range[ animate ? "animate" : "css" ]( { width: ( 100 - valPercent ) + "%" }, { queue: false, duration: o.animate } );
				}
				if ( oRange === "min" && this.orientation === "vertical" ) {
					this.range.stop( 1, 1 )[ animate ? "animate" : "css" ]( { height: valPercent + "%" }, o.animate );
				}
				if ( oRange === "max" && this.orientation === "vertical" ) {
					this.range[ animate ? "animate" : "css" ]( { height: ( 100 - valPercent ) + "%" }, { queue: false, duration: o.animate } );
				}
			}
		},
	
		_handleEvents: {
			keydown: function( event ) {
				var allowed, curVal, newVal, step,
					index = $( event.target ).data( "ui-slider-handle-index" );
	
				switch ( event.keyCode ) {
					case $.ui.keyCode.HOME:
					case $.ui.keyCode.END:
					case $.ui.keyCode.PAGE_UP:
					case $.ui.keyCode.PAGE_DOWN:
					case $.ui.keyCode.UP:
					case $.ui.keyCode.RIGHT:
					case $.ui.keyCode.DOWN:
					case $.ui.keyCode.LEFT:
						event.preventDefault();
						if ( !this._keySliding ) {
							this._keySliding = true;
							$( event.target ).addClass( "ui-state-active" );
							allowed = this._start( event, index );
							if ( allowed === false ) {
								return;
							}
						}
						break;
				}
	
				step = this.options.step;
				if ( this.options.values && this.options.values.length ) {
					curVal = newVal = this.values( index );
				} else {
					curVal = newVal = this.value();
				}
	
				switch ( event.keyCode ) {
					case $.ui.keyCode.HOME:
						newVal = this._valueMin();
						break;
					case $.ui.keyCode.END:
						newVal = this._valueMax();
						break;
					case $.ui.keyCode.PAGE_UP:
						newVal = this._trimAlignValue(
							curVal + ( ( this._valueMax() - this._valueMin() ) / this.numPages )
						);
						break;
					case $.ui.keyCode.PAGE_DOWN:
						newVal = this._trimAlignValue(
							curVal - ( (this._valueMax() - this._valueMin()) / this.numPages ) );
						break;
					case $.ui.keyCode.UP:
					case $.ui.keyCode.RIGHT:
						if ( curVal === this._valueMax() ) {
							return;
						}
						newVal = this._trimAlignValue( curVal + step );
						break;
					case $.ui.keyCode.DOWN:
					case $.ui.keyCode.LEFT:
						if ( curVal === this._valueMin() ) {
							return;
						}
						newVal = this._trimAlignValue( curVal - step );
						break;
				}
	
				this._slide( event, index, newVal );
			},
			keyup: function( event ) {
				var index = $( event.target ).data( "ui-slider-handle-index" );
	
				if ( this._keySliding ) {
					this._keySliding = false;
					this._stop( event, index );
					this._change( event, index );
					$( event.target ).removeClass( "ui-state-active" );
				}
			}
		}
	});
	
	
	/*!
	 * jQuery UI Sortable 1.11.4
	 * http://jqueryui.com
	 *
	 * Copyright jQuery Foundation and other contributors
	 * Released under the MIT license.
	 * http://jquery.org/license
	 *
	 * http://api.jqueryui.com/sortable/
	 */
	
	
	var sortable = $.widget("ui.sortable", $.ui.mouse, {
		version: "1.11.4",
		widgetEventPrefix: "sort",
		ready: false,
		options: {
			appendTo: "parent",
			axis: false,
			connectWith: false,
			containment: false,
			cursor: "auto",
			cursorAt: false,
			dropOnEmpty: true,
			forcePlaceholderSize: false,
			forceHelperSize: false,
			grid: false,
			handle: false,
			helper: "original",
			items: "> *",
			opacity: false,
			placeholder: false,
			revert: false,
			scroll: true,
			scrollSensitivity: 20,
			scrollSpeed: 20,
			scope: "default",
			tolerance: "intersect",
			zIndex: 1000,
	
			// callbacks
			activate: null,
			beforeStop: null,
			change: null,
			deactivate: null,
			out: null,
			over: null,
			receive: null,
			remove: null,
			sort: null,
			start: null,
			stop: null,
			update: null
		},
	
		_isOverAxis: function( x, reference, size ) {
			return ( x >= reference ) && ( x < ( reference + size ) );
		},
	
		_isFloating: function( item ) {
			return (/left|right/).test(item.css("float")) || (/inline|table-cell/).test(item.css("display"));
		},
	
		_create: function() {
			this.containerCache = {};
			this.element.addClass("ui-sortable");
	
			//Get the items
			this.refresh();
	
			//Let's determine the parent's offset
			this.offset = this.element.offset();
	
			//Initialize mouse events for interaction
			this._mouseInit();
	
			this._setHandleClassName();
	
			//We're ready to go
			this.ready = true;
	
		},
	
		_setOption: function( key, value ) {
			this._super( key, value );
	
			if ( key === "handle" ) {
				this._setHandleClassName();
			}
		},
	
		_setHandleClassName: function() {
			this.element.find( ".ui-sortable-handle" ).removeClass( "ui-sortable-handle" );
			$.each( this.items, function() {
				( this.instance.options.handle ?
					this.item.find( this.instance.options.handle ) : this.item )
					.addClass( "ui-sortable-handle" );
			});
		},
	
		_destroy: function() {
			this.element
				.removeClass( "ui-sortable ui-sortable-disabled" )
				.find( ".ui-sortable-handle" )
					.removeClass( "ui-sortable-handle" );
			this._mouseDestroy();
	
			for ( var i = this.items.length - 1; i >= 0; i-- ) {
				this.items[i].item.removeData(this.widgetName + "-item");
			}
	
			return this;
		},
	
		_mouseCapture: function(event, overrideHandle) {
			var currentItem = null,
				validHandle = false,
				that = this;
	
			if (this.reverting) {
				return false;
			}
	
			if(this.options.disabled || this.options.type === "static") {
				return false;
			}
	
			//We have to refresh the items data once first
			this._refreshItems(event);
	
			//Find out if the clicked node (or one of its parents) is a actual item in this.items
			$(event.target).parents().each(function() {
				if($.data(this, that.widgetName + "-item") === that) {
					currentItem = $(this);
					return false;
				}
			});
			if($.data(event.target, that.widgetName + "-item") === that) {
				currentItem = $(event.target);
			}
	
			if(!currentItem) {
				return false;
			}
			if(this.options.handle && !overrideHandle) {
				$(this.options.handle, currentItem).find("*").addBack().each(function() {
					if(this === event.target) {
						validHandle = true;
					}
				});
				if(!validHandle) {
					return false;
				}
			}
	
			this.currentItem = currentItem;
			this._removeCurrentsFromItems();
			return true;
	
		},
	
		_mouseStart: function(event, overrideHandle, noActivation) {
	
			var i, body,
				o = this.options;
	
			this.currentContainer = this;
	
			//We only need to call refreshPositions, because the refreshItems call has been moved to mouseCapture
			this.refreshPositions();
	
			//Create and append the visible helper
			this.helper = this._createHelper(event);
	
			//Cache the helper size
			this._cacheHelperProportions();
	
			/*
			 * - Position generation -
			 * This block generates everything position related - it's the core of draggables.
			 */
	
			//Cache the margins of the original element
			this._cacheMargins();
	
			//Get the next scrolling parent
			this.scrollParent = this.helper.scrollParent();
	
			//The element's absolute position on the page minus margins
			this.offset = this.currentItem.offset();
			this.offset = {
				top: this.offset.top - this.margins.top,
				left: this.offset.left - this.margins.left
			};
	
			$.extend(this.offset, {
				click: { //Where the click happened, relative to the element
					left: event.pageX - this.offset.left,
					top: event.pageY - this.offset.top
				},
				parent: this._getParentOffset(),
				relative: this._getRelativeOffset() //This is a relative to absolute position minus the actual position calculation - only used for relative positioned helper
			});
	
			// Only after we got the offset, we can change the helper's position to absolute
			// TODO: Still need to figure out a way to make relative sorting possible
			this.helper.css("position", "absolute");
			this.cssPosition = this.helper.css("position");
	
			//Generate the original position
			this.originalPosition = this._generatePosition(event);
			this.originalPageX = event.pageX;
			this.originalPageY = event.pageY;
	
			//Adjust the mouse offset relative to the helper if "cursorAt" is supplied
			(o.cursorAt && this._adjustOffsetFromHelper(o.cursorAt));
	
			//Cache the former DOM position
			this.domPosition = { prev: this.currentItem.prev()[0], parent: this.currentItem.parent()[0] };
	
			//If the helper is not the original, hide the original so it's not playing any role during the drag, won't cause anything bad this way
			if(this.helper[0] !== this.currentItem[0]) {
				this.currentItem.hide();
			}
	
			//Create the placeholder
			this._createPlaceholder();
	
			//Set a containment if given in the options
			if(o.containment) {
				this._setContainment();
			}
	
			if( o.cursor && o.cursor !== "auto" ) { // cursor option
				body = this.document.find( "body" );
	
				// support: IE
				this.storedCursor = body.css( "cursor" );
				body.css( "cursor", o.cursor );
	
				this.storedStylesheet = $( "<style>*{ cursor: "+o.cursor+" !important; }</style>" ).appendTo( body );
			}
	
			if(o.opacity) { // opacity option
				if (this.helper.css("opacity")) {
					this._storedOpacity = this.helper.css("opacity");
				}
				this.helper.css("opacity", o.opacity);
			}
	
			if(o.zIndex) { // zIndex option
				if (this.helper.css("zIndex")) {
					this._storedZIndex = this.helper.css("zIndex");
				}
				this.helper.css("zIndex", o.zIndex);
			}
	
			//Prepare scrolling
			if(this.scrollParent[0] !== this.document[0] && this.scrollParent[0].tagName !== "HTML") {
				this.overflowOffset = this.scrollParent.offset();
			}
	
			//Call callbacks
			this._trigger("start", event, this._uiHash());
	
			//Recache the helper size
			if(!this._preserveHelperProportions) {
				this._cacheHelperProportions();
			}
	
	
			//Post "activate" events to possible containers
			if( !noActivation ) {
				for ( i = this.containers.length - 1; i >= 0; i-- ) {
					this.containers[ i ]._trigger( "activate", event, this._uiHash( this ) );
				}
			}
	
			//Prepare possible droppables
			if($.ui.ddmanager) {
				$.ui.ddmanager.current = this;
			}
	
			if ($.ui.ddmanager && !o.dropBehaviour) {
				$.ui.ddmanager.prepareOffsets(this, event);
			}
	
			this.dragging = true;
	
			this.helper.addClass("ui-sortable-helper");
			this._mouseDrag(event); //Execute the drag once - this causes the helper not to be visible before getting its correct position
			return true;
	
		},
	
		_mouseDrag: function(event) {
			var i, item, itemElement, intersection,
				o = this.options,
				scrolled = false;
	
			//Compute the helpers position
			this.position = this._generatePosition(event);
			this.positionAbs = this._convertPositionTo("absolute");
	
			if (!this.lastPositionAbs) {
				this.lastPositionAbs = this.positionAbs;
			}
	
			//Do scrolling
			if(this.options.scroll) {
				if(this.scrollParent[0] !== this.document[0] && this.scrollParent[0].tagName !== "HTML") {
	
					if((this.overflowOffset.top + this.scrollParent[0].offsetHeight) - event.pageY < o.scrollSensitivity) {
						this.scrollParent[0].scrollTop = scrolled = this.scrollParent[0].scrollTop + o.scrollSpeed;
					} else if(event.pageY - this.overflowOffset.top < o.scrollSensitivity) {
						this.scrollParent[0].scrollTop = scrolled = this.scrollParent[0].scrollTop - o.scrollSpeed;
					}
	
					if((this.overflowOffset.left + this.scrollParent[0].offsetWidth) - event.pageX < o.scrollSensitivity) {
						this.scrollParent[0].scrollLeft = scrolled = this.scrollParent[0].scrollLeft + o.scrollSpeed;
					} else if(event.pageX - this.overflowOffset.left < o.scrollSensitivity) {
						this.scrollParent[0].scrollLeft = scrolled = this.scrollParent[0].scrollLeft - o.scrollSpeed;
					}
	
				} else {
	
					if(event.pageY - this.document.scrollTop() < o.scrollSensitivity) {
						scrolled = this.document.scrollTop(this.document.scrollTop() - o.scrollSpeed);
					} else if(this.window.height() - (event.pageY - this.document.scrollTop()) < o.scrollSensitivity) {
						scrolled = this.document.scrollTop(this.document.scrollTop() + o.scrollSpeed);
					}
	
					if(event.pageX - this.document.scrollLeft() < o.scrollSensitivity) {
						scrolled = this.document.scrollLeft(this.document.scrollLeft() - o.scrollSpeed);
					} else if(this.window.width() - (event.pageX - this.document.scrollLeft()) < o.scrollSensitivity) {
						scrolled = this.document.scrollLeft(this.document.scrollLeft() + o.scrollSpeed);
					}
	
				}
	
				if(scrolled !== false && $.ui.ddmanager && !o.dropBehaviour) {
					$.ui.ddmanager.prepareOffsets(this, event);
				}
			}
	
			//Regenerate the absolute position used for position checks
			this.positionAbs = this._convertPositionTo("absolute");
	
			//Set the helper position
			if(!this.options.axis || this.options.axis !== "y") {
				this.helper[0].style.left = this.position.left+"px";
			}
			if(!this.options.axis || this.options.axis !== "x") {
				this.helper[0].style.top = this.position.top+"px";
			}
	
			//Rearrange
			for (i = this.items.length - 1; i >= 0; i--) {
	
				//Cache variables and intersection, continue if no intersection
				item = this.items[i];
				itemElement = item.item[0];
				intersection = this._intersectsWithPointer(item);
				if (!intersection) {
					continue;
				}
	
				// Only put the placeholder inside the current Container, skip all
				// items from other containers. This works because when moving
				// an item from one container to another the
				// currentContainer is switched before the placeholder is moved.
				//
				// Without this, moving items in "sub-sortables" can cause
				// the placeholder to jitter between the outer and inner container.
				if (item.instance !== this.currentContainer) {
					continue;
				}
	
				// cannot intersect with itself
				// no useless actions that have been done before
				// no action if the item moved is the parent of the item checked
				if (itemElement !== this.currentItem[0] &&
					this.placeholder[intersection === 1 ? "next" : "prev"]()[0] !== itemElement &&
					!$.contains(this.placeholder[0], itemElement) &&
					(this.options.type === "semi-dynamic" ? !$.contains(this.element[0], itemElement) : true)
				) {
	
					this.direction = intersection === 1 ? "down" : "up";
	
					if (this.options.tolerance === "pointer" || this._intersectsWithSides(item)) {
						this._rearrange(event, item);
					} else {
						break;
					}
	
					this._trigger("change", event, this._uiHash());
					break;
				}
			}
	
			//Post events to containers
			this._contactContainers(event);
	
			//Interconnect with droppables
			if($.ui.ddmanager) {
				$.ui.ddmanager.drag(this, event);
			}
	
			//Call callbacks
			this._trigger("sort", event, this._uiHash());
	
			this.lastPositionAbs = this.positionAbs;
			return false;
	
		},
	
		_mouseStop: function(event, noPropagation) {
	
			if(!event) {
				return;
			}
	
			//If we are using droppables, inform the manager about the drop
			if ($.ui.ddmanager && !this.options.dropBehaviour) {
				$.ui.ddmanager.drop(this, event);
			}
	
			if(this.options.revert) {
				var that = this,
					cur = this.placeholder.offset(),
					axis = this.options.axis,
					animation = {};
	
				if ( !axis || axis === "x" ) {
					animation.left = cur.left - this.offset.parent.left - this.margins.left + (this.offsetParent[0] === this.document[0].body ? 0 : this.offsetParent[0].scrollLeft);
				}
				if ( !axis || axis === "y" ) {
					animation.top = cur.top - this.offset.parent.top - this.margins.top + (this.offsetParent[0] === this.document[0].body ? 0 : this.offsetParent[0].scrollTop);
				}
				this.reverting = true;
				$(this.helper).animate( animation, parseInt(this.options.revert, 10) || 500, function() {
					that._clear(event);
				});
			} else {
				this._clear(event, noPropagation);
			}
	
			return false;
	
		},
	
		cancel: function() {
	
			if(this.dragging) {
	
				this._mouseUp({ target: null });
	
				if(this.options.helper === "original") {
					this.currentItem.css(this._storedCSS).removeClass("ui-sortable-helper");
				} else {
					this.currentItem.show();
				}
	
				//Post deactivating events to containers
				for (var i = this.containers.length - 1; i >= 0; i--){
					this.containers[i]._trigger("deactivate", null, this._uiHash(this));
					if(this.containers[i].containerCache.over) {
						this.containers[i]._trigger("out", null, this._uiHash(this));
						this.containers[i].containerCache.over = 0;
					}
				}
	
			}
	
			if (this.placeholder) {
				//$(this.placeholder[0]).remove(); would have been the jQuery way - unfortunately, it unbinds ALL events from the original node!
				if(this.placeholder[0].parentNode) {
					this.placeholder[0].parentNode.removeChild(this.placeholder[0]);
				}
				if(this.options.helper !== "original" && this.helper && this.helper[0].parentNode) {
					this.helper.remove();
				}
	
				$.extend(this, {
					helper: null,
					dragging: false,
					reverting: false,
					_noFinalSort: null
				});
	
				if(this.domPosition.prev) {
					$(this.domPosition.prev).after(this.currentItem);
				} else {
					$(this.domPosition.parent).prepend(this.currentItem);
				}
			}
	
			return this;
	
		},
	
		serialize: function(o) {
	
			var items = this._getItemsAsjQuery(o && o.connected),
				str = [];
			o = o || {};
	
			$(items).each(function() {
				var res = ($(o.item || this).attr(o.attribute || "id") || "").match(o.expression || (/(.+)[\-=_](.+)/));
				if (res) {
					str.push((o.key || res[1]+"[]")+"="+(o.key && o.expression ? res[1] : res[2]));
				}
			});
	
			if(!str.length && o.key) {
				str.push(o.key + "=");
			}
	
			return str.join("&");
	
		},
	
		toArray: function(o) {
	
			var items = this._getItemsAsjQuery(o && o.connected),
				ret = [];
	
			o = o || {};
	
			items.each(function() { ret.push($(o.item || this).attr(o.attribute || "id") || ""); });
			return ret;
	
		},
	
		/* Be careful with the following core functions */
		_intersectsWith: function(item) {
	
			var x1 = this.positionAbs.left,
				x2 = x1 + this.helperProportions.width,
				y1 = this.positionAbs.top,
				y2 = y1 + this.helperProportions.height,
				l = item.left,
				r = l + item.width,
				t = item.top,
				b = t + item.height,
				dyClick = this.offset.click.top,
				dxClick = this.offset.click.left,
				isOverElementHeight = ( this.options.axis === "x" ) || ( ( y1 + dyClick ) > t && ( y1 + dyClick ) < b ),
				isOverElementWidth = ( this.options.axis === "y" ) || ( ( x1 + dxClick ) > l && ( x1 + dxClick ) < r ),
				isOverElement = isOverElementHeight && isOverElementWidth;
	
			if ( this.options.tolerance === "pointer" ||
				this.options.forcePointerForContainers ||
				(this.options.tolerance !== "pointer" && this.helperProportions[this.floating ? "width" : "height"] > item[this.floating ? "width" : "height"])
			) {
				return isOverElement;
			} else {
	
				return (l < x1 + (this.helperProportions.width / 2) && // Right Half
					x2 - (this.helperProportions.width / 2) < r && // Left Half
					t < y1 + (this.helperProportions.height / 2) && // Bottom Half
					y2 - (this.helperProportions.height / 2) < b ); // Top Half
	
			}
		},
	
		_intersectsWithPointer: function(item) {
	
			var isOverElementHeight = (this.options.axis === "x") || this._isOverAxis(this.positionAbs.top + this.offset.click.top, item.top, item.height),
				isOverElementWidth = (this.options.axis === "y") || this._isOverAxis(this.positionAbs.left + this.offset.click.left, item.left, item.width),
				isOverElement = isOverElementHeight && isOverElementWidth,
				verticalDirection = this._getDragVerticalDirection(),
				horizontalDirection = this._getDragHorizontalDirection();
	
			if (!isOverElement) {
				return false;
			}
	
			return this.floating ?
				( ((horizontalDirection && horizontalDirection === "right") || verticalDirection === "down") ? 2 : 1 )
				: ( verticalDirection && (verticalDirection === "down" ? 2 : 1) );
	
		},
	
		_intersectsWithSides: function(item) {
	
			var isOverBottomHalf = this._isOverAxis(this.positionAbs.top + this.offset.click.top, item.top + (item.height/2), item.height),
				isOverRightHalf = this._isOverAxis(this.positionAbs.left + this.offset.click.left, item.left + (item.width/2), item.width),
				verticalDirection = this._getDragVerticalDirection(),
				horizontalDirection = this._getDragHorizontalDirection();
	
			if (this.floating && horizontalDirection) {
				return ((horizontalDirection === "right" && isOverRightHalf) || (horizontalDirection === "left" && !isOverRightHalf));
			} else {
				return verticalDirection && ((verticalDirection === "down" && isOverBottomHalf) || (verticalDirection === "up" && !isOverBottomHalf));
			}
	
		},
	
		_getDragVerticalDirection: function() {
			var delta = this.positionAbs.top - this.lastPositionAbs.top;
			return delta !== 0 && (delta > 0 ? "down" : "up");
		},
	
		_getDragHorizontalDirection: function() {
			var delta = this.positionAbs.left - this.lastPositionAbs.left;
			return delta !== 0 && (delta > 0 ? "right" : "left");
		},
	
		refresh: function(event) {
			this._refreshItems(event);
			this._setHandleClassName();
			this.refreshPositions();
			return this;
		},
	
		_connectWith: function() {
			var options = this.options;
			return options.connectWith.constructor === String ? [options.connectWith] : options.connectWith;
		},
	
		_getItemsAsjQuery: function(connected) {
	
			var i, j, cur, inst,
				items = [],
				queries = [],
				connectWith = this._connectWith();
	
			if(connectWith && connected) {
				for (i = connectWith.length - 1; i >= 0; i--){
					cur = $(connectWith[i], this.document[0]);
					for ( j = cur.length - 1; j >= 0; j--){
						inst = $.data(cur[j], this.widgetFullName);
						if(inst && inst !== this && !inst.options.disabled) {
							queries.push([$.isFunction(inst.options.items) ? inst.options.items.call(inst.element) : $(inst.options.items, inst.element).not(".ui-sortable-helper").not(".ui-sortable-placeholder"), inst]);
						}
					}
				}
			}
	
			queries.push([$.isFunction(this.options.items) ? this.options.items.call(this.element, null, { options: this.options, item: this.currentItem }) : $(this.options.items, this.element).not(".ui-sortable-helper").not(".ui-sortable-placeholder"), this]);
	
			function addItems() {
				items.push( this );
			}
			for (i = queries.length - 1; i >= 0; i--){
				queries[i][0].each( addItems );
			}
	
			return $(items);
	
		},
	
		_removeCurrentsFromItems: function() {
	
			var list = this.currentItem.find(":data(" + this.widgetName + "-item)");
	
			this.items = $.grep(this.items, function (item) {
				for (var j=0; j < list.length; j++) {
					if(list[j] === item.item[0]) {
						return false;
					}
				}
				return true;
			});
	
		},
	
		_refreshItems: function(event) {
	
			this.items = [];
			this.containers = [this];
	
			var i, j, cur, inst, targetData, _queries, item, queriesLength,
				items = this.items,
				queries = [[$.isFunction(this.options.items) ? this.options.items.call(this.element[0], event, { item: this.currentItem }) : $(this.options.items, this.element), this]],
				connectWith = this._connectWith();
	
			if(connectWith && this.ready) { //Shouldn't be run the first time through due to massive slow-down
				for (i = connectWith.length - 1; i >= 0; i--){
					cur = $(connectWith[i], this.document[0]);
					for (j = cur.length - 1; j >= 0; j--){
						inst = $.data(cur[j], this.widgetFullName);
						if(inst && inst !== this && !inst.options.disabled) {
							queries.push([$.isFunction(inst.options.items) ? inst.options.items.call(inst.element[0], event, { item: this.currentItem }) : $(inst.options.items, inst.element), inst]);
							this.containers.push(inst);
						}
					}
				}
			}
	
			for (i = queries.length - 1; i >= 0; i--) {
				targetData = queries[i][1];
				_queries = queries[i][0];
	
				for (j=0, queriesLength = _queries.length; j < queriesLength; j++) {
					item = $(_queries[j]);
	
					item.data(this.widgetName + "-item", targetData); // Data for target checking (mouse manager)
	
					items.push({
						item: item,
						instance: targetData,
						width: 0, height: 0,
						left: 0, top: 0
					});
				}
			}
	
		},
	
		refreshPositions: function(fast) {
	
			// Determine whether items are being displayed horizontally
			this.floating = this.items.length ?
				this.options.axis === "x" || this._isFloating( this.items[ 0 ].item ) :
				false;
	
			//This has to be redone because due to the item being moved out/into the offsetParent, the offsetParent's position will change
			if(this.offsetParent && this.helper) {
				this.offset.parent = this._getParentOffset();
			}
	
			var i, item, t, p;
	
			for (i = this.items.length - 1; i >= 0; i--){
				item = this.items[i];
	
				//We ignore calculating positions of all connected containers when we're not over them
				if(item.instance !== this.currentContainer && this.currentContainer && item.item[0] !== this.currentItem[0]) {
					continue;
				}
	
				t = this.options.toleranceElement ? $(this.options.toleranceElement, item.item) : item.item;
	
				if (!fast) {
					item.width = t.outerWidth();
					item.height = t.outerHeight();
				}
	
				p = t.offset();
				item.left = p.left;
				item.top = p.top;
			}
	
			if(this.options.custom && this.options.custom.refreshContainers) {
				this.options.custom.refreshContainers.call(this);
			} else {
				for (i = this.containers.length - 1; i >= 0; i--){
					p = this.containers[i].element.offset();
					this.containers[i].containerCache.left = p.left;
					this.containers[i].containerCache.top = p.top;
					this.containers[i].containerCache.width = this.containers[i].element.outerWidth();
					this.containers[i].containerCache.height = this.containers[i].element.outerHeight();
				}
			}
	
			return this;
		},
	
		_createPlaceholder: function(that) {
			that = that || this;
			var className,
				o = that.options;
	
			if(!o.placeholder || o.placeholder.constructor === String) {
				className = o.placeholder;
				o.placeholder = {
					element: function() {
	
						var nodeName = that.currentItem[0].nodeName.toLowerCase(),
							element = $( "<" + nodeName + ">", that.document[0] )
								.addClass(className || that.currentItem[0].className+" ui-sortable-placeholder")
								.removeClass("ui-sortable-helper");
	
						if ( nodeName === "tbody" ) {
							that._createTrPlaceholder(
								that.currentItem.find( "tr" ).eq( 0 ),
								$( "<tr>", that.document[ 0 ] ).appendTo( element )
							);
						} else if ( nodeName === "tr" ) {
							that._createTrPlaceholder( that.currentItem, element );
						} else if ( nodeName === "img" ) {
							element.attr( "src", that.currentItem.attr( "src" ) );
						}
	
						if ( !className ) {
							element.css( "visibility", "hidden" );
						}
	
						return element;
					},
					update: function(container, p) {
	
						// 1. If a className is set as 'placeholder option, we don't force sizes - the class is responsible for that
						// 2. The option 'forcePlaceholderSize can be enabled to force it even if a class name is specified
						if(className && !o.forcePlaceholderSize) {
							return;
						}
	
						//If the element doesn't have a actual height by itself (without styles coming from a stylesheet), it receives the inline height from the dragged item
						if(!p.height()) { p.height(that.currentItem.innerHeight() - parseInt(that.currentItem.css("paddingTop")||0, 10) - parseInt(that.currentItem.css("paddingBottom")||0, 10)); }
						if(!p.width()) { p.width(that.currentItem.innerWidth() - parseInt(that.currentItem.css("paddingLeft")||0, 10) - parseInt(that.currentItem.css("paddingRight")||0, 10)); }
					}
				};
			}
	
			//Create the placeholder
			that.placeholder = $(o.placeholder.element.call(that.element, that.currentItem));
	
			//Append it after the actual current item
			that.currentItem.after(that.placeholder);
	
			//Update the size of the placeholder (TODO: Logic to fuzzy, see line 316/317)
			o.placeholder.update(that, that.placeholder);
	
		},
	
		_createTrPlaceholder: function( sourceTr, targetTr ) {
			var that = this;
	
			sourceTr.children().each(function() {
				$( "<td>&#160;</td>", that.document[ 0 ] )
					.attr( "colspan", $( this ).attr( "colspan" ) || 1 )
					.appendTo( targetTr );
			});
		},
	
		_contactContainers: function(event) {
			var i, j, dist, itemWithLeastDistance, posProperty, sizeProperty, cur, nearBottom, floating, axis,
				innermostContainer = null,
				innermostIndex = null;
	
			// get innermost container that intersects with item
			for (i = this.containers.length - 1; i >= 0; i--) {
	
				// never consider a container that's located within the item itself
				if($.contains(this.currentItem[0], this.containers[i].element[0])) {
					continue;
				}
	
				if(this._intersectsWith(this.containers[i].containerCache)) {
	
					// if we've already found a container and it's more "inner" than this, then continue
					if(innermostContainer && $.contains(this.containers[i].element[0], innermostContainer.element[0])) {
						continue;
					}
	
					innermostContainer = this.containers[i];
					innermostIndex = i;
	
				} else {
					// container doesn't intersect. trigger "out" event if necessary
					if(this.containers[i].containerCache.over) {
						this.containers[i]._trigger("out", event, this._uiHash(this));
						this.containers[i].containerCache.over = 0;
					}
				}
	
			}
	
			// if no intersecting containers found, return
			if(!innermostContainer) {
				return;
			}
	
			// move the item into the container if it's not there already
			if(this.containers.length === 1) {
				if (!this.containers[innermostIndex].containerCache.over) {
					this.containers[innermostIndex]._trigger("over", event, this._uiHash(this));
					this.containers[innermostIndex].containerCache.over = 1;
				}
			} else {
	
				//When entering a new container, we will find the item with the least distance and append our item near it
				dist = 10000;
				itemWithLeastDistance = null;
				floating = innermostContainer.floating || this._isFloating(this.currentItem);
				posProperty = floating ? "left" : "top";
				sizeProperty = floating ? "width" : "height";
				axis = floating ? "clientX" : "clientY";
	
				for (j = this.items.length - 1; j >= 0; j--) {
					if(!$.contains(this.containers[innermostIndex].element[0], this.items[j].item[0])) {
						continue;
					}
					if(this.items[j].item[0] === this.currentItem[0]) {
						continue;
					}
	
					cur = this.items[j].item.offset()[posProperty];
					nearBottom = false;
					if ( event[ axis ] - cur > this.items[ j ][ sizeProperty ] / 2 ) {
						nearBottom = true;
					}
	
					if ( Math.abs( event[ axis ] - cur ) < dist ) {
						dist = Math.abs( event[ axis ] - cur );
						itemWithLeastDistance = this.items[ j ];
						this.direction = nearBottom ? "up": "down";
					}
				}
	
				//Check if dropOnEmpty is enabled
				if(!itemWithLeastDistance && !this.options.dropOnEmpty) {
					return;
				}
	
				if(this.currentContainer === this.containers[innermostIndex]) {
					if ( !this.currentContainer.containerCache.over ) {
						this.containers[ innermostIndex ]._trigger( "over", event, this._uiHash() );
						this.currentContainer.containerCache.over = 1;
					}
					return;
				}
	
				itemWithLeastDistance ? this._rearrange(event, itemWithLeastDistance, null, true) : this._rearrange(event, null, this.containers[innermostIndex].element, true);
				this._trigger("change", event, this._uiHash());
				this.containers[innermostIndex]._trigger("change", event, this._uiHash(this));
				this.currentContainer = this.containers[innermostIndex];
	
				//Update the placeholder
				this.options.placeholder.update(this.currentContainer, this.placeholder);
	
				this.containers[innermostIndex]._trigger("over", event, this._uiHash(this));
				this.containers[innermostIndex].containerCache.over = 1;
			}
	
	
		},
	
		_createHelper: function(event) {
	
			var o = this.options,
				helper = $.isFunction(o.helper) ? $(o.helper.apply(this.element[0], [event, this.currentItem])) : (o.helper === "clone" ? this.currentItem.clone() : this.currentItem);
	
			//Add the helper to the DOM if that didn't happen already
			if(!helper.parents("body").length) {
				$(o.appendTo !== "parent" ? o.appendTo : this.currentItem[0].parentNode)[0].appendChild(helper[0]);
			}
	
			if(helper[0] === this.currentItem[0]) {
				this._storedCSS = { width: this.currentItem[0].style.width, height: this.currentItem[0].style.height, position: this.currentItem.css("position"), top: this.currentItem.css("top"), left: this.currentItem.css("left") };
			}
	
			if(!helper[0].style.width || o.forceHelperSize) {
				helper.width(this.currentItem.width());
			}
			if(!helper[0].style.height || o.forceHelperSize) {
				helper.height(this.currentItem.height());
			}
	
			return helper;
	
		},
	
		_adjustOffsetFromHelper: function(obj) {
			if (typeof obj === "string") {
				obj = obj.split(" ");
			}
			if ($.isArray(obj)) {
				obj = {left: +obj[0], top: +obj[1] || 0};
			}
			if ("left" in obj) {
				this.offset.click.left = obj.left + this.margins.left;
			}
			if ("right" in obj) {
				this.offset.click.left = this.helperProportions.width - obj.right + this.margins.left;
			}
			if ("top" in obj) {
				this.offset.click.top = obj.top + this.margins.top;
			}
			if ("bottom" in obj) {
				this.offset.click.top = this.helperProportions.height - obj.bottom + this.margins.top;
			}
		},
	
		_getParentOffset: function() {
	
	
			//Get the offsetParent and cache its position
			this.offsetParent = this.helper.offsetParent();
			var po = this.offsetParent.offset();
	
			// This is a special case where we need to modify a offset calculated on start, since the following happened:
			// 1. The position of the helper is absolute, so it's position is calculated based on the next positioned parent
			// 2. The actual offset parent is a child of the scroll parent, and the scroll parent isn't the document, which means that
			//    the scroll is included in the initial calculation of the offset of the parent, and never recalculated upon drag
			if(this.cssPosition === "absolute" && this.scrollParent[0] !== this.document[0] && $.contains(this.scrollParent[0], this.offsetParent[0])) {
				po.left += this.scrollParent.scrollLeft();
				po.top += this.scrollParent.scrollTop();
			}
	
			// This needs to be actually done for all browsers, since pageX/pageY includes this information
			// with an ugly IE fix
			if( this.offsetParent[0] === this.document[0].body || (this.offsetParent[0].tagName && this.offsetParent[0].tagName.toLowerCase() === "html" && $.ui.ie)) {
				po = { top: 0, left: 0 };
			}
	
			return {
				top: po.top + (parseInt(this.offsetParent.css("borderTopWidth"),10) || 0),
				left: po.left + (parseInt(this.offsetParent.css("borderLeftWidth"),10) || 0)
			};
	
		},
	
		_getRelativeOffset: function() {
	
			if(this.cssPosition === "relative") {
				var p = this.currentItem.position();
				return {
					top: p.top - (parseInt(this.helper.css("top"),10) || 0) + this.scrollParent.scrollTop(),
					left: p.left - (parseInt(this.helper.css("left"),10) || 0) + this.scrollParent.scrollLeft()
				};
			} else {
				return { top: 0, left: 0 };
			}
	
		},
	
		_cacheMargins: function() {
			this.margins = {
				left: (parseInt(this.currentItem.css("marginLeft"),10) || 0),
				top: (parseInt(this.currentItem.css("marginTop"),10) || 0)
			};
		},
	
		_cacheHelperProportions: function() {
			this.helperProportions = {
				width: this.helper.outerWidth(),
				height: this.helper.outerHeight()
			};
		},
	
		_setContainment: function() {
	
			var ce, co, over,
				o = this.options;
			if(o.containment === "parent") {
				o.containment = this.helper[0].parentNode;
			}
			if(o.containment === "document" || o.containment === "window") {
				this.containment = [
					0 - this.offset.relative.left - this.offset.parent.left,
					0 - this.offset.relative.top - this.offset.parent.top,
					o.containment === "document" ? this.document.width() : this.window.width() - this.helperProportions.width - this.margins.left,
					(o.containment === "document" ? this.document.width() : this.window.height() || this.document[0].body.parentNode.scrollHeight) - this.helperProportions.height - this.margins.top
				];
			}
	
			if(!(/^(document|window|parent)$/).test(o.containment)) {
				ce = $(o.containment)[0];
				co = $(o.containment).offset();
				over = ($(ce).css("overflow") !== "hidden");
	
				this.containment = [
					co.left + (parseInt($(ce).css("borderLeftWidth"),10) || 0) + (parseInt($(ce).css("paddingLeft"),10) || 0) - this.margins.left,
					co.top + (parseInt($(ce).css("borderTopWidth"),10) || 0) + (parseInt($(ce).css("paddingTop"),10) || 0) - this.margins.top,
					co.left+(over ? Math.max(ce.scrollWidth,ce.offsetWidth) : ce.offsetWidth) - (parseInt($(ce).css("borderLeftWidth"),10) || 0) - (parseInt($(ce).css("paddingRight"),10) || 0) - this.helperProportions.width - this.margins.left,
					co.top+(over ? Math.max(ce.scrollHeight,ce.offsetHeight) : ce.offsetHeight) - (parseInt($(ce).css("borderTopWidth"),10) || 0) - (parseInt($(ce).css("paddingBottom"),10) || 0) - this.helperProportions.height - this.margins.top
				];
			}
	
		},
	
		_convertPositionTo: function(d, pos) {
	
			if(!pos) {
				pos = this.position;
			}
			var mod = d === "absolute" ? 1 : -1,
				scroll = this.cssPosition === "absolute" && !(this.scrollParent[0] !== this.document[0] && $.contains(this.scrollParent[0], this.offsetParent[0])) ? this.offsetParent : this.scrollParent,
				scrollIsRootNode = (/(html|body)/i).test(scroll[0].tagName);
	
			return {
				top: (
					pos.top	+																// The absolute mouse position
					this.offset.relative.top * mod +										// Only for relative positioned nodes: Relative offset from element to offset parent
					this.offset.parent.top * mod -											// The offsetParent's offset without borders (offset + border)
					( ( this.cssPosition === "fixed" ? -this.scrollParent.scrollTop() : ( scrollIsRootNode ? 0 : scroll.scrollTop() ) ) * mod)
				),
				left: (
					pos.left +																// The absolute mouse position
					this.offset.relative.left * mod +										// Only for relative positioned nodes: Relative offset from element to offset parent
					this.offset.parent.left * mod	-										// The offsetParent's offset without borders (offset + border)
					( ( this.cssPosition === "fixed" ? -this.scrollParent.scrollLeft() : scrollIsRootNode ? 0 : scroll.scrollLeft() ) * mod)
				)
			};
	
		},
	
		_generatePosition: function(event) {
	
			var top, left,
				o = this.options,
				pageX = event.pageX,
				pageY = event.pageY,
				scroll = this.cssPosition === "absolute" && !(this.scrollParent[0] !== this.document[0] && $.contains(this.scrollParent[0], this.offsetParent[0])) ? this.offsetParent : this.scrollParent, scrollIsRootNode = (/(html|body)/i).test(scroll[0].tagName);
	
			// This is another very weird special case that only happens for relative elements:
			// 1. If the css position is relative
			// 2. and the scroll parent is the document or similar to the offset parent
			// we have to refresh the relative offset during the scroll so there are no jumps
			if(this.cssPosition === "relative" && !(this.scrollParent[0] !== this.document[0] && this.scrollParent[0] !== this.offsetParent[0])) {
				this.offset.relative = this._getRelativeOffset();
			}
	
			/*
			 * - Position constraining -
			 * Constrain the position to a mix of grid, containment.
			 */
	
			if(this.originalPosition) { //If we are not dragging yet, we won't check for options
	
				if(this.containment) {
					if(event.pageX - this.offset.click.left < this.containment[0]) {
						pageX = this.containment[0] + this.offset.click.left;
					}
					if(event.pageY - this.offset.click.top < this.containment[1]) {
						pageY = this.containment[1] + this.offset.click.top;
					}
					if(event.pageX - this.offset.click.left > this.containment[2]) {
						pageX = this.containment[2] + this.offset.click.left;
					}
					if(event.pageY - this.offset.click.top > this.containment[3]) {
						pageY = this.containment[3] + this.offset.click.top;
					}
				}
	
				if(o.grid) {
					top = this.originalPageY + Math.round((pageY - this.originalPageY) / o.grid[1]) * o.grid[1];
					pageY = this.containment ? ( (top - this.offset.click.top >= this.containment[1] && top - this.offset.click.top <= this.containment[3]) ? top : ((top - this.offset.click.top >= this.containment[1]) ? top - o.grid[1] : top + o.grid[1])) : top;
	
					left = this.originalPageX + Math.round((pageX - this.originalPageX) / o.grid[0]) * o.grid[0];
					pageX = this.containment ? ( (left - this.offset.click.left >= this.containment[0] && left - this.offset.click.left <= this.containment[2]) ? left : ((left - this.offset.click.left >= this.containment[0]) ? left - o.grid[0] : left + o.grid[0])) : left;
				}
	
			}
	
			return {
				top: (
					pageY -																// The absolute mouse position
					this.offset.click.top -													// Click offset (relative to the element)
					this.offset.relative.top	-											// Only for relative positioned nodes: Relative offset from element to offset parent
					this.offset.parent.top +												// The offsetParent's offset without borders (offset + border)
					( ( this.cssPosition === "fixed" ? -this.scrollParent.scrollTop() : ( scrollIsRootNode ? 0 : scroll.scrollTop() ) ))
				),
				left: (
					pageX -																// The absolute mouse position
					this.offset.click.left -												// Click offset (relative to the element)
					this.offset.relative.left	-											// Only for relative positioned nodes: Relative offset from element to offset parent
					this.offset.parent.left +												// The offsetParent's offset without borders (offset + border)
					( ( this.cssPosition === "fixed" ? -this.scrollParent.scrollLeft() : scrollIsRootNode ? 0 : scroll.scrollLeft() ))
				)
			};
	
		},
	
		_rearrange: function(event, i, a, hardRefresh) {
	
			a ? a[0].appendChild(this.placeholder[0]) : i.item[0].parentNode.insertBefore(this.placeholder[0], (this.direction === "down" ? i.item[0] : i.item[0].nextSibling));
	
			//Various things done here to improve the performance:
			// 1. we create a setTimeout, that calls refreshPositions
			// 2. on the instance, we have a counter variable, that get's higher after every append
			// 3. on the local scope, we copy the counter variable, and check in the timeout, if it's still the same
			// 4. this lets only the last addition to the timeout stack through
			this.counter = this.counter ? ++this.counter : 1;
			var counter = this.counter;
	
			this._delay(function() {
				if(counter === this.counter) {
					this.refreshPositions(!hardRefresh); //Precompute after each DOM insertion, NOT on mousemove
				}
			});
	
		},
	
		_clear: function(event, noPropagation) {
	
			this.reverting = false;
			// We delay all events that have to be triggered to after the point where the placeholder has been removed and
			// everything else normalized again
			var i,
				delayedTriggers = [];
	
			// We first have to update the dom position of the actual currentItem
			// Note: don't do it if the current item is already removed (by a user), or it gets reappended (see #4088)
			if(!this._noFinalSort && this.currentItem.parent().length) {
				this.placeholder.before(this.currentItem);
			}
			this._noFinalSort = null;
	
			if(this.helper[0] === this.currentItem[0]) {
				for(i in this._storedCSS) {
					if(this._storedCSS[i] === "auto" || this._storedCSS[i] === "static") {
						this._storedCSS[i] = "";
					}
				}
				this.currentItem.css(this._storedCSS).removeClass("ui-sortable-helper");
			} else {
				this.currentItem.show();
			}
	
			if(this.fromOutside && !noPropagation) {
				delayedTriggers.push(function(event) { this._trigger("receive", event, this._uiHash(this.fromOutside)); });
			}
			if((this.fromOutside || this.domPosition.prev !== this.currentItem.prev().not(".ui-sortable-helper")[0] || this.domPosition.parent !== this.currentItem.parent()[0]) && !noPropagation) {
				delayedTriggers.push(function(event) { this._trigger("update", event, this._uiHash()); }); //Trigger update callback if the DOM position has changed
			}
	
			// Check if the items Container has Changed and trigger appropriate
			// events.
			if (this !== this.currentContainer) {
				if(!noPropagation) {
					delayedTriggers.push(function(event) { this._trigger("remove", event, this._uiHash()); });
					delayedTriggers.push((function(c) { return function(event) { c._trigger("receive", event, this._uiHash(this)); };  }).call(this, this.currentContainer));
					delayedTriggers.push((function(c) { return function(event) { c._trigger("update", event, this._uiHash(this));  }; }).call(this, this.currentContainer));
				}
			}
	
	
			//Post events to containers
			function delayEvent( type, instance, container ) {
				return function( event ) {
					container._trigger( type, event, instance._uiHash( instance ) );
				};
			}
			for (i = this.containers.length - 1; i >= 0; i--){
				if (!noPropagation) {
					delayedTriggers.push( delayEvent( "deactivate", this, this.containers[ i ] ) );
				}
				if(this.containers[i].containerCache.over) {
					delayedTriggers.push( delayEvent( "out", this, this.containers[ i ] ) );
					this.containers[i].containerCache.over = 0;
				}
			}
	
			//Do what was originally in plugins
			if ( this.storedCursor ) {
				this.document.find( "body" ).css( "cursor", this.storedCursor );
				this.storedStylesheet.remove();
			}
			if(this._storedOpacity) {
				this.helper.css("opacity", this._storedOpacity);
			}
			if(this._storedZIndex) {
				this.helper.css("zIndex", this._storedZIndex === "auto" ? "" : this._storedZIndex);
			}
	
			this.dragging = false;
	
			if(!noPropagation) {
				this._trigger("beforeStop", event, this._uiHash());
			}
	
			//$(this.placeholder[0]).remove(); would have been the jQuery way - unfortunately, it unbinds ALL events from the original node!
			this.placeholder[0].parentNode.removeChild(this.placeholder[0]);
	
			if ( !this.cancelHelperRemoval ) {
				if ( this.helper[ 0 ] !== this.currentItem[ 0 ] ) {
					this.helper.remove();
				}
				this.helper = null;
			}
	
			if(!noPropagation) {
				for (i=0; i < delayedTriggers.length; i++) {
					delayedTriggers[i].call(this, event);
				} //Trigger all delayed events
				this._trigger("stop", event, this._uiHash());
			}
	
			this.fromOutside = false;
			return !this.cancelHelperRemoval;
	
		},
	
		_trigger: function() {
			if ($.Widget.prototype._trigger.apply(this, arguments) === false) {
				this.cancel();
			}
		},
	
		_uiHash: function(_inst) {
			var inst = _inst || this;
			return {
				helper: inst.helper,
				placeholder: inst.placeholder || $([]),
				position: inst.position,
				originalPosition: inst.originalPosition,
				offset: inst.positionAbs,
				item: inst.currentItem,
				sender: _inst ? _inst.element : null
			};
		}
	
	});
	
	
	/*!
	 * jQuery UI Spinner 1.11.4
	 * http://jqueryui.com
	 *
	 * Copyright jQuery Foundation and other contributors
	 * Released under the MIT license.
	 * http://jquery.org/license
	 *
	 * http://api.jqueryui.com/spinner/
	 */
	
	
	function spinner_modifier( fn ) {
		return function() {
			var previous = this.element.val();
			fn.apply( this, arguments );
			this._refresh();
			if ( previous !== this.element.val() ) {
				this._trigger( "change" );
			}
		};
	}
	
	var spinner = $.widget( "ui.spinner", {
		version: "1.11.4",
		defaultElement: "<input>",
		widgetEventPrefix: "spin",
		options: {
			culture: null,
			icons: {
				down: "ui-icon-triangle-1-s",
				up: "ui-icon-triangle-1-n"
			},
			incremental: true,
			max: null,
			min: null,
			numberFormat: null,
			page: 10,
			step: 1,
	
			change: null,
			spin: null,
			start: null,
			stop: null
		},
	
		_create: function() {
			// handle string values that need to be parsed
			this._setOption( "max", this.options.max );
			this._setOption( "min", this.options.min );
			this._setOption( "step", this.options.step );
	
			// Only format if there is a value, prevents the field from being marked
			// as invalid in Firefox, see #9573.
			if ( this.value() !== "" ) {
				// Format the value, but don't constrain.
				this._value( this.element.val(), true );
			}
	
			this._draw();
			this._on( this._events );
			this._refresh();
	
			// turning off autocomplete prevents the browser from remembering the
			// value when navigating through history, so we re-enable autocomplete
			// if the page is unloaded before the widget is destroyed. #7790
			this._on( this.window, {
				beforeunload: function() {
					this.element.removeAttr( "autocomplete" );
				}
			});
		},
	
		_getCreateOptions: function() {
			var options = {},
				element = this.element;
	
			$.each( [ "min", "max", "step" ], function( i, option ) {
				var value = element.attr( option );
				if ( value !== undefined && value.length ) {
					options[ option ] = value;
				}
			});
	
			return options;
		},
	
		_events: {
			keydown: function( event ) {
				if ( this._start( event ) && this._keydown( event ) ) {
					event.preventDefault();
				}
			},
			keyup: "_stop",
			focus: function() {
				this.previous = this.element.val();
			},
			blur: function( event ) {
				if ( this.cancelBlur ) {
					delete this.cancelBlur;
					return;
				}
	
				this._stop();
				this._refresh();
				if ( this.previous !== this.element.val() ) {
					this._trigger( "change", event );
				}
			},
			mousewheel: function( event, delta ) {
				if ( !delta ) {
					return;
				}
				if ( !this.spinning && !this._start( event ) ) {
					return false;
				}
	
				this._spin( (delta > 0 ? 1 : -1) * this.options.step, event );
				clearTimeout( this.mousewheelTimer );
				this.mousewheelTimer = this._delay(function() {
					if ( this.spinning ) {
						this._stop( event );
					}
				}, 100 );
				event.preventDefault();
			},
			"mousedown .ui-spinner-button": function( event ) {
				var previous;
	
				// We never want the buttons to have focus; whenever the user is
				// interacting with the spinner, the focus should be on the input.
				// If the input is focused then this.previous is properly set from
				// when the input first received focus. If the input is not focused
				// then we need to set this.previous based on the value before spinning.
				previous = this.element[0] === this.document[0].activeElement ?
					this.previous : this.element.val();
				function checkFocus() {
					var isActive = this.element[0] === this.document[0].activeElement;
					if ( !isActive ) {
						this.element.focus();
						this.previous = previous;
						// support: IE
						// IE sets focus asynchronously, so we need to check if focus
						// moved off of the input because the user clicked on the button.
						this._delay(function() {
							this.previous = previous;
						});
					}
				}
	
				// ensure focus is on (or stays on) the text field
				event.preventDefault();
				checkFocus.call( this );
	
				// support: IE
				// IE doesn't prevent moving focus even with event.preventDefault()
				// so we set a flag to know when we should ignore the blur event
				// and check (again) if focus moved off of the input.
				this.cancelBlur = true;
				this._delay(function() {
					delete this.cancelBlur;
					checkFocus.call( this );
				});
	
				if ( this._start( event ) === false ) {
					return;
				}
	
				this._repeat( null, $( event.currentTarget ).hasClass( "ui-spinner-up" ) ? 1 : -1, event );
			},
			"mouseup .ui-spinner-button": "_stop",
			"mouseenter .ui-spinner-button": function( event ) {
				// button will add ui-state-active if mouse was down while mouseleave and kept down
				if ( !$( event.currentTarget ).hasClass( "ui-state-active" ) ) {
					return;
				}
	
				if ( this._start( event ) === false ) {
					return false;
				}
				this._repeat( null, $( event.currentTarget ).hasClass( "ui-spinner-up" ) ? 1 : -1, event );
			},
			// TODO: do we really want to consider this a stop?
			// shouldn't we just stop the repeater and wait until mouseup before
			// we trigger the stop event?
			"mouseleave .ui-spinner-button": "_stop"
		},
	
		_draw: function() {
			var uiSpinner = this.uiSpinner = this.element
				.addClass( "ui-spinner-input" )
				.attr( "autocomplete", "off" )
				.wrap( this._uiSpinnerHtml() )
				.parent()
					// add buttons
					.append( this._buttonHtml() );
	
			this.element.attr( "role", "spinbutton" );
	
			// button bindings
			this.buttons = uiSpinner.find( ".ui-spinner-button" )
				.attr( "tabIndex", -1 )
				.button()
				.removeClass( "ui-corner-all" );
	
			// IE 6 doesn't understand height: 50% for the buttons
			// unless the wrapper has an explicit height
			if ( this.buttons.height() > Math.ceil( uiSpinner.height() * 0.5 ) &&
					uiSpinner.height() > 0 ) {
				uiSpinner.height( uiSpinner.height() );
			}
	
			// disable spinner if element was already disabled
			if ( this.options.disabled ) {
				this.disable();
			}
		},
	
		_keydown: function( event ) {
			var options = this.options,
				keyCode = $.ui.keyCode;
	
			switch ( event.keyCode ) {
			case keyCode.UP:
				this._repeat( null, 1, event );
				return true;
			case keyCode.DOWN:
				this._repeat( null, -1, event );
				return true;
			case keyCode.PAGE_UP:
				this._repeat( null, options.page, event );
				return true;
			case keyCode.PAGE_DOWN:
				this._repeat( null, -options.page, event );
				return true;
			}
	
			return false;
		},
	
		_uiSpinnerHtml: function() {
			return "<span class='ui-spinner ui-widget ui-widget-content ui-corner-all'></span>";
		},
	
		_buttonHtml: function() {
			return "" +
				"<a class='ui-spinner-button ui-spinner-up ui-corner-tr'>" +
					"<span class='ui-icon " + this.options.icons.up + "'>&#9650;</span>" +
				"</a>" +
				"<a class='ui-spinner-button ui-spinner-down ui-corner-br'>" +
					"<span class='ui-icon " + this.options.icons.down + "'>&#9660;</span>" +
				"</a>";
		},
	
		_start: function( event ) {
			if ( !this.spinning && this._trigger( "start", event ) === false ) {
				return false;
			}
	
			if ( !this.counter ) {
				this.counter = 1;
			}
			this.spinning = true;
			return true;
		},
	
		_repeat: function( i, steps, event ) {
			i = i || 500;
	
			clearTimeout( this.timer );
			this.timer = this._delay(function() {
				this._repeat( 40, steps, event );
			}, i );
	
			this._spin( steps * this.options.step, event );
		},
	
		_spin: function( step, event ) {
			var value = this.value() || 0;
	
			if ( !this.counter ) {
				this.counter = 1;
			}
	
			value = this._adjustValue( value + step * this._increment( this.counter ) );
	
			if ( !this.spinning || this._trigger( "spin", event, { value: value } ) !== false) {
				this._value( value );
				this.counter++;
			}
		},
	
		_increment: function( i ) {
			var incremental = this.options.incremental;
	
			if ( incremental ) {
				return $.isFunction( incremental ) ?
					incremental( i ) :
					Math.floor( i * i * i / 50000 - i * i / 500 + 17 * i / 200 + 1 );
			}
	
			return 1;
		},
	
		_precision: function() {
			var precision = this._precisionOf( this.options.step );
			if ( this.options.min !== null ) {
				precision = Math.max( precision, this._precisionOf( this.options.min ) );
			}
			return precision;
		},
	
		_precisionOf: function( num ) {
			var str = num.toString(),
				decimal = str.indexOf( "." );
			return decimal === -1 ? 0 : str.length - decimal - 1;
		},
	
		_adjustValue: function( value ) {
			var base, aboveMin,
				options = this.options;
	
			// make sure we're at a valid step
			// - find out where we are relative to the base (min or 0)
			base = options.min !== null ? options.min : 0;
			aboveMin = value - base;
			// - round to the nearest step
			aboveMin = Math.round(aboveMin / options.step) * options.step;
			// - rounding is based on 0, so adjust back to our base
			value = base + aboveMin;
	
			// fix precision from bad JS floating point math
			value = parseFloat( value.toFixed( this._precision() ) );
	
			// clamp the value
			if ( options.max !== null && value > options.max) {
				return options.max;
			}
			if ( options.min !== null && value < options.min ) {
				return options.min;
			}
	
			return value;
		},
	
		_stop: function( event ) {
			if ( !this.spinning ) {
				return;
			}
	
			clearTimeout( this.timer );
			clearTimeout( this.mousewheelTimer );
			this.counter = 0;
			this.spinning = false;
			this._trigger( "stop", event );
		},
	
		_setOption: function( key, value ) {
			if ( key === "culture" || key === "numberFormat" ) {
				var prevValue = this._parse( this.element.val() );
				this.options[ key ] = value;
				this.element.val( this._format( prevValue ) );
				return;
			}
	
			if ( key === "max" || key === "min" || key === "step" ) {
				if ( typeof value === "string" ) {
					value = this._parse( value );
				}
			}
			if ( key === "icons" ) {
				this.buttons.first().find( ".ui-icon" )
					.removeClass( this.options.icons.up )
					.addClass( value.up );
				this.buttons.last().find( ".ui-icon" )
					.removeClass( this.options.icons.down )
					.addClass( value.down );
			}
	
			this._super( key, value );
	
			if ( key === "disabled" ) {
				this.widget().toggleClass( "ui-state-disabled", !!value );
				this.element.prop( "disabled", !!value );
				this.buttons.button( value ? "disable" : "enable" );
			}
		},
	
		_setOptions: spinner_modifier(function( options ) {
			this._super( options );
		}),
	
		_parse: function( val ) {
			if ( typeof val === "string" && val !== "" ) {
				val = window.Globalize && this.options.numberFormat ?
					Globalize.parseFloat( val, 10, this.options.culture ) : +val;
			}
			return val === "" || isNaN( val ) ? null : val;
		},
	
		_format: function( value ) {
			if ( value === "" ) {
				return "";
			}
			return window.Globalize && this.options.numberFormat ?
				Globalize.format( value, this.options.numberFormat, this.options.culture ) :
				value;
		},
	
		_refresh: function() {
			this.element.attr({
				"aria-valuemin": this.options.min,
				"aria-valuemax": this.options.max,
				// TODO: what should we do with values that can't be parsed?
				"aria-valuenow": this._parse( this.element.val() )
			});
		},
	
		isValid: function() {
			var value = this.value();
	
			// null is invalid
			if ( value === null ) {
				return false;
			}
	
			// if value gets adjusted, it's invalid
			return value === this._adjustValue( value );
		},
	
		// update the value without triggering change
		_value: function( value, allowAny ) {
			var parsed;
			if ( value !== "" ) {
				parsed = this._parse( value );
				if ( parsed !== null ) {
					if ( !allowAny ) {
						parsed = this._adjustValue( parsed );
					}
					value = this._format( parsed );
				}
			}
			this.element.val( value );
			this._refresh();
		},
	
		_destroy: function() {
			this.element
				.removeClass( "ui-spinner-input" )
				.prop( "disabled", false )
				.removeAttr( "autocomplete" )
				.removeAttr( "role" )
				.removeAttr( "aria-valuemin" )
				.removeAttr( "aria-valuemax" )
				.removeAttr( "aria-valuenow" );
			this.uiSpinner.replaceWith( this.element );
		},
	
		stepUp: spinner_modifier(function( steps ) {
			this._stepUp( steps );
		}),
		_stepUp: function( steps ) {
			if ( this._start() ) {
				this._spin( (steps || 1) * this.options.step );
				this._stop();
			}
		},
	
		stepDown: spinner_modifier(function( steps ) {
			this._stepDown( steps );
		}),
		_stepDown: function( steps ) {
			if ( this._start() ) {
				this._spin( (steps || 1) * -this.options.step );
				this._stop();
			}
		},
	
		pageUp: spinner_modifier(function( pages ) {
			this._stepUp( (pages || 1) * this.options.page );
		}),
	
		pageDown: spinner_modifier(function( pages ) {
			this._stepDown( (pages || 1) * this.options.page );
		}),
	
		value: function( newVal ) {
			if ( !arguments.length ) {
				return this._parse( this.element.val() );
			}
			spinner_modifier( this._value ).call( this, newVal );
		},
	
		widget: function() {
			return this.uiSpinner;
		}
	});
	
	
	/*!
	 * jQuery UI Tabs 1.11.4
	 * http://jqueryui.com
	 *
	 * Copyright jQuery Foundation and other contributors
	 * Released under the MIT license.
	 * http://jquery.org/license
	 *
	 * http://api.jqueryui.com/tabs/
	 */
	
	
	var tabs = $.widget( "ui.tabs", {
		version: "1.11.4",
		delay: 300,
		options: {
			active: null,
			collapsible: false,
			event: "click",
			heightStyle: "content",
			hide: null,
			show: null,
	
			// callbacks
			activate: null,
			beforeActivate: null,
			beforeLoad: null,
			load: null
		},
	
		_isLocal: (function() {
			var rhash = /#.*$/;
	
			return function( anchor ) {
				var anchorUrl, locationUrl;
	
				// support: IE7
				// IE7 doesn't normalize the href property when set via script (#9317)
				anchor = anchor.cloneNode( false );
	
				anchorUrl = anchor.href.replace( rhash, "" );
				locationUrl = location.href.replace( rhash, "" );
	
				// decoding may throw an error if the URL isn't UTF-8 (#9518)
				try {
					anchorUrl = decodeURIComponent( anchorUrl );
				} catch ( error ) {}
				try {
					locationUrl = decodeURIComponent( locationUrl );
				} catch ( error ) {}
	
				return anchor.hash.length > 1 && anchorUrl === locationUrl;
			};
		})(),
	
		_create: function() {
			var that = this,
				options = this.options;
	
			this.running = false;
	
			this.element
				.addClass( "ui-tabs ui-widget ui-widget-content ui-corner-all" )
				.toggleClass( "ui-tabs-collapsible", options.collapsible );
	
			this._processTabs();
			options.active = this._initialActive();
	
			// Take disabling tabs via class attribute from HTML
			// into account and update option properly.
			if ( $.isArray( options.disabled ) ) {
				options.disabled = $.unique( options.disabled.concat(
					$.map( this.tabs.filter( ".ui-state-disabled" ), function( li ) {
						return that.tabs.index( li );
					})
				) ).sort();
			}
	
			// check for length avoids error when initializing empty list
			if ( this.options.active !== false && this.anchors.length ) {
				this.active = this._findActive( options.active );
			} else {
				this.active = $();
			}
	
			this._refresh();
	
			if ( this.active.length ) {
				this.load( options.active );
			}
		},
	
		_initialActive: function() {
			var active = this.options.active,
				collapsible = this.options.collapsible,
				locationHash = location.hash.substring( 1 );
	
			if ( active === null ) {
				// check the fragment identifier in the URL
				if ( locationHash ) {
					this.tabs.each(function( i, tab ) {
						if ( $( tab ).attr( "aria-controls" ) === locationHash ) {
							active = i;
							return false;
						}
					});
				}
	
				// check for a tab marked active via a class
				if ( active === null ) {
					active = this.tabs.index( this.tabs.filter( ".ui-tabs-active" ) );
				}
	
				// no active tab, set to false
				if ( active === null || active === -1 ) {
					active = this.tabs.length ? 0 : false;
				}
			}
	
			// handle numbers: negative, out of range
			if ( active !== false ) {
				active = this.tabs.index( this.tabs.eq( active ) );
				if ( active === -1 ) {
					active = collapsible ? false : 0;
				}
			}
	
			// don't allow collapsible: false and active: false
			if ( !collapsible && active === false && this.anchors.length ) {
				active = 0;
			}
	
			return active;
		},
	
		_getCreateEventData: function() {
			return {
				tab: this.active,
				panel: !this.active.length ? $() : this._getPanelForTab( this.active )
			};
		},
	
		_tabKeydown: function( event ) {
			var focusedTab = $( this.document[0].activeElement ).closest( "li" ),
				selectedIndex = this.tabs.index( focusedTab ),
				goingForward = true;
	
			if ( this._handlePageNav( event ) ) {
				return;
			}
	
			switch ( event.keyCode ) {
				case $.ui.keyCode.RIGHT:
				case $.ui.keyCode.DOWN:
					selectedIndex++;
					break;
				case $.ui.keyCode.UP:
				case $.ui.keyCode.LEFT:
					goingForward = false;
					selectedIndex--;
					break;
				case $.ui.keyCode.END:
					selectedIndex = this.anchors.length - 1;
					break;
				case $.ui.keyCode.HOME:
					selectedIndex = 0;
					break;
				case $.ui.keyCode.SPACE:
					// Activate only, no collapsing
					event.preventDefault();
					clearTimeout( this.activating );
					this._activate( selectedIndex );
					return;
				case $.ui.keyCode.ENTER:
					// Toggle (cancel delayed activation, allow collapsing)
					event.preventDefault();
					clearTimeout( this.activating );
					// Determine if we should collapse or activate
					this._activate( selectedIndex === this.options.active ? false : selectedIndex );
					return;
				default:
					return;
			}
	
			// Focus the appropriate tab, based on which key was pressed
			event.preventDefault();
			clearTimeout( this.activating );
			selectedIndex = this._focusNextTab( selectedIndex, goingForward );
	
			// Navigating with control/command key will prevent automatic activation
			if ( !event.ctrlKey && !event.metaKey ) {
	
				// Update aria-selected immediately so that AT think the tab is already selected.
				// Otherwise AT may confuse the user by stating that they need to activate the tab,
				// but the tab will already be activated by the time the announcement finishes.
				focusedTab.attr( "aria-selected", "false" );
				this.tabs.eq( selectedIndex ).attr( "aria-selected", "true" );
	
				this.activating = this._delay(function() {
					this.option( "active", selectedIndex );
				}, this.delay );
			}
		},
	
		_panelKeydown: function( event ) {
			if ( this._handlePageNav( event ) ) {
				return;
			}
	
			// Ctrl+up moves focus to the current tab
			if ( event.ctrlKey && event.keyCode === $.ui.keyCode.UP ) {
				event.preventDefault();
				this.active.focus();
			}
		},
	
		// Alt+page up/down moves focus to the previous/next tab (and activates)
		_handlePageNav: function( event ) {
			if ( event.altKey && event.keyCode === $.ui.keyCode.PAGE_UP ) {
				this._activate( this._focusNextTab( this.options.active - 1, false ) );
				return true;
			}
			if ( event.altKey && event.keyCode === $.ui.keyCode.PAGE_DOWN ) {
				this._activate( this._focusNextTab( this.options.active + 1, true ) );
				return true;
			}
		},
	
		_findNextTab: function( index, goingForward ) {
			var lastTabIndex = this.tabs.length - 1;
	
			function constrain() {
				if ( index > lastTabIndex ) {
					index = 0;
				}
				if ( index < 0 ) {
					index = lastTabIndex;
				}
				return index;
			}
	
			while ( $.inArray( constrain(), this.options.disabled ) !== -1 ) {
				index = goingForward ? index + 1 : index - 1;
			}
	
			return index;
		},
	
		_focusNextTab: function( index, goingForward ) {
			index = this._findNextTab( index, goingForward );
			this.tabs.eq( index ).focus();
			return index;
		},
	
		_setOption: function( key, value ) {
			if ( key === "active" ) {
				// _activate() will handle invalid values and update this.options
				this._activate( value );
				return;
			}
	
			if ( key === "disabled" ) {
				// don't use the widget factory's disabled handling
				this._setupDisabled( value );
				return;
			}
	
			this._super( key, value);
	
			if ( key === "collapsible" ) {
				this.element.toggleClass( "ui-tabs-collapsible", value );
				// Setting collapsible: false while collapsed; open first panel
				if ( !value && this.options.active === false ) {
					this._activate( 0 );
				}
			}
	
			if ( key === "event" ) {
				this._setupEvents( value );
			}
	
			if ( key === "heightStyle" ) {
				this._setupHeightStyle( value );
			}
		},
	
		_sanitizeSelector: function( hash ) {
			return hash ? hash.replace( /[!"$%&'()*+,.\/:;<=>?@\[\]\^`{|}~]/g, "\\$&" ) : "";
		},
	
		refresh: function() {
			var options = this.options,
				lis = this.tablist.children( ":has(a[href])" );
	
			// get disabled tabs from class attribute from HTML
			// this will get converted to a boolean if needed in _refresh()
			options.disabled = $.map( lis.filter( ".ui-state-disabled" ), function( tab ) {
				return lis.index( tab );
			});
	
			this._processTabs();
	
			// was collapsed or no tabs
			if ( options.active === false || !this.anchors.length ) {
				options.active = false;
				this.active = $();
			// was active, but active tab is gone
			} else if ( this.active.length && !$.contains( this.tablist[ 0 ], this.active[ 0 ] ) ) {
				// all remaining tabs are disabled
				if ( this.tabs.length === options.disabled.length ) {
					options.active = false;
					this.active = $();
				// activate previous tab
				} else {
					this._activate( this._findNextTab( Math.max( 0, options.active - 1 ), false ) );
				}
			// was active, active tab still exists
			} else {
				// make sure active index is correct
				options.active = this.tabs.index( this.active );
			}
	
			this._refresh();
		},
	
		_refresh: function() {
			this._setupDisabled( this.options.disabled );
			this._setupEvents( this.options.event );
			this._setupHeightStyle( this.options.heightStyle );
	
			this.tabs.not( this.active ).attr({
				"aria-selected": "false",
				"aria-expanded": "false",
				tabIndex: -1
			});
			this.panels.not( this._getPanelForTab( this.active ) )
				.hide()
				.attr({
					"aria-hidden": "true"
				});
	
			// Make sure one tab is in the tab order
			if ( !this.active.length ) {
				this.tabs.eq( 0 ).attr( "tabIndex", 0 );
			} else {
				this.active
					.addClass( "ui-tabs-active ui-state-active" )
					.attr({
						"aria-selected": "true",
						"aria-expanded": "true",
						tabIndex: 0
					});
				this._getPanelForTab( this.active )
					.show()
					.attr({
						"aria-hidden": "false"
					});
			}
		},
	
		_processTabs: function() {
			var that = this,
				prevTabs = this.tabs,
				prevAnchors = this.anchors,
				prevPanels = this.panels;
	
			this.tablist = this._getList()
				.addClass( "ui-tabs-nav ui-helper-reset ui-helper-clearfix ui-widget-header ui-corner-all" )
				.attr( "role", "tablist" )
	
				// Prevent users from focusing disabled tabs via click
				.delegate( "> li", "mousedown" + this.eventNamespace, function( event ) {
					if ( $( this ).is( ".ui-state-disabled" ) ) {
						event.preventDefault();
					}
				})
	
				// support: IE <9
				// Preventing the default action in mousedown doesn't prevent IE
				// from focusing the element, so if the anchor gets focused, blur.
				// We don't have to worry about focusing the previously focused
				// element since clicking on a non-focusable element should focus
				// the body anyway.
				.delegate( ".ui-tabs-anchor", "focus" + this.eventNamespace, function() {
					if ( $( this ).closest( "li" ).is( ".ui-state-disabled" ) ) {
						this.blur();
					}
				});
	
			this.tabs = this.tablist.find( "> li:has(a[href])" )
				.addClass( "ui-state-default ui-corner-top" )
				.attr({
					role: "tab",
					tabIndex: -1
				});
	
			this.anchors = this.tabs.map(function() {
					return $( "a", this )[ 0 ];
				})
				.addClass( "ui-tabs-anchor" )
				.attr({
					role: "presentation",
					tabIndex: -1
				});
	
			this.panels = $();
	
			this.anchors.each(function( i, anchor ) {
				var selector, panel, panelId,
					anchorId = $( anchor ).uniqueId().attr( "id" ),
					tab = $( anchor ).closest( "li" ),
					originalAriaControls = tab.attr( "aria-controls" );
	
				// inline tab
				if ( that._isLocal( anchor ) ) {
					selector = anchor.hash;
					panelId = selector.substring( 1 );
					panel = that.element.find( that._sanitizeSelector( selector ) );
				// remote tab
				} else {
					// If the tab doesn't already have aria-controls,
					// generate an id by using a throw-away element
					panelId = tab.attr( "aria-controls" ) || $( {} ).uniqueId()[ 0 ].id;
					selector = "#" + panelId;
					panel = that.element.find( selector );
					if ( !panel.length ) {
						panel = that._createPanel( panelId );
						panel.insertAfter( that.panels[ i - 1 ] || that.tablist );
					}
					panel.attr( "aria-live", "polite" );
				}
	
				if ( panel.length) {
					that.panels = that.panels.add( panel );
				}
				if ( originalAriaControls ) {
					tab.data( "ui-tabs-aria-controls", originalAriaControls );
				}
				tab.attr({
					"aria-controls": panelId,
					"aria-labelledby": anchorId
				});
				panel.attr( "aria-labelledby", anchorId );
			});
	
			this.panels
				.addClass( "ui-tabs-panel ui-widget-content ui-corner-bottom" )
				.attr( "role", "tabpanel" );
	
			// Avoid memory leaks (#10056)
			if ( prevTabs ) {
				this._off( prevTabs.not( this.tabs ) );
				this._off( prevAnchors.not( this.anchors ) );
				this._off( prevPanels.not( this.panels ) );
			}
		},
	
		// allow overriding how to find the list for rare usage scenarios (#7715)
		_getList: function() {
			return this.tablist || this.element.find( "ol,ul" ).eq( 0 );
		},
	
		_createPanel: function( id ) {
			return $( "<div>" )
				.attr( "id", id )
				.addClass( "ui-tabs-panel ui-widget-content ui-corner-bottom" )
				.data( "ui-tabs-destroy", true );
		},
	
		_setupDisabled: function( disabled ) {
			if ( $.isArray( disabled ) ) {
				if ( !disabled.length ) {
					disabled = false;
				} else if ( disabled.length === this.anchors.length ) {
					disabled = true;
				}
			}
	
			// disable tabs
			for ( var i = 0, li; ( li = this.tabs[ i ] ); i++ ) {
				if ( disabled === true || $.inArray( i, disabled ) !== -1 ) {
					$( li )
						.addClass( "ui-state-disabled" )
						.attr( "aria-disabled", "true" );
				} else {
					$( li )
						.removeClass( "ui-state-disabled" )
						.removeAttr( "aria-disabled" );
				}
			}
	
			this.options.disabled = disabled;
		},
	
		_setupEvents: function( event ) {
			var events = {};
			if ( event ) {
				$.each( event.split(" "), function( index, eventName ) {
					events[ eventName ] = "_eventHandler";
				});
			}
	
			this._off( this.anchors.add( this.tabs ).add( this.panels ) );
			// Always prevent the default action, even when disabled
			this._on( true, this.anchors, {
				click: function( event ) {
					event.preventDefault();
				}
			});
			this._on( this.anchors, events );
			this._on( this.tabs, { keydown: "_tabKeydown" } );
			this._on( this.panels, { keydown: "_panelKeydown" } );
	
			this._focusable( this.tabs );
			this._hoverable( this.tabs );
		},
	
		_setupHeightStyle: function( heightStyle ) {
			var maxHeight,
				parent = this.element.parent();
	
			if ( heightStyle === "fill" ) {
				maxHeight = parent.height();
				maxHeight -= this.element.outerHeight() - this.element.height();
	
				this.element.siblings( ":visible" ).each(function() {
					var elem = $( this ),
						position = elem.css( "position" );
	
					if ( position === "absolute" || position === "fixed" ) {
						return;
					}
					maxHeight -= elem.outerHeight( true );
				});
	
				this.element.children().not( this.panels ).each(function() {
					maxHeight -= $( this ).outerHeight( true );
				});
	
				this.panels.each(function() {
					$( this ).height( Math.max( 0, maxHeight -
						$( this ).innerHeight() + $( this ).height() ) );
				})
				.css( "overflow", "auto" );
			} else if ( heightStyle === "auto" ) {
				maxHeight = 0;
				this.panels.each(function() {
					maxHeight = Math.max( maxHeight, $( this ).height( "" ).height() );
				}).height( maxHeight );
			}
		},
	
		_eventHandler: function( event ) {
			var options = this.options,
				active = this.active,
				anchor = $( event.currentTarget ),
				tab = anchor.closest( "li" ),
				clickedIsActive = tab[ 0 ] === active[ 0 ],
				collapsing = clickedIsActive && options.collapsible,
				toShow = collapsing ? $() : this._getPanelForTab( tab ),
				toHide = !active.length ? $() : this._getPanelForTab( active ),
				eventData = {
					oldTab: active,
					oldPanel: toHide,
					newTab: collapsing ? $() : tab,
					newPanel: toShow
				};
	
			event.preventDefault();
	
			if ( tab.hasClass( "ui-state-disabled" ) ||
					// tab is already loading
					tab.hasClass( "ui-tabs-loading" ) ||
					// can't switch durning an animation
					this.running ||
					// click on active header, but not collapsible
					( clickedIsActive && !options.collapsible ) ||
					// allow canceling activation
					( this._trigger( "beforeActivate", event, eventData ) === false ) ) {
				return;
			}
	
			options.active = collapsing ? false : this.tabs.index( tab );
	
			this.active = clickedIsActive ? $() : tab;
			if ( this.xhr ) {
				this.xhr.abort();
			}
	
			if ( !toHide.length && !toShow.length ) {
				$.error( "jQuery UI Tabs: Mismatching fragment identifier." );
			}
	
			if ( toShow.length ) {
				this.load( this.tabs.index( tab ), event );
			}
			this._toggle( event, eventData );
		},
	
		// handles show/hide for selecting tabs
		_toggle: function( event, eventData ) {
			var that = this,
				toShow = eventData.newPanel,
				toHide = eventData.oldPanel;
	
			this.running = true;
	
			function complete() {
				that.running = false;
				that._trigger( "activate", event, eventData );
			}
	
			function show() {
				eventData.newTab.closest( "li" ).addClass( "ui-tabs-active ui-state-active" );
	
				if ( toShow.length && that.options.show ) {
					that._show( toShow, that.options.show, complete );
				} else {
					toShow.show();
					complete();
				}
			}
	
			// start out by hiding, then showing, then completing
			if ( toHide.length && this.options.hide ) {
				this._hide( toHide, this.options.hide, function() {
					eventData.oldTab.closest( "li" ).removeClass( "ui-tabs-active ui-state-active" );
					show();
				});
			} else {
				eventData.oldTab.closest( "li" ).removeClass( "ui-tabs-active ui-state-active" );
				toHide.hide();
				show();
			}
	
			toHide.attr( "aria-hidden", "true" );
			eventData.oldTab.attr({
				"aria-selected": "false",
				"aria-expanded": "false"
			});
			// If we're switching tabs, remove the old tab from the tab order.
			// If we're opening from collapsed state, remove the previous tab from the tab order.
			// If we're collapsing, then keep the collapsing tab in the tab order.
			if ( toShow.length && toHide.length ) {
				eventData.oldTab.attr( "tabIndex", -1 );
			} else if ( toShow.length ) {
				this.tabs.filter(function() {
					return $( this ).attr( "tabIndex" ) === 0;
				})
				.attr( "tabIndex", -1 );
			}
	
			toShow.attr( "aria-hidden", "false" );
			eventData.newTab.attr({
				"aria-selected": "true",
				"aria-expanded": "true",
				tabIndex: 0
			});
		},
	
		_activate: function( index ) {
			var anchor,
				active = this._findActive( index );
	
			// trying to activate the already active panel
			if ( active[ 0 ] === this.active[ 0 ] ) {
				return;
			}
	
			// trying to collapse, simulate a click on the current active header
			if ( !active.length ) {
				active = this.active;
			}
	
			anchor = active.find( ".ui-tabs-anchor" )[ 0 ];
			this._eventHandler({
				target: anchor,
				currentTarget: anchor,
				preventDefault: $.noop
			});
		},
	
		_findActive: function( index ) {
			return index === false ? $() : this.tabs.eq( index );
		},
	
		_getIndex: function( index ) {
			// meta-function to give users option to provide a href string instead of a numerical index.
			if ( typeof index === "string" ) {
				index = this.anchors.index( this.anchors.filter( "[href$='" + index + "']" ) );
			}
	
			return index;
		},
	
		_destroy: function() {
			if ( this.xhr ) {
				this.xhr.abort();
			}
	
			this.element.removeClass( "ui-tabs ui-widget ui-widget-content ui-corner-all ui-tabs-collapsible" );
	
			this.tablist
				.removeClass( "ui-tabs-nav ui-helper-reset ui-helper-clearfix ui-widget-header ui-corner-all" )
				.removeAttr( "role" );
	
			this.anchors
				.removeClass( "ui-tabs-anchor" )
				.removeAttr( "role" )
				.removeAttr( "tabIndex" )
				.removeUniqueId();
	
			this.tablist.unbind( this.eventNamespace );
	
			this.tabs.add( this.panels ).each(function() {
				if ( $.data( this, "ui-tabs-destroy" ) ) {
					$( this ).remove();
				} else {
					$( this )
						.removeClass( "ui-state-default ui-state-active ui-state-disabled " +
							"ui-corner-top ui-corner-bottom ui-widget-content ui-tabs-active ui-tabs-panel" )
						.removeAttr( "tabIndex" )
						.removeAttr( "aria-live" )
						.removeAttr( "aria-busy" )
						.removeAttr( "aria-selected" )
						.removeAttr( "aria-labelledby" )
						.removeAttr( "aria-hidden" )
						.removeAttr( "aria-expanded" )
						.removeAttr( "role" );
				}
			});
	
			this.tabs.each(function() {
				var li = $( this ),
					prev = li.data( "ui-tabs-aria-controls" );
				if ( prev ) {
					li
						.attr( "aria-controls", prev )
						.removeData( "ui-tabs-aria-controls" );
				} else {
					li.removeAttr( "aria-controls" );
				}
			});
	
			this.panels.show();
	
			if ( this.options.heightStyle !== "content" ) {
				this.panels.css( "height", "" );
			}
		},
	
		enable: function( index ) {
			var disabled = this.options.disabled;
			if ( disabled === false ) {
				return;
			}
	
			if ( index === undefined ) {
				disabled = false;
			} else {
				index = this._getIndex( index );
				if ( $.isArray( disabled ) ) {
					disabled = $.map( disabled, function( num ) {
						return num !== index ? num : null;
					});
				} else {
					disabled = $.map( this.tabs, function( li, num ) {
						return num !== index ? num : null;
					});
				}
			}
			this._setupDisabled( disabled );
		},
	
		disable: function( index ) {
			var disabled = this.options.disabled;
			if ( disabled === true ) {
				return;
			}
	
			if ( index === undefined ) {
				disabled = true;
			} else {
				index = this._getIndex( index );
				if ( $.inArray( index, disabled ) !== -1 ) {
					return;
				}
				if ( $.isArray( disabled ) ) {
					disabled = $.merge( [ index ], disabled ).sort();
				} else {
					disabled = [ index ];
				}
			}
			this._setupDisabled( disabled );
		},
	
		load: function( index, event ) {
			index = this._getIndex( index );
			var that = this,
				tab = this.tabs.eq( index ),
				anchor = tab.find( ".ui-tabs-anchor" ),
				panel = this._getPanelForTab( tab ),
				eventData = {
					tab: tab,
					panel: panel
				},
				complete = function( jqXHR, status ) {
					if ( status === "abort" ) {
						that.panels.stop( false, true );
					}
	
					tab.removeClass( "ui-tabs-loading" );
					panel.removeAttr( "aria-busy" );
	
					if ( jqXHR === that.xhr ) {
						delete that.xhr;
					}
				};
	
			// not remote
			if ( this._isLocal( anchor[ 0 ] ) ) {
				return;
			}
	
			this.xhr = $.ajax( this._ajaxSettings( anchor, event, eventData ) );
	
			// support: jQuery <1.8
			// jQuery <1.8 returns false if the request is canceled in beforeSend,
			// but as of 1.8, $.ajax() always returns a jqXHR object.
			if ( this.xhr && this.xhr.statusText !== "canceled" ) {
				tab.addClass( "ui-tabs-loading" );
				panel.attr( "aria-busy", "true" );
	
				this.xhr
					.done(function( response, status, jqXHR ) {
						// support: jQuery <1.8
						// http://bugs.jquery.com/ticket/11778
						setTimeout(function() {
							panel.html( response );
							that._trigger( "load", event, eventData );
	
							complete( jqXHR, status );
						}, 1 );
					})
					.fail(function( jqXHR, status ) {
						// support: jQuery <1.8
						// http://bugs.jquery.com/ticket/11778
						setTimeout(function() {
							complete( jqXHR, status );
						}, 1 );
					});
			}
		},
	
		_ajaxSettings: function( anchor, event, eventData ) {
			var that = this;
			return {
				url: anchor.attr( "href" ),
				beforeSend: function( jqXHR, settings ) {
					return that._trigger( "beforeLoad", event,
						$.extend( { jqXHR: jqXHR, ajaxSettings: settings }, eventData ) );
				}
			};
		},
	
		_getPanelForTab: function( tab ) {
			var id = $( tab ).attr( "aria-controls" );
			return this.element.find( this._sanitizeSelector( "#" + id ) );
		}
	});
	
	
	/*!
	 * jQuery UI Tooltip 1.11.4
	 * http://jqueryui.com
	 *
	 * Copyright jQuery Foundation and other contributors
	 * Released under the MIT license.
	 * http://jquery.org/license
	 *
	 * http://api.jqueryui.com/tooltip/
	 */
	
	
	var tooltip = $.widget( "ui.tooltip", {
		version: "1.11.4",
		options: {
			content: function() {
				// support: IE<9, Opera in jQuery <1.7
				// .text() can't accept undefined, so coerce to a string
				var title = $( this ).attr( "title" ) || "";
				// Escape title, since we're going from an attribute to raw HTML
				return $( "<a>" ).text( title ).html();
			},
			hide: true,
			// Disabled elements have inconsistent behavior across browsers (#8661)
			items: "[title]:not([disabled])",
			position: {
				my: "left top+15",
				at: "left bottom",
				collision: "flipfit flip"
			},
			show: true,
			tooltipClass: null,
			track: false,
	
			// callbacks
			close: null,
			open: null
		},
	
		_addDescribedBy: function( elem, id ) {
			var describedby = (elem.attr( "aria-describedby" ) || "").split( /\s+/ );
			describedby.push( id );
			elem
				.data( "ui-tooltip-id", id )
				.attr( "aria-describedby", $.trim( describedby.join( " " ) ) );
		},
	
		_removeDescribedBy: function( elem ) {
			var id = elem.data( "ui-tooltip-id" ),
				describedby = (elem.attr( "aria-describedby" ) || "").split( /\s+/ ),
				index = $.inArray( id, describedby );
	
			if ( index !== -1 ) {
				describedby.splice( index, 1 );
			}
	
			elem.removeData( "ui-tooltip-id" );
			describedby = $.trim( describedby.join( " " ) );
			if ( describedby ) {
				elem.attr( "aria-describedby", describedby );
			} else {
				elem.removeAttr( "aria-describedby" );
			}
		},
	
		_create: function() {
			this._on({
				mouseover: "open",
				focusin: "open"
			});
	
			// IDs of generated tooltips, needed for destroy
			this.tooltips = {};
	
			// IDs of parent tooltips where we removed the title attribute
			this.parents = {};
	
			if ( this.options.disabled ) {
				this._disable();
			}
	
			// Append the aria-live region so tooltips announce correctly
			this.liveRegion = $( "<div>" )
				.attr({
					role: "log",
					"aria-live": "assertive",
					"aria-relevant": "additions"
				})
				.addClass( "ui-helper-hidden-accessible" )
				.appendTo( this.document[ 0 ].body );
		},
	
		_setOption: function( key, value ) {
			var that = this;
	
			if ( key === "disabled" ) {
				this[ value ? "_disable" : "_enable" ]();
				this.options[ key ] = value;
				// disable element style changes
				return;
			}
	
			this._super( key, value );
	
			if ( key === "content" ) {
				$.each( this.tooltips, function( id, tooltipData ) {
					that._updateContent( tooltipData.element );
				});
			}
		},
	
		_disable: function() {
			var that = this;
	
			// close open tooltips
			$.each( this.tooltips, function( id, tooltipData ) {
				var event = $.Event( "blur" );
				event.target = event.currentTarget = tooltipData.element[ 0 ];
				that.close( event, true );
			});
	
			// remove title attributes to prevent native tooltips
			this.element.find( this.options.items ).addBack().each(function() {
				var element = $( this );
				if ( element.is( "[title]" ) ) {
					element
						.data( "ui-tooltip-title", element.attr( "title" ) )
						.removeAttr( "title" );
				}
			});
		},
	
		_enable: function() {
			// restore title attributes
			this.element.find( this.options.items ).addBack().each(function() {
				var element = $( this );
				if ( element.data( "ui-tooltip-title" ) ) {
					element.attr( "title", element.data( "ui-tooltip-title" ) );
				}
			});
		},
	
		open: function( event ) {
			var that = this,
				target = $( event ? event.target : this.element )
					// we need closest here due to mouseover bubbling,
					// but always pointing at the same event target
					.closest( this.options.items );
	
			// No element to show a tooltip for or the tooltip is already open
			if ( !target.length || target.data( "ui-tooltip-id" ) ) {
				return;
			}
	
			if ( target.attr( "title" ) ) {
				target.data( "ui-tooltip-title", target.attr( "title" ) );
			}
	
			target.data( "ui-tooltip-open", true );
	
			// kill parent tooltips, custom or native, for hover
			if ( event && event.type === "mouseover" ) {
				target.parents().each(function() {
					var parent = $( this ),
						blurEvent;
					if ( parent.data( "ui-tooltip-open" ) ) {
						blurEvent = $.Event( "blur" );
						blurEvent.target = blurEvent.currentTarget = this;
						that.close( blurEvent, true );
					}
					if ( parent.attr( "title" ) ) {
						parent.uniqueId();
						that.parents[ this.id ] = {
							element: this,
							title: parent.attr( "title" )
						};
						parent.attr( "title", "" );
					}
				});
			}
	
			this._registerCloseHandlers( event, target );
			this._updateContent( target, event );
		},
	
		_updateContent: function( target, event ) {
			var content,
				contentOption = this.options.content,
				that = this,
				eventType = event ? event.type : null;
	
			if ( typeof contentOption === "string" ) {
				return this._open( event, target, contentOption );
			}
	
			content = contentOption.call( target[0], function( response ) {
	
				// IE may instantly serve a cached response for ajax requests
				// delay this call to _open so the other call to _open runs first
				that._delay(function() {
	
					// Ignore async response if tooltip was closed already
					if ( !target.data( "ui-tooltip-open" ) ) {
						return;
					}
	
					// jQuery creates a special event for focusin when it doesn't
					// exist natively. To improve performance, the native event
					// object is reused and the type is changed. Therefore, we can't
					// rely on the type being correct after the event finished
					// bubbling, so we set it back to the previous value. (#8740)
					if ( event ) {
						event.type = eventType;
					}
					this._open( event, target, response );
				});
			});
			if ( content ) {
				this._open( event, target, content );
			}
		},
	
		_open: function( event, target, content ) {
			var tooltipData, tooltip, delayedShow, a11yContent,
				positionOption = $.extend( {}, this.options.position );
	
			if ( !content ) {
				return;
			}
	
			// Content can be updated multiple times. If the tooltip already
			// exists, then just update the content and bail.
			tooltipData = this._find( target );
			if ( tooltipData ) {
				tooltipData.tooltip.find( ".ui-tooltip-content" ).html( content );
				return;
			}
	
			// if we have a title, clear it to prevent the native tooltip
			// we have to check first to avoid defining a title if none exists
			// (we don't want to cause an element to start matching [title])
			//
			// We use removeAttr only for key events, to allow IE to export the correct
			// accessible attributes. For mouse events, set to empty string to avoid
			// native tooltip showing up (happens only when removing inside mouseover).
			if ( target.is( "[title]" ) ) {
				if ( event && event.type === "mouseover" ) {
					target.attr( "title", "" );
				} else {
					target.removeAttr( "title" );
				}
			}
	
			tooltipData = this._tooltip( target );
			tooltip = tooltipData.tooltip;
			this._addDescribedBy( target, tooltip.attr( "id" ) );
			tooltip.find( ".ui-tooltip-content" ).html( content );
	
			// Support: Voiceover on OS X, JAWS on IE <= 9
			// JAWS announces deletions even when aria-relevant="additions"
			// Voiceover will sometimes re-read the entire log region's contents from the beginning
			this.liveRegion.children().hide();
			if ( content.clone ) {
				a11yContent = content.clone();
				a11yContent.removeAttr( "id" ).find( "[id]" ).removeAttr( "id" );
			} else {
				a11yContent = content;
			}
			$( "<div>" ).html( a11yContent ).appendTo( this.liveRegion );
	
			function position( event ) {
				positionOption.of = event;
				if ( tooltip.is( ":hidden" ) ) {
					return;
				}
				tooltip.position( positionOption );
			}
			if ( this.options.track && event && /^mouse/.test( event.type ) ) {
				this._on( this.document, {
					mousemove: position
				});
				// trigger once to override element-relative positioning
				position( event );
			} else {
				tooltip.position( $.extend({
					of: target
				}, this.options.position ) );
			}
	
			tooltip.hide();
	
			this._show( tooltip, this.options.show );
			// Handle tracking tooltips that are shown with a delay (#8644). As soon
			// as the tooltip is visible, position the tooltip using the most recent
			// event.
			if ( this.options.show && this.options.show.delay ) {
				delayedShow = this.delayedShow = setInterval(function() {
					if ( tooltip.is( ":visible" ) ) {
						position( positionOption.of );
						clearInterval( delayedShow );
					}
				}, $.fx.interval );
			}
	
			this._trigger( "open", event, { tooltip: tooltip } );
		},
	
		_registerCloseHandlers: function( event, target ) {
			var events = {
				keyup: function( event ) {
					if ( event.keyCode === $.ui.keyCode.ESCAPE ) {
						var fakeEvent = $.Event(event);
						fakeEvent.currentTarget = target[0];
						this.close( fakeEvent, true );
					}
				}
			};
	
			// Only bind remove handler for delegated targets. Non-delegated
			// tooltips will handle this in destroy.
			if ( target[ 0 ] !== this.element[ 0 ] ) {
				events.remove = function() {
					this._removeTooltip( this._find( target ).tooltip );
				};
			}
	
			if ( !event || event.type === "mouseover" ) {
				events.mouseleave = "close";
			}
			if ( !event || event.type === "focusin" ) {
				events.focusout = "close";
			}
			this._on( true, target, events );
		},
	
		close: function( event ) {
			var tooltip,
				that = this,
				target = $( event ? event.currentTarget : this.element ),
				tooltipData = this._find( target );
	
			// The tooltip may already be closed
			if ( !tooltipData ) {
	
				// We set ui-tooltip-open immediately upon open (in open()), but only set the
				// additional data once there's actually content to show (in _open()). So even if the
				// tooltip doesn't have full data, we always remove ui-tooltip-open in case we're in
				// the period between open() and _open().
				target.removeData( "ui-tooltip-open" );
				return;
			}
	
			tooltip = tooltipData.tooltip;
	
			// disabling closes the tooltip, so we need to track when we're closing
			// to avoid an infinite loop in case the tooltip becomes disabled on close
			if ( tooltipData.closing ) {
				return;
			}
	
			// Clear the interval for delayed tracking tooltips
			clearInterval( this.delayedShow );
	
			// only set title if we had one before (see comment in _open())
			// If the title attribute has changed since open(), don't restore
			if ( target.data( "ui-tooltip-title" ) && !target.attr( "title" ) ) {
				target.attr( "title", target.data( "ui-tooltip-title" ) );
			}
	
			this._removeDescribedBy( target );
	
			tooltipData.hiding = true;
			tooltip.stop( true );
			this._hide( tooltip, this.options.hide, function() {
				that._removeTooltip( $( this ) );
			});
	
			target.removeData( "ui-tooltip-open" );
			this._off( target, "mouseleave focusout keyup" );
	
			// Remove 'remove' binding only on delegated targets
			if ( target[ 0 ] !== this.element[ 0 ] ) {
				this._off( target, "remove" );
			}
			this._off( this.document, "mousemove" );
	
			if ( event && event.type === "mouseleave" ) {
				$.each( this.parents, function( id, parent ) {
					$( parent.element ).attr( "title", parent.title );
					delete that.parents[ id ];
				});
			}
	
			tooltipData.closing = true;
			this._trigger( "close", event, { tooltip: tooltip } );
			if ( !tooltipData.hiding ) {
				tooltipData.closing = false;
			}
		},
	
		_tooltip: function( element ) {
			var tooltip = $( "<div>" )
					.attr( "role", "tooltip" )
					.addClass( "ui-tooltip ui-widget ui-corner-all ui-widget-content " +
						( this.options.tooltipClass || "" ) ),
				id = tooltip.uniqueId().attr( "id" );
	
			$( "<div>" )
				.addClass( "ui-tooltip-content" )
				.appendTo( tooltip );
	
			tooltip.appendTo( this.document[0].body );
	
			return this.tooltips[ id ] = {
				element: element,
				tooltip: tooltip
			};
		},
	
		_find: function( target ) {
			var id = target.data( "ui-tooltip-id" );
			return id ? this.tooltips[ id ] : null;
		},
	
		_removeTooltip: function( tooltip ) {
			tooltip.remove();
			delete this.tooltips[ tooltip.attr( "id" ) ];
		},
	
		_destroy: function() {
			var that = this;
	
			// close open tooltips
			$.each( this.tooltips, function( id, tooltipData ) {
				// Delegate to close method to handle common cleanup
				var event = $.Event( "blur" ),
					element = tooltipData.element;
				event.target = event.currentTarget = element[ 0 ];
				that.close( event, true );
	
				// Remove immediately; destroying an open tooltip doesn't use the
				// hide animation
				$( "#" + id ).remove();
	
				// Restore the title
				if ( element.data( "ui-tooltip-title" ) ) {
					// If the title attribute has changed since open(), don't restore
					if ( !element.attr( "title" ) ) {
						element.attr( "title", element.data( "ui-tooltip-title" ) );
					}
					element.removeData( "ui-tooltip-title" );
				}
			});
			this.liveRegion.remove();
		}
	});
	
	
	
	}));

/***/ },
/* 67 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 68 */,
/* 69 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ }
/******/ ]);
//# sourceMappingURL=admin.all.js.map